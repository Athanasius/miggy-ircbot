09:01:57.657290 setpgid(0, 0)           = 0
09:01:57.657438 rt_sigprocmask(SIG_BLOCK, [ABRT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.657523 rt_sigaction(SIGABRT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.657808 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.657861 rt_sigprocmask(SIG_BLOCK, [TRAP], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.657908 rt_sigaction(SIGTRAP, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.657955 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658046 rt_sigprocmask(SIG_BLOCK, [CHLD], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658098 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.658171 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658236 rt_sigprocmask(SIG_BLOCK, [TTOU], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658293 rt_sigaction(SIGTTOU, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.658340 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658378 rt_sigprocmask(SIG_BLOCK, [IO], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658426 rt_sigaction(SIGIO, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.658483 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658535 rt_sigprocmask(SIG_BLOCK, [URG], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658584 rt_sigaction(SIGURG, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.658634 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658678 rt_sigprocmask(SIG_BLOCK, [STOP], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658713 rt_sigaction(SIGSTOP, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = -1 EINVAL (Invalid argument)
09:01:57.658763 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658807 rt_sigprocmask(SIG_BLOCK, [PROF], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658845 rt_sigaction(SIGPROF, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.658898 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.658943 rt_sigprocmask(SIG_BLOCK, [TSTP], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.658981 rt_sigaction(SIGTSTP, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659033 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659084 rt_sigprocmask(SIG_BLOCK, [IO], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659122 rt_sigaction(SIGIO, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.659179 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659236 rt_sigprocmask(SIG_BLOCK, [PIPE], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659290 rt_sigaction(SIGPIPE, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_IGN, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.659529 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659560 rt_sigprocmask(SIG_BLOCK, [USR2], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659588 rt_sigaction(SIGUSR2, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659618 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659643 rt_sigprocmask(SIG_BLOCK, [SYS], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659669 rt_sigaction(SIGSYS, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659699 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659724 rt_sigprocmask(SIG_BLOCK, [CONT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659752 rt_sigaction(SIGCONT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659783 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659808 rt_sigprocmask(SIG_BLOCK, [VTALRM], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659845 rt_sigaction(SIGVTALRM, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659899 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.659934 rt_sigprocmask(SIG_BLOCK, [TERM], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.659961 rt_sigaction(SIGTERM, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.659992 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660016 rt_sigprocmask(SIG_BLOCK, [PWR], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660042 rt_sigaction(SIGPWR, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.660073 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660097 rt_sigprocmask(SIG_BLOCK, [CHLD], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660123 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.660153 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660178 rt_sigprocmask(SIG_BLOCK, [BUS], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660204 rt_sigaction(SIGBUS, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.660255 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660300 rt_sigprocmask(SIG_BLOCK, [HUP], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660346 rt_sigaction(SIGHUP, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.660378 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660402 rt_sigprocmask(SIG_BLOCK, [FPE], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660449 rt_sigaction(SIGFPE, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0x7f7435f9f1e0}, 8) = 0
09:01:57.660483 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660508 rt_sigprocmask(SIG_BLOCK, [XCPU], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660534 rt_sigaction(SIGXCPU, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.660564 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660589 rt_sigprocmask(SIG_BLOCK, [ABRT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660615 rt_sigaction(SIGABRT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.660646 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660693 rt_sigprocmask(SIG_BLOCK, [STKFLT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660735 rt_sigaction(SIGSTKFLT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.660783 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.660819 rt_sigprocmask(SIG_BLOCK, [TTIN], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.660972 rt_sigaction(SIGTTIN, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.661029 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661065 rt_sigprocmask(SIG_BLOCK, [XFSZ], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661110 rt_sigaction(SIGXFSZ, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.661267 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661321 rt_sigprocmask(SIG_BLOCK, [INT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661372 rt_sigaction(SIGINT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.661431 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661484 rt_sigprocmask(SIG_BLOCK, [QUIT], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661524 rt_sigaction(SIGQUIT, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.661570 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661612 rt_sigprocmask(SIG_BLOCK, [KILL], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661653 rt_sigaction(SIGKILL, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = -1 EINVAL (Invalid argument)
09:01:57.661713 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661766 rt_sigprocmask(SIG_BLOCK, [SYS], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661813 rt_sigaction(SIGSYS, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.661861 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.661903 rt_sigprocmask(SIG_BLOCK, [WINCH], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.661938 rt_sigaction(SIGWINCH, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.661995 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.662064 rt_sigprocmask(SIG_BLOCK, [USR1], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.662124 rt_sigaction(SIGUSR1, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.662180 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.662229 rt_sigprocmask(SIG_BLOCK, [ILL], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.662279 rt_sigaction(SIGILL, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.662341 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.662389 rt_sigprocmask(SIG_BLOCK, [ALRM], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.662439 rt_sigaction(SIGALRM, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.662485 rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
09:01:57.662650 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.662700 close(27)               = 0
09:01:57.662725 close(19)               = 0
09:01:57.662749 close(23)               = 0
09:01:57.662850 dup(26)                 = 19
09:01:57.662894 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.662929 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.662968 fstat(19, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
09:01:57.663018 dup2(19, 0)             = 0
09:01:57.663052 close(19)               = 0
09:01:57.663086 fcntl(0, F_SETFD, 0)    = 0
09:01:57.663141 dup(22)                 = 19
09:01:57.663187 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.663227 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.663259 fstat(19, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
09:01:57.663314 dup2(19, 1)             = 1
09:01:57.663365 close(19)               = 0
09:01:57.663409 fcntl(1, F_SETFD, 0)    = 0
09:01:57.663456 dup(25)                 = 19
09:01:57.663500 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.663539 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.663569 fstat(19, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
09:01:57.663613 dup2(19, 2)             = 2
09:01:57.663663 close(19)               = 0
09:01:57.663707 fcntl(2, F_SETFD, 0)    = 0
09:01:57.663789 close(3)                = 0
09:01:57.663848 write(6, "go\n", 3)     = 3
09:01:57.663900 close(6)                = 0
09:01:57.663971 rt_sigaction(SIGFPE, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.664319 execve("/usr/bin/perl", ["/usr/bin/perl", "-Imodules", "-Imodules", "-I/etc/perl", "-I/usr/local/lib/perl/5.14.2", "-I/usr/local/share/perl/5.14.2", "-I/usr/lib/perl5", "-I/usr/share/perl5", "-I/usr/lib/perl/5.14", "-I/usr/share/perl/5.14", "-I/usr/local/lib/site_perl", "-I.", "-MPOE::Component::Resolver::Sidecar", "-e", "POE::Component::Resolver::Sidecar->main()"], [/* 39 vars */]) = 0
09:01:57.664992 brk(0)                  = 0x1dfd000
09:01:57.665050 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.665095 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c3c000
09:01:57.665147 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
09:01:57.665202 open("/etc/ld.so.cache", O_RDONLY) = 3
09:01:57.665251 fstat(3, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.665380 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f92d7c23000
09:01:57.665421 close(3)                = 0
09:01:57.665460 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.665518 open("/usr/lib/libperl.so.5.14", O_RDONLY) = 3
09:01:57.665570 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@@\3\0\0\0\0\0@\0\0\0\0\0\0\0\30\0\30\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324m\27\0\0\0\0\0\324m\27\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0t\27\0\0\0\0\0\0t7\0\0\0\0\0\0t7\0\0\0\0\0\4\213\0\0\0\0\0\0(\215\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320\250\27\0\0\0\0\0\320\2507\0\0\0\0\0\320\2507\0\0\0\0\0 \2\0\0\0\0\0\0 \2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\0\365\25\0\0\0\0\0\0\365\25\0\0\0\0\0\0\365\25\0\0\0\0\0\\8\0\0\0\0\0\0\\8\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\0t\27\0\0\0\0\0\0t7\0\0\0\0\0\0t7\0\0\0\0\0\0<\0\0\0\0\0\0\0<\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\216\256)\302R\327\341k\275\330\277$\3\25\377GQ\372\236\214\0\0\0\0\7\4\0\0\244\7\0\0>\6\0\0$\7\0\0h\6\0\0\0\5\0\0@\7\0\0-\5\0\0\7\2\0\0\30\4\0\0\237\2\0\0|\0\0\0\234\2\0\0\0\0\0\0\370\2\0\0\336\0\0\0\0\0\0\0008\6\0\0\216\0\0\0\0\0\0\0\330\4\0\0\250\1\0\0\0\0\0\0\200\0\0\0S\6\0\0\374\1\0\0)\2\0\0\4\4\0\0E\7\0\0'\5\0\0006\1\0\0\37\3\0\0\216\6\0\0\0\0\0\0007\2\0\0\314\2\0\0\220\4\0\0\0\0\0\0\315\3\0\0~\7\0\0\0\0\0\0\377\6\0\0\v\4\0\0\0\0\0\0\327\0\0\0009\5\0\0G\2\0\0l\3\0\0z\2\0\0\0\0\0\0'\4\0\0i\0\0\0\365\6\0\0\304\4\0\0\221\7\0\0\351\2\0\0(\5\0\0`\7\0\0\215\6\0\0\363\0\0\0\277\4\0\0\222\3\0\0\251\3\0\0\246\6\0\0Q\2\0\0\37\5\0\0\20\6\0\0\264\6\0\0\0\0\0\0I\2\0\0\353\2\0\0\224\6\0\0P\4\0\0\310\0\0\0\242\7\0\0\33\6\0\0\233\6\0\0\22\1\0\0V\5\0\0D\6\0\0\260\0\0\0\312\6\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.665696 fstat(3, {st_mode=S_IFREG|0644, st_size=1574680, ...}) = 0
09:01:57.665739 mmap(NULL, 3670312, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d769e000
09:01:57.665775 mprotect(0x7f92d7815000, 2097152, PROT_NONE) = 0
09:01:57.665857 mmap(0x7f92d7a15000, 36864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x177000) = 0x7f92d7a15000
09:01:57.665909 mmap(0x7f92d7a1e000, 296, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f92d7a1e000
09:01:57.665950 close(3)                = 0
09:01:57.665989 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.666045 open("/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY) = 3
09:01:57.666090 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340\r\0\0\0\0\0\0@\0\0\0\0\0\0\0\2601\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0 \0\37\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\260\31\0\0\0\0\0\0\260\31\0\0\0\0\0\0\260\31\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\250\36\0\0\0\0\0\0\250\36\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0H-\0\0\0\0\0\0H- \0\0\0\0\0H- \0\0\0\0\0008\3\0\0\0\0\0\0\270\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\200-\0\0\0\0\0\0\200- \0\0\0\0\0\200- \0\0\0\0\0\20\2\0\0\0\0\0\0\20\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\314\31\0\0\0\0\0\0\314\31\0\0\0\0\0\0\314\31\0\0\0\0\0\0\274\0\0\0\0\0\0\0\274\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0H-\0\0\0\0\0\0H- \0\0\0\0\0H- \0\0\0\0\0\270\2\0\0\0\0\0\0\270\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0]\34\243\243\331>\325\266\306F/\372\3\347\207\375\276@\23\243\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\31\0\0\0\2\0\0\0\7\0\0\0\230\2\21\0\200H\0\4\22\0\0@\203(\10\236\31\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0$\0\0\0%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\353\26\251\30a\257\0\371\301S\200\30\273\25sB\257\304M\17\221!\374\370\6\2\4\371\3733\373\17\371\31sB\372\31sB\225\263_\31\177\236\320\30a\242\222\6", 832) = 832
09:01:57.666221 fstat(3, {st_mode=S_IFREG|0644, st_size=14768, ...}) = 0
09:01:57.666295 mmap(NULL, 2109696, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d749a000
09:01:57.666344 mprotect(0x7f92d749c000, 2097152, PROT_NONE) = 0
09:01:57.666385 mmap(0x7f92d769c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f92d769c000
09:01:57.666437 close(3)                = 0
09:01:57.666476 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.666519 open("/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY) = 3
09:01:57.666592 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360>\0\0\0\0\0\0@\0\0\0\0\0\0\0\260\21\10\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\220\272\7\0\0\0\0\0\220\272\7\0\0\0\0\0\220\272\7\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\24\n\10\0\0\0\0\0\24\n\10\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\300\r\10\0\0\0\0\0\300\r(\0\0\0\0\0\300\r(\0\0\0\0\0\330\2\0\0\0\0\0\0(\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\350\r\10\0\0\0\0\0\350\r(\0\0\0\0\0\350\r(\0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\254\272\7\0\0\0\0\0\254\272\7\0\0\0\0\0\254\272\7\0\0\0\0\0|\16\0\0\0\0\0\0|\16\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\300\r\10\0\0\0\0\0\300\r(\0\0\0\0\0\300\r(\0\0\0\0\0@\2\0\0\0\0\0\0@\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\177X\326fEq\224\34\206\262\331ip\32W*\324\327\277\35\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0i\2\0\0\20\0\0\0 \0\0\0\v\0\0\0%\0 \303\t\224g\r\0H\20 \4\243ER\202\24\200 \0y\210\272\10\0A\0\0\10\10\0\31\4\3\0\2\0\232U0A\20\0\0\200\244\322\20\1@\232\242\20\304aR\220\10\6\206\0\232\10\7\300 \10\200\240\0\242@\30\201\4E\207\0054\351\0\0\10!C\30\3000\0103\30\24M8\"\0R\224\21@\4\3\2e\t\0\1\204\fY\20 \10\2\0\0\200@\0$\214\5\10\0\0\0\0\1\0\242\1 \t\24E \325\241\10\273o\220\"@\236\1\10\4\200\200\0\4\200PLG\242\0\200\201 B\220 \0201*@\t\242 \0A\10\0", 832) = 832
09:01:57.666727 fstat(3, {st_mode=S_IFREG|0644, st_size=530736, ...}) = 0
09:01:57.666776 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c22000
09:01:57.666811 mmap(NULL, 2625768, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d7218000
09:01:57.666853 mprotect(0x7f92d7299000, 2093056, PROT_NONE) = 0
09:01:57.667225 mmap(0x7f92d7498000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x80000) = 0x7f92d7498000
09:01:57.667271 close(3)                = 0
09:01:57.667310 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.667351 open("/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY) = 3
09:01:57.667413 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\\\0\0\0\0\0\0@\0\0\0\0\0\0\0\320s\1\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0#\0 \0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4j\1\0\0\0\0\0\4j\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\240k\1\0\0\0\0\0\240k!\0\0\0\0\0\240k!\0\0\0\0\0\320\6\0\0\0\0\0\0\0H\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\210m\1\0\0\0\0\0\210m!\0\0\0\0\0\210m!\0\0\0\0\0\360\1\0\0\0\0\0\0\360\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0<\n\0\0\0\0\0\0<\n\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\240k\1\0\0\0\0\0\240k!\0\0\0\0\0\240k!\0\0\0\0\0`\4\0\0\0\0\0\0`\4\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\376\362\201!\207\227\255j\347&\335_\316\336\312\335\236\237Q\334\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\345\1\0\0O\0\0\0 \0\0\0\v\0\0\0\31#\2\261\1\10\20\2@@a\370\3\10\10\25\200 \0\0\0\0\200\300\321Q\0\0\0\22\353\3020D\0\10\20A\0\2\0\2\f\1\200\v\221\1\330\240\r\240@\230 \244\200\21\n\202-l@g\214V\24\0\224 \200$H\200P(\1\22\f\311B\240\220\22\10\f \2ZdA\245c\4@\n\n\2\0\2009\1(\314@\204\201@\22\10(\fD\0\0\0\200Q\10\200\35\4B\320\2608A\0\1\0\0\265\0300\0\200`\2\20\"\0\tA\20\1\5\0P \251\2\7(\0\0\202\4\230@\4\0\20\340T\0\2@\2\2\20\3010D\26\200\0", 832) = 832
09:01:57.667542 fstat(3, {st_mode=S_IFREG|0755, st_size=131107, ...}) = 0
09:01:57.667583 mmap(NULL, 2208672, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d6ffc000
09:01:57.667615 mprotect(0x7f92d7013000, 2093056, PROT_NONE) = 0
09:01:57.667668 mmap(0x7f92d7212000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16000) = 0x7f92d7212000
09:01:57.668024 mmap(0x7f92d7214000, 13216, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f92d7214000
09:01:57.668079 close(3)                = 0
09:01:57.668123 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.668176 open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY) = 3
09:01:57.668257 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\357\1\0\0\0\0\0@\0\0\0\0\0\0\0P_\30\0\0\0\0\0\0\0\0\0@\0008\0\n\0@\0#\0\"\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0000e\25\0\0\0\0\0000e\25\0\0\0\0\0000e\25\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\n\30\0\0\0\0\0T\n\30\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\220F\0\0\0\0\0\0\20\221\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0@K\30\0\0\0\0\0@K8\0\0\0\0\0@K8\0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\7\0\0\0\4\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\20\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0P\345td\4\0\0\0Le\25\0\0\0\0\0Le\25\0\0\0\0\0Le\25\0\0\0\0\0,h\0\0\0\0\0\0,h\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\3308\0\0\0\0\0\0\3308\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\247E\353\242\301k\250\n\341\357\32z{pt\f,\361\263c\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\363\3\0\0\t\0\0\0\0\1\0\0\16\0\0\0\0000\20D\240 \2\1\210\3\346\220\305E\214\0\300\0\10\0\5\200\0`\300\200\0\r\212\f\0\4\20\0\210D2\10.@\210P4, \16\"H&\204\300\214\4\10\0\2\2\16\241\254\32\4f\300\0\3002\0\300\0P\1 \201\10\204\v  ($\0\4 P\0\20X\200\312DB(\0\6\200\20\30B\0 @\200\0\tP\0Q\212@\20\0\0\0\0\10\0\0\21\20", 832) = 832
09:01:57.668381 fstat(3, {st_mode=S_IFREG|0755, st_size=1599504, ...}) = 0
09:01:57.668535 mmap(NULL, 3713080, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d6c71000
09:01:57.668576 mprotect(0x7f92d6df2000, 2097152, PROT_NONE) = 0
09:01:57.668623 mmap(0x7f92d6ff2000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x181000) = 0x7f92d6ff2000
09:01:57.668685 mmap(0x7f92d6ff7000, 18488, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f92d6ff7000
09:01:57.668738 close(3)                = 0
09:01:57.668797 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.668842 open("/lib/x86_64-linux-gnu/libcrypt.so.1", O_RDONLY) = 3
09:01:57.668887 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\n\0\0\0\0\0\0@\0\0\0\0\0\0\0\240\201\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0 v\0\0\0\0\0\0 v\0\0\0\0\0\0 v\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\230}\0\0\0\0\0\0\230}\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\320}\0\0\0\0\0\0\320} \0\0\0\0\0\320} \0\0\0\0\0\260\2\0\0\0\0\0\0\360\343\2\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\370}\0\0\0\0\0\0\370} \0\0\0\0\0\370} \0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0<v\0\0\0\0\0\0<v\0\0\0\0\0\0<v\0\0\0\0\0\0$\1\0\0\0\0\0\0$\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\320}\0\0\0\0\0\0\320} \0\0\0\0\0\320} \0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0Nn\35\213\16>\360\260\326A\352\263%\345v\331}ZF\v\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\17\0\0\0\23\0\0\0\1\0\0\0\6\0\0\0\4I\300,$\204 \f\0\0\0\0\0\0\0\0\0\0\0\0\23\0\0\0\24\0\0\0\25\0\0\0\0\0\0\0\26\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\31\0\0\0\32\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\273\25sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\v\0008\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.669015 fstat(3, {st_mode=S_IFREG|0644, st_size=35104, ...}) = 0
09:01:57.669065 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c21000
09:01:57.669110 mmap(NULL, 2318784, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f92d6a3a000
09:01:57.669169 mprotect(0x7f92d6a42000, 2093056, PROT_NONE) = 0
09:01:57.669230 mmap(0x7f92d6c41000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x7000) = 0x7f92d6c41000
09:01:57.669289 mmap(0x7f92d6c43000, 184768, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f92d6c43000
09:01:57.669329 close(3)                = 0
09:01:57.669396 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c20000
09:01:57.669437 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c1f000
09:01:57.669482 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f92d7c1e000
09:01:57.669518 arch_prctl(ARCH_SET_FS, 0x7f92d7c1f700) = 0
09:01:57.669581 mprotect(0x7f92d6c41000, 4096, PROT_READ) = 0
09:01:57.669748 mprotect(0x7f92d6ff2000, 16384, PROT_READ) = 0
09:01:57.669816 mprotect(0x7f92d7212000, 4096, PROT_READ) = 0
09:01:57.669858 mprotect(0x7f92d7498000, 4096, PROT_READ) = 0
09:01:57.669910 mprotect(0x7f92d769c000, 4096, PROT_READ) = 0
09:01:57.670133 mprotect(0x7f92d7a15000, 16384, PROT_READ) = 0
09:01:57.670189 mprotect(0x601000, 4096, PROT_READ) = 0
09:01:57.670232 mprotect(0x7f92d7c3e000, 4096, PROT_READ) = 0
09:01:57.670266 munmap(0x7f92d7c23000, 98904) = 0
09:01:57.670324 set_tid_address(0x7f92d7c1f9d0) = 5508
09:01:57.670367 set_robust_list(0x7f92d7c1f9e0, 0x18) = 0
09:01:57.670403 futex(0x7ffc53d0c4bc, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, 7f92d7c1f700) = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.670454 rt_sigaction(SIGRTMIN, {0x7f92d7001ad0, [], SA_RESTORER|SA_SIGINFO, 0x7f92d700b0a0}, NULL, 8) = 0
09:01:57.670503 rt_sigaction(SIGRT_1, {0x7f92d7001b60, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7f92d700b0a0}, NULL, 8) = 0
09:01:57.670545 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
09:01:57.670593 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=8192*1024}) = 0
09:01:57.670687 rt_sigaction(SIGFPE, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0x7f92d6ca31e0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.670779 brk(0)                  = 0x1dfd000
09:01:57.670820 brk(0x1e1e000)          = 0x1e1e000
09:01:57.670933 getuid()                = 1000
09:01:57.670974 geteuid()               = 1000
09:01:57.671033 getgid()                = 1000
09:01:57.671077 getegid()               = 1000
09:01:57.671134 open("/usr/lib/locale/locale-archive", O_RDONLY) = 3
09:01:57.671192 fstat(3, {st_mode=S_IFREG|0644, st_size=2051648, ...}) = 0
09:01:57.671246 mmap(NULL, 2051648, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f92d6845000
09:01:57.671299 close(3)                = 0
09:01:57.671427 open("/dev/urandom", O_RDONLY) = 3
09:01:57.671489 read(3, "\225_\340\t", 4) = 4
09:01:57.671536 close(3)                = 0
09:01:57.671980 stat("modules/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672028 stat("modules/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672073 stat("modules/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672111 stat("modules/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672157 stat("modules/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672202 stat("modules/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672239 stat("/etc/perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672284 stat("/etc/perl/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672329 stat("/etc/perl/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672401 stat("/usr/local/lib/perl/5.14.2/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672459 stat("/usr/local/lib/perl/5.14.2/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672501 stat("/usr/local/lib/perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672553 stat("/usr/local/share/perl/5.14.2/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672607 stat("/usr/local/share/perl/5.14.2/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672649 stat("/usr/local/share/perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672701 stat("/usr/lib/perl5/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672754 stat("/usr/lib/perl5/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672795 stat("/usr/lib/perl5/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672844 stat("/usr/share/perl5/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672898 stat("/usr/share/perl5/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672938 stat("/usr/share/perl5/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.672988 stat("/usr/lib/perl/5.14/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673043 stat("/usr/lib/perl/5.14/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673085 stat("/usr/lib/perl/5.14/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673147 stat("/usr/share/perl/5.14/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673204 stat("/usr/share/perl/5.14/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673247 stat("/usr/share/perl/5.14/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673306 stat("/usr/local/lib/site_perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673361 stat("/usr/local/lib/site_perl/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673402 stat("/usr/local/lib/site_perl/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673455 stat("./5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673508 stat("./5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673548 stat("./x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673615 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
09:01:57.673707 stat("/usr/local/lib/site_perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673751 stat("/usr/local/lib/site_perl/5.14.2", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673798 stat("/usr/local/lib/site_perl/x86_64-linux-gnu-thread-multi", 0x7ffc53d0c150) = -1 ENOENT (No such file or directory)
09:01:57.673872 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0beb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.673915 lseek(0, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.673963 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0beb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.674012 lseek(1, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.674075 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0bec0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.674121 lseek(2, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.674171 open("/dev/null", O_RDONLY) = 3
09:01:57.674217 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0bff0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.674260 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.674309 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.674348 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
09:01:57.674481 brk(0x1e3f000)          = 0x1e3f000
09:01:57.674689 stat("modules/POE/Component/Resolver/Sidecar.pmc", 0x7ffc53d0bc10) = -1 ENOENT (No such file or directory)
09:01:57.674738 stat("modules/POE/Component/Resolver/Sidecar.pm", {st_mode=S_IFREG|0600, st_size=2388, ...}) = 0
09:01:57.674788 open("modules/POE/Component/Resolver/Sidecar.pm", O_RDONLY) = 4
09:01:57.674885 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b8f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.674929 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.674993 read(4, "package POE::Component::Resolver::Sidecar;\n{\n  $POE::Component::Resolver::Sidecar::VERSION = '0.921';\n}\n\nuse warnings;\nuse strict;\n\nuse Storable qw(nfreeze thaw);\n\nuse Socket qw(getaddrinfo);\n\nsub main {\n\tmy $buffer = \"\";\n\tmy $read_length;\n\n\tbinmode(STDIN);\n\tbinmode(STDOUT);\n\tselect STDOUT; $| = 1;\n\n\tuse bytes;\n\n\twhile (1) {\n\t\tif (defined $read_length) {\n\t\t\tif (length($buffer) >= $read_length) {\n\t\t\t\tmy $request = thaw(substr($buffer, 0, $read_length, \"\"));\n\t\t\t\t$read_length = undef;\n\n\t\t\t\tmy ($request_id, $host, $service, $hints) = @$request;\n\t\t\t\tmy ($err, @addrs) = getaddrinfo($host, $service, $hints);\n\n\t\t\t\tmy $streamable = nfreeze( [ $request_id, $err, \\@addrs ] );\n\t\t\t\tmy $stream = length($streamable) . chr(0) . $streamable;\n\n\t\t\t\tmy $octets_wrote = syswrite(STDOUT, $stream);\n\t\t\t\tdie $! unless $octets_wrote == length($stream);\n\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\telsif ($buffer =~ s/^(\\d+)\\0//) {\n\t\t\t$read_length = $1;\n\t\t\tnext;\n\t\t}\n\n\t\tmy $octets_read = sysread(STDIN, $buffer, 4096, length($buffer));\n\t\tlast unless $octets_read;\n\t}\n\n\texit 0;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Resolver::Sidecar - delegate subprocess to call getaddrinfo()\n\n=head1 VERSION\n\nversion 0.921\n\n=head1 SYNOPSIS\n\nUsed internally by POE::Component::Resolver.\n\n=head1 DESCRIPTION\n\nPOE::Component::Resolver creates subprocesses to call getaddrinfo() so\nthat the main program doesn't block during that time.\n\nThe actual getaddrinfo() calling code is abstracted into this module\nso it can be run in a separate executable program.  This reduces the\nmemory footprint of forking the entire main process for just\ngetaddrinfo().\n\nIt's a strong, useful pattern that other POE::Components have\nimplemented before.  POE::Quickie does it generically.\nPOE::Component::SimpleDBI and POE::Component::EasyDBI do it so their\nDBI subprocesses are relatively lightweight.\n\n=head2 main\n\nThe main code to read POE::Component::Resolver requests from STDIN and\nwrite getaddrinfo() responses to STDOUT.\n\n=head1 SEE ALSO\n\nL<POE::Component::Generic> is one generic implementation of this\npattern.\n\nL<POE::Quickie> is another generic implementation of this pattern.\n\n=head1 BUGS\n\nNone known.\n\n=head1 LICENSE\n\nExcept where otherwise noted, this distribution is Copyright 2011 by\nRocco Caputo.  All rights reserved.  This distribution is free\nsoftware; you may redistribute it and/or modify it under the same\nterms as Perl itself.\n\n=cut\n", 8192) = 2388
09:01:57.675192 stat("modules/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675239 stat("modules/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675281 stat("modules/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675322 stat("modules/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675365 stat("/etc/perl/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675407 stat("/etc/perl/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675447 stat("/usr/local/lib/perl/5.14.2/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675494 stat("/usr/local/lib/perl/5.14.2/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675534 stat("/usr/local/share/perl/5.14.2/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675574 stat("/usr/local/share/perl/5.14.2/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675616 stat("/usr/lib/perl5/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675659 stat("/usr/lib/perl5/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675702 stat("/usr/share/perl5/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675740 stat("/usr/share/perl5/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675786 stat("/usr/lib/perl/5.14/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675829 stat("/usr/lib/perl/5.14/warnings.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.675883 stat("/usr/share/perl/5.14/warnings.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.675925 stat("/usr/share/perl/5.14/warnings.pm", {st_mode=S_IFREG|0644, st_size=15015, ...}) = 0
09:01:57.676004 open("/usr/share/perl/5.14/warnings.pm", O_RDONLY) = 5
09:01:57.676084 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b2c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.676124 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.676222 read(5, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file is built by regen/warnings.pl.\n# Any changes made here will be lost!\n\npackage warnings;\n\nour $VERSION = '1.12';\n\n# Verify that we're called correctly so that warnings will work.\n# see also strict.pm.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    'all'\t\t=> 0,\n    'closure'\t\t=> 2,\n    'deprecated'\t=> 4,\n    'exiting'\t\t=> 6,\n    'glob'\t\t=> 8,\n    'io'\t\t=> 10,\n    'closed'\t\t=> 12,\n    'exec'\t\t=> 14,\n    'layer'\t\t=> 16,\n    'newline'\t\t=> 18,\n    'pipe'\t\t=> 20,\n    'unopened'\t\t=> 22,\n    'misc'\t\t=> 24,\n    'numeric'\t\t=> 26,\n    'once'\t\t=> 28,\n    'overflow'\t\t=> 30,\n    'pack'\t\t=> 32,\n    'portable'\t\t=> 34,\n    'recursion'\t\t=> 36,\n    'redefine'\t\t=> 38,\n    'regexp'\t\t=> 40,\n    'severe'\t\t=> 42,\n    'debugging'\t\t=> 44,\n    'inplace'\t\t=> 46,\n    'internal'\t\t=> 48,\n    'malloc'\t\t=> 50,\n    'signal'\t\t=> 52,\n    'substr'\t\t=> 54,\n    'syntax'\t\t=> 56,\n    'ambiguous'\t\t=> 58,\n    'bareword'\t\t=> 60,\n    'digit'\t\t=> 62,\n    'parenthesis'\t=> 64,\n    'precedence'\t=> 66,\n    'printf'\t\t=> 68,\n    'prototype'\t\t=> 70,\n    'qw'\t\t=> 72,\n    'reserved'\t\t=> 74,\n    'semicolon'\t\t=> 76,\n    'taint'\t\t=> 78,\n    'threads'\t\t=> 80,\n    'uninitialized'\t=> 82,\n    'unpack'\t\t=> 84,\n    'untie'\t\t=> 86,\n    'utf8'\t\t=> 88,\n    'void'\t\t=> 90,\n\n    # Warnings Categories added in Perl 5.011\n\n    'imprecision'\t=> 92,\n    'illegalproto'\t=> 94,\n\n    # Warnings Categories added in Perl 5.013\n\n    'non_unicode'\t=> 96,\n    'nonchar'\t\t=> 98,\n    'surrogate'\t\t=> 100,\n  );\n\nour %Bits = (\n    'all'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..50]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecated'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'glob'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    'layer'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x40\\x00\", # [28..38,47]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x15\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [45]\n  );\n\nour %DeadBits = (\n    'all'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..50]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecated'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'glob'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    'layer'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x", 8192) = 8192
09:01:57.677442 brk(0x1e60000)          = 0x1e60000
09:01:57.677515 read(5, "08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x80\\x00\", # [28..38,47]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x2a\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [45]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 102 ;\n$BYTES    = 13 ;\n\n$All = \"\" ; vec($All, $Offsets{'all'}, 2) = 3 ;\n\nsub Croaker\n{\n    require Carp; # this initializes %CarpInternal\n    local $Carp::CarpInternal{'warnings'};\n    delete $Carp::CarpInternal{'warnings'};\n    Carp::croak(@_);\n}\n\nsub _bits {\n    my $mask = shift ;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq 'NONFATAL') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    return $mask ;\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n    push @_, 'all' unless @_ ;\n    return _bits(undef, @_) ;\n}\n\nsub import \n{\n    shift;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n    \n    # Empty @_ is equivalent to @_ = 'all' ;\n    ${^WARNING_BITS} = @_ ? _bits($mask, @_) : $mask | $Bits{all} ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n\n    push @_, 'all' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub MESSAGE () { 4 };\nsub FATAL () { 2 };\nsub NORMAL () { 1 };\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n    my $wanted = shift;\n    my $has_message = $wanted & MESSAGE;\n\n    unless (@_ == 1 || @_ == ($has_message ? 2 : 0)) {\n\tmy $sub = (caller 1)[3];\n\tmy $syntax = $has_message ? \"[category,] 'message'\" : '[category]';\n\tCroaker(\"Usage: $sub($syntax)\");\n    }\n\n    my $message = pop if $has_message;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category '$category'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package '$category' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $i;\n\n    if ($isobj) {\n        my $pkg;\n        $i = 2;\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        $i = _error_loc(); # see where Carp will allocate the error\n    }\n\n    # Defaulting this to 0 reduces complexity in code paths below.\n    my $callers_bitmask = (caller($i))[9] || 0 ;\n\n    my @results;\n    foreach my $type (FATAL, NORMAL) {\n\tnext unless $wanted & $type;\n\n\tpush @results, (vec($callers_bitmask, $offset + $type - 1, 1) ||\n\t\t\tvec($callers_bitmask, $Offsets{'all'} + $type - 1, 1));\n    }\n\n    # &enabled and &fatal_enabled\n    return $results[0] unless $has_message;\n\n    # &warnif, and the category is neither enabled as warning nor as fatal\n    return if $wanted == (NORMAL | FATAL | MESSAGE)\n\t&& !($results[0] || $results[1]);\n\n    require Carp;\n    Carp::croak($message) if $results[0];\n    # will always get here for &warn. will only get here for &warnif if the\n    # category is enabled\n    Carp::carp($message);\n}\n\nsub _mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub register_categories\n{\n    my @names = @_;\n\n    for my $name (@names) {\n\tif (! defined $Bits{$name}) {\n\t    $Bits{$name}     = _mkMask($LAST_BIT);\n\t    vec($Bits{'all'}, $LAST_BIT, 1) = 1;\n\t    $Offsets{$name}  = $LAST_BIT ++;\n\t    foreach my $k (keys %Bits) {\n\t\tvec($Bits{$k}, $LAST_BIT, 1) = 0;\n\t    }\n\t    $DeadBits{$name} = _mkMask($LAST_BIT);\n\t    vec($DeadBits{'all'}, $LAST_BIT++, 1) = 1;\n\t}\n    }\n}\n\nsub _error_loc {\n    require Carp;\n    goto &Carp::short_error_loc; # don't introduce another stack frame\n}\n\nsub enabled\n{\n    return __chk(NORMAL, @_);\n}\n\nsub fatal_enabled\n{\n    return __chk(FATAL, @_);\n}\n\nsub warn\n{\n    return __chk(FATAL | MESSAGE, @_);\n}\n\nsub warnif\n{\n    return __chk(NORMAL | FATAL | MESSAGE, @_);\n}\n\n# These are not part of any public interface, so we can delete them to save\n# space.\ndelete $warnings::{$_} foreach qw(NORMAL FATAL MESSAGE);\n\n1;\n\n# ex: set ro:\n", 8192) = 6823
09:01:57.678972 read(5, "", 8192)       = 0
09:01:57.679056 close(5)                = 0
09:01:57.679267 brk(0x1e81000)          = 0x1e81000
09:01:57.679444 stat("modules/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.679489 stat("modules/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.679547 stat("modules/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.679582 stat("modules/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.679625 stat("/etc/perl/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.679676 stat("/etc/perl/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.679721 stat("/usr/local/lib/perl/5.14.2/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.679770 stat("/usr/local/lib/perl/5.14.2/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.679914 stat("/usr/local/share/perl/5.14.2/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.679960 stat("/usr/local/share/perl/5.14.2/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.680003 stat("/usr/lib/perl5/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.680051 stat("/usr/lib/perl5/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.680093 stat("/usr/share/perl5/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.680139 stat("/usr/share/perl5/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.680195 stat("/usr/lib/perl/5.14/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.680333 stat("/usr/lib/perl/5.14/strict.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.680375 stat("/usr/share/perl/5.14/strict.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.680410 stat("/usr/share/perl/5.14/strict.pm", {st_mode=S_IFREG|0644, st_size=879, ...}) = 0
09:01:57.680454 open("/usr/share/perl/5.14/strict.pm", O_RDONLY) = 5
09:01:57.680495 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b2c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.680542 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.680629 read(5, "package strict;\n\n$strict::VERSION = \"1.04\";\n\n# Verify that we're called correctly so that strictures will work.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    # Can't use Carp, since Carp uses us!\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown 'strict' tag(s) '@wrong'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 8192) = 879
09:01:57.680881 lseek(5, 878, SEEK_SET) = 878
09:01:57.680923 lseek(5, 0, SEEK_CUR)   = 878
09:01:57.680965 close(5)                = 0
09:01:57.681444 stat("modules/Storable.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.681499 stat("modules/Storable.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.681552 stat("modules/Storable.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.681597 stat("modules/Storable.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.681631 stat("/etc/perl/Storable.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.681758 stat("/etc/perl/Storable.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.681802 stat("/usr/local/lib/perl/5.14.2/Storable.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.681874 stat("/usr/local/lib/perl/5.14.2/Storable.pm", {st_mode=S_IFREG|0444, st_size=43139, ...}) = 0
09:01:57.681958 open("/usr/local/lib/perl/5.14.2/Storable.pm", O_RDONLY) = 5
09:01:57.682047 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b2c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.682114 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.682194 read(5, "#\n#  Copyright (c) 1995-2001, Raphael Manfredi\n#  Copyright (c) 2002-2014 by the Perl 5 Porters\n#\n#  You may redistribute only under the same terms as Perl 5, as specified\n#  in the README file that comes with the distribution.\n#\n\nrequire XSLoader;\nrequire Exporter;\npackage Storable; @ISA = qw(Exporter);\n\n@EXPORT = qw(store retrieve);\n@EXPORT_OK = qw(\n\tnstore store_fd nstore_fd fd_retrieve\n\tfreeze nfreeze thaw\n\tdclone\n\tretrieve_fd\n\tlock_store lock_nstore lock_retrieve\n        file_magic read_magic\n);\n\nuse vars qw($canonical $forgive_me $VERSION);\n\n$VERSION = '2.51';\n\nBEGIN {\n    if (eval { local $SIG{__DIE__}; require Log::Agent; 1 }) {\n        Log::Agent->import;\n    }\n    #\n    # Use of Log::Agent is optional. If it hasn't imported these subs then\n    # provide a fallback implementation.\n    #\n    unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {\n        require Carp;\n        *logcroak = sub {\n            Carp::croak(@_);\n        };\n    }\n    unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {\n\trequire Carp;\n        *logcarp = sub {\n          Carp::carp(@_);\n        };\n    }\n}\n\n#\n# They might miss :flock in Fcntl\n#\n\nBEGIN {\n\tif (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {\n\t\tFcntl->import(':flock');\n\t} else {\n\t\teval q{\n\t\t\tsub LOCK_SH ()\t{1}\n\t\t\tsub LOCK_EX ()\t{2}\n\t\t};\n\t}\n}\n\nsub CLONE {\n    # clone context under threads\n    Storable::init_perinterp();\n}\n\n# By default restricted hashes are downgraded on earlier perls.\n\n$Storable::downgrade_restricted = 1;\n$Storable::accept_future_minor = 1;\n\nXSLoader::load('Storable', $Storable::VERSION);\n\n#\n# Determine whether locking is possible, but only when needed.\n#\n\nsub CAN_FLOCK; my $CAN_FLOCK; sub CAN_FLOCK {\n\treturn $CAN_FLOCK if defined $CAN_FLOCK;\n\trequire Config; import Config;\n\treturn $CAN_FLOCK =\n\t\t$Config{'d_flock'} ||\n\t\t$Config{'d_fcntl_can_lock'} ||\n\t\t$Config{'d_lockf'};\n}\n\nsub show_file_magic {\n    print <<EOM;\n#\n# To recognize the data files of the Perl module Storable,\n# the following lines need to be added to the local magic(5) file,\n# usually either /usr/share/misc/magic or /etc/magic.\n#\n0\tstring\tperl-store\tperl Storable(v0.6) data\n>4\tbyte\t>0\t(net-order %d)\n>>4\tbyte\t&01\t(network-ordered)\n>>4\tbyte\t=3\t(major 1)\n>>4\tbyte\t=2\t(major 1)\n\n0\tstring\tpst0\tperl Storable(v0.7) data\n>4\tbyte\t>0\n>>4\tbyte\t&01\t(network-ordered)\n>>4\tbyte\t=5\t(major 2)\n>>4\tbyte\t=4\t(major 2)\n>>5\tbyte\t>0\t(minor %d)\nEOM\n}\n\nsub file_magic {\n    require IO::File;\n\n    my $file = shift;\n    my $fh = IO::File->new;\n    open($fh, \"<\". $file) || die \"Can't open '$file': $!\";\n    binmode($fh);\n    defined(sysread($fh, my $buf, 32)) || die \"Can't read from '$file': $!\";\n    close($fh);\n\n    $file = \"./$file\" unless $file;  # ensure TRUE value\n\n    return read_magic($buf, $file);\n}\n\nsub read_magic {\n    my($buf, $file) = @_;\n    my %info;\n\n    my $buflen = length($buf);\n    my $magic;\n    if ($buf =~ s/^(pst0|perl-store)//) {\n\t$magic = $1;\n\t$info{file} = $file || 1;\n    }\n    else {\n\treturn undef if $file;\n\t$magic = \"\";\n    }\n\n    return undef unless length($buf);\n\n    my $net_order;\n    if ($magic eq \"perl-store\" && ord(substr($buf, 0, 1)) > 1) {\n\t$info{version} = -1;\n\t$net_order = 0;\n    }\n    else {\n\t$buf =~ s/(.)//s;\n\tmy $major = (ord $1) >> 1;\n\treturn undef if $major > 4; # sanity (assuming we never go that high)\n\t$info{major} = $major;\n\t$net_order = (ord $1) & 0x01;\n\tif ($major > 1) {\n\t    return undef unless $buf =~ s/(.)//s;\n\t    my $minor = ord $1;\n\t    $info{minor} = $minor;\n\t    $info{version} = \"$major.$minor\";\n\t    $info{version_nv} = sprintf \"%d.%03d\", $major, $minor;\n\t}\n\telse {\n\t    $info{version} = $major;\n\t}\n    }\n    $info{version_nv} ||= $info{version};\n    $info{netorder} = $net_order;\n\n    unless ($net_order) {\n\treturn undef unless $buf =~ s/(.)//s;\n\tmy $len = ord $1;\n\treturn undef unless length($buf) >= $len;\n\treturn undef unless $len == 4 || $len == 8;  # sanity\n\t@info{qw(byteorder intsize longsize ptrsize)}\n\t    = unpack \"a${len}CCC\", $buf;\n\t(substr $buf, 0, $len + 3) = '';\n\tif ($info{version_nv} >= 2.002) {\n\t    return undef unless $buf =~ s/(.)//s;\n\t    $info{nvsize} = ord $1;\n\t}\n    }\n    $info{hdrsize} = $buflen - length($buf);\n\n    return \\%info;\n}\n\nsub BIN_VERSION_NV {\n    sprintf \"%d.%03d\", BIN_MAJOR(), BIN_MINOR();\n}\n\nsub BIN_WRITE_VERSION_NV {\n    sprintf \"%d.%03d\", BIN_MAJOR(), BIN_WRITE_MINOR();\n}\n\n#\n# store\n#\n# Store target object hierarchy, identified by a reference to its root.\n# The stored object tree may later be retrieved to memory via retrieve.\n# Returns undef if an I/O error occurred, in which case the file is\n# removed.\n#\nsub store {\n\treturn _store(\\&pstore, @_, 0);\n}\n\n#\n# nstore\n#\n# Same as store, but in network order.\n#\nsub nstore {\n\treturn _store(\\&net_pstore, @_, 0);\n}\n\n#\n# lock_store\n#\n# Same as store, but flock the file first (advisory locking).\n#\nsub lock_store {\n\treturn _store(\\&pstore, @_, 1);\n}\n\n#\n# lock_nstore\n#\n# Same as nstore, but flock the file first (advisory locking).\n#\nsub lock_nstore {\n\treturn _store(\\&net_pstore, @_, 1);\n}\n\n# Internal store to file routine\nsub _store {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tmy ($file, $use_locking) = @_;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"wrong argument number\" unless @_ == 2;\t# No @foo in arglist\n\tlocal *FILE;\n\tif ($use_locking) {\n\t\topen(FILE, \">>$file\") || logcroak \"can't write into $file: $!\";\n\t\tunless (&CAN_FLOCK) {\n\t\t\tlogcarp\n\t\t\t\t\"Storable::lock_store: fcntl/flock emulation broken on $^O\";\n\t\t\treturn undef;\n\t\t}\n\t\tflock(FILE, LOCK_EX) ||\n\t\t\tlogcroak \"can't get exclusive lock on $file: $!\";\n\t\ttruncate FILE, 0;\n\t\t# Unlocking will happen when FILE is closed\n\t} else {\n\t\topen(FILE, \">$file\") || logcroak \"can't create $file: $!\";\n\t}\n\tbinmode FILE;\t\t\t\t# Archaic systems...\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine nstore or pstore, depending on network order\n\teval { $ret = &$xsptr(*FILE, $self) };\n\t# close will return true on success, so the or short-circuits, the ()\n\t# expression is true, and for that case the block will only be entered\n\t# if $@ is true (ie eval failed)\n\t# if close fails, it returns false, $ret is altered, *that* is (also)\n\t# false, so the () expression is false, !() is true, and the block is\n\t# entered.\n\tif (!(close(FILE) or undef $ret) || $@) {\n\t\tunlink($file) or warn \"Can't unlink $file: $!\\n\";\n\t}\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $ret;\n}\n\n#\n# store_fd\n#\n# Same as store, but perform on an already opened file descriptor instead.\n# Returns undef if an I/O error occurred.\n#\nsub store_fd {\n\treturn _store_fd(\\&pstore, @_);\n}\n\n#\n# nstore_fd\n#\n# Same as store_fd, but in network order.\n#\nsub nstore_fd {\n\tmy ($self, $file) = @_;\n\treturn _store_fd(\\&net_pstore, @_);\n}\n\n# Internal store routine on opened file descriptor\nsub _store_fd {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tmy ($file) = @_;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"too many arguments\" unless @_ == 1;\t# No @foo in arglist\n\tmy $fd = fileno($file);\n\tlogcroak \"not a valid file descriptor\" unless defined $fd;\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine nstore or pstore, depending on network order\n\teval { $ret = &$xsptr($file, $self) };\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\tlocal $\\; print $file '';\t# Autoflush the file if wanted\n\t$@ = $da;\n\treturn $ret;\n}\n\n#\n# freeze\n#\n# Store object and its hierarchy in memory and return a scalar\n# containing the result.\n#\nsub freeze {\n\t_freeze(\\&mstore, @_);\n}\n\n#\n# nfreeze\n#\n# Same as freeze but in network order.\n#\nsub nfreeze {\n\t_freeze(\\&net_mstore, @_);\n}\n\n# Internal freeze routine\nsub _freeze {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"too many arguments\" unless @_ == 0;\t# No @foo in arglist\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine mstore or net_mstore, depending on network order\n\teval { $ret = &$xsptr($self) };\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $ret ? $ret : undef;\n}\n\n#\n# retrieve\n#\n# Retrieve object hierarchy from disk, returning a reference to the root\n# object of that tree.\n#\nsub retrieve {\n\t_retr", 8192) = 8192
09:01:57.682686 stat("modules/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.682730 stat("modules/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.682787 stat("modules/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.682822 stat("modules/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.682857 stat("/etc/perl/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683263 stat("/etc/perl/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683304 stat("/usr/local/lib/perl/5.14.2/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683388 stat("/usr/local/lib/perl/5.14.2/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683456 stat("/usr/local/share/perl/5.14.2/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683519 stat("/usr/local/share/perl/5.14.2/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683581 stat("/usr/lib/perl5/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683644 stat("/usr/lib/perl5/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683687 stat("/usr/share/perl5/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683740 stat("/usr/share/perl5/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683805 stat("/usr/lib/perl/5.14/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683877 stat("/usr/lib/perl/5.14/vars.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.683944 stat("/usr/share/perl/5.14/vars.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.683992 stat("/usr/share/perl/5.14/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
09:01:57.684048 open("/usr/share/perl/5.14/vars.pm", O_RDONLY) = 6
09:01:57.684090 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0ac90) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.684121 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.684198 read(6, "package vars;\n\nuse 5.006;\n\nour $VERSION = '1.02';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my (undef, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can't declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits('vars'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"'$_' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"'$_' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"'$_' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 8192) = 1149
09:01:57.684411 stat("modules/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.684477 stat("modules/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.684540 stat("modules/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.684596 stat("modules/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.684654 stat("/etc/perl/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.684713 stat("/etc/perl/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.684782 stat("/usr/local/lib/perl/5.14.2/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.684848 stat("/usr/local/lib/perl/5.14.2/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.684917 stat("/usr/local/share/perl/5.14.2/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.684983 stat("/usr/local/share/perl/5.14.2/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.685027 stat("/usr/lib/perl5/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.685103 stat("/usr/lib/perl5/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.685144 stat("/usr/share/perl5/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.685207 stat("/usr/share/perl5/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.685268 stat("/usr/lib/perl/5.14/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.685313 stat("/usr/lib/perl/5.14/warnings/register.pm", 0x7ffc53d0a8d0) = -1 ENOENT (No such file or directory)
09:01:57.685372 stat("/usr/share/perl/5.14/warnings/register.pmc", 0x7ffc53d0a980) = -1 ENOENT (No such file or directory)
09:01:57.685433 stat("/usr/share/perl/5.14/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=481, ...}) = 0
09:01:57.685502 open("/usr/share/perl/5.14/warnings/register.pm", O_RDONLY) = 7
09:01:57.685564 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a660) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.685606 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.685695 read(7, "package warnings::register;\n\nour $VERSION = '1.02';\n\nrequire warnings;\n\n# left here as cruft in case other users were using this undocumented routine\n# -- rjbs, 2010-09-08\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my @categories = @_;\n\n    my $package = (caller(0))[0];\n    warnings::register_categories($package);\n\n    warnings::register_categories($package . \"::$_\") for @categories;\n}\n\n1;\n", 8192) = 481
09:01:57.685864 read(7, "", 8192)       = 0
09:01:57.685925 close(7)                = 0
09:01:57.686246 lseek(6, 1148, SEEK_SET) = 1148
09:01:57.686295 lseek(6, 0, SEEK_CUR)   = 1148
09:01:57.686330 close(6)                = 0
09:01:57.686553 stat("modules/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.686619 stat("modules/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.686691 stat("modules/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.686737 stat("modules/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.686780 stat("/etc/perl/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.686822 stat("/etc/perl/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.686890 stat("/usr/local/lib/perl/5.14.2/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.686955 stat("/usr/local/lib/perl/5.14.2/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.687023 stat("/usr/local/share/perl/5.14.2/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.687093 stat("/usr/local/share/perl/5.14.2/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.687159 stat("/usr/lib/perl5/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.687222 stat("/usr/lib/perl5/Log/Agent.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.687290 stat("/usr/share/perl5/Log/Agent.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.687354 stat("/usr/share/perl5/Log/Agent.pm", {st_mode=S_IFREG|0644, st_size=23745, ...}) = 0
09:01:57.687427 open("/usr/share/perl5/Log/Agent.pm", O_RDONLY) = 6
09:01:57.687511 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0ace0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.687570 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.687646 read(6, "###########################################################################\n# $Id: Agent.pm,v 1.11 2005/10/02 16:57:17 wendigo Exp $\n###########################################################################\n#\n# Log::Agent\n#\n# RCS Revision: $Revision: 1.11 $\n# Date: $Date: 2005/10/02 16:57:17 $\n#\n# Copyright (C) 1999 Raphael Manfredi.\n# Copyright (C) 2002-2003,2005 Mark Rogaski, mrogaski@cpan.org;\n# all rights reserved.\n#\n# See the README file included with the\n# distribution for license information.\n#\n###########################################################################\n\nuse strict;\nrequire Exporter;\n\n########################################################################\npackage Log::Agent;\n\nuse vars qw($VERSION $Driver $Prefix $Trace $Debug $Confess\n\t$OS_Error $AUTOLOAD $Caller $Priorities $Tags $DATUM %prio_cache);\n\nuse AutoLoader;\nuse vars qw(@ISA @EXPORT @EXPORT_OK);\n\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tlogconfig\n\tlogconfess logcroak logcarp logxcroak logxcarp\n\tlogsay logerr logwarn logdie logtrc logdbg\n);\n@EXPORT_OK = qw(\n\tlogwrite logtags\n);\n\nuse Log::Agent::Priorities qw(:LEVELS priority_level level_from_prio);\nuse Log::Agent::Formatting qw(tag_format_args);\n\n$VERSION = '0.307';\n\n$Trace = NOTICE;\t# Default tracing\n$OS_Error = '';         # Data stash for the $! value\n\nsub AUTOLOAD {\n    ${Log::Agent::OS_Error} = $!;       # for safe-keeping, the braces\n                                        # prevent CVS substitution\n    $AutoLoader::AUTOLOAD = $AUTOLOAD;\n    goto &AutoLoader::AUTOLOAD;\n}\n\n1;\n__END__\n\n#\n# logconfig\n#\n# Configure the logging system at the application level. By default, logging\n# uses the Log::Agent::Driver::Default driver.\n#\n# Available options (case insensitive):\n#\n#   -PREFIX   => string           logging prefix/tag to use, for Default agent\n#   -DRIVER   => object           object heir of Log::Agent::Driver\n#   -TRACE    => level            trace level\n#   -DEBUG    => level            debug level\n#   -LEVEL    => level            specifies common trace/debug level\n#   -CONFESS  => flag             whether to automatically confess on logdie\n#   -CALLER   => listref          info from caller to add and where\n#   -PRIORITY => listref          message priority information to add\n#   -TAGS     => listref          list of user-defined tags to add\n#\n# Notes:\n#   -CALLER   allowed keys documented in Log::Agent::Tag::Caller's make()\n#   -PRIORITY allowed keys documented in Log::Agent::Tag::Priority's make()\n#   -TAGS     supplies list of Log::Agent::Tag objects\n#\nsub logconfig {\n\tmy (%args) = @_;\n\tmy ($calldef, $priodef, $tags);\n\n\tmy %set = (\n\t\t-prefix\t\t\t=> \\$Prefix,\t\t# Only for Default init\n\t\t-driver\t\t\t=> \\$Driver,\n\t\t-trace\t\t\t=> \\$Trace,\n\t\t-debug\t\t\t=> \\$Debug,\n\t\t-level\t\t\t=> [\\$Trace, \\$Debug],\n\t\t-confess\t\t=> \\$Confess,\n\t\t-caller\t\t\t=> \\$calldef,\n\t\t-priority\t\t=> \\$priodef,\n\t\t-tags\t\t\t=> \\$tags,\n\t);\n\n\twhile (my ($arg, $val) = each %args) {\n\t\tmy $vset = $set{lc($arg)};\n\t\tunless (ref $vset) {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Unknown switch $arg\");\n\t\t}\n\t\tif\t\t(ref $vset eq 'SCALAR')\t\t{ $$vset = $val }\n\t\telsif\t(ref $vset eq 'ARRAY')\t\t{ map { $$_ = $val } @$vset }\n\t\telsif\t(ref $vset eq 'REF')\t\t{ $$vset = $val }\n\t\telse\t\t\t\t\t\t\t\t{ die \"bug in logconfig\" }\n\t}\n\n\tunless (defined $Driver) {\n\t\trequire Log::Agent::Driver::Default;\n\t\t# Keep only basename for default prefix\n\t\t$Prefix =~ s|^.*/(.*)|$1| if defined $Prefix;\n\t\t$Driver = Log::Agent::Driver::Default->make($Prefix);\n\t}\n\n\t$Prefix = $Driver->prefix;\n\t$Trace = level_from_prio($Trace) if defined $Trace && $Trace =~ /^\\D+/;\n\t$Debug = level_from_prio($Debug) if defined $Debug && $Debug =~ /^\\D+/;\n\n\t#\n\t# Handle -caller => [ <options for Log::Agent::Tag::Caller's make> ]\n\t#\n\n\tif (defined $calldef) {\n\t\tunless (ref $calldef eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -caller must supply an array ref\");\n\t\t}\n\t\trequire Log::Agent::Tag::Caller;\n\t\t$Caller = Log::Agent::Tag::Caller->make(-offset => 3, @{$calldef});\n\t};\n\n\t#\n\t# Handle -priority => [ <options for Log::Agent::Tag::Priority's make> ]\n\t#\n\n\tif (defined $priodef) {\n\t\tunless (ref $priodef eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -priority must supply an array ref\");\n\t\t}\n\t\t$Priorities = $priodef;\t\t# Objects created via prio_tag()\n\t};\n\n\t#\n\t# Handle -tags => [ <list of Log::Agent::Tag objects> ]\n\t#\n\n\tif (defined $tags) {\n\t\tunless (ref $tags eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -tags must supply an array ref\");\n\t\t}\n\t\tmy $type = \"Log::Agent::Tag\";\n\t\tif (grep { !ref $_ || !$_->isa($type) } @$tags) {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -tags must supply list of $type objects\");\n\t\t}\n\t\tif (@$tags) {\n\t\t\trequire Log::Agent::Tag_List;\n\t\t\t$Tags = Log::Agent::Tag_List->make(@$tags);\n\t\t} else {\n\t\t\tundef $Tags;\n\t\t}\n\t}\n\n\t# Install interceptor if needed\n\tDATUM_is_here() if defined $DATUM && $DATUM;\n}\n\n#\n# inited\n#\n# Returns whether Log::Agent was inited.\n# NOT exported, must be called as Log::Agent::inited().\n#\nsub inited {\n\treturn 0 unless defined $Driver;\n\treturn ref $Driver ? 1 : 0;\n}\n\n#\n# DATUM_is_here\t\t-- undocumented, but for Carp::Datum\n#\n# Tell Log::Agent that the Carp::Datum package was loaded and configured\n# for debug.\n#\n# If there is a driver configured already, install the interceptor.\n# Otherwise, record that DATUM is here and the interceptor will be installed\n# by logconfig().\n#\n# NOT exported, must be called as Log::Agent::DATUM_is_here().\n#\nsub DATUM_is_here {\n\t$DATUM = 1;\n\treturn unless defined $Driver;\n\treturn if ref $Driver eq 'Log::Agent::Driver::Datum';\n\n\t#\n\t# Install the interceptor.\n\t#\n\n\trequire Log::Agent::Driver::Datum;\n\t$Driver = Log::Agent::Driver::Datum->make($Driver);\n}\n\n#\n# log_default\n#\n# Initialize a default logging driver.\n#\nsub log_default {\n\treturn if defined $Driver;\n\tlogconfig();\n}\n\n#\n# logconfess\n#\n# Die with a full stack trace\n#\nsub logconfess {\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logconfess($str);\n\tbug(\"back from logconfess in driver $Driver\\n\");\n}\n\n#\n# logcroak\n#\n# Fatal error, from the perspective of our caller\n# Error is logged, and then we die.\n#\nsub logcroak {\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcroak(0, $str);\n\tbug(\"back from logxcroak in driver $Driver\\n\");\n}\n\n#\n# logxcroak\n#\n# Same a logcroak, but with a specific additional offset.\n#\nsub logxcroak {\n\tmy $offset = shift;\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcroak($offset, $str);\n\tbug(\"back from logxcroak in driver $Driver\\n\");\n}\n\n#\n# logdie\n#\n# Fatal error\n# Error is logged, and then we die.\n#\nsub logdie {\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logdie($str);\n\tbug(\"back from logdie in driver $Driver\\n\");\n}\n\n#\n# logerr\n#\n# Log error, at the \"error\" level.\n#\nsub logerr {\n\treturn if $Trace < ERROR;\n\tmy $ptag = prio_tag(priority_level(ERROR)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logerr($str);\n}\n\n#\n# logcarp\n#\n# Warning, from the perspective of our caller (at the \"warning\" level)\n#\nsub logcarp {\n\treturn if $Trace < WARN;\n\tmy $ptag = prio_tag(priority_level(WARN)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcarp(0, $str);\n}\n\n#\n# logxcarp\n#\n# Same a logcarp, but with a specific additional offset.\n#\nsub logxcarp {\n\treturn if $Trace < WARN;\n\tmy $offset = shift;\n\tmy $ptag = prio_tag(priority_level(WARN)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Dr", 8192) = 8192
09:01:57.688219 stat("modules/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688288 stat("modules/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.688354 stat("modules/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688421 stat("modules/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.688484 stat("/etc/perl/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688547 stat("/etc/perl/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.688616 stat("/usr/local/lib/perl/5.14.2/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688680 stat("/usr/local/lib/perl/5.14.2/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.688748 stat("/usr/local/share/perl/5.14.2/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688827 stat("/usr/local/share/perl/5.14.2/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.688892 stat("/usr/lib/perl5/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.688954 stat("/usr/lib/perl5/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.689022 stat("/usr/share/perl5/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.689084 stat("/usr/share/perl5/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.689169 stat("/usr/lib/perl/5.14/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.689247 stat("/usr/lib/perl/5.14/AutoLoader.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.689312 stat("/usr/share/perl/5.14/AutoLoader.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.689394 stat("/usr/share/perl/5.14/AutoLoader.pm", {st_mode=S_IFREG|0644, st_size=5404, ...}) = 0
09:01:57.689474 open("/usr/share/perl/5.14/AutoLoader.pm", O_RDONLY) = 7
09:01:57.689541 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.689602 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.689679 read(7, "package AutoLoader;\n\nuse strict;\nuse 5.006_001;\n\nour($VERSION, $AUTOLOAD);\n\nmy $is_dosish;\nmy $is_epoc;\nmy $is_vms;\nmy $is_macos;\n\nBEGIN {\n    $is_dosish = $^O eq 'dos' || $^O eq 'os2' || $^O eq 'MSWin32' || $^O eq 'NetWare';\n    $is_epoc = $^O eq 'epoc';\n    $is_vms = $^O eq 'VMS';\n    $is_macos = $^O eq 'MacOS';\n    $VERSION = '5.71';\n}\n\nAUTOLOAD {\n    my $sub = $AUTOLOAD;\n    my $filename = AutoLoader::find_filename( $sub );\n\n    my $save = $@;\n    local $!; # Do not munge the value. \n    eval { local $SIG{__DIE__}; require $filename };\n    if ($@) {\n\tif (substr($sub,-9) eq '::DESTROY') {\n\t    no strict 'refs';\n\t    *$sub = sub {};\n\t    $@ = undef;\n\t} elsif ($@ =~ /^Can't locate/) {\n\t    # The load might just have failed because the filename was too\n\t    # long for some old SVR3 systems which treat long names as errors.\n\t    # If we can successfully truncate a long name then it's worth a go.\n\t    # There is a slight risk that we could pick up the wrong file here\n\t    # but autosplit should have warned about that when splitting.\n\t    if ($filename =~ s/(\\w{12,})\\.al$/substr($1,0,11).\".al\"/e){\n\t\teval { local $SIG{__DIE__}; require $filename };\n\t    }\n\t}\n\tif ($@){\n\t    $@ =~ s/ at .*\\n//;\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::croak($error);\n\t}\n    }\n    $@ = $save;\n    goto &$sub;\n}\n\nsub find_filename {\n    my $sub = shift;\n    my $filename;\n    # Braces used to preserve $1 et al.\n    {\n\t# Try to find the autoloaded file from the package-qualified\n\t# name of the sub. e.g., if the sub needed is\n\t# Getopt::Long::GetOptions(), then $INC{Getopt/Long.pm} is\n\t# something like '/usr/lib/perl5/Getopt/Long.pm', and the\n\t# autoload file is '/usr/lib/perl5/auto/Getopt/Long/GetOptions.al'.\n\t#\n\t# However, if @INC is a relative path, this might not work.  If,\n\t# for example, @INC = ('lib'), then $INC{Getopt/Long.pm} is\n\t# 'lib/Getopt/Long.pm', and we want to require\n\t# 'auto/Getopt/Long/GetOptions.al' (without the leading 'lib').\n\t# In this case, we simple prepend the 'auto/' and let the\n\t# C<require> take care of the searching for us.\n\n\tmy ($pkg,$func) = ($sub =~ /(.*)::([^:]+)$/);\n\t$pkg =~ s#::#/#g;\n\tif (defined($filename = $INC{\"$pkg.pm\"})) {\n\t    if ($is_macos) {\n\t\t$pkg =~ tr#/#:#;\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto:$pkg:$func.al#s;\n\t    } else {\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto/$pkg/$func.al#s;\n\t    }\n\n\t    # if the file exists, then make sure that it is a\n\t    # a fully anchored path (i.e either '/usr/lib/auto/foo/bar.al',\n\t    # or './lib/auto/foo/bar.al'.  This avoids C<require> searching\n\t    # (and failing) to find the 'lib/auto/foo/bar.al' because it\n\t    # looked for 'lib/lib/auto/foo/bar.al', given @INC = ('lib').\n\n\t    if (defined $filename and -r $filename) {\n\t\tunless ($filename =~ m|^/|s) {\n\t\t    if ($is_dosish) {\n\t\t\tunless ($filename =~ m{^([a-z]:)?[\\\\/]}is) {\n\t\t\t    if ($^O ne 'NetWare') {\n\t\t\t\t$filename = \"./$filename\";\n\t\t\t    } else {\n\t\t\t\t$filename = \"$filename\";\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_epoc) {\n\t\t\tunless ($filename =~ m{^([a-z?]:)?[\\\\/]}is) {\n\t\t\t     $filename = \"./$filename\";\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_vms) {\n\t\t\t# XXX todo by VMSmiths\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t    elsif (!$is_macos) {\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\t$filename = undef;\n\t    }\n\t}\n\tunless (defined $filename) {\n\t    # let C<require> do the searching\n\t    $filename = \"auto/$sub.al\";\n\t    $filename =~ s#::#/#g;\n\t}\n    }\n    return $filename;\n}\n\nsub import {\n    my $pkg = shift;\n    my $callpkg = caller;\n\n    #\n    # Export symbols, but not by accident of inheritance.\n    #\n\n    if ($pkg eq 'AutoLoader') {\n\tif ( @_ and $_[0] =~ /^&?AUTOLOAD$/ ) {\n\t    no strict 'refs';\n\t    *{ $callpkg . '::AUTOLOAD' } = \\&AUTOLOAD;\n\t}\n    }\n\n    #\n    # Try to find the autosplit index file.  Eg., if the call package\n    # is POSIX, then $INC{POSIX.pm} is something like\n    # '/usr/local/lib/perl5/POSIX.pm', and the autosplit index file is in\n    # '/usr/local/lib/perl5/auto/POSIX/autosplit.ix', so we require that.\n    #\n    # However, if @INC is a relative path, this might not work.  If,\n    # for example, @INC = ('lib'), then\n    # $INC{POSIX.pm} is 'lib/POSIX.pm', and we want to require\n    # 'auto/POSIX/autosplit.ix' (without the leading 'lib').\n    #\n\n    (my $calldir = $callpkg) =~ s#::#/#g;\n    my $path = $INC{$calldir . '.pm'};\n    if (defined($path)) {\n\t# Try absolute path name, but only eval it if the\n        # transformation from module path to autosplit.ix path\n        # succeeded!\n\tmy $replaced_okay;\n\tif ($is_macos) {\n\t    (my $malldir = $calldir) =~ tr#/#:#;\n\t    $replaced_okay = ($path =~ s#^(.*)$malldir\\.pm\\z#$1auto:$malldir:autosplit.ix#s);\n\t} else {\n\t    $replaced_okay = ($path =~ s#^(.*)$calldir\\.pm\\z#$1auto/$calldir/autosplit.ix#);\n\t}\n\n\teval { require $path; } if $replaced_okay;\n\t# If that failed, try relative path with normal @INC searching.\n\tif (!$replaced_okay or $@) {\n\t    $path =\"auto/$calldir/autosplit.ix\";\n\t    eval { require $path; };\n\t}\n\tif ($@) {\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::carp($error);\n\t}\n    } \n}\n\nsub unimport {\n    my $callpkg = caller;\n\n    no strict 'refs';\n\n    for my $exported (qw( AUTOLOAD )) {\n\tmy $symname = $callpkg . '::' . $exported;\n\tundef *{ $symname } if \\&{ $symname } == \\&{ $exported };\n\t*{ $symname } = \\&{ $symname };\n    }\n}\n\n1;\n\n__END__\n\n", 8192) = 5404
09:01:57.690142 brk(0x1ea2000)          = 0x1ea2000
09:01:57.690747 lseek(7, 5403, SEEK_SET) = 5403
09:01:57.690812 lseek(7, 0, SEEK_CUR)   = 5403
09:01:57.690873 close(7)                = 0
09:01:57.690971 stat("/usr/share/perl5/auto/Log/Agent/autosplit.ix", {st_mode=S_IFREG|0644, st_size=404, ...}) = 0
09:01:57.691051 open("/usr/share/perl5/auto/Log/Agent/autosplit.ix", O_RDONLY) = 7
09:01:57.691118 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.691173 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.691243 read(7, "# Index created by AutoSplit for blib/lib/Log/Agent.pm\n#    (file acts as timestamp)\npackage Log::Agent;\nsub logconfig  ;\nsub inited  ;\nsub DATUM_is_here  ;\nsub log_default  ;\nsub logconfess  ;\nsub logcroak  ;\nsub logxcroak  ;\nsub logdie  ;\nsub logerr  ;\nsub logcarp  ;\nsub logxcarp  ;\nsub logwarn  ;\nsub logsay  ;\nsub logtrc  ;\nsub logdbg  ;\nsub logtags  ;\nsub logwrite  ;\nsub bug  ;\nsub prio_tag  ;\n1;\n", 8192) = 404
09:01:57.691381 read(7, "", 8192)       = 0
09:01:57.691443 close(7)                = 0
09:01:57.691580 stat("modules/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.691642 stat("modules/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.691705 stat("modules/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.691764 stat("modules/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.691818 stat("/etc/perl/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.691872 stat("/etc/perl/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.691930 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.691979 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.692036 stat("/usr/local/share/perl/5.14.2/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.692082 stat("/usr/local/share/perl/5.14.2/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.692141 stat("/usr/lib/perl5/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.692184 stat("/usr/lib/perl5/Log/Agent/Priorities.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.692248 stat("/usr/share/perl5/Log/Agent/Priorities.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.692314 stat("/usr/share/perl5/Log/Agent/Priorities.pm", {st_mode=S_IFREG|0644, st_size=5086, ...}) = 0
09:01:57.692398 open("/usr/share/perl5/Log/Agent/Priorities.pm", O_RDONLY) = 7
09:01:57.692464 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.692519 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.692577 read(7, "#\n# $Id: Priorities.pm,v 1.1 2002/03/09 16:01:37 wendigo Exp $\n#\n#  Copyright (c) 1999, Raphael Manfredi\n#  \n#  You may redistribute only under the terms of the Artistic License,\n#  as specified in the README file that comes with the distribution.\n#\n# HISTORY\n# $Log: Priorities.pm,v $\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.3  2001/04/11 15:51:55  ram\n# patch8: routines are now auto-loaded\n#\n# Revision 0.2.1.2  2001/03/31 10:02:04  ram\n# patch7: fixed off-by-one error in prio_from_level()\n#\n# Revision 0.2.1.1  2000/11/12 14:46:52  ram\n# patch1: fixed indentation\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n# $EndLog$\n#\n\nuse strict;\n\n########################################################################\npackage Log::Agent::Priorities;\n\nrequire Exporter;\nuse AutoLoader 'AUTOLOAD';\nuse vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS @LEVELS);\n@ISA = qw(Exporter);\n\n@LEVELS = qw(NONE EMERG ALERT CRIT ERROR WARN NOTICE INFO DEBUG);\n\n@EXPORT = qw(priority_level);\n@EXPORT_OK = qw(prio_from_level level_from_prio);\npush(@EXPORT_OK, @LEVELS);\n\n%EXPORT_TAGS = (LEVELS => \\@LEVELS);\n\nBEGIN {\n\tsub NONE ()\t\t{-1}\n\tsub EMERG ()\t {0}\n\tsub ALERT ()\t {1}\n\tsub CRIT ()\t\t {2}\n\tsub ERROR ()\t {3}\n\tsub WARN ()\t\t {4}\n\tsub NOTICE ()\t {6}\n\tsub INFO ()\t\t {8}\n\tsub DEBUG ()\t{10}\n}\n\nuse vars qw(@basic_prio %basic_level);\n\n@basic_prio = qw(\n\temergency\n\talert\n\tcritical\n\terror\n\twarning warning\n\tnotice notice\n\tinfo info);\n\n%basic_level = (\n\t'em'\t=> EMERG,\t\t# emergency\n\t'al'\t=> ALERT,\t\t# alert\n\t'cr'\t=> CRIT,\t\t# critical\n\t'er'\t=> ERROR,\t\t# error\n\t'wa'\t=> WARN,\t\t# warning\n\t'no'\t=> NOTICE,\t\t# notice\n\t'in'\t=> INFO,\t\t# info\n\t'de'\t=> DEBUG,\t\t# debug\n);\n\n1;\n__END__\n\n#\n# prio_from_level\n#\n# Given a level, compute suitable priority.\n#\nsub prio_from_level {\n\tmy ($level) = @_;\n\treturn 'none' if $level < 0;\n\treturn 'debug' if $level >= @basic_prio;\n\treturn $basic_prio[$level];\n}\n\n#\n# level_from_prio\n#\n# Given a syslog priority, compute suitable level.\n#\nsub level_from_prio {\n\tmy ($prio) = @_;\n\treturn -1 if lc($prio) eq 'none';\t\t# none & notice would look alike\n\tmy $canonical = lc(substr($prio, 0, 2));\n\treturn 10 unless exists $basic_level{$canonical};\n\treturn $basic_level{$canonical} || -1;\n}\n\n#\n# priority_level\n#\n# Decompiles priority which can be either a single digit, a \"priority\" string\n# or a \"priority:digit\" string. Returns the priority (computed if none) and\n# the level (computed if none).\n#\nsub priority_level {\n\tmy ($id) = @_;\n\treturn (prio_from_level($id), $id) if $id =~ /^\\d+$/;\n\treturn ($1, $2) if $id =~ /^([^:]+):(\\d+)$/;\n\treturn ($id, level_from_prio($id));\n}\n\n=head1 NAME\n\nLog::Agent::Priorities - conversion between syslog priorities and levels\n\n=head1 SYNOPSIS\n\n Not intended to be used directly\n\n=head1 DESCRIPTION\n\nThis package contains routines to convert between syslog priorities\nand logging levels: level_from_prio(\"crit\") yields 2, and\nprio_from_level(4) yields \"warning\", as does prio_from_level(5).\n\nHere are the known priorities (which may be abbreviated to the first\n2 letters, in a case-insensitive manner) and their corresponding\nlogging level:\n\n      Name    Level   Traditional    Export\n    --------- -----  --------------  ------\n    none       -1                    NONE    (special, see text)\n    emergency   0    (emerg, panic)  EMERG\n    alert       1                    ALERT\n    critical    2    (crit)          CRIT\n    error       3    (err)           ERROR\n    warning     4                    WARN\n    notice      6                    NOTICE\n    info        8                    INFO\n    debug       10                   DEBUG\n\nThe values between parenthesis show the traditional syslog priority tokens.\nThe missing levels (5, 7, 9) are there for possible extension.\nThey currently map to the level immediately below.\n\nThe Export column lists the symbolic constants defined by this package.\nThey can be imported selectively, or alltogether via the C<:LEVELS>\ntag, as in:\n\n    use Log::Agent::Priorities qw(:LEVELS);\n\nThe special token \"none\" may be used (and spelled out fully) on special\noccasions: it maps to -1, and is convenient when specifying a logging\nlevel, for instance: specifying \"none\" ensures that B<no logging> will\ntake place, even for emergency situations.\n\nAnywhere where a I<priority> is expected, one may specify a number taken\nas a logging level or a string taken as a priority. If the default\nmapping outlined above is not satisfactory, it can be redefined by\nspecifying, for instance C<\"notice:9\">. It will be taken as being of\nlevel 9, but with a C<notice> priority nonetheless, not C<info> as\nit would have been implicitely determined otherwise.\n\nThe routine priority_level() decompiles C<\"notice:9\"> into (\"notice\", 9),\nand otherwise uses prio_from_level() or level_from_prio() to compute the\nmissing informatin.  For instance, given \"critical\", priority_level()\nroutine will return the tuple (\"critical\", 2).\n\n=head1 AUTHOR\n\nRaphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>\n\n=head1 SEE ALSO\n\nLog::Agent(3), Log::Agent::Logger(3).\n\n=cut\n\n", 8192) = 5086
09:01:57.693037 stat("/usr/share/perl5/auto/Log/Agent/Priorities/autosplit.ix", {st_mode=S_IFREG|0644, st_size=199, ...}) = 0
09:01:57.693103 open("/usr/share/perl5/auto/Log/Agent/Priorities/autosplit.ix", O_RDONLY) = 8
09:01:57.693192 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a080) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.693251 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.693328 read(8, "# Index created by AutoSplit for blib/lib/Log/Agent/Priorities.pm\n#    (file acts as timestamp)\npackage Log::Agent::Priorities;\nsub prio_from_level  ;\nsub level_from_prio  ;\nsub priority_level  ;\n1;\n", 8192) = 199
09:01:57.693435 read(8, "", 8192)       = 0
09:01:57.693499 close(8)                = 0
09:01:57.693767 lseek(7, 1725, SEEK_SET) = 1725
09:01:57.693831 lseek(7, 0, SEEK_CUR)   = 1725
09:01:57.693889 close(7)                = 0
09:01:57.693965 stat("modules/Exporter.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.694040 stat("modules/Exporter.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.694106 stat("modules/Exporter.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.694165 stat("modules/Exporter.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.694228 stat("/etc/perl/Exporter.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.694289 stat("/etc/perl/Exporter.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.694353 stat("/usr/local/lib/perl/5.14.2/Exporter.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.694416 stat("/usr/local/lib/perl/5.14.2/Exporter.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.694489 stat("/usr/local/share/perl/5.14.2/Exporter.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.694560 stat("/usr/local/share/perl/5.14.2/Exporter.pm", {st_mode=S_IFREG|0444, st_size=18746, ...}) = 0
09:01:57.694634 open("/usr/local/share/perl/5.14.2/Exporter.pm", O_RDONLY) = 7
09:01:57.694699 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.694753 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.694816 read(7, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict 'refs';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = '5.72';\nour (%Cache);\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my $exports = \\@{\"$pkg\\::EXPORT\"};\n  # But, avoid creating things if they don't exist, which saves a couple of\n  # hundred bytes per package processed.\n  my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \\@{\"$pkg\\::EXPORT_FAIL\"};\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or $fail && @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or $fail and @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp} if not $SIG{__WARN__};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n=head1 NAME\n\nExporter - Implements default import method for modules\n\n=head1 SYNOPSIS\n\nIn module F<YourModule.pm>:\n\n  package YourModule;\n  require Exporter;\n  @ISA = qw(Exporter);\n  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request\n\nor\n\n  package YourModule;\n  use Exporter 'import'; # gives you Exporter's import() method directly\n  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request\n\nIn other files which wish to use C<YourModule>:\n\n  use YourModule qw(frobnicate);      # import listed symbols\n  frobnicate ($left, $right)          # calls YourModule::frobnicate\n\nTake a look at L</Good Practices> for some variants\nyou will like to use in modern Perl code.\n\n=head1 DESCRIPTION\n\nThe Exporter module implements an C<import> method which allows a module\nto export functions and variables to its users' namespaces.  Many modules\nuse Exporter rather than implementing their own C<import> method because\nExporter provides a highly flexible interface, with an implementation optimised\nfor the common case.\n\nPerl automatically calls the C<import> method when processing a\nC<use> statement for a module.  Modules and C<use> are documented\nin L<perlfunc> and L<perlmod>.  Understanding the concept of\nmodules and how the C<use> statement operates is important to\nunderstanding the Exporter.\n\n=head2 How to Export\n\nThe arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of\nsymbols that are going to be exported into the users name space by\ndefault, or which they can request to be exported, respectively.  The\nsymbols can represent functions, scalars, arrays, hashes, or typeglobs.\nThe symbols must be given by full name with the exception that the\nampersand in front of a function is optional, e.g.\n\n    @EXPORT    = qw(afunc $scalar @array);   # afunc is a function\n    @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc\n\nIf you are only exporting function names it is recommended to omit the\nampersand, as the implementation is faster this way.\n\n=head2 Selecting What to Export\n\nDo B<not> export method names!\n\nDo B<not> export anything else by default without a good reason!\n\nExports pollute the namespace of the module user.  If you must export\ntry to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or\ncommon symbol names to reduce the risk of name clashes.\n\nGenerally anything not exported is still accessible from outside the\nmodule using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)\nsyntax.  By convention you can use a leading underscore on names to\ninformally indicate that they are 'internal' and not for public use.\n\n(It is actually possible to get private functions by saying:\n\n  my $subref = sub { ... };\n  $subref->(@args);            # Call it as a function\n  $obj->$subref(@args);        # Use it as a method\n\nHowever if you use them for methods it is up to you to figure out\nhow to make inheritance work.)\n\nAs a general rule, if the module is trying to be object oriented\nthen export nothing.  If it's just a collection of functions then\nC<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and\nmethod names use barewords in preference to names prefixed with\nampersands for the export lists.\n\nOther module design guidelines can be found in L<perlmod>.\n\n=head2 How to Import\n\nIn other files which wish to use your module there are three basic ways for\nthem to load your module and import its symbols:\n\n=over 4\n\n=item C<use YourModule;>\n\nThis imports all the symbols from YourModule's C<@EXPORT> into the namespace\nof the C<use> statement.\n\n=item C<use YourModule ();>\n\nThis causes perl to load your module but does not import any symbols.\n\n=item C<use YourModule qw(...);>\n\nThis imports only the symbols listed by the caller into their namespace.\nAll listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error\noccurs.  The advanced export features of Exporter are accessed like this,\nbut with list entries that are syntactically distinct from symbol names.\n\n=back\n\nUnless you want to use its advanced features, this is probably all you\nneed to know to use Exporter.\n\n=head1 Advanced Features\n\n=head2 Specialised Import Lists\n\nIf any of the entries in an import list begins with !, : or / then\nthe list is treated as a series of specifications which either add to\nor delete from the list of names to import.  They are processed left to\nright. Specifications are in the form:\n\n    [!]name         This name only\n    [!]:DEFAULT     All names in @EXPORT\n    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array\n    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match\n\nA leading ! indicates that matching names should be deleted from the\nlist of names to import.  If the first specification is a deletion it\nis treated as though preceded by :DEFAULT.  If you just want to import\nextra names in addition to the default set you will still need to\ninclude :DEFAULT explicitly.\n\ne.g., F<Module.pm> defines:\n\n    @EXPORT      = qw(A1 A2 A3 A4 A5);\n    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);\n    %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);\n\nNote that you cannot use tags in @EXPORT or @EXPORT_OK.\n\nNames in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.\n\nAn application using Module can say something like:\n\n    use Module qw(:DEFAULT :T2 !B3 A3);\n\nOther examples include:\n\n    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);\n    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);\n\nRemember that most patterns (using //) will need to be anchored\nwith a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.\n\nYou can say C<BEGIN { $Exporter::Verbose=1 }> to see how the\nspecifications are being processed and what is actually being imported\ninto modules.\n\n=head2 Exporting Without Using Exporter's import Method\n\nExporter has a special method, 'expo", 8192) = 8192
09:01:57.696098 brk(0x1ec3000)          = 0x1ec3000
09:01:57.696307 lseek(7, 2366, SEEK_SET) = 2366
09:01:57.696649 lseek(7, 0, SEEK_CUR)   = 2366
09:01:57.696684 close(7)                = 0
09:01:57.696805 stat("modules/Exporter/Heavy.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.696853 stat("modules/Exporter/Heavy.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.696899 stat("modules/Exporter/Heavy.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.696941 stat("modules/Exporter/Heavy.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.696985 stat("/etc/perl/Exporter/Heavy.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.697028 stat("/etc/perl/Exporter/Heavy.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.697074 stat("/usr/local/lib/perl/5.14.2/Exporter/Heavy.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.697118 stat("/usr/local/lib/perl/5.14.2/Exporter/Heavy.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.697166 stat("/usr/local/share/perl/5.14.2/Exporter/Heavy.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.697212 stat("/usr/local/share/perl/5.14.2/Exporter/Heavy.pm", {st_mode=S_IFREG|0444, st_size=6551, ...}) = 0
09:01:57.697271 open("/usr/local/share/perl/5.14.2/Exporter/Heavy.pm", O_RDONLY) = 7
09:01:57.697322 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.697360 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.697417 read(7, "package Exporter::Heavy;\n\nuse strict;\nno strict 'refs';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n\n=head1 NAME\n\nExporter::Heavy - Exporter guts\n\n=head1 SYNOPSIS\n\n(internal use only)\n\n=head1 DESCRIPTION\n\nNo user-serviceable parts inside.\n\n=cut\n\n#\n# We go to a lot of trouble not to 'require Carp' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # Save the old __WARN__ handler in case it was defined\n    my $oldwarn = $SIG{__WARN__};\n\n    # First make import warnings look like they're coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\t# restore it back so proper stacking occurs\n\tlocal $SIG{__WARN__} = $oldwarn;\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq 'DEFAULT'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate 'use Foo ()' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, ''\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they've updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can't continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cache at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, '&'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can't continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\tno warnings 'once';\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq '&' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq '$' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq '@' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq '%' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq '*' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can't export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 8192) = 6551
09:01:57.698809 brk(0x1ee4000)          = 0x1ee4000
09:01:57.698941 read(7, "", 8192)       = 0
09:01:57.698987 close(7)                = 0
09:01:57.699188 stat("modules/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699238 stat("modules/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699282 stat("modules/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699322 stat("modules/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699398 stat("/etc/perl/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699459 stat("/etc/perl/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699523 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699585 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699651 stat("/usr/local/share/perl/5.14.2/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699713 stat("/usr/local/share/perl/5.14.2/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699780 stat("/usr/lib/perl5/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699841 stat("/usr/lib/perl5/Log/Agent/Formatting.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.699907 stat("/usr/share/perl5/Log/Agent/Formatting.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.699970 stat("/usr/share/perl5/Log/Agent/Formatting.pm", {st_mode=S_IFREG|0644, st_size=4232, ...}) = 0
09:01:57.700043 open("/usr/share/perl5/Log/Agent/Formatting.pm", O_RDONLY) = 7
09:01:57.700109 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.700169 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.700244 read(7, "###########################################################################\n# $Id: Formatting.pm,v 1.6 2005/10/02 16:47:36 wendigo Exp $\n###########################################################################\n#\n# Log::Agent::Formatting\n#\n# RCS Revision: $Revision: 1.6 $\n# Date: $Date: 2005/10/02 16:47:36 $\n#\n# Copyright (c) 1999 Raphael Manfredi\n# Copyright (c) 2002-2003,2005 Mark Rogaski, mrogaski@cpan.org;\n# all rights reserved.\n#\n# See the README file included with the\n# distribution for license information.\n#\n# $Log: Formatting.pm,v $\n# Revision 1.6  2005/10/02 16:47:36  wendigo\n# Fixed formatting behavior for strings that contain \"%%\" without any other\n# formating characters.\n#\n# Revision 1.5  2003/09/27 18:11:16  wendigo\n# Modified comments.\n#\n# Revision 1.4  2003/09/27 17:41:41  wendigo\n# Modified to use $Log::Agent::OS_Error for substitution of %m instead\n# of $!.\n#\n# Revision 1.3  2003/03/08 16:40:27  wendigo\n# Merged format and multiline carp changes\n#\n# Revision 1.2.2.1  2002/12/13 04:25:24  wendigo\n# Fixed logxxx() formatting to match sprintf semantics.\n#\n# Revision 1.2  2002/05/12 07:20:03  wendigo\n# Reduced format_args to adjust_msg\n# Added prechecks of sprintf() arguments\n#\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.1  2001/03/13 18:45:06  ram\n# patch2: renamed caller_format_args() as tag_format_args()\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n###########################################################################\n\nuse strict;\nrequire Exporter;\n\n########################################################################\npackage Log::Agent::Formatting;\n\nuse vars qw(@ISA @EXPORT_OK);\n\n@ISA = qw(Exporter);\n@EXPORT_OK = qw(format_args tag_format_args);\n\nrequire Log::Agent::Message;\n\n#\n# adjust_fmt\n# \n# We process syslog's %m macro as being the current error message ($!) in\n# the first argument only. Doing it at this level means it will be supported\n# independently from the driver they'll choose. It's also done BEFORE any\n# log-related system call, thus ensuring that $! retains its original value.\n#\nif ($] >= 5.005) {\n    eval q{     # if VERSION >= 5.005\n        # 5.005 and later version grok /(?<!)/\n        sub adjust_fmt {\n            my $fmt = shift;\n            $fmt =~ s/((?<!%)(?:%%)*)%m/$Log::Agent::OS_Error/g;\n            return $fmt;\n        }\n    }\n} else {\n    eval q{     # else /* VERSION < 5.005 */\n        # pre-5.005 does not grok /(?<!)/\n        sub adjust_fmt {\n            my $fmt = shift;\n            $fmt =~ s/%%/\\01/g;\n            $fmt =~ s/%m/$Log::Agent::OS_Error/g;\n            $fmt =~ s/\\01/%%/g;\n            return $fmt;\n        }\n    }\n}       # endif /* VERSION >= 5.005 */\n\n#\n# whine\n#\n# This is a local hack of carp \n#\nsub whine {\n    my $msg = shift;\n    unless (chomp $msg) {\n        my($package, $filename, $line) = caller 2;\n        $msg .= \" at $filename line $line.\";\n    }\n    warn \"$msg\\n\";\n}\n\n#\n# tag_format_args\n#\n# Arguments:\n#\n#   $caller     caller information, done firstly\n#   $priority   priority information, done secondly\n#   $tags       list of user-defined tags, done lastly\n#   $ary        arguments for sprintf()\n#\n# Returns a Log::Agent::Message object, which, when stringified, prints\n# the string itself.\n#\nsub tag_format_args {\n    my ($caller, $priority, $tags, $ary) = @_;\n    my $msg = adjust_fmt(shift @$ary);\n\n    # This bit of tomfoolery is intended to make debugging of\n    # programs a bit easier by prechecking input to sprintf() \n    # for errors.  I usually prefer lazy error checking, but \n    # this seems to be an appropriate exception.\n    if (my @arglist = $msg =~ /\\%[^\\%]*[csduoxefgXEGbpniDUOF]|\\%\\%/g) {\n        BEGIN { no warnings }\n        my $argcnt = grep !/\\%\\%/, @arglist;\n        if (grep {! defined} @$ary[0..($argcnt - 1)]) {\n            whine(\"Use of uninitialized value in sprintf\");\n        }\n        $msg = sprintf $msg, @$ary;\n    }\n\n    my $str = Log::Agent::Message->make($msg);\n    $caller->insert($str) if defined $caller;\n    $priority->insert($str) if defined $priority;\n    if (defined $tags) {\n        foreach my $tag (@$tags) {\n            $tag->insert($str);\n        }\n    }\n    return $str;\n}\n\n1;\n\n", 8192) = 4232
09:01:57.700769 read(7, "", 8192)       = 0
09:01:57.700835 close(7)                = 0
09:01:57.700916 stat("modules/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.700987 stat("modules/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701053 stat("modules/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701120 stat("modules/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701179 stat("/etc/perl/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701235 stat("/etc/perl/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701321 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701368 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701417 stat("/usr/local/share/perl/5.14.2/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701462 stat("/usr/local/share/perl/5.14.2/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701510 stat("/usr/lib/perl5/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701580 stat("/usr/lib/perl5/Log/Agent/Message.pm", 0x7ffc53d0a920) = -1 ENOENT (No such file or directory)
09:01:57.701640 stat("/usr/share/perl5/Log/Agent/Message.pmc", 0x7ffc53d0a9d0) = -1 ENOENT (No such file or directory)
09:01:57.701703 stat("/usr/share/perl5/Log/Agent/Message.pm", {st_mode=S_IFREG|0644, st_size=5491, ...}) = 0
09:01:57.701761 open("/usr/share/perl5/Log/Agent/Message.pm", O_RDONLY) = 7
09:01:57.701841 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a6b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.701900 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.701982 read(7, "#\n# $Id: Message.pm,v 1.1 2002/03/09 16:01:37 wendigo Exp $\n#\n#  Copyright (c) 1999, Raphael Manfredi\n#  \n#  You may redistribute only under the terms of the Artistic License,\n#  as specified in the README file that comes with the distribution.\n#\n# HISTORY\n# $Log: Message.pm,v $\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.1  2001/03/31 10:01:22  ram\n# patch7: fixed =over to add explicit indent level\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n# $EndLog$\n#\n\nuse strict;\n\n########################################################################\npackage Log::Agent::Message;\n\nuse overload\n\tqw(\"\" stringify);\n\n#\n# ->make\n#\n# Creation routine.\n#\n# Attributes:\n#\tstr\t\t\t\tformatted message string coming from user\n#\tprepend_list\tlist of strings to prepend to `str'\n#\tappend_list\t\tlist of strings to append to `str'\n#\nsub make {\n\tmy $self = bless [], shift;\t\t# Array for minimal overhead\n\t$self->[0] = $_[0];\n\treturn $self;\n}\n\n#\n# Attribute access\n#\n\nsub str\t\t\t\t{ $_[0]->[0] }\nsub prepend_list\t{ $_[0]->[1] }\nsub append_list\t\t{ $_[0]->[2] }\n\n#\n# Attribute setting\n#\n\nsub set_str\t\t\t\t{ $_[0]->[0] = $_[1] }\nsub set_prepend_list\t{ $_[0]->[1] = $_[1] }\nsub set_append_list\t\t{ $_[0]->[2] = $_[1] }\n\n#\n# ->prepend\n#\n# Add string to the prepend list, at its TAIL.\n# (i.e. the first to prepend gets output first)\n#\nsub prepend {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->prepend_list;\n\t$array = $self->set_prepend_list([]) unless $array;\n\n\tpush(@{$array}, $str);\n}\n\n#\n# ->prepend_first\n#\n# Add string to the prepend list, at its HEAD.\n#\nsub prepend_first {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->prepend_list;\n\t$array = $self->set_prepend_list([]) unless $array;\n\n\tunshift(@{$array}, $str);\n}\n\n#\n# ->append\n#\n# Add string to the append list, at its HEAD.\n# (i.e. the first to append gets output last)\n#\nsub append {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->append_list;\n\t$array = $self->set_append_list([]) unless $array;\n\n\tunshift(@{$array}, $str);\n}\n\n#\n# ->append_last\n#\n# Add string to the append list, at its TAIL.\n#\nsub append_last {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->append_list;\n\t$array = $self->set_append_list([]) unless $array;\n\n\tpush(@{$array}, $str);\n}\n\n#\n# ->stringify\n# (stringify)\n#\n# Returns complete string, with all prepended strings first, then the\n# original string followed by all the appended strings.\n#\nsub stringify {\n\tmy $self = shift;\n\treturn $self->[0] if @{$self} == 1;\t\t# Optimize usual case\n\n\tmy $prepend = $self->prepend_list;\n\tmy $append = $self->append_list;\n\n\treturn\n\t\t($prepend ? join('', @{$prepend}) : '') .\n\t\t$self->str .\n\t\t($append ? join('', @{$append}) : '');\n}\n\n#\n# ->clone\n#\n# Clone object\n# (not a deep clone, but prepend and append lists are also shallow-cloned.)\n#\nsub clone {\n\tmy $self = shift;\n\tmy $other = bless [], ref $self;\n\t$other->[0] = $self->[0];\n\treturn $other if @{$self} == 1;\t\t\t# Optimize usual case\n\n\tif (defined $self->[1]) {\n\t\tmy @array = @{$self->[1]};\n\t\t$other->[1] = \\@array;\n\t}\n\tif (defined $self->[2]) {\n\t\tmy @array = @{$self->[2]};\n\t\t$other->[2] = \\@array;\n\t}\n\n\treturn $other;\n}\n\n1;\t# for require\n__END__\n\n=head1 NAME\n\nLog::Agent::Message - a log message\n\n=head1 SYNOPSIS\n\n require Log::Agent::Message;\n\n my $msg = Log::Agent::Message->make(\"string\");\n $msg->prepend(\"string\");\n $msg->append(\"string\");\n my $copy = $msg->clone;\n\n print \"Message is $msg\\n\";     # overloaded stringification\n\n=head1 DESCRIPTION\n\nThe Log::Agent::Message class represents an original log message\n(a string) to which one may prepend or append other strings, but with\nthe special property that prepended strings aggregate themselves\nin FIFO order, whilst appended strings aggregate themselves in LIFO\norder, which is counter-intuitive at first sight.\n\nIn plain words, this means that the last routine that prepends something\nto the message will get its prepended string right next to the original\nstring, regardless of what could have been prepended already. The behaviour\nis symetric for appending.\n\n=head1 INTERFACE\n\nThe following routines are available:\n\n=over 4\n\n=item append($str)\n\nAppend suppled string $str to the original string (given at creation\ntime), at the head of all existing appended strings.\n\n=item append_last($str)\n\nAppend suppled string $str to the original string (given at creation\ntime), at the tail of all existing appended strings.\n\n=item clone\n\nClone the message. This is not a shallow clone, because the list of\nprepended and appended strings is recreated. However it is not a deep\nclone, because the items held in those lists are merely copied (this would\nmatter only when other objects with overloaded stringification routines\nwere supplied to prepend() and append(), which is not the case today in\nthe basic Log::Agent framework).\n\n=item make($string)\n\nThis is the creation routine.\n\n=item prepend($str)\n\nPrepend supplied string $str to the original string (given at creation\ntime), at the tail of all existing prepended strings.\n\n=item prepend_first($str)\n\nPrepend supplied string $str to the original string (given at creation\ntime), at the head of all existing prepended strings.\n\n=item stringify\n\nThis is the overloaded \"\" operator, which returns the complete string\ncomposed of all the prepended strings, the original string, and all\nthe appended strings.\n\n=back\n\n=head1 AUTHOR\n\nRaphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>\n\n=head1 SEE ALSO\n\nLog::Agent(3).\n\n=cut\n", 8192) = 5491
09:01:57.702333 stat("modules/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.702398 stat("modules/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.702460 stat("modules/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.702521 stat("modules/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.702591 stat("/etc/perl/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.702655 stat("/etc/perl/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.702718 stat("/usr/local/lib/perl/5.14.2/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.702785 stat("/usr/local/lib/perl/5.14.2/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.703204 stat("/usr/local/share/perl/5.14.2/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.703249 stat("/usr/local/share/perl/5.14.2/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.703313 stat("/usr/lib/perl5/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.703374 stat("/usr/lib/perl5/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.703437 stat("/usr/share/perl5/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.703496 stat("/usr/share/perl5/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.703558 stat("/usr/lib/perl/5.14/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.703619 stat("/usr/lib/perl/5.14/overload.pm", 0x7ffc53d0a2f0) = -1 ENOENT (No such file or directory)
09:01:57.703684 stat("/usr/share/perl/5.14/overload.pmc", 0x7ffc53d0a3a0) = -1 ENOENT (No such file or directory)
09:01:57.703746 stat("/usr/share/perl/5.14/overload.pm", {st_mode=S_IFREG|0644, st_size=4612, ...}) = 0
09:01:57.703822 open("/usr/share/perl/5.14/overload.pm", O_RDONLY) = 8
09:01:57.703889 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0a080) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.703948 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.704024 read(8, "package overload;\n\nour $VERSION = '1.13';\n\nsub nil {}\n\nsub OVERLOAD {\n  $package = shift;\n  my %arg = @_;\n  my ($sub, $fb);\n  $ {$package . \"::OVERLOAD\"}{dummy}++; # Register with magic by touching.\n  $fb = ${$package . \"::()\"}; # preserve old fallback value RT#68196\n  *{$package . \"::()\"} = \\&nil; # Make it findable via fetchmethod.\n  for (keys %arg) {\n    if ($_ eq 'fallback') {\n      $fb = $arg{$_};\n    } else {\n      $sub = $arg{$_};\n      if (not ref $sub and $sub !~ /::/) {\n\t$ {$package . \"::(\" . $_} = $sub;\n\t$sub = \\&nil;\n      }\n      #print STDERR \"Setting `$ {'package'}::\\cO$_' to \\\\&`$sub'.\\n\";\n      *{$package . \"::(\" . $_} = \\&{ $sub };\n    }\n  }\n  ${$package . \"::()\"} = $fb; # Make it findable too (fallback only).\n}\n\nsub import {\n  $package = (caller())[0];\n  # *{$package . \"::OVERLOAD\"} = \\&OVERLOAD;\n  shift;\n  $package->overload::OVERLOAD(@_);\n}\n\nsub unimport {\n  $package = (caller())[0];\n  ${$package . \"::OVERLOAD\"}{dummy}++; # Upgrade the table\n  shift;\n  for (@_) {\n    if ($_ eq 'fallback') {\n      undef $ {$package . \"::()\"};\n    } else {\n      delete $ {$package . \"::\"}{\"(\" . $_};\n    }\n  }\n}\n\nsub Overloaded {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  $package->can('()');\n}\n\nsub ov_method {\n  my $globref = shift;\n  return undef unless $globref;\n  my $sub = \\&{*$globref};\n  require Scalar::Util;\n  return $sub\n    if Scalar::Util::refaddr($sub) != Scalar::Util::refaddr(\\&nil);\n  return shift->can($ {*$globref});\n}\n\nsub OverloadedStringify {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  #$package->can('(\"\"')\n  ov_method mycan($package, '(\"\"'), $package\n    or ov_method mycan($package, '(0+'), $package\n    or ov_method mycan($package, '(bool'), $package\n    or ov_method mycan($package, '(nomethod'), $package;\n}\n\nsub Method {\n  my $package = shift;\n  if(ref $package) {\n    local $@;\n    local $!;\n    require Scalar::Util;\n    $package = Scalar::Util::blessed($package);\n    return undef if !defined $package;\n  }\n  #my $meth = $package->can('(' . shift);\n  ov_method mycan($package, '(' . shift), $package;\n  #return $meth if $meth ne \\&nil;\n  #return $ {*{$meth}};\n}\n\nsub AddrRef {\n  my $package = ref $_[0];\n  return \"$_[0]\" unless $package;\n\n  local $@;\n  local $!;\n  require Scalar::Util;\n  my $class = Scalar::Util::blessed($_[0]);\n  my $class_prefix = defined($class) ? \"$class=\" : \"\";\n  my $type = Scalar::Util::reftype($_[0]);\n  my $addr = Scalar::Util::refaddr($_[0]);\n  return sprintf(\"%s%s(0x%x)\", $class_prefix, $type, $addr);\n}\n\n*StrVal = *AddrRef;\n\nsub mycan {\t\t\t\t# Real can would leave stubs.\n  my ($package, $meth) = @_;\n\n  local $@;\n  local $!;\n  require mro;\n\n  my $mro = mro::get_linear_isa($package);\n  foreach my $p (@$mro) {\n    my $fqmeth = $p . q{::} . $meth;\n    return \\*{$fqmeth} if defined &{$fqmeth};\n  }\n\n  return undef;\n}\n\n%constants = (\n\t      'integer'\t  =>  0x1000, # HINT_NEW_INTEGER\n\t      'float'\t  =>  0x2000, # HINT_NEW_FLOAT\n\t      'binary'\t  =>  0x4000, # HINT_NEW_BINARY\n\t      'q'\t  =>  0x8000, # HINT_NEW_STRING\n\t      'qr'\t  => 0x10000, # HINT_NEW_RE\n\t     );\n\n%ops = ( with_assign\t  => \"+ - * / % ** << >> x .\",\n\t assign\t\t  => \"+= -= *= /= %= **= <<= >>= x= .=\",\n\t num_comparison\t  => \"< <= >  >= == !=\",\n\t '3way_comparison'=> \"<=> cmp\",\n\t str_comparison\t  => \"lt le gt ge eq ne\",\n\t binary\t\t  => '& &= | |= ^ ^=',\n\t unary\t\t  => \"neg ! ~\",\n\t mutators\t  => '++ --',\n\t func\t\t  => \"atan2 cos sin exp abs log sqrt int\",\n\t conversion\t  => 'bool \"\" 0+ qr',\n\t iterators\t  => '<>',\n         filetest         => \"-X\",\n\t dereferencing\t  => '${} @{} %{} &{} *{}',\n\t matching\t  => '~~',\n\t special\t  => 'nomethod fallback =');\n\nuse warnings::register;\nsub constant {\n  # Arguments: what, sub\n  while (@_) {\n    if (@_ == 1) {\n        warnings::warnif (\"Odd number of arguments for overload::constant\");\n        last;\n    }\n    elsif (!exists $constants {$_ [0]}) {\n        warnings::warnif (\"`$_[0]' is not an overloadable type\");\n    }\n    elsif (!ref $_ [1] || \"$_[1]\" !~ /(^|=)CODE\\(0x[0-9a-f]+\\)$/) {\n        # Can't use C<ref $_[1] eq \"CODE\"> above as code references can be\n        # blessed, and C<ref> would return the package the ref is blessed into.\n        if (warnings::enabled) {\n            $_ [1] = \"undef\" unless defined $_ [1];\n            warnings::warn (\"`$_[1]' is not a code reference\");\n        }\n    }\n    else {\n        $^H{$_[0]} = $_[1];\n        $^H |= $constants{$_[0]};\n    }\n    shift, shift;\n  }\n}\n\nsub remove_constant {\n  # Arguments: what, sub\n  while (@_) {\n    delete $^H{$_[0]};\n    $^H &= ~ $constants{$_[0]};\n    shift, shift;\n  }\n}\n\n1;\n\n__END__\n\n", 8192) = 4612
09:01:57.704640 brk(0x1f05000)          = 0x1f05000
09:01:57.704979 lseek(8, 4611, SEEK_SET) = 4611
09:01:57.705041 lseek(8, 0, SEEK_CUR)   = 4611
09:01:57.705100 close(8)                = 0
09:01:57.705478 lseek(7, 3208, SEEK_SET) = 3208
09:01:57.705538 lseek(7, 0, SEEK_CUR)   = 3208
09:01:57.705605 close(7)                = 0
09:01:57.705780 lseek(6, 1544, SEEK_SET) = 1544
09:01:57.705838 lseek(6, 0, SEEK_CUR)   = 1544
09:01:57.705876 close(6)                = 0
09:01:57.706117 stat("modules/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706163 stat("modules/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706207 stat("modules/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706245 stat("modules/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706320 stat("/etc/perl/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706381 stat("/etc/perl/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706446 stat("/usr/local/lib/perl/5.14.2/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706508 stat("/usr/local/lib/perl/5.14.2/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706573 stat("/usr/local/share/perl/5.14.2/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706635 stat("/usr/local/share/perl/5.14.2/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706703 stat("/usr/lib/perl5/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706764 stat("/usr/lib/perl5/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706837 stat("/usr/share/perl5/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.706900 stat("/usr/share/perl5/Fcntl.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.706965 stat("/usr/lib/perl/5.14/Fcntl.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.707027 stat("/usr/lib/perl/5.14/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=2036, ...}) = 0
09:01:57.707100 open("/usr/lib/perl/5.14/Fcntl.pm", O_RDONLY) = 6
09:01:57.707166 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0ace0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.707227 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.707298 read(6, "package Fcntl;\n\nuse strict;\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nrequire Exporter;\nrequire XSLoader;\n@ISA = qw(Exporter);\n$VERSION = '1.11';\n\nXSLoader::load();\n\n# Named groups of exports\n%EXPORT_TAGS = (\n    'flock'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    'Fcompat' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    'seek'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    'mode'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = (qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_MAND\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n), map {@{$_}} values %EXPORT_TAGS);\n\n1;\n", 8192) = 2036
09:01:57.707578 read(6, "", 8192)       = 0
09:01:57.707649 close(6)                = 0
09:01:57.707731 stat("modules/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.707792 stat("modules/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.707850 stat("modules/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.707906 stat("modules/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.707974 stat("/etc/perl/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708017 stat("/etc/perl/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708062 stat("/usr/local/lib/perl/5.14.2/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708132 stat("/usr/local/lib/perl/5.14.2/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708196 stat("/usr/local/share/perl/5.14.2/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708245 stat("/usr/local/share/perl/5.14.2/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708303 stat("/usr/lib/perl5/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708347 stat("/usr/lib/perl5/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708392 stat("/usr/share/perl5/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708437 stat("/usr/share/perl5/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708482 stat("/usr/lib/perl/5.14/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708528 stat("/usr/lib/perl/5.14/XSLoader.pm", 0x7ffc53d0af50) = -1 ENOENT (No such file or directory)
09:01:57.708574 stat("/usr/share/perl/5.14/XSLoader.pmc", 0x7ffc53d0b000) = -1 ENOENT (No such file or directory)
09:01:57.708637 stat("/usr/share/perl/5.14/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=2991, ...}) = 0
09:01:57.708707 open("/usr/share/perl/5.14/XSLoader.pm", O_RDONLY) = 6
09:01:57.708769 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0ace0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.708812 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.708868 read(6, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.13\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\npackage DynaLoader;\n\n# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    my ($module, $modlibname) = caller();\n\n    if (@_) {\n\t$module = $_[0];\n    } else {\n\t$_[0] = $module;\n    }\n\n    # work with static linking too\n    my $boots = \"$module\\::bootstrap\";\n    goto &$boots if defined &$boots;\n\n    goto \\&XSLoader::bootstrap_inherit unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join('/',@modparts);\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.so\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs 'beside' the library\n\n    if (-s $bs) { # only read file if it's not empty\n#       print STDERR \"BS: $bs ($^O, $dlsrc)\\n\" if $dl_debug;\n        eval { do $bs; };\n        warn \"$bs: $@\\n\" if $@;\n    }\n\n    goto \\&XSLoader::bootstrap_inherit if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can't load '$file' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can't find '$bootname' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub($boots, $boot_symbol_ref, $file);\n\n    # See comment block above\n    push(@DynaLoader::dl_shared_objects, $file); # record files loaded\n    return &$xs(@_);\n}\n\nsub bootstrap_inherit {\n    require DynaLoader;\n    goto \\&DynaLoader::bootstrap_inherit;\n}\n\n1;\n\n__END__\n\n", 8192) = 2991
09:01:57.709391 brk(0x1f26000)          = 0x1f26000
09:01:57.709513 lseek(6, 2990, SEEK_SET) = 2990
09:01:57.709574 lseek(6, 0, SEEK_CUR)   = 2990
09:01:57.709630 close(6)                = 0
09:01:57.709778 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.bs", 0x1dfd138) = -1 ENOENT (No such file or directory)
09:01:57.709848 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=18672, ...}) = 0
09:01:57.709922 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.bs", 0x1dfd138) = -1 ENOENT (No such file or directory)
09:01:57.709999 futex(0x7f92d769d0ec, FUTEX_WAKE_PRIVATE, 2147483647) = 0
09:01:57.710079 open("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.so", O_RDONLY) = 6
09:01:57.710146 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\35\0\0\0\0\0\0@\0\0\0\0\0\0\0\360A\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2140\0\0\0\0\0\0\2140\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\3601\0\0\0\0\0\0\3601 \0\0\0\0\0\3601 \0\0\0\0\0\370\16\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320=\0\0\0\0\0\0\320= \0\0\0\0\0\320= \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\340.\0\0\0\0\0\0\340.\0\0\0\0\0\0\340.\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\3601\0\0\0\0\0\0\3601 \0\0\0\0\0\3601 \0\0\0\0\0\20\16\0\0\0\0\0\0\20\16\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\3370o+!\26#\244_\317\375\275`p\7J\31\302\206\7\0\0\0\0%\0\0\0,\0\0\0\0\0\0\0\30\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\31\0\0\0\r\0\0\0\21\0\0\0\0\0\0\0\17\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\37\0\0\0\6\0\0\0#\0\0\0*\0\0\0!\0\0\0\0\0\0\0\0\0\0\0(\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0'\0\0\0 \0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\27\0\0\0\"\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\0\0\0\0\7\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\23\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\t\0\0\0\24\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\16\0\0\0\25\0\0\0\20\0\0\0\0\0\0\0)\0\0\0\3\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\f\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.710295 fstat(6, {st_mode=S_IFREG|0644, st_size=18672, ...}) = 0
09:01:57.710364 mmap(NULL, 2113776, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f92d6640000
09:01:57.710427 mprotect(0x7f92d6644000, 2093056, PROT_NONE) = 0
09:01:57.710489 mmap(0x7f92d6843000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3000) = 0x7f92d6843000
09:01:57.710569 close(6)                = 0
09:01:57.710640 mprotect(0x7f92d6843000, 4096, PROT_READ) = 0
09:01:57.711638 brk(0x1f47000)          = 0x1f47000
09:01:57.711758 read(5, "ieve($_[0], 0);\n}\n\n#\n# lock_retrieve\n#\n# Same as retrieve, but with advisory locking.\n#\nsub lock_retrieve {\n\t_retrieve($_[0], 1);\n}\n\n# Internal retrieve routine\nsub _retrieve {\n\tmy ($file, $use_locking) = @_;\n\tlocal *FILE;\n\topen(FILE, $file) || logcroak \"can't open $file: $!\";\n\tbinmode FILE;\t\t\t\t\t\t\t# Archaic systems...\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\tif ($use_locking) {\n\t\tunless (&CAN_FLOCK) {\n\t\t\tlogcarp\n\t\t\t\t\"Storable::lock_store: fcntl/flock emulation broken on $^O\";\n\t\t\treturn undef;\n\t\t}\n\t\tflock(FILE, LOCK_SH) || logcroak \"can't get shared lock on $file: $!\";\n\t\t# Unlocking will happen when FILE is closed\n\t}\n\teval { $self = pretrieve(*FILE) };\t\t# Call C routine\n\tclose(FILE);\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\n#\n# fd_retrieve\n#\n# Same as retrieve, but perform from an already opened file descriptor instead.\n#\nsub fd_retrieve {\n\tmy ($file) = @_;\n\tmy $fd = fileno($file);\n\tlogcroak \"not a valid file descriptor\" unless defined $fd;\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\teval { $self = pretrieve($file) };\t\t# Call C routine\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\nsub retrieve_fd { &fd_retrieve }\t\t# Backward compatibility\n\n#\n# thaw\n#\n# Recreate objects in memory from an existing frozen image created\n# by freeze.  If the frozen image passed is undef, return undef.\n#\nsub thaw {\n\tmy ($frozen) = @_;\n\treturn undef unless defined $frozen;\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\teval { $self = mretrieve($frozen) };\t# Call C routine\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nStorable - persistence for Perl data structures\n\n=head1 SYNOPSIS\n\n use Storable;\n store \\%table, 'file';\n $hashref = retrieve('file');\n\n use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);\n\n # Network order\n nstore \\%table, 'file';\n $hashref = retrieve('file');\t# There is NO nretrieve()\n\n # Storing to and retrieving from an already opened file\n store_fd \\@array, \\*STDOUT;\n nstore_fd \\%table, \\*STDOUT;\n $aryref = fd_retrieve(\\*SOCKET);\n $hashref = fd_retrieve(\\*SOCKET);\n\n # Serializing to memory\n $serialized = freeze \\%table;\n %table_clone = %{ thaw($serialized) };\n\n # Deep (recursive) cloning\n $cloneref = dclone($ref);\n\n # Advisory locking\n use Storable qw(lock_store lock_nstore lock_retrieve)\n lock_store \\%table, 'file';\n lock_nstore \\%table, 'file';\n $hashref = lock_retrieve('file');\n\n=head1 DESCRIPTION\n\nThe Storable package brings persistence to your Perl data structures\ncontaining SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be\nconveniently stored to disk and retrieved at a later time.\n\nIt can be used in the regular procedural way by calling C<store> with\na reference to the object to be stored, along with the file name where\nthe image should be written.\n\nThe routine returns C<undef> for I/O problems or other internal error,\na true value otherwise. Serious errors are propagated as a C<die> exception.\n\nTo retrieve data stored to disk, use C<retrieve> with a file name.\nThe objects stored into that file are recreated into memory for you,\nand a I<reference> to the root object is returned. In case an I/O error\noccurs while reading, C<undef> is returned instead. Other serious\nerrors are propagated via C<die>.\n\nSince storage is performed recursively, you might want to stuff references\nto objects that share a lot of common data into a single array or hash\ntable, and then store that object. That way, when you retrieve back the\nwhole thing, the objects will continue to share what they originally shared.\n\nAt the cost of a slight header overhead, you may store to an already\nopened file descriptor using the C<store_fd> routine, and retrieve\nfrom a file via C<fd_retrieve>. Those names aren't imported by default,\nso you will have to do that explicitly if you need those routines.\nThe file descriptor you supply must be already opened, for read\nif you're going to retrieve and for write if you wish to store.\n\n\tstore_fd(\\%table, *STDOUT) || die \"can't store to stdout\\n\";\n\t$hashref = fd_retrieve(*STDIN);\n\nYou can also store data in network order to allow easy sharing across\nmultiple platforms, or when storing on a socket known to be remotely\nconnected. The routines to call have an initial C<n> prefix for I<network>,\nas in C<nstore> and C<nstore_fd>. At retrieval time, your data will be\ncorrectly restored so you don't have to know whether you're restoring\nfrom native or network ordered data.  Double values are stored stringified\nto ensure portability as well, at the slight risk of loosing some precision\nin the last decimals.\n\nWhen using C<fd_retrieve>, objects are retrieved in sequence, one\nobject (i.e. one recursive tree) per associated C<store_fd>.\n\nIf you're more from the object-oriented camp, you can inherit from\nStorable and directly store your objects by invoking C<store> as\na method. The fact that the root of the to-be-stored tree is a\nblessed reference (i.e. an object) is special-cased so that the\nretrieve does not provide a reference to that object but rather the\nblessed object reference itself. (Otherwise, you'd get a reference\nto that blessed object).\n\n=head1 MEMORY STORE\n\nThe Storable engine can also store data into a Perl scalar instead, to\nlater retrieve them. This is mainly used to freeze a complex structure in\nsome safe compact memory place (where it can possibly be sent to another\nprocess via some IPC, since freezing the structure also serializes it in\neffect). Later on, and maybe somewhere else, you can thaw the Perl scalar\nout and recreate the original complex structure in memory.\n\nSurprisingly, the routines to be called are named C<freeze> and C<thaw>.\nIf you wish to send out the frozen scalar to another machine, use\nC<nfreeze> instead to get a portable image.\n\nNote that freezing an object structure and immediately thawing it\nactually achieves a deep cloning of that structure:\n\n    dclone(.) = thaw(freeze(.))\n\nStorable provides you with a C<dclone> interface which does not create\nthat intermediary scalar but instead freezes the structure in some\ninternal memory space and then immediately thaws it out.\n\n=head1 ADVISORY LOCKING\n\nThe C<lock_store> and C<lock_nstore> routine are equivalent to\nC<store> and C<nstore>, except that they get an exclusive lock on\nthe file before writing.  Likewise, C<lock_retrieve> does the same\nas C<retrieve>, but also gets a shared lock on the file before reading.\n\nAs with any advisory locking scheme, the protection only works if you\nsystematically use C<lock_store> and C<lock_retrieve>.  If one side of\nyour application uses C<store> whilst the other uses C<lock_retrieve>,\nyou will get no protection at all.\n\nThe internal advisory locking is implemented using Perl's flock()\nroutine.  If your system does not support any form of flock(), or if\nyou share your files across NFS, you might wish to use other forms\nof locking by using modules such as LockFile::Simple which lock a\nfile using a filesystem entry, instead of locking the file descriptor.\n\n=head1 SPEED\n\nThe heart of Storable is written in C for decent speed. Extra low-level\noptimizations have been made when manipulating perl internals, to\nsacrifice encapsulation for the benefit of greater speed.\n\n=head1 CANONICAL REPRESENTATION\n\nNormally, Storable stores elements of hashes in the order they are\nstored internally by Perl, i.e. pseudo-randomly.  If you set\nC<$Storable::canonical> to some C<TRUE> value, Storable will store\nhashes with the elements sorted by their key.  This allows you to\ncompare data structures by comparing their frozen representations (or\neven the compressed frozen representations), which can be useful for\ncreating lookup tables for complicated queries.\n\nCanonical order does not imply network order; those are two orthogonal\nsettings.\n\n=head1 CODE REFERENCES\n\nSince Storable version 2.05, CODE references may be serialized with\nthe help of L<B::Deparse>. To enable this feature, set\nC<$Storable::Deparse> to a true value. To enable deserialization,\nC<$Storable::Eval> should be set to a true value. Be aware that\ndeserialization is done through C<eval>, which is dangerous if the\nStorable fi", 8192) = 8192
09:01:57.712820 lseek(5, 9846, SEEK_SET) = 9846
09:01:57.712882 lseek(5, 0, SEEK_CUR)   = 9846
09:01:57.712941 close(5)                = 0
09:01:57.713047 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.bs", {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
09:01:57.713125 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.so", {st_mode=S_IFREG|0555, st_size=345692, ...}) = 0
09:01:57.713197 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.bs", {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
09:01:57.713286 open("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.so", O_RDONLY) = 5
09:01:57.713351 read(5, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\2400\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\32\5\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0%\0\"\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\254>\1\0\0\0\0\0\254>\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0@\1\0\0\0\0\0\0@!\0\0\0\0\0\0@!\0\0\0\0\0@\10\0\0\0\0\0\0H\10\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\210B\1\0\0\0\0\0\210B!\0\0\0\0\0\210B!\0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0x.\1\0\0\0\0\0x.\1\0\0\0\0\0x.\1\0\0\0\0\0,\2\0\0\0\0\0\0,\2\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0!\230\7\364\31\362\271 ;\244\255J\302\r\27\317?\355\366\10\0\0\0\0a\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0o\0\0\0H\0\0\0\0\0\0\0T\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\36\0\0\0O\0\0\0r\0\0\0\25\0\0\0P\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0m\0\0\0^\0\0\0K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0A\0\0\0_\0\0\0F\0\0\0U\0\0\0q\0\0\0X\0\0\0!\0\0\0\0\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0I\0\0\0+\0\0\0c\0\0\0\20\0\0\0b\0\0\0J\0\0\0l\0\0\0;\0\0\0S\0\0\0\0\0\0\0\0\0\0\0[\0\0\0*\0\0\0\"\0\0\0d\0\0\0\30\0\0\0Q\0\0\0@\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0\21\0\0\0\v\0\0\0t\0\0\0:\0\0\0R\0\0\0\32\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0G\0\0\0<\0\0\0008\0\0\0&\0\0\0-\0\0\0\0\0\0\0?\0\0\0a\0\0\0\4\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\0\0C\0\0\0\0\0\0\0g\0\0\0V\0\0\0'\0\0\0", 832) = 832
09:01:57.713499 fstat(5, {st_mode=S_IFREG|0555, st_size=345692, ...}) = 0
09:01:57.713570 mmap(NULL, 2181192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0x7f92d642b000
09:01:57.713632 mprotect(0x7f92d643f000, 2097152, PROT_NONE) = 0
09:01:57.713698 mmap(0x7f92d663f000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x14000) = 0x7f92d663f000
09:01:57.713766 close(5)                = 0
09:01:57.713933 stat("modules/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.713998 stat("modules/Socket.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.714092 stat("modules/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.714161 stat("modules/Socket.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.714232 stat("/etc/perl/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.714297 stat("/etc/perl/Socket.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.714360 stat("/usr/local/lib/perl/5.14.2/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.714418 stat("/usr/local/lib/perl/5.14.2/Socket.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.714477 stat("/usr/local/share/perl/5.14.2/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.714785 stat("/usr/local/share/perl/5.14.2/Socket.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.714834 stat("/usr/lib/perl5/Socket.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.714877 stat("/usr/lib/perl5/Socket.pm", {st_mode=S_IFREG|0644, st_size=35267, ...}) = 0
09:01:57.714935 open("/usr/lib/perl5/Socket.pm", O_RDONLY) = 5
09:01:57.714982 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b2c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.715036 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.715103 read(5, "package Socket;\n\nuse strict;\n{ use 5.006001; }\n\nour $VERSION = '2.002';\n\n=head1 NAME\n\nC<Socket> - networking constants and support functions\n\n=head1 SYNOPSIS\n\nC<Socket> a low-level module used by, among other things, the L<IO::Socket>\nfamily of modules. The following examples demonstrate some low-level uses but\na practical program would likely use the higher-level API provided by\nC<IO::Socket> or similar instead.\n\n use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);\n\n socket(my $socket, PF_INET, SOCK_STREAM, 0)\n     or die \"socket: $!\";\n\n my $port = getservbyname \"echo\", \"tcp\";\n connect($socket, pack_sockaddr_in($port, inet_aton(\"localhost\")))\n     or die \"connect: $!\";\n\n print $socket \"Hello, world!\\n\";\n print <$socket>;\n\nSee also the L</EXAMPLES> section.\n\n=head1 DESCRIPTION\n\nThis module provides a variety of constants, structure manipulators and other\nfunctions related to socket-based networking. The values and functions\nprovided are useful when used in conjunction with Perl core functions such as\nsocket(), setsockopt() and bind(). It also provides several other support\nfunctions, mostly for dealing with conversions of network addresses between\nhuman-readable and native binary forms, and for hostname resolver operations.\n\nSome constants and functions are exported by default by this module; but for\nbackward-compatibility any recently-added symbols are not exported by default\nand must be requested explicitly. When an import list is provided to the\nC<use Socket> line, the default exports are not automatically imported. It is\ntherefore best practice to always to explicitly list all the symbols required.\n\nAlso, some common socket \"newline\" constants are provided: the constants\nC<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map\nto C<\\015>, C<\\012>, and C<\\015\\012>. If you do not want to use the literal\ncharacters in your programs, then use the constants provided here. They are\nnot exported by default, but can be imported individually, and with the\nC<:crlf> export tag:\n\n use Socket qw(:DEFAULT :crlf);\n\n $sock->print(\"GET / HTTP/1.0$CRLF\");\n\nThe entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;\nthis exports the getaddrinfo() and getnameinfo() functions, and all the\nC<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.\n\n=cut\n\n=head1 CONSTANTS\n\nIn each of the following groups, there may be many more constants provided\nthan just the ones given as examples in the section heading. If the heading\nends C<...> then this means there are likely more; the exact constants\nprovided will depend on the OS and headers found at compile-time.\n\n=cut\n\n=head2 PF_INET, PF_INET6, PF_UNIX, ...\n\nProtocol family constants to use as the first argument to socket() or the\nvalue of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.\n\n=head2 AF_INET, AF_INET6, AF_UNIX, ...\n\nAddress family constants used by the socket address structures, to pass to\nsuch functions as inet_pton() or getaddrinfo(), or are returned by such\nfunctions as sockaddr_family().\n\n=head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...\n\nSocket type constants to use as the second argument to socket(), or the value\nof the C<SO_TYPE> socket option.\n\n=head2 SOCK_NONBLOCK. SOCK_CLOEXEC\n\nLinux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags\nduring a C<socket(2)> call.\n\n socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )\n\n=head2 SOL_SOCKET\n\nSocket option level constant for setsockopt() and getsockopt().\n\n=head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...\n\nSocket option name constants for setsockopt() and getsockopt() at the\nC<SOL_SOCKET> level.\n\n=head2 IP_OPTIONS, IP_TOS, IP_TTL, ...\n\nSocket option name constants for IPv4 socket options at the C<IPPROTO_IP>\nlevel.\n\n=head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...\n\nMessage flag constants for send() and recv().\n\n=head2 SHUT_RD, SHUT_RDWR, SHUT_WR\n\nDirection constants for shutdown().\n\n=head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE\n\nConstants giving the special C<AF_INET> addresses for wildcard, broadcast,\nlocal loopback, and invalid addresses.\n\nNormally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),\ninet_aton('localhost') and inet_aton('255.255.255.255') respectively.\n\n=head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...\n\nIP protocol constants to use as the third argument to socket(), the level\nargument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>\nsocket option.\n\n=head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...\n\nSocket option name constants for TCP socket options at the C<IPPROTO_TCP>\nlevel.\n\n=head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK\n\nConstants giving the special C<AF_INET6> addresses for wildcard and local\nloopback.\n\nNormally equivalent to inet_pton(AF_INET6, \"::\") and\ninet_pton(AF_INET6, \"::1\") respectively.\n\n=head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...\n\nSocket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>\nlevel.\n\n=cut\n\n# Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV\n\n=head1 STRUCTURE MANIPULATORS\n\nThe following functions convert between lists of Perl values and packed binary\nstrings representing structures.\n\n=cut\n\n=head2 $family = sockaddr_family $sockaddr\n\nTakes a packed socket address (as returned by pack_sockaddr_in(),\npack_sockaddr_un() or the perl builtin functions getsockname() and\ngetpeername()). Returns the address family tag. This will be one of the\nC<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or\nC<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to\nuse for a sockaddr of unknown type.\n\n=head2 $sockaddr = pack_sockaddr_in $port, $ip_address\n\nTakes two arguments, a port number and an opaque string (as returned by\ninet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those\narguments packed in and C<AF_INET> filled in. For Internet domain sockets,\nthis structure is normally what you need for the arguments in bind(),\nconnect(), and send().\n\n=head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr\n\nTakes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),\ngetpeername() or recv()). Returns a list of two elements: the port and an\nopaque string representing the IP address (you can use inet_ntoa() to convert\nthe address to the four-dotted numeric format). Will croak if the structure\ndoes not represent an C<AF_INET> address.\n\n=head2 $sockaddr = sockaddr_in $port, $ip_address\n\n=head2 ($port, $ip_address) = sockaddr_in $sockaddr\n\nA wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,\nunpacks its argument and returns a list consisting of the port and IP address.\nIn scalar context, packs its port and IP address arguments as a C<sockaddr_in>\nand returns it.\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_in() or unpack_sockaddr_in() explicitly.\n\n=head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]\n\nTakes two to four arguments, a port number, an opaque string (as returned by\ninet_pton()), optionally a scope ID number, and optionally a flow label\nnumber. Returns the C<sockaddr_in6> structure with those arguments packed in\nand C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().\n\n=head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr\n\nTakes a C<sockaddr_in6> structure. Returns a list of four elements: the port\nnumber, an opaque string representing the IPv6 address, the scope ID, and the\nflow label. (You can use inet_ntop() to convert the address to the usual\nstring format). Will croak if the structure does not represent an C<AF_INET6>\naddress.\n\n=head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]\n\n=head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr\n\nA wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,\nunpacks its argument according to unpack_sockaddr_in6(). In scalar context,\npacks its arguments according to pack_sockaddr_in6().\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.\n\n=head2 $sockaddr = pack_sockaddr_un $path\n\nTakes one argument, a pathname. Returns the C<sockaddr_", 8192) = 8192
09:01:57.715888 read(5, "un> structure with that\npath packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this\nstructure is normally what you need for the arguments in bind(), connect(),\nand send().\n\n=head2 ($path) = unpack_sockaddr_un $sockaddr\n\nTakes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),\ngetpeername() or recv()). Returns a list of one element: the pathname. Will\ncroak if the structure does not represent an C<AF_UNIX> address.\n\n=head2 $sockaddr = sockaddr_un $path\n\n=head2 ($path) = sockaddr_un $sockaddr\n\nA wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,\nunpacks its argument and returns a list consisting of the pathname. In a\nscalar context, packs its pathname as a C<sockaddr_un> and returns it.\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_un() or unpack_sockaddr_un() explicitly.\n\nThese are only supported if your system has E<lt>F<sys/un.h>E<gt>.\n\n=head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface\n\nTakes an IPv4 multicast address and optionally an interface address (or\nC<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed\nin. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>\nsockopts.\n\n=head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq\n\nTakes an C<ip_mreq> structure. Returns a list of two elements; the IPv4\nmulticast address and interface address.\n\n=head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex\n\nTakes an IPv6 multicast address and an interface number. Returns the\nC<ipv6_mreq> structure with those arguments packed in. Suitable for use with\nthe C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.\n\n=head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq\n\nTakes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6\naddress and an interface number.\n\n=cut\n\n=head1 FUNCTIONS\n\n=cut\n\n=head2 $ip_address = inet_aton $string\n\nTakes a string giving the name of a host, or a textual representation of an IP\naddress and translates that to an packed binary address structure suitable to\npass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,\nreturns C<undef>. For multi-homed hosts (hosts with more than one address),\nthe first address found is returned.\n\nFor portability do not assume that the result of inet_aton() is 32 bits wide,\nin other words, that it would contain only the IPv4 address in network order.\n\nThis IPv4-only function is provided largely for legacy reasons. Newly-written\ncode should use getaddrinfo() or inet_pton() instead for IPv6 support.\n\n=head2 $string = inet_ntoa $ip_address\n\nTakes a packed binary address structure such as returned by\nunpack_sockaddr_in() (or a v-string representing the four octets of the IPv4\naddress in network order) and translates it into a string of the form\nC<d.d.d.d> where the C<d>s are numbers less than 256 (the normal\nhuman-readable four dotted number notation for Internet addresses).\n\nThis IPv4-only function is provided largely for legacy reasons. Newly-written\ncode should use getnameinfo() or inet_ntop() instead for IPv6 support.\n\n=head2 $address = inet_pton $family, $string\n\nTakes an address family (such as C<AF_INET> or C<AF_INET6>) and a string\ncontaining a textual representation of an address in that family and\ntranslates that to an packed binary address structure.\n\nSee also getaddrinfo() for a more powerful and flexible function to look up\nsocket addresses given hostnames or textual addresses.\n\n=head2 $string = inet_ntop $family, $address\n\nTakes an address family and a packed binary address structure and translates\nit into a human-readable textual representation of the address; typically in\nC<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.\n\nSee also getnameinfo() for a more powerful and flexible function to turn\nsocket addresses into human-readable textual representations.\n\n=head2 ($err, @result) = getaddrinfo $host, $service, [$hints]\n\nGiven both a hostname and service name, this function attempts to resolve the\nhost name into a list of network addresses, and the service name into a\nprotocol and port number, and then returns a list of address structures\nsuitable to connect() to it.\n\nGiven just a host name, this function attempts to resolve it to a list of\nnetwork addresses, and then returns a list of address structures giving these\naddresses.\n\nGiven just a service name, this function attempts to resolve it to a protocol\nand port number, and then returns a list of address structures that represent\nit suitable to bind() to. This use should be combined with the C<AI_PASSIVE>\nflag; see below.\n\nGiven neither name, it generates an error.\n\nIf present, $hints should be a reference to a hash, where the following keys\nare recognised:\n\n=over 4\n\n=item flags => INT\n\nA bitfield containing C<AI_*> constants; see below.\n\n=item family => INT\n\nRestrict to only generating addresses in this address family\n\n=item socktype => INT\n\nRestrict to only generating addresses of this socket type\n\n=item protocol => INT\n\nRestrict to only generating addresses for this protocol\n\n=back\n\nThe return value will be a list; the first value being an error indication,\nfollowed by a list of address structures (if no error occurred).\n\nThe error value will be a dualvar; comparable to the C<EI_*> error constants,\nor printable as a human-readable error message string. If no error occurred it\nwill be zero numerically and an empty string.\n\nEach value in the results list will be a hash reference containing the following\nfields:\n\n=over 4\n\n=item family => INT\n\nThe address family (e.g. C<AF_INET>)\n\n=item socktype => INT\n\nThe socket type (e.g. C<SOCK_STREAM>)\n\n=item protocol => INT\n\nThe protocol (e.g. C<IPPROTO_TCP>)\n\n=item addr => STRING\n\nThe address in a packed string (such as would be returned by\npack_sockaddr_in())\n\n=item canonname => STRING\n\nThe canonical name for the host if the C<AI_CANONNAME> flag was provided, or\nC<undef> otherwise. This field will only be present on the first returned\naddress.\n\n=back\n\nThe following flag constants are recognised in the $hints hash. Other flag\nconstants may exist as provided by the OS.\n\n=over 4\n\n=item AI_PASSIVE\n\nIndicates that this resolution is for a local bind() for a passive (i.e.\nlistening) socket, rather than an active (i.e. connecting) socket.\n\n=item AI_CANONNAME\n\nIndicates that the caller wishes the canonical hostname (C<canonname>) field\nof the result to be filled in.\n\n=item AI_NUMERICHOST\n\nIndicates that the caller will pass a numeric address, rather than a hostname,\nand that getaddrinfo() must not perform a resolve operation on this name. This\nflag will prevent a possibly-slow network lookup operation, and instead return\nan error if a hostname is passed.\n\n=back\n\n=head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]\n\nGiven a packed socket address (such as from getsockname(), getpeername(), or\nreturned by getaddrinfo() in a C<addr> field), returns the hostname and\nsymbolic service name it represents. $flags may be a bitmask of C<NI_*>\nconstants, or defaults to 0 if unspecified.\n\nThe return value will be a list; the first value being an error condition,\nfollowed by the hostname and service name.\n\nThe error value will be a dualvar; comparable to the C<EI_*> error constants,\nor printable as a human-readable error message string. The host and service\nnames will be plain strings.\n\nThe following flag constants are recognised as $flags. Other flag constants may\nexist as provided by the OS.\n\n=over 4\n\n=item NI_NUMERICHOST\n\nRequests that a human-readable string representation of the numeric address be\nreturned directly, rather than performing a name resolve operation that may\nconvert it into a hostname. This will also avoid potentially-blocking network\nIO.\n\n=item NI_NUMERICSERV\n\nRequests that the port number be returned directly as a number representation\nrather than performing a name resolve operation that may convert it into a\nservice name.\n\n=item NI_NAMEREQD\n\nIf a name resolve operation fails to provide a name, then this flag will cause\ngetnameinfo() to indicate an error, rather than returning the numeric\nrepresentation as a human-readable string.\n\n=item NI_DGRAM\n\nIndicates that the sock", 8192) = 8192
09:01:57.716320 read(5, "et address relates to a C<SOCK_DGRAM> socket, for the\nservices whose name differs between TCP and UDP protocols.\n\n=back\n\nThe following constants may be supplied as $xflags.\n\n=over 4\n\n=item NIx_NOHOST\n\nIndicates that the caller is not interested in the hostname of the result, so\nit does not have to be converted. C<undef> will be returned as the hostname.\n\n=item NIx_NOSERV\n\nIndicates that the caller is not interested in the service name of the result,\nso it does not have to be converted. C<undef> will be returned as the service\nname.\n\n=back\n\n=head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS\n\nThe following constants may be returned by getaddrinfo() or getnameinfo().\nOthers may be provided by the OS.\n\n=over 4\n\n=item EAI_AGAIN\n\nA temporary failure occurred during name resolution. The operation may be\nsuccessful if it is retried later.\n\n=item EAI_BADFLAGS\n\nThe value of the C<flags> hint to getaddrinfo(), or the $flags parameter to\ngetnameinfo() contains unrecognised flags.\n\n=item EAI_FAMILY\n\nThe C<family> hint to getaddrinfo(), or the family of the socket address\npassed to getnameinfo() is not supported.\n\n=item EAI_NODATA\n\nThe host name supplied to getaddrinfo() did not provide any usable address\ndata.\n\n=item EAI_NONAME\n\nThe host name supplied to getaddrinfo() does not exist, or the address\nsupplied to getnameinfo() is not associated with a host name and the\nC<NI_NAMEREQD> flag was supplied.\n\n=item EAI_SERVICE\n\nThe service name supplied to getaddrinfo() is not available for the socket\ntype given in the $hints.\n\n=back\n\n=cut\n\n=head1 EXAMPLES\n\n=head2 Lookup for connect()\n\nThe getaddrinfo() function converts a hostname and a service name into a list\nof structures, each containing a potential way to connect() to the named\nservice on the named host.\n\n use IO::Socket;\n use Socket qw(SOCK_STREAM getaddrinfo);\n\n my %hints = (socktype => SOCK_STREAM);\n my ($err, @res) = getaddrinfo(\"localhost\", \"echo\", \\%hints);\n die \"Cannot getaddrinfo - $err\" if $err;\n\n my $sock;\n\n foreach my $ai (@res) {\n     my $candidate = IO::Socket->new();\n\n     $candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})\n         or next;\n\n     $candidate->connect($ai->{addr})\n         or next;\n\n     $sock = $candidate;\n     last;\n }\n\n die \"Cannot connect to localhost:echo\" unless $sock;\n\n $sock->print(\"Hello, world!\\n\");\n print <$sock>;\n\nBecause a list of potential candidates is returned, the C<while> loop tries\neach in turn until it it finds one that succeeds both the socket() and\nconnect() calls.\n\nThis function performs the work of the legacy functions gethostbyname(),\ngetservbyname(), inet_aton() and pack_sockaddr_in().\n\nIn practice this logic is better performed by L<IO::Socket::IP>.\n\n=head2 Making a human-readable string out of an address\n\nThe getnameinfo() function converts a socket address, such as returned by\ngetsockname() or getpeername(), into a pair of human-readable strings\nrepresenting the address and service name.\n\n use IO::Socket::IP;\n use Socket qw(getnameinfo);\n\n my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or\n     die \"Cannot listen - $@\";\n\n my $socket = $server->accept or die \"accept: $!\";\n\n my ($err, $hostname, $servicename) = getnameinfo($socket->peername);\n die \"Cannot getnameinfo - $err\" if $err;\n\n print \"The peer is connected from $hostname\\n\";\n\nSince in this example only the hostname was used, the redundant conversion of\nthe port number into a service name may be omitted by passing the\nC<NIx_NOSERV> flag.\n\n use Socket qw(getnameinfo NIx_NOSERV);\n\n my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);\n\nThis function performs the work of the legacy functions unpack_sockaddr_in(),\ninet_ntoa(), gethostbyaddr() and getservbyport().\n\nIn practice this logic is better performed by L<IO::Socket::IP>.\n\n=head2 Resolving hostnames into IP addresses\n\nTo turn a hostname into a human-readable plain IP address use getaddrinfo()\nto turn the hostname into a list of socket structures, then getnameinfo() on\neach one to make it a readable IP address again.\n\n use Socket qw(:addrinfo SOCK_RAW);\n\n my ($err, @res) = getaddrinfo($hostname, \"\", {socktype => SOCK_RAW});\n die \"Cannot getaddrinfo - $err\" if $err;\n\n while( my $ai = shift @res ) {\n     my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);\n     die \"Cannot getnameinfo - $err\" if $err;\n\n     print \"$ipaddr\\n\";\n }\n\nThe C<socktype> hint to getaddrinfo() filters the results to only include one\nsocket type and protocol. Without this most OSes return three combinations,\nfor C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate\noutput of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to\nreturn a string-formatted plain IP address, rather than reverse resolving it\nback into a hostname.\n\nThis combination performs the work of the legacy functions gethostbyname()\nand inet_ntoa().\n\n=head2 Accessing socket options\n\nThe many C<SO_*> and other constants provide the socket option names for\ngetsockopt() and setsockopt().\n\n use IO::Socket::INET;\n use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);\n\n my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')\n     or die \"Cannot create socket: $@\";\n\n $socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or\n     die \"setsockopt: $!\";\n\n print \"Receive buffer is \", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),\n     \" bytes\\n\";\n\n print \"IP TTL is \", $socket->getsockopt(IPPROTO_IP, IP_TTL), \"\\n\";\n\nAs a convenience, L<IO::Socket>'s setsockopt() method will convert a number\ninto a packed byte buffer, and getsockopt() will unpack a byte buffer of the\ncorrect size back into a number.\n\n=cut\n\n=head1 AUTHOR\n\nThis module was originally maintained in Perl core by the Perl 5 Porters.\n\nIt was extracted to dual-life on CPAN at version 1.95 by\nPaul Evans <leonerd@leonerd.org.uk>\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nrequire XSLoader;\nour @ISA = qw(Exporter);\n\n# <@Nicholas> you can't change @EXPORT without breaking the implicit API\n# Please put any new constants in @EXPORT_OK!\n\n# List re-ordered to match documentation above. Try to keep the ordering\n# consistent so it's easier to see which ones are or aren't documented.\nour @EXPORT = qw(\n\tPF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT\n\tPF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6\n\tPF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI\n\tPF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN\n\tPF_X25\n\n\tAF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT\n\tAF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6\n\tAF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI\n\tAF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN\n\tAF_X25\n\n\tSOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM\n\n\tSOL_SOCKET\n\n\tSO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON\n\tSO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER\n\tSO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE\n\tSO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE\n\tSO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO\n\tSO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE\n\n\tIP_OPTIONS IP_HDRINCL IP_TOS IP_TTL IP_RECVOPTS IP_RECVRETOPTS\n\tIP_RETOPTS\n\n\tMSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE\n\tMSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FIN\n\tMSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST\n\tMSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE\n\n\tSHUT_RD SHUT_RDWR SHUT_WR\n\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\n\tSCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP\n\n\tSOMAXCONN\n\n\tIOV_MAX\n\tUIO_MAXIOV\n\n\tsockaddr_family\n\tpack_sockaddr_in  unpack_sockaddr_in  sockaddr_in\n\tpack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6\n\tpack_sockaddr_un  unpack_sockaddr_un  sockaddr_un \n\n\tinet_aton inet_ntoa\n);\n\n# List re-ordered to match documentation above. Try to keep the ordering\n# consistent so it's easier to see which on", 8192) = 8192
09:01:57.716751 stat("modules/Carp.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.716798 stat("modules/Carp.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.716866 stat("modules/Carp.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.716938 stat("modules/Carp.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.717001 stat("/etc/perl/Carp.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.717059 stat("/etc/perl/Carp.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.717106 stat("/usr/local/lib/perl/5.14.2/Carp.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.717186 stat("/usr/local/lib/perl/5.14.2/Carp.pm", 0x7ffc53d0af00) = -1 ENOENT (No such file or directory)
09:01:57.717231 stat("/usr/local/share/perl/5.14.2/Carp.pmc", 0x7ffc53d0afb0) = -1 ENOENT (No such file or directory)
09:01:57.717274 stat("/usr/local/share/perl/5.14.2/Carp.pm", {st_mode=S_IFREG|0444, st_size=30436, ...}) = 0
09:01:57.717345 open("/usr/local/share/perl/5.14.2/Carp.pm", O_RDONLY) = 6
09:01:57.717409 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0ac90) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.717447 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.717506 read(6, "package Carp;\n\n{ use 5.006; }\nuse strict;\nuse warnings;\nBEGIN {\n    # Very old versions of warnings.pm load Carp.  This can go wrong due\n    # to the circular dependency.  If warnings is invoked before Carp,\n    # then warnings starts by loading Carp, then Carp (above) tries to\n    # invoke warnings, and gets nothing because warnings is in the process\n    # of loading and hasn't defined its import method yet.  If we were\n    # only turning on warnings (\"use warnings\" above) this wouldn't be too\n    # bad, because Carp would just gets the state of the -w switch and so\n    # might not get some warnings that it wanted.  The real problem is\n    # that we then want to turn off Unicode warnings, but \"no warnings\n    # 'utf8'\" won't be effective if we're in this circular-dependency\n    # situation.  So, if warnings.pm is an affected version, we turn\n    # off all warnings ourselves by directly setting ${^WARNING_BITS}.\n    # On unaffected versions, we turn off just Unicode warnings, via\n    # the proper API.\n    if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {\n\t${^WARNING_BITS} = \"\";\n    } else {\n\t\"warnings\"->unimport(\"utf8\");\n    }\n}\n\nsub _fetch_sub { # fetch sub without autovivifying\n    my($pack, $sub) = @_;\n    $pack .= '::';\n    # only works with top-level packages\n    return unless exists($::{$pack});\n    for ($::{$pack}) {\n\treturn unless ref \\$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};\n\tfor ($$_{$sub}) {\n\t    return ref \\$_ eq 'GLOB' ? *$_{CODE} : undef\n\t}\n    }\n}\n\n# UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp\n# must avoid applying a regular expression to an upgraded (is_utf8)\n# string.  There are multiple problems, on different Perl versions,\n# that require this to be avoided.  All versions prior to 5.13.8 will\n# load utf8_heavy.pl for the swash system, even if the regexp doesn't\n# use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit\n# specific problems when Carp is being invoked in the aftermath of a\n# syntax error.\nBEGIN {\n    if(\"$]\" < 5.013011) {\n\t*UTF8_REGEXP_PROBLEM = sub () { 1 };\n    } else {\n\t*UTF8_REGEXP_PROBLEM = sub () { 0 };\n    }\n}\n\n# is_utf8() is essentially the utf8::is_utf8() function, which indicates\n# whether a string is represented in the upgraded form (using UTF-8\n# internally).  As utf8::is_utf8() is only available from Perl 5.8\n# onwards, extra effort is required here to make it work on Perl 5.6.\nBEGIN {\n    if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {\n\t*is_utf8 = $sub;\n    } else {\n\t# black magic for perl 5.6\n\t*is_utf8 = sub { unpack(\"C\", \"\\xaa\".$_[0]) != 170 };\n    }\n}\n\n# The downgrade() function defined here is to be used for attempts to\n# downgrade where it is acceptable to fail.  It must be called with a\n# second argument that is a true value.\nBEGIN {\n    if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {\n\t*downgrade = \\&{\"utf8::downgrade\"};\n    } else {\n\t*downgrade = sub {\n\t    my $r = \"\";\n\t    my $l = length($_[0]);\n\t    for(my $i = 0; $i != $l; $i++) {\n\t\tmy $o = ord(substr($_[0], $i, 1));\n\t\treturn if $o > 255;\n\t\t$r .= chr($o);\n\t    }\n\t    $_[0] = $r;\n\t};\n    }\n}\n\nour $VERSION = '1.38';\n$VERSION =~ tr/_//d;\n\nour $MaxEvalLen = 0;\nour $Verbose    = 0;\nour $CarpLevel  = 0;\nour $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.\nour $MaxArgNums = 8;     # How many arguments to print. 0 = all.\nour $RefArgFormatter = undef; # allow caller to format reference arguments\n\nrequire Exporter;\nour @ISA       = ('Exporter');\nour @EXPORT    = qw(confess croak carp);\nour @EXPORT_OK = qw(cluck verbose longmess shortmess);\nour @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl's warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\nour %CarpInternal;\nour %Internal;\n\n# disable these by default, so they can live w/o require Carp\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$Internal{Exporter}++;\n$Internal{'Exporter::Heavy'}++;\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# 'verbose'.\n\nsub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }\n\nsub _cgc {\n    no strict 'refs';\n    return \\&{\"CORE::GLOBAL::caller\"} if defined &{\"CORE::GLOBAL::caller\"};\n    return;\n}\n\nsub longmess {\n    local($!, $^E);\n    # Icky backwards compatibility wrapper. :-(\n    #\n    # The story is that the original implementation hard-coded the\n    # number of call levels to go back, so calls to longmess were off\n    # by one.  Other code began calling longmess and expecting this\n    # behaviour, so the replacement has to emulate that behaviour.\n    my $cgc = _cgc();\n    my $call_pack = $cgc ? $cgc->() : caller();\n    if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {\n        return longmess_heavy(@_);\n    }\n    else {\n        local $CarpLevel = $CarpLevel + 1;\n        return longmess_heavy(@_);\n    }\n}\n\nour @CARP_NOT;\n\nsub shortmess {\n    local($!, $^E);\n    my $cgc = _cgc();\n\n    # Icky backwards compatibility wrapper. :-(\n    local @CARP_NOT = $cgc ? $cgc->() : caller();\n    shortmess_heavy(@_);\n}\n\nsub croak   { die shortmess @_ }\nsub confess { die longmess @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn longmess @_ }\n\nBEGIN {\n    if(\"$]\" >= 5.015002 || (\"$]\" >= 5.014002 && \"$]\" < 5.015) ||\n\t    (\"$]\" >= 5.012005 && \"$]\" < 5.013)) {\n\t*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };\n    } else {\n\t*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };\n    }\n}\n\nsub caller_info {\n    my $i = shift(@_) + 1;\n    my %call_info;\n    my $cgc = _cgc();\n    {\n\t# Some things override caller() but forget to implement the\n\t# @DB::args part of it, which we need.  We check for this by\n\t# pre-populating @DB::args with a sentinel which no-one else\n\t# has the address of, so that we can detect whether @DB::args\n\t# has been properly populated.  However, on earlier versions\n\t# of perl this check tickles a bug in CORE::caller() which\n\t# leaks memory.  So we only check on fixed perls.\n        @DB::args = \\$i if CALLER_OVERRIDE_CHECK_OK;\n        package DB;\n        @call_info{\n            qw(pack file line sub has_args wantarray evaltext is_require) }\n            = $cgc ? $cgc->($i) : caller($i);\n    }\n\n    unless ( defined $call_info{file} ) {\n        return ();\n    }\n\n    my $sub_name = Carp::get_subname( \\%call_info );\n    if ( $call_info{has_args} ) {\n        my @args;\n        if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1\n            && ref $DB::args[0] eq ref \\$i\n            && $DB::args[0] == \\$i ) {\n            @DB::args = ();    # Don't let anyone see the address of $i\n            local $@;\n            my $where = eval {\n                my $func    = $cgc or return '';\n                my $gv      =\n                    (_fetch_sub B => 'svref_2object' or return '')\n                        ->($func)->GV;\n                my $package = $gv->STASH->NAME;\n                my $subname = $gv->NAME;\n                return unless defined $package && defined $subname;\n\n                # returning CORE::GLOBAL::caller isn't useful for tracing the cause:\n                return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';\n                \" in &${package}::$subname\";\n            } || '';\n            @args\n                = \"** Incomplete caller override detected$where; \\@DB::args were not set **\";\n        }\n        else {\n            @args = @DB::args;\n            my $overflow;\n            if ( $MaxArgNums and @args > $MaxArgNums )\n            {    # More than we want to show?\n                $#args = $MaxArgNums - 1;\n                $overflow = 1;\n            }\n\n            @args = map { Carp::format_arg($_) ", 8192) = 8192
09:01:57.718522 brk(0x1f68000)          = 0x1f68000
09:01:57.718809 read(6, "} @args;\n\n            if ($overflow) {\n                push @args, '...';\n            }\n        }\n\n        # Push the args onto the subroutine\n        $sub_name .= '(' . join( ', ', @args ) . ')';\n    }\n    $call_info{sub_name} = $sub_name;\n    return wantarray() ? %call_info : \\%call_info;\n}\n\n# Transform an argument to a function into a string.\nour $in_recurse;\nsub format_arg {\n    my $arg = shift;\n\n    if ( ref($arg) ) {\n         # legitimate, let's not leak it.\n        if (!$in_recurse &&\n\t    do {\n                local $@;\n\t        local $in_recurse = 1;\n\t\tlocal $SIG{__DIE__} = sub{};\n                eval {$arg->can('CARP_TRACE') }\n            })\n        {\n            return $arg->CARP_TRACE();\n        }\n        elsif (!$in_recurse &&\n\t       defined($RefArgFormatter) &&\n\t       do {\n                local $@;\n\t        local $in_recurse = 1;\n\t\tlocal $SIG{__DIE__} = sub{};\n                eval {$arg = $RefArgFormatter->($arg); 1}\n                })\n        {\n            return $arg;\n        }\n        else\n        {\n\t    my $sub = _fetch_sub(overload => 'StrVal');\n\t    return $sub ? &$sub($arg) : \"$arg\";\n        }\n    }\n    return \"undef\" if !defined($arg);\n    downgrade($arg, 1);\n    return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&\n\t    $arg =~ /\\A-?[0-9]+(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\\z/;\n    my $suffix = \"\";\n    if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {\n        substr ( $arg, $MaxArgLen - 3 ) = \"\";\n\t$suffix = \"...\";\n    }\n    if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {\n\tfor(my $i = length($arg); $i--; ) {\n\t    my $c = substr($arg, $i, 1);\n\t    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}\n\t    if($c eq \"\\\"\" || $c eq \"\\\\\" || $c eq \"\\$\" || $c eq \"\\@\") {\n\t\tsubstr $arg, $i, 0, \"\\\\\";\n\t\tnext;\n\t    }\n\t    my $o = ord($c);\n\n            # This code is repeated in Regexp::CARP_TRACE()\n            if ($] ge 5.007_003) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n\t\t  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)\n                  || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);\n            } elsif (ord(\"A\") == 65) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < 0x20 || $o > 0x7e;\n            } else { # Early EBCDIC\n\n                # 3 EBCDIC code pages supported then;  all controls but one\n                # are the code points below SPACE.  The other one is 0x5F on\n                # POSIX-BC; FF on the other two.\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < ord(\" \") || ((ord (\"^\") == 106)\n                                          ? $o == 0x5f\n                                          : $o == 0xff);\n            }\n\t}\n    } else {\n\t$arg =~ s/([\\\"\\\\\\$\\@])/\\\\$1/g;\n        # This is all the ASCII printables spelled-out.  It is portable to all\n        # Perl versions and platforms (such as EBCDIC).  There are other more\n        # compact ways to do this, but may not work everywhere every version.\n        $arg =~ s/([^ !\"\\$\\%#'()*+,\\-.\\/0123456789:;<=>?\\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]^_`abcdefghijklmnopqrstuvwxyz\\{|}~])/sprintf(\"\\\\x{%x}\",ord($1))/eg;\n    }\n    downgrade($arg, 1);\n    return \"\\\"\".$arg.\"\\\"\".$suffix;\n}\n\nsub Regexp::CARP_TRACE {\n    my $arg = \"$_[0]\";\n    downgrade($arg, 1);\n    if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {\n\tfor(my $i = length($arg); $i--; ) {\n\t    my $o = ord(substr($arg, $i, 1));\n\t    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}\n\n            # This code is repeated in format_arg()\n            if ($] ge 5.007_003) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n\t\t  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)\n                  || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);\n            } elsif (ord(\"A\") == 65) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < 0x20 || $o > 0x7e;\n            } else { # Early EBCDIC\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < ord(\" \") || ((ord (\"^\") == 106)\n                                          ? $o == 0x5f\n                                          : $o == 0xff);\n            }\n\t}\n    } else {\n        # See comment in format_arg() about this same regex.\n        $arg =~ s/([^ !\"\\$\\%#'()*+,\\-.\\/0123456789:;<=>?\\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]^_`abcdefghijklmnopqrstuvwxyz\\{|}~])/sprintf(\"\\\\x{%x}\",ord($1))/eg;\n    }\n    downgrade($arg, 1);\n    my $suffix = \"\";\n    if($arg =~ /\\A\\(\\?\\^?([a-z]*)(?:-[a-z]*)?:(.*)\\)\\z/s) {\n\t($suffix, $arg) = ($1, $2);\n    }\n    if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {\n        substr ( $arg, $MaxArgLen - 3 ) = \"\";\n\t$suffix = \"...\".$suffix;\n    }\n    return \"qr($arg)$suffix\";\n}\n\n# Takes an inheritance cache and a package and returns\n# an anon hash of known inheritances and anon array of\n# inheritances which consequences have not been figured\n# for.\nsub get_status {\n    my $cache = shift;\n    my $pkg   = shift;\n    $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];\n    return @{ $cache->{$pkg} };\n}\n\n# Takes the info from caller() and figures out the name of\n# the sub/require/eval\nsub get_subname {\n    my $info = shift;\n    if ( defined( $info->{evaltext} ) ) {\n        my $eval = $info->{evaltext};\n        if ( $info->{is_require} ) {\n            return \"require $eval\";\n        }\n        else {\n            $eval =~ s/([\\\\\\'])/\\\\$1/g;\n            return \"eval '\" . str_len_trim( $eval, $MaxEvalLen ) . \"'\";\n        }\n    }\n\n    # this can happen on older perls when the sub (or the stash containing it)\n    # has been deleted\n    if ( !defined( $info->{sub} ) ) {\n        return '__ANON__::__ANON__';\n    }\n\n    return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};\n}\n\n# Figures out what call (from the point of view of the caller)\n# the long error backtrace should start at.\nsub long_error_loc {\n    my $i;\n    my $lvl = $CarpLevel;\n    {\n        ++$i;\n        my $cgc = _cgc();\n        my @caller = $cgc ? $cgc->($i) : caller($i);\n        my $pkg = $caller[0];\n        unless ( defined($pkg) ) {\n\n            # This *shouldn't* happen.\n            if (%Internal) {\n                local %Internal;\n                $i = long_error_loc();\n                last;\n            }\n            elsif (defined $caller[2]) {\n                # this can happen when the stash has been deleted\n                # in that case, just assume that it's a reasonable place to\n                # stop (the file and line data will still be intact in any\n                # case) - the only issue is that we can't detect if the\n                # deleted package was internal (so don't do that then)\n                # -doy\n                redo unless 0 > --$lvl;\n                last;\n            }\n            else {\n                return 2;\n            }\n        }\n        redo if $CarpInternal{$pkg};\n        redo unless 0 > --$lvl;\n        redo if $Internal{$pkg};\n    }\n    return $i - 1;\n}\n\nsub longmess_heavy {\n    return @_ if ref( $_[0] );    # don't break references as exceptions\n    my $i = long_error_loc();\n    return ret_backtrace( $i, @_ );\n}\n\n# Returns a full stack backtrace starting from where it is\n# told.\nsub ret_backtrace {\n    my ( $i, @error ) = @_;\n    my $mess;\n    my $err = join '', @error;\n    $i++;\n\n    my $tid_msg = '';\n    if ( defined &threads::tid ) {\n        my $tid = threads->tid;\n        $tid_msg = \" thread $tid\" if $tid;\n    }\n\n    my %i = caller_info($i);\n    $mess = \"$err at $i{file} line $i{line}$tid_msg\";\n    if( defined $. ) {\n        local $@ = '';\n        local $SIG{__DIE__};\n        eval {\n            CORE::die;\n        };\n        if($@ =~ /^Died at .*(, <.*?> line \\d+).$/ ) {\n            $mess .= $1;\n        }\n    }\n    $mess .= \"\\.\\n\";\n\n    while ( my %i = caller_info( ++$i ) ) {\n        $mess .= \"\\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\\n\";\n    }\n\n    return $mess;\n}\n\nsub ret_summary {\n    my ( $i, @error ) = @_;\n    my $err = join '', @error;\n    $i++;\n\n    my $tid_msg = '';\n    if ( defined &threads::tid ) {\n        my $tid = threads->tid;\n        $tid_msg = \" thread $tid\" if $tid;\n    }\n\n    my %i ", 8192) = 8192
09:01:57.720080 brk(0x1f89000)          = 0x1f89000
09:01:57.720185 read(6, "= caller_info($i);\n    return \"$err at $i{file} line $i{line}$tid_msg\\.\\n\";\n}\n\nsub short_error_loc {\n    # You have to create your (hash)ref out here, rather than defaulting it\n    # inside trusts *on a lexical*, as you want it to persist across calls.\n    # (You can default it on $_[2], but that gets messy)\n    my $cache = {};\n    my $i     = 1;\n    my $lvl   = $CarpLevel;\n    {\n        my $cgc = _cgc();\n        my $called = $cgc ? $cgc->($i) : caller($i);\n        $i++;\n        my $caller = $cgc ? $cgc->($i) : caller($i);\n\n        if (!defined($caller)) {\n            my @caller = $cgc ? $cgc->($i) : caller($i);\n            if (@caller) {\n                # if there's no package but there is other caller info, then\n                # the package has been deleted - treat this as a valid package\n                # in this case\n                redo if defined($called) && $CarpInternal{$called};\n                redo unless 0 > --$lvl;\n                last;\n            }\n            else {\n                return 0;\n            }\n        }\n        redo if $Internal{$caller};\n        redo if $CarpInternal{$caller};\n        redo if $CarpInternal{$called};\n        redo if trusts( $called, $caller, $cache );\n        redo if trusts( $caller, $called, $cache );\n        redo unless 0 > --$lvl;\n    }\n    return $i - 1;\n}\n\nsub shortmess_heavy {\n    return longmess_heavy(@_) if $Verbose;\n    return @_ if ref( $_[0] );    # don't break references as exceptions\n    my $i = short_error_loc();\n    if ($i) {\n        ret_summary( $i, @_ );\n    }\n    else {\n        longmess_heavy(@_);\n    }\n}\n\n# If a string is too long, trims it with ...\nsub str_len_trim {\n    my $str = shift;\n    my $max = shift || 0;\n    if ( 2 < $max and $max < length($str) ) {\n        substr( $str, $max - 3 ) = '...';\n    }\n    return $str;\n}\n\n# Takes two packages and an optional cache.  Says whether the\n# first inherits from the second.\n#\n# Recursive versions of this have to work to avoid certain\n# possible endless loops, and when following long chains of\n# inheritance are less efficient.\nsub trusts {\n    my $child  = shift;\n    my $parent = shift;\n    my $cache  = shift;\n    my ( $known, $partial ) = get_status( $cache, $child );\n\n    # Figure out consequences until we have an answer\n    while ( @$partial and not exists $known->{$parent} ) {\n        my $anc = shift @$partial;\n        next if exists $known->{$anc};\n        $known->{$anc}++;\n        my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );\n        my @found = keys %$anc_knows;\n        @$known{@found} = ();\n        push @$partial, @$anc_partial;\n    }\n    return exists $known->{$parent};\n}\n\n# Takes a package and gives a list of those trusted directly\nsub trusts_directly {\n    my $class = shift;\n    no strict 'refs';\n    my $stash = \\%{\"$class\\::\"};\n    for my $var (qw/ CARP_NOT ISA /) {\n        # Don't try using the variable until we know it exists,\n        # to avoid polluting the caller's namespace.\n        if ( $stash->{$var} && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {\n           return @{$stash->{$var}}\n        }\n    }\n    return;\n}\n\nif(!defined($warnings::VERSION) ||\n\tdo { no warnings \"numeric\"; $warnings::VERSION < 1.03 }) {\n    # Very old versions of warnings.pm import from Carp.  This can go\n    # wrong due to the circular dependency.  If Carp is invoked before\n    # warnings, then Carp starts by loading warnings, then warnings\n    # tries to import from Carp, and gets nothing because Carp is in\n    # the process of loading and hasn't defined its import method yet.\n    # So we work around that by manually exporting to warnings here.\n    no strict \"refs\";\n    *{\"warnings::$_\"} = \\&$_ foreach @EXPORT;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nCarp - alternative warn and die for modules\n\n=head1 SYNOPSIS\n\n    use Carp;\n\n    # warn user (from perspective of caller)\n    carp \"string trimmed to 80 chars\";\n\n    # die of errors (from perspective of caller)\n    croak \"We're outta here!\";\n\n    # die of errors with stack backtrace\n    confess \"not implemented\";\n\n    # cluck, longmess and shortmess not exported by default\n    use Carp qw(cluck longmess shortmess);\n    cluck \"This is how we got here!\";\n    $long_message   = longmess( \"message from cluck() or confess()\" );\n    $short_message  = shortmess( \"message from carp() or croak()\" );\n\n=head1 DESCRIPTION\n\nThe Carp routines are useful in your own modules because\nthey act like C<die()> or C<warn()>, but with a message which is more\nlikely to be useful to a user of your module.  In the case of\nC<cluck()> and C<confess()>, that context is a summary of every\ncall in the call-stack; C<longmess()> returns the contents of the error\nmessage.\n\nFor a shorter message you can use C<carp()> or C<croak()> which report the\nerror as being from where your module was called.  C<shortmess()> returns the\ncontents of this error message.  There is no guarantee that that is where the\nerror was, but it is a good educated guess.\n\nC<Carp> takes care not to clobber the status variables C<$!> and C<$^E>\nin the course of assembling its error messages.  This means that a\nC<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error\ninformation held in those variables, if it is required to augment the\nerror message, and if the code calling C<Carp> left useful values there.\nOf course, C<Carp> can't guarantee the latter.\n\nYou can also alter the way the output and logic of C<Carp> works, by\nchanging some global variables in the C<Carp> namespace. See the\nsection on C<GLOBAL VARIABLES> below.\n\nHere is a more complete description of how C<carp> and C<croak> work.\nWhat they do is search the call-stack for a function call stack where\nthey have not been told that there shouldn't be an error.  If every\ncall is marked safe, they give up and give a full stack backtrace\ninstead.  In other words they presume that the first likely looking\npotential suspect is guilty.  Their rules for telling whether\na call shouldn't generate errors work as follows:\n\n=over 4\n\n=item 1.\n\nAny call from a package to itself is safe.\n\n=item 2.\n\nPackages claim that there won't be errors on calls to or from\npackages explicitly marked as safe by inclusion in C<@CARP_NOT>, or\n(if that array is empty) C<@ISA>.  The ability to override what\n@ISA says is new in 5.8.\n\n=item 3.\n\nThe trust in item 2 is transitive.  If A trusts B, and B\ntrusts C, then A trusts C.  So if you do not override C<@ISA>\nwith C<@CARP_NOT>, then this trust relationship is identical to,\n\"inherits from\".\n\n=item 4.\n\nAny call from an internal Perl module is safe.  (Nothing keeps\nuser modules from marking themselves as internal to Perl, but\nthis practice is discouraged.)\n\n=item 5.\n\nAny call to Perl's warning system (eg Carp itself) is safe.\n(This rule is what keeps it from reporting the error at the\npoint where you call C<carp> or C<croak>.)\n\n=item 6.\n\nC<$Carp::CarpLevel> can be set to skip a fixed number of additional\ncall levels.  Using this is not recommended because it is very\ndifficult to get it to behave correctly.\n\n=back\n\n=head2 Forcing a Stack Trace\n\nAs a debugging aid, you can force Carp to treat a croak as a confess\nand a carp as a cluck across I<all> modules. In other words, force a\ndetailed stack trace to be given.  This can be very helpful when trying\nto understand why, or from where, a warning or error is being generated.\n\nThis feature is enabled by 'importing' the non-existent symbol\n'verbose'. You would typically enable it by saying\n\n    perl -MCarp=verbose script.pl\n\nor by including the string C<-MCarp=verbose> in the PERL5OPT\nenvironment variable.\n\nAlternately, you can set the global variable C<$Carp::Verbose> to true.\nSee the C<GLOBAL VARIABLES> section below.\n\n=head2 Stack Trace formatting\n\nAt each stack level, the subroutine's name is displayed along with\nits parameters.  For simple scalars, this is sufficient.  For complex\ndata types, such as objects and other references, this can simply\ndisplay C<'HASH(0x1ab36d8)'>.\n\nCarp gives two ways to control this.\n\n=over 4\n\n=item 1.\n\nFor objects, a method, C<CARP_TRACE>, will be called, if it exists.  If\nthis method doesn't exist, or it recurses into C<Carp>, or it otherwise\nthrows an exception, this is skipped, and C", 8192) = 8192
09:01:57.720963 lseek(6, 20098, SEEK_SET) = 20098
09:01:57.721026 lseek(6, 0, SEEK_CUR)   = 20098
09:01:57.721088 close(6)                = 0
09:01:57.721327 read(5, "es are or aren't documented.\nour @EXPORT_OK = qw(\n\tCR LF CRLF $CR $LF $CRLF\n\n\tSOCK_NONBLOCK SOCK_CLOEXEC\n\n\tIP_ADD_MEMBERSHIP IP_DROP_MEMBERSHIP IP_MULTICAST_IF\n\tIP_MULTICAST_LOOP IP_MULTICAST_TTL\n\n\tIPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_TCP\n\tIPPROTO_UDP\n\n\tTCP_CONGESTION TCP_CORK TCP_DEFER_ACCEPT TCP_INFO TCP_KEEPALIVE\n\tTCP_KEEPCNT TCP_KEEPIDLE TCP_KEEPINTVL TCP_LINGER2 TCP_MAXRT TCP_MAXSEG\n\tTCP_MD5SIG TCP_NODELAY TCP_QUICKACK TCP_STDURG TCP_SYNCNT\n\tTCP_WINDOW_CLAMP \n\n\tIN6ADDR_ANY IN6ADDR_LOOPBACK\n\n\tIPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_MTU IPV6_MTU_DISCOVER\n\tIPV6_MULTICAST_HOPS IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP\n\tIPV6_UNICAST_HOPS IPV6_V6ONLY\n\n\tpack_ip_mreq unpack_ip_mreq\n\n\tpack_ipv6_mreq unpack_ipv6_mreq\n\n\tinet_pton inet_ntop\n\n\tgetaddrinfo getnameinfo\n\n\tAI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN\n\tAI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST\n\tAI_NUMERICSERV AI_PASSIVE AI_V4MAPPED\n\n\tNI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES\n\tNI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV\n\n\tNIx_NOHOST NIx_NOSERV\n\n\tEAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY\n\tEAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM\n);\n\nour %EXPORT_TAGS = (\n    crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],\n    addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],\n    all      => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n\n    # These are not gni() constants; they're extensions for the perl API\n    # The definitions in Socket.pm and Socket.xs must match\n    sub NIx_NOHOST() {1 << 0}\n    sub NIx_NOSERV() {1 << 1}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join('.', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_in6 {\n    if (wantarray) {\n\tcroak \"usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)\" unless @_ == 1;\n\tunpack_sockaddr_in6(@_);\n    }\n    else {\n\tcroak \"usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])\" unless @_ >= 2 and @_ <= 4;\n\tpack_sockaddr_in6(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nXSLoader::load(__PACKAGE__, $VERSION);\n\nmy %errstr;\n\nif( defined &getaddrinfo ) {\n    # These are not part of the API, nothing uses them, and deleting them\n    # reduces the size of %Socket:: by about 12K\n    delete $Socket::{fake_getaddrinfo};\n    delete $Socket::{fake_getnameinfo};\n} else {\n    require Scalar::Util;\n\n    *getaddrinfo = \\&fake_getaddrinfo;\n    *getnameinfo = \\&fake_getnameinfo;\n\n    # These numbers borrowed from GNU libc's implementation, but since\n    # they're only used by our emulation, it doesn't matter if the real\n    # platform's values differ\n    my %constants = (\n\tAI_PASSIVE     => 1,\n\tAI_CANONNAME   => 2,\n\tAI_NUMERICHOST => 4,\n\tAI_V4MAPPED    => 8,\n\tAI_ALL         => 16,\n\tAI_ADDRCONFIG  => 32,\n\t# RFC 2553 doesn't define this but Linux does - lets be nice and\n\t# provide it since we can\n\tAI_NUMERICSERV => 1024,\n\n\tEAI_BADFLAGS   => -1,\n\tEAI_NONAME     => -2,\n\tEAI_NODATA     => -5,\n\tEAI_FAMILY     => -6,\n\tEAI_SERVICE    => -8,\n\n\tNI_NUMERICHOST => 1,\n\tNI_NUMERICSERV => 2,\n\tNI_NOFQDN      => 4,\n\tNI_NAMEREQD    => 8,\n\tNI_DGRAM       => 16,\n\n\t# Constants we don't support. Export them, but croak if anyone tries to\n\t# use them\n\tAI_IDN                      => 64,\n\tAI_CANONIDN                 => 128,\n\tAI_IDN_ALLOW_UNASSIGNED     => 256,\n\tAI_IDN_USE_STD3_ASCII_RULES => 512,\n\tNI_IDN                      => 32,\n\tNI_IDN_ALLOW_UNASSIGNED     => 64,\n\tNI_IDN_USE_STD3_ASCII_RULES => 128,\n\n\t# Error constants we'll never return, so it doesn't matter what value\n\t# these have, nor that we don't provide strings for them\n\tEAI_SYSTEM   => -11,\n\tEAI_BADHINTS => -1000,\n\tEAI_PROTOCOL => -1001\n    );\n\n    foreach my $name ( keys %constants ) {\n\tmy $value = $constants{$name};\n\n\tno strict 'refs';\n\tdefined &$name or *$name = sub () { $value };\n    }\n\n    %errstr = (\n\t# These strings from RFC 2553\n\tEAI_BADFLAGS()   => \"invalid value for ai_flags\",\n\tEAI_NONAME()     => \"nodename nor servname provided, or not known\",\n\tEAI_NODATA()     => \"no address associated with nodename\",\n\tEAI_FAMILY()     => \"ai_family not supported\",\n\tEAI_SERVICE()    => \"servname not supported for ai_socktype\",\n    );\n}\n\n# The following functions are used if the system does not have a\n# getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET\n# family\n\n# Borrowed from Regexp::Common::net\nmy $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|1?[0-9][0-9]{1,2}/;\nmy $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL/;\n\nsub fake_makeerr\n{\n    my ( $errno ) = @_;\n    my $errstr = $errno == 0 ? \"\" : ( $errstr{$errno} || $errno );\n    return Scalar::Util::dualvar( $errno, $errstr );\n}\n\nsub fake_getaddrinfo\n{\n    my ( $node, $service, $hints ) = @_;\n\n    $node = \"\" unless defined $node;\n\n    $service = \"\" unless defined $service;\n\n    my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};\n\n    $family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too\n    $family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );\n\n    $socktype ||= 0;\n\n    $protocol ||= 0;\n\n    $flags ||= 0;\n\n    my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();\n    my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();\n    my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();\n    my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();\n\n    # These constants don't apply to AF_INET-only lookups, so we might as well\n    # just ignore them. For AI_ADDRCONFIG we just presume the host has ability\n    # to talk AF_INET. If not we'd have to return no addresses at all. :)\n    $flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());\n\n    $flags & (AI_IDN()|AI_CANONIDN()|AI_IDN_ALLOW_UNASSIGNED()|AI_IDN_USE_STD3_ASCII_RULES()) and\n\tcroak \"Socket::getaddrinfo() does not support IDN\";\n\n    $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );\n\n    $node eq \"\" and $service eq \"\" and return fake_makeerr( EAI_NONAME() );\n\n    my $canonname;\n    my @addrs;\n    if( $node ne \"\" ) {\n\treturn fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );\n\t( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );\n\tdefined $canonname or return fake_makeerr( EAI_NONAME() );\n\n\tundef $canonname unless $flag_canonname;\n    }\n    else {\n\t$addrs[0] = $flag_passive ? Socket::inet_aton( \"0.0.0.0\" )\n\t\t\t\t  : Socket::inet_aton( \"127.0.0.1\" );\n    }\n\n    my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]\n    my $protname = \"\";\n    if( $protocol ) {\n\t$protname = getprotobynumber( $protocol );\n    }\n\n    if( $service ne \"\" and $service !~ m/^\\d+$/ ) {\n\treturn fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );\n\tgetservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );\n    }\n\n    foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {\n\tnext if $socktype and $this_socktype != $socktype;\n\n\tmy $this_protname = \"raw\";\n\t$this_socktype == Socket::SOCK_STREAM() and $this_protname = \"tcp\";\n\t$this_socktype == Socket::SOCK_DGRAM()  and $this_protname = \"udp\";\n\n\tnext if $protname and $this_protname ne $protname;\n\n\tmy $port;\n\tif( $service ne \"\" ) {\n\t    if( $service =~ m/^\\d+$/ ) {\n\t\t$port = \"$service\";\n\t    }\n\t    else {\n\t\t(", 8192) = 8192
09:01:57.722309 brk(0x1faa000)          = 0x1faa000
09:01:57.722588 read(5, " undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );\n\t\tnext unless defined $port;\n\t    }\n\t}\n\telse {\n\t    $port = 0;\n\t}\n\n\tpush @ports, [ $this_socktype, scalar getprotobyname( $this_protname ) || 0, $port ];\n    }\n\n    my @ret;\n    foreach my $addr ( @addrs ) {\n\tforeach my $portspec ( @ports ) {\n\t    my ( $socktype, $protocol, $port ) = @$portspec;\n\t    push @ret, {\n\t\tfamily    => $family,\n\t\tsocktype  => $socktype,\n\t\tprotocol  => $protocol,\n\t\taddr      => Socket::pack_sockaddr_in( $port, $addr ),\n\t\tcanonname => undef,\n\t    };\n\t}\n    }\n\n    # Only supply canonname for the first result\n    if( defined $canonname ) {\n\t$ret[0]->{canonname} = $canonname;\n    }\n\n    return ( fake_makeerr( 0 ), @ret );\n}\n\nsub fake_getnameinfo\n{\n    my ( $addr, $flags, $xflags ) = @_;\n\n    my ( $port, $inetaddr );\n    eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }\n\tor return fake_makeerr( EAI_FAMILY() );\n\n    my $family = Socket::AF_INET();\n\n    $flags ||= 0;\n\n    my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();\n    my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();\n    my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();\n    my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();\n    my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();\n\n    $flags & (NI_IDN()|NI_IDN_ALLOW_UNASSIGNED()|NI_IDN_USE_STD3_ASCII_RULES()) and\n\tcroak \"Socket::getnameinfo() does not support IDN\";\n\n    $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );\n\n    $xflags ||= 0;\n\n    my $node;\n    if( $xflags & NIx_NOHOST ) {\n\t$node = undef;\n    }\n    elsif( $flag_numerichost ) {\n\t$node = Socket::inet_ntoa( $inetaddr );\n    }\n    else {\n\t$node = gethostbyaddr( $inetaddr, $family );\n\tif( !defined $node ) {\n\t    return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;\n\t    $node = Socket::inet_ntoa( $inetaddr );\n\t}\n\telsif( $flag_nofqdn ) {\n\t    my ( $shortname ) = split m/\\./, $node;\n\t    my ( $fqdn ) = gethostbyname $shortname;\n\t    $node = $shortname if defined $fqdn and $fqdn eq $node;\n\t}\n    }\n\n    my $service;\n    if( $xflags & NIx_NOSERV ) {\n\t$service = undef;\n    }\n    elsif( $flag_numericserv ) {\n\t$service = \"$port\";\n    }\n    else {\n\tmy $protname = $flag_dgram ? \"udp\" : \"\";\n\t$service = getservbyport( $port, $protname );\n\tif( !defined $service ) {\n\t    $service = \"$port\";\n\t}\n    }\n\n    return ( fake_makeerr( 0 ), $node, $service );\n}\n\n1;\n", 8192) = 2499
09:01:57.723063 read(5, "", 8192)       = 0
09:01:57.723129 close(5)                = 0
09:01:57.723325 stat("/usr/lib/perl5/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.723408 stat("/usr/lib/perl5/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=39256, ...}) = 0
09:01:57.723482 stat("/usr/lib/perl5/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.723561 open("/usr/lib/perl5/auto/Socket/Socket.so", O_RDONLY) = 5
09:01:57.723621 read(5, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\3002\0\0\0\0\0\0@\0\0\0\0\0\0\0\230\222\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324y\0\0\0\0\0\0\324y\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\200z\0\0\0\0\0\0\200z \0\0\0\0\0\200z \0\0\0\0\0000\27\0\0\0\0\0\0008\27\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0`\215\0\0\0\0\0\0`\215 \0\0\0\0\0`\215 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\340s\0\0\0\0\0\0\340s\0\0\0\0\0\0\340s\0\0\0\0\0\0\304\0\0\0\0\0\0\0\304\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\200z\0\0\0\0\0\0\200z \0\0\0\0\0\200z \0\0\0\0\0\200\25\0\0\0\0\0\0\200\25\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\311P\223\265b\356\325\340\334:BD\267\201Y\363\314\246p\357\0\0\0\0C\0\0\0R\0\0\0\0\0\0\0,\0\0\0005\0\0\0\0\0\0\0003\0\0\0\32\0\0\0\0\0\0\0#\0\0\0(\0\0\0H\0\0\0002\0\0\0<\0\0\0.\0\0\0\17\0\0\0\0\0\0\0009\0\0\0%\0\0\0\0\0\0\0006\0\0\0/\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0=\0\0\0\23\0\0\0Q\0\0\0A\0\0\0G\0\0\0\0\0\0\0D\0\0\0)\0\0\0M\0\0\0@\0\0\0;\0\0\0 \0\0\0\34\0\0\0008\0\0\0*\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0'\0\0\0!\0\0\0\16\0\0\0\7\0\0\0:\0\0\0\0\0\0\0I\0\0\0$\0\0\0001\0\0\0\35\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0J\0\0\0\21\0\0\0\"\0\0\0K\0\0\0\25\0\0\0F\0\0\0\0\0\0\0&\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.723768 fstat(5, {st_mode=S_IFREG|0644, st_size=39256, ...}) = 0
09:01:57.724047 mmap(NULL, 2134456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0x7f92d6221000
09:01:57.724090 mprotect(0x7f92d6229000, 2093056, PROT_NONE) = 0
09:01:57.724173 mmap(0x7f92d6428000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x7000) = 0x7f92d6428000
09:01:57.724250 close(5)                = 0
09:01:57.724328 mprotect(0x7f92d6428000, 8192, PROT_READ) = 0
09:01:57.724455 brk(0x1fcb000)          = 0x1fcb000
09:01:57.724863 stat("modules/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.724923 stat("modules/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.724994 stat("modules/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725053 stat("modules/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725097 stat("/etc/perl/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725141 stat("/etc/perl/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725185 stat("/usr/local/lib/perl/5.14.2/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725230 stat("/usr/local/lib/perl/5.14.2/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725278 stat("/usr/local/share/perl/5.14.2/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725324 stat("/usr/local/share/perl/5.14.2/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725387 stat("/usr/lib/perl5/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725446 stat("/usr/lib/perl5/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725505 stat("/usr/share/perl5/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725551 stat("/usr/share/perl5/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725619 stat("/usr/lib/perl/5.14/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725686 stat("/usr/lib/perl/5.14/bytes.pm", 0x7ffc53d0b530) = -1 ENOENT (No such file or directory)
09:01:57.725753 stat("/usr/share/perl/5.14/bytes.pmc", 0x7ffc53d0b5e0) = -1 ENOENT (No such file or directory)
09:01:57.725816 stat("/usr/share/perl/5.14/bytes.pm", {st_mode=S_IFREG|0644, st_size=447, ...}) = 0
09:01:57.725889 open("/usr/share/perl/5.14/bytes.pm", O_RDONLY) = 5
09:01:57.725955 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffc53d0b2c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.726016 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.726112 read(5, "package bytes;\n\nour $VERSION = '1.04';\n\n$bytes::hint_bits = 0x00000008;\n\nsub import {\n    $^H |= $bytes::hint_bits;\n}\n\nsub unimport {\n    $^H &= ~$bytes::hint_bits;\n}\n\nsub AUTOLOAD {\n    require \"bytes_heavy.pl\";\n    goto &$AUTOLOAD if defined &$AUTOLOAD;\n    require Carp;\n    Carp::croak(\"Undefined subroutine $AUTOLOAD called\");\n}\n\nsub length (_);\nsub chr (_);\nsub ord (_);\nsub substr ($$;$$);\nsub index ($$;$);\nsub rindex ($$;$);\n\n1;\n__END__\n\n", 8192) = 447
09:01:57.726292 lseek(5, 446, SEEK_SET) = 446
09:01:57.726361 lseek(5, 0, SEEK_CUR)   = 446
09:01:57.726420 close(5)                = 0
09:01:57.726608 lseek(4, 1054, SEEK_SET) = 1054
09:01:57.726664 lseek(4, 0, SEEK_CUR)   = 1054
09:01:57.726712 close(4)                = 0
09:01:57.727142 close(3)                = 0
09:01:57.727246 read(0, 09:02:12.968759 +++ killed by SIGKILL +++
