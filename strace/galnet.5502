09:01:56.831980 execve("./urltest.pl", ["./urltest.pl", "https://community.elitedangerous.com/galnet/uid/56a60d089657ba197a730a88"], [/* 39 vars */]) = 0
09:01:56.832556 brk(0)                  = 0x65f000
09:01:56.832652 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.832751 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f38000
09:01:56.832836 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
09:01:56.832916 open("/etc/ld.so.cache", O_RDONLY) = 3
09:01:56.832985 fstat(3, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:56.833057 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7436f1f000
09:01:56.833110 close(3)                = 0
09:01:56.833181 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.833254 open("/usr/lib/libperl.so.5.14", O_RDONLY) = 3
09:01:56.833318 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@@\3\0\0\0\0\0@\0\0\0\0\0\0\0\30\0\30\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324m\27\0\0\0\0\0\324m\27\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0t\27\0\0\0\0\0\0t7\0\0\0\0\0\0t7\0\0\0\0\0\4\213\0\0\0\0\0\0(\215\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320\250\27\0\0\0\0\0\320\2507\0\0\0\0\0\320\2507\0\0\0\0\0 \2\0\0\0\0\0\0 \2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\0\365\25\0\0\0\0\0\0\365\25\0\0\0\0\0\0\365\25\0\0\0\0\0\\8\0\0\0\0\0\0\\8\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\0t\27\0\0\0\0\0\0t7\0\0\0\0\0\0t7\0\0\0\0\0\0<\0\0\0\0\0\0\0<\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\216\256)\302R\327\341k\275\330\277$\3\25\377GQ\372\236\214\0\0\0\0\7\4\0\0\244\7\0\0>\6\0\0$\7\0\0h\6\0\0\0\5\0\0@\7\0\0-\5\0\0\7\2\0\0\30\4\0\0\237\2\0\0|\0\0\0\234\2\0\0\0\0\0\0\370\2\0\0\336\0\0\0\0\0\0\0008\6\0\0\216\0\0\0\0\0\0\0\330\4\0\0\250\1\0\0\0\0\0\0\200\0\0\0S\6\0\0\374\1\0\0)\2\0\0\4\4\0\0E\7\0\0'\5\0\0006\1\0\0\37\3\0\0\216\6\0\0\0\0\0\0007\2\0\0\314\2\0\0\220\4\0\0\0\0\0\0\315\3\0\0~\7\0\0\0\0\0\0\377\6\0\0\v\4\0\0\0\0\0\0\327\0\0\0009\5\0\0G\2\0\0l\3\0\0z\2\0\0\0\0\0\0'\4\0\0i\0\0\0\365\6\0\0\304\4\0\0\221\7\0\0\351\2\0\0(\5\0\0`\7\0\0\215\6\0\0\363\0\0\0\277\4\0\0\222\3\0\0\251\3\0\0\246\6\0\0Q\2\0\0\37\5\0\0\20\6\0\0\264\6\0\0\0\0\0\0I\2\0\0\353\2\0\0\224\6\0\0P\4\0\0\310\0\0\0\242\7\0\0\33\6\0\0\233\6\0\0\22\1\0\0V\5\0\0D\6\0\0\260\0\0\0\312\6\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.833630 fstat(3, {st_mode=S_IFREG|0644, st_size=1574680, ...}) = 0
09:01:56.833754 mmap(NULL, 3670312, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f743699a000
09:01:56.833827 mprotect(0x7f7436b11000, 2097152, PROT_NONE) = 0
09:01:56.833899 mmap(0x7f7436d11000, 36864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x177000) = 0x7f7436d11000
09:01:56.833988 mmap(0x7f7436d1a000, 296, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7436d1a000
09:01:56.834151 close(3)                = 0
09:01:56.834218 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.834292 open("/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY) = 3
09:01:56.834372 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340\r\0\0\0\0\0\0@\0\0\0\0\0\0\0\2601\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0 \0\37\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\260\31\0\0\0\0\0\0\260\31\0\0\0\0\0\0\260\31\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\250\36\0\0\0\0\0\0\250\36\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0H-\0\0\0\0\0\0H- \0\0\0\0\0H- \0\0\0\0\0008\3\0\0\0\0\0\0\270\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\200-\0\0\0\0\0\0\200- \0\0\0\0\0\200- \0\0\0\0\0\20\2\0\0\0\0\0\0\20\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\314\31\0\0\0\0\0\0\314\31\0\0\0\0\0\0\314\31\0\0\0\0\0\0\274\0\0\0\0\0\0\0\274\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0H-\0\0\0\0\0\0H- \0\0\0\0\0H- \0\0\0\0\0\270\2\0\0\0\0\0\0\270\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0]\34\243\243\331>\325\266\306F/\372\3\347\207\375\276@\23\243\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\31\0\0\0\2\0\0\0\7\0\0\0\230\2\21\0\200H\0\4\22\0\0@\203(\10\236\31\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0$\0\0\0%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\353\26\251\30a\257\0\371\301S\200\30\273\25sB\257\304M\17\221!\374\370\6\2\4\371\3733\373\17\371\31sB\372\31sB\225\263_\31\177\236\320\30a\242\222\6", 832) = 832
09:01:56.834724 fstat(3, {st_mode=S_IFREG|0644, st_size=14768, ...}) = 0
09:01:56.834817 mmap(NULL, 2109696, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7436796000
09:01:56.834888 mprotect(0x7f7436798000, 2097152, PROT_NONE) = 0
09:01:56.834965 mmap(0x7f7436998000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f7436998000
09:01:56.835060 close(3)                = 0
09:01:56.835133 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.835209 open("/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY) = 3
09:01:56.835288 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360>\0\0\0\0\0\0@\0\0\0\0\0\0\0\260\21\10\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\220\272\7\0\0\0\0\0\220\272\7\0\0\0\0\0\220\272\7\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\24\n\10\0\0\0\0\0\24\n\10\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\300\r\10\0\0\0\0\0\300\r(\0\0\0\0\0\300\r(\0\0\0\0\0\330\2\0\0\0\0\0\0(\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\350\r\10\0\0\0\0\0\350\r(\0\0\0\0\0\350\r(\0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\254\272\7\0\0\0\0\0\254\272\7\0\0\0\0\0\254\272\7\0\0\0\0\0|\16\0\0\0\0\0\0|\16\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\300\r\10\0\0\0\0\0\300\r(\0\0\0\0\0\300\r(\0\0\0\0\0@\2\0\0\0\0\0\0@\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\177X\326fEq\224\34\206\262\331ip\32W*\324\327\277\35\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0i\2\0\0\20\0\0\0 \0\0\0\v\0\0\0%\0 \303\t\224g\r\0H\20 \4\243ER\202\24\200 \0y\210\272\10\0A\0\0\10\10\0\31\4\3\0\2\0\232U0A\20\0\0\200\244\322\20\1@\232\242\20\304aR\220\10\6\206\0\232\10\7\300 \10\200\240\0\242@\30\201\4E\207\0054\351\0\0\10!C\30\3000\0103\30\24M8\"\0R\224\21@\4\3\2e\t\0\1\204\fY\20 \10\2\0\0\200@\0$\214\5\10\0\0\0\0\1\0\242\1 \t\24E \325\241\10\273o\220\"@\236\1\10\4\200\200\0\4\200PLG\242\0\200\201 B\220 \0201*@\t\242 \0A\10\0", 832) = 832
09:01:56.835613 fstat(3, {st_mode=S_IFREG|0644, st_size=530736, ...}) = 0
09:01:56.835695 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f1e000
09:01:56.835772 mmap(NULL, 2625768, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7436514000
09:01:56.835871 mprotect(0x7f7436595000, 2093056, PROT_NONE) = 0
09:01:56.835930 mmap(0x7f7436794000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x80000) = 0x7f7436794000
09:01:56.836006 close(3)                = 0
09:01:56.836067 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.836148 open("/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY) = 3
09:01:56.836242 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\\\0\0\0\0\0\0@\0\0\0\0\0\0\0\320s\1\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0#\0 \0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4j\1\0\0\0\0\0\4j\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\240k\1\0\0\0\0\0\240k!\0\0\0\0\0\240k!\0\0\0\0\0\320\6\0\0\0\0\0\0\0H\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\210m\1\0\0\0\0\0\210m!\0\0\0\0\0\210m!\0\0\0\0\0\360\1\0\0\0\0\0\0\360\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0<\n\0\0\0\0\0\0<\n\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\240k\1\0\0\0\0\0\240k!\0\0\0\0\0\240k!\0\0\0\0\0`\4\0\0\0\0\0\0`\4\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\376\362\201!\207\227\255j\347&\335_\316\336\312\335\236\237Q\334\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\345\1\0\0O\0\0\0 \0\0\0\v\0\0\0\31#\2\261\1\10\20\2@@a\370\3\10\10\25\200 \0\0\0\0\200\300\321Q\0\0\0\22\353\3020D\0\10\20A\0\2\0\2\f\1\200\v\221\1\330\240\r\240@\230 \244\200\21\n\202-l@g\214V\24\0\224 \200$H\200P(\1\22\f\311B\240\220\22\10\f \2ZdA\245c\4@\n\n\2\0\2009\1(\314@\204\201@\22\10(\fD\0\0\0\200Q\10\200\35\4B\320\2608A\0\1\0\0\265\0300\0\200`\2\20\"\0\tA\20\1\5\0P \251\2\7(\0\0\202\4\230@\4\0\20\340T\0\2@\2\2\20\3010D\26\200\0", 832) = 832
09:01:56.836567 fstat(3, {st_mode=S_IFREG|0755, st_size=131107, ...}) = 0
09:01:56.836650 mmap(NULL, 2208672, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f74362f8000
09:01:56.836718 mprotect(0x7f743630f000, 2093056, PROT_NONE) = 0
09:01:56.836785 mmap(0x7f743650e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16000) = 0x7f743650e000
09:01:56.836873 mmap(0x7f7436510000, 13216, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7436510000
09:01:56.836960 close(3)                = 0
09:01:56.837036 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.837119 open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY) = 3
09:01:56.837202 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\357\1\0\0\0\0\0@\0\0\0\0\0\0\0P_\30\0\0\0\0\0\0\0\0\0@\0008\0\n\0@\0#\0\"\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0000e\25\0\0\0\0\0000e\25\0\0\0\0\0000e\25\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\n\30\0\0\0\0\0T\n\30\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\220F\0\0\0\0\0\0\20\221\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0@K\30\0\0\0\0\0@K8\0\0\0\0\0@K8\0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\7\0\0\0\4\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\20\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0P\345td\4\0\0\0Le\25\0\0\0\0\0Le\25\0\0\0\0\0Le\25\0\0\0\0\0,h\0\0\0\0\0\0,h\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0(\27\30\0\0\0\0\0(\0278\0\0\0\0\0(\0278\0\0\0\0\0\3308\0\0\0\0\0\0\3308\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\247E\353\242\301k\250\n\341\357\32z{pt\f,\361\263c\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\363\3\0\0\t\0\0\0\0\1\0\0\16\0\0\0\0000\20D\240 \2\1\210\3\346\220\305E\214\0\300\0\10\0\5\200\0`\300\200\0\r\212\f\0\4\20\0\210D2\10.@\210P4, \16\"H&\204\300\214\4\10\0\2\2\16\241\254\32\4f\300\0\3002\0\300\0P\1 \201\10\204\v  ($\0\4 P\0\20X\200\312DB(\0\6\200\20\30B\0 @\200\0\tP\0Q\212@\20\0\0\0\0\10\0\0\21\20", 832) = 832
09:01:56.837500 fstat(3, {st_mode=S_IFREG|0755, st_size=1599504, ...}) = 0
09:01:56.837591 mmap(NULL, 3713080, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7435f6d000
09:01:56.837673 mprotect(0x7f74360ee000, 2097152, PROT_NONE) = 0
09:01:56.837746 mmap(0x7f74362ee000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x181000) = 0x7f74362ee000
09:01:56.837833 mmap(0x7f74362f3000, 18488, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f74362f3000
09:01:56.837919 close(3)                = 0
09:01:56.837995 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.838125 open("/lib/x86_64-linux-gnu/libcrypt.so.1", O_RDONLY) = 3
09:01:56.838193 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\n\0\0\0\0\0\0@\0\0\0\0\0\0\0\240\201\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0 v\0\0\0\0\0\0 v\0\0\0\0\0\0 v\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\230}\0\0\0\0\0\0\230}\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\320}\0\0\0\0\0\0\320} \0\0\0\0\0\320} \0\0\0\0\0\260\2\0\0\0\0\0\0\360\343\2\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\370}\0\0\0\0\0\0\370} \0\0\0\0\0\370} \0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0<v\0\0\0\0\0\0<v\0\0\0\0\0\0<v\0\0\0\0\0\0$\1\0\0\0\0\0\0$\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\320}\0\0\0\0\0\0\320} \0\0\0\0\0\320} \0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0Nn\35\213\16>\360\260\326A\352\263%\345v\331}ZF\v\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\17\0\0\0\23\0\0\0\1\0\0\0\6\0\0\0\4I\300,$\204 \f\0\0\0\0\0\0\0\0\0\0\0\0\23\0\0\0\24\0\0\0\25\0\0\0\0\0\0\0\26\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\31\0\0\0\32\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\273\25sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\v\0008\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.838498 fstat(3, {st_mode=S_IFREG|0644, st_size=35104, ...}) = 0
09:01:56.838579 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f1d000
09:01:56.838657 mmap(NULL, 2318784, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7435d36000
09:01:56.838725 mprotect(0x7f7435d3e000, 2093056, PROT_NONE) = 0
09:01:56.838796 mmap(0x7f7435f3d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x7000) = 0x7f7435f3d000
09:01:56.838881 mmap(0x7f7435f3f000, 184768, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7435f3f000
09:01:56.838966 close(3)                = 0
09:01:56.839078 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f1c000
09:01:56.839158 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f1b000
09:01:56.839229 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f1a000
09:01:56.839302 arch_prctl(ARCH_SET_FS, 0x7f7436f1b700) = 0
09:01:56.839391 mprotect(0x7f7435f3d000, 4096, PROT_READ) = 0
09:01:56.839596 mprotect(0x7f74362ee000, 16384, PROT_READ) = 0
09:01:56.839693 mprotect(0x7f743650e000, 4096, PROT_READ) = 0
09:01:56.839778 mprotect(0x7f7436794000, 4096, PROT_READ) = 0
09:01:56.839856 mprotect(0x7f7436998000, 4096, PROT_READ) = 0
09:01:56.840268 mprotect(0x7f7436d11000, 16384, PROT_READ) = 0
09:01:56.840370 mprotect(0x601000, 4096, PROT_READ) = 0
09:01:56.840447 mprotect(0x7f7436f3a000, 4096, PROT_READ) = 0
09:01:56.840512 munmap(0x7f7436f1f000, 98904) = 0
09:01:56.840593 set_tid_address(0x7f7436f1b9d0) = 5502
09:01:56.840652 set_robust_list(0x7f7436f1b9e0, 0x18) = 0
09:01:56.840708 futex(0x7ffe1233cb6c, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, 7f7436f1b700) = -1 EAGAIN (Resource temporarily unavailable)
09:01:56.840800 rt_sigaction(SIGRTMIN, {0x7f74362fdad0, [], SA_RESTORER|SA_SIGINFO, 0x7f74363070a0}, NULL, 8) = 0
09:01:56.840893 rt_sigaction(SIGRT_1, {0x7f74362fdb60, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7f74363070a0}, NULL, 8) = 0
09:01:56.840970 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
09:01:56.841052 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=8192*1024}) = 0
09:01:56.841243 rt_sigaction(SIGFPE, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0x7f7435f9f1e0}, {SIG_DFL, [], 0}, 8) = 0
09:01:56.841405 brk(0)                  = 0x65f000
09:01:56.841479 brk(0x680000)           = 0x680000
09:01:56.841724 getuid()                = 1000
09:01:56.841775 geteuid()               = 1000
09:01:56.841817 getgid()                = 1000
09:01:56.841857 getegid()               = 1000
09:01:56.841964 open("/usr/lib/locale/locale-archive", O_RDONLY) = 3
09:01:56.842096 fstat(3, {st_mode=S_IFREG|0644, st_size=2051648, ...}) = 0
09:01:56.842173 mmap(NULL, 2051648, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7435b41000
09:01:56.842229 close(3)                = 0
09:01:56.842465 open("/dev/urandom", O_RDONLY) = 3
09:01:56.842559 read(3, "\317\356\v\367", 4) = 4
09:01:56.842634 close(3)                = 0
09:01:56.842968 stat("modules/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843034 stat("modules/5.14.2", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843083 stat("modules/x86_64-linux-gnu-thread-multi", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843150 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
09:01:56.843318 stat("/usr/local/lib/site_perl/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843405 stat("/usr/local/lib/site_perl/5.14.2", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843475 stat("/usr/local/lib/site_perl/x86_64-linux-gnu-thread-multi", 0x7ffe1233c800) = -1 ENOENT (No such file or directory)
09:01:56.843624 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0
09:01:56.843727 lseek(0, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:56.843802 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0
09:01:56.843882 lseek(1, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:56.843929 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0
09:01:56.843977 lseek(2, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:56.844022 open("./urltest.pl", O_RDONLY) = 3
09:01:56.844074 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c6a0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.844118 lseek(3, 0, SEEK_CUR)   = 0
09:01:56.844192 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:56.844256 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
09:01:56.844504 brk(0x6a1000)           = 0x6a1000
09:01:56.844930 read(3, "#!/usr/bin/perl -w -Imodules\n# vim: textwidth=0 wrapmargin=0 shiftwidth=2 tabstop=2 expandtab\n\nuse strict;\nuse POE;\nuse POE::Component::IRC;\nuse MiggyIRCBot::ConfigFile;\nuse MiggyIRCBot::URLParse;\nuse POSIX qw/strftime/;\nuse Data::Dumper;\n\nmy $config = MiggyIRCBot::ConfigFile->new(file => \"bot-config.txt\");\nif (!defined($config)) {\n  die \"No config!\";\n}\n\nmy $irc = POE::Component::IRC->spawn();\n\nPOE::Session->create(\n  package_states => [\n    main => [ qw( _default _start irc_001\n      irc_miggybot_url_success irc_miggybot_url_error\n\n      ) ]\n  ],\n  inline_states => {\n  }\n);\n\n$poe_kernel->run();\n\nsub _start {\n  my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];\n\n  $irc->plugin_add('MiggyIRCBotURLParse',\n    MiggyIRCBot::URLParse->new(\n            youtube_api_key => $config->getconf('youtube_api_key'),\n            imgur_clientid => $config->getconf('imgur_clientid'),\n            imgur_clientsecret => $config->getconf('imgur_clientsecret')\n    )\n  );\n\n  $kernel->yield('get_url', { _channel => \"#test\", session => $session, quiet => 0, url => $ARGV[0] } );\n}\n\nsub irc_001 {\n  my ($kernel, $sender) = @_[KERNEL, SENDER];\n  my $irc = $_[SENDER]->get_heap();\n\n  print \" irc_001:\\n\";\n\n  # Set mode +x\n  print \" Attempt to set usermode +x\\n\";\n  $irc->yield('mode', $config->getconf('nickname') . \" +x\");\n\n  return;\n}\n\n###########################################################################\n# URL Parsing\n###########################################################################\nsub irc_miggybot_url_success {\n  my ($kernel,$sender,$args,$title) = @_[KERNEL,SENDER,ARG0,ARG1];\n  my $channel = delete $args->{_channel};\n\n#printf STDERR \"irc_miggybot_url_success:\\n\";\n  if (defined($_[ARG1]) and $_[ARG1] ne \"\" and $args->{quiet} == 0) {\n    my $blurb = $_[ARG1];\n    print $blurb, \"\\n\";\n  }\n  exit(0);\n}\n\nsub irc_miggybot_url_error {\n  my ($kernel, $sender, $args, $error) = @_[KERNEL, SENDER, ARG0, ARG1];\n  my $channel = delete $args->{_channel};\n\nmylog(\"irc_miggybot_url_error...\");\n  print $error, \"\\n\";\n  exit(0);\n}\n###########################################################################\n\nsub _default {\n    my ($event, $args) = @_[ARG0 .. $#_];\n    my @output = ( \"$event: \" );\n\n    for my $arg (@$args) {\n        if ( ref $arg eq 'ARRAY' ) {\n            push( @output, '[' . join(', ', @$arg ) . ']' );\n        } elsif (defined($arg)) {\n            push ( @output, \"'$arg'\" );\n        }\n    }\n    mylog(join ' ', @output);\n    return;\n}\n\nsub mylog {\n  printf STDERR \"%s - %s\\n\", strftime(\"%Y-%m-%d %H:%M:%S UTC\", gmtime()), @_;\n}\n", 8192) = 2560
09:01:56.845350 stat("modules/5.14.2/x86_64-linux-gnu-thread-multi", 0x7ffe1233c110) = -1 ENOENT (No such file or directory)
09:01:56.845427 stat("modules/5.14.2", 0x7ffe1233c110) = -1 ENOENT (No such file or directory)
09:01:56.845496 stat("modules/x86_64-linux-gnu-thread-multi", 0x7ffe1233c110) = -1 ENOENT (No such file or directory)
09:01:56.845756 stat("modules/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.845829 stat("modules/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.845890 stat("modules/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.845946 stat("modules/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846005 stat("/etc/perl/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846132 stat("/etc/perl/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846190 stat("/usr/local/lib/perl/5.14.2/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846243 stat("/usr/local/lib/perl/5.14.2/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846295 stat("/usr/local/share/perl/5.14.2/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846364 stat("/usr/local/share/perl/5.14.2/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846430 stat("/usr/lib/perl5/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846492 stat("/usr/lib/perl5/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846556 stat("/usr/share/perl5/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846616 stat("/usr/share/perl5/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846676 stat("/usr/lib/perl/5.14/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846740 stat("/usr/lib/perl/5.14/strict.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.846803 stat("/usr/share/perl/5.14/strict.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.846885 stat("/usr/share/perl/5.14/strict.pm", {st_mode=S_IFREG|0644, st_size=879, ...}) = 0
09:01:56.846969 open("/usr/share/perl/5.14/strict.pm", O_RDONLY) = 4
09:01:56.847038 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bfa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.847092 lseek(4, 0, SEEK_CUR)   = 0
09:01:56.847206 read(4, "package strict;\n\n$strict::VERSION = \"1.04\";\n\n# Verify that we're called correctly so that strictures will work.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    # Can't use Carp, since Carp uses us!\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown 'strict' tag(s) '@wrong'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 8192) = 879
09:01:56.847890 lseek(4, 878, SEEK_SET) = 878
09:01:56.847943 lseek(4, 0, SEEK_CUR)   = 878
09:01:56.847984 close(4)                = 0
09:01:56.848312 stat("modules/POE.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.848386 stat("modules/POE.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.848449 stat("modules/POE.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.848505 stat("modules/POE.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.848564 stat("/etc/perl/POE.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.848622 stat("/etc/perl/POE.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.848683 stat("/usr/local/lib/perl/5.14.2/POE.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.848745 stat("/usr/local/lib/perl/5.14.2/POE.pm", 0x7ffe1233c210) = -1 ENOENT (No such file or directory)
09:01:56.848809 stat("/usr/local/share/perl/5.14.2/POE.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:56.848869 stat("/usr/local/share/perl/5.14.2/POE.pm", {st_mode=S_IFREG|0444, st_size=26682, ...}) = 0
09:01:56.848951 open("/usr/local/share/perl/5.14.2/POE.pm", O_RDONLY) = 4
09:01:56.849020 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bfa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.849074 lseek(4, 0, SEEK_CUR)   = 0
09:01:56.849186 read(4, "# Copyrights and documentation are after __END__.\n\npackage POE;\n\nuse strict;\nuse Carp qw( croak );\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse POE::Resource::Clock qw( monotime time walltime sleep mono2wall wall2mono );\n\nsub import {\n  my $self = shift;\n\n  my @loops    = grep(/^(?:XS::)?Loop::/, @_);\n  my @sessions = grep(/^(Session|NFA)$/, @_);\n  my @modules  = grep(!/^(Kernel|Session|NFA|(?:XS::)?Loop::[\\w:]+)$/, @_);\n\n  croak \"can't use multiple event loops at once\"\n    if (@loops > 1);\n  croak \"POE::Session and POE::NFA export conflicting constants\"\n    if scalar @sessions > 1;\n\n  # If a session was specified, use that.  Otherwise use Session.\n  if (@sessions) {\n    unshift @modules, @sessions;\n  }\n  else {\n    unshift @modules, 'Session';\n  }\n\n  my $package = caller();\n  my @failed;\n\n  # Load POE::Kernel in the caller's package.  This is separate\n  # because we need to push POE::Loop classes through POE::Kernel's\n  # import().\n\n  {\n    my $loop = \"\";\n    if (@loops) {\n      $loop = \"{ loop => '\" . shift (@loops) . \"' }\";\n    }\n    my $code = \"package $package; use POE::Kernel $loop;\";\n    # warn $code;\n    eval $code;\n    if ($@) {\n      warn $@;\n      push @failed, \"Kernel\"\n    }\n  }\n\n  # Load all the others.\n\n  foreach my $module (@modules) {\n    my $code = \"package $package; use POE::$module;\";\n    # warn $code;\n    eval($code);\n    if ($@) {\n      warn $@;\n      push(@failed, $module);\n    }\n  }\n\n  @failed and croak \"could not import qw(\" . join(' ', @failed) . \")\";\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE - portable multitasking and networking framework for any event loop\n\n=head1 SYNOPSIS\n\n  #!/usr/bin/perl -w\n  use strict;\n\n  use POE;  # Auto-includes POE::Kernel and POE::Session.\n\n  sub handler_start {\n    my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];\n    print \"Session \", $session->ID, \" has started.\\n\";\n    $heap->{count} = 0;\n    $kernel->yield('increment');\n  }\n\n  sub handler_increment {\n    my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];\n    print \"Session \", $session->ID, \" counted to \", ++$heap->{count}, \".\\n\";\n    $kernel->yield('increment') if $heap->{count} < 10;\n  }\n\n  sub handler_stop {\n    print \"Session \", $_[SESSION]->ID, \" has stopped.\\n\";\n  }\n\n  for (1..10) {\n    POE::Session->create(\n      inline_states => {\n        _start    => \\&handler_start,\n        increment => \\&handler_increment,\n        _stop     => \\&handler_stop,\n      }\n    );\n  }\n\n  POE::Kernel->run();\n  exit;\n\n=head1 DESCRIPTION\n\nPOE is a framework for cooperative, event driven multitasking and\nnetworking in Perl.  Other languages have similar frameworks.  Python\nhas Twisted.  TCL has \"the event loop\".\n\nPOE provides a unified interface for several other event loops,\nincluding select(), L<IO::Poll|IO::Poll>, L<Glib>, L<Gtk>, L<Tk>,\nL<Wx>, and L<Gtk2>.  Many of these event loop interfaces were written\nby others, with the help of POE::Test::Loops.  They may be found on\nthe CPAN.\n\nPOE achieves its high degree of portability to different operating\nsystems and Perl versions by being written entirely in Perl.  CPAN\nhosts optional XS modules for POE if speed is more desirable than\nportability.\n\nPOE is designed in layers.  Each layer builds atop the lower level\nones.  Programs are free to use POE at any level of abstraction, and\ndifferent levels can be mixed and matched seamlessly within a single\nprogram.  Remember, though, that higher-level abstractions often\nrequire more resources than lower-level ones.  The conveniences they\nprovide are not free.\n\nPOE's bundled abstraction layers are the tip of a growing iceberg.\nL<Sprocket>, L<POE::Stage|POE::Stage>, and other CPAN distributions\nbuild upon this work.  You're encouraged to look around.\n\nNo matter how high you go, though, it all boils down to calls to\nL<POE::Kernel|POE::Kernel>.  So your down-to-earth code can easily\ncooperate with stratospheric systems.\n\n=head2 Layer 1: Kernel and Sessions\n\nThe lowest public layer is comprised of L<POE::Kernel|POE::Kernel>,\nL<POE::Session|POE::Session>, and other session types.\n\nL<POE::Kernel|POE::Kernel> does most of the heavy lifting.  It provides a portable\ninterface for filehandle activity detection, multiple alarms and other\ntimers, signal handling, and other less-common features.\n\nL<POE::Session|POE::Session> and derived classes encapsulate the notion of an event\ndriven task.  They also customize event dispatch to a particular\ncalling convention.  L<POE::NFA|POE::NFA>, for example, is more of a proper state\nmachine.  The CPAN has several other kinds of sessions.\n\nEverything ultimately builds on these classes or the concepts they\nimplement.  If you're short on time, the things to read besides this\nare L<POE::Kernel|POE::Kernel> and L<POE::Session|POE::Session>.\n\n=head2 Layer 2: Wheels, Filters, and Drivers\n\nPOE::Wheel objects are dynamic mix-ins for POE::Session instances. These\n\"wheels\" perform very common, generic tasks in a highly reusable and\ncustomizable way.  L<POE::Wheel::ReadWrite|POE::Wheel::ReadWrite>, for\nexample, implements non-blocking buffered I/O.  Nearly everybody needs this,\nso why require people to reinvent it all the time?\n\nL<POE::Filter|POE::Filter> objects customize wheels in a modular way.  Filters act as\nI/O layers, turning raw streams into structured data, and serializing\nstructures into something suitable for streams.  The CPAN also has several\nof these.\n\nDrivers are where the wheels meet the road.  In this case, the road is\nsome type of file handle.  Drivers do the actual reading and writing\nin a standard way so wheels don't need to know the difference between\nsend() and syswrite().\n\nL<POE::Driver|POE::Driver> objects get relatively short shrift because very few are\nneeded.  The most common driver, L<POE::Driver::SysRW|POE::Driver::SysRW> is ubiquitous and\nalso the default, so most people will never need to specify one.\n\n=head2 Layer 3: Components\n\nL<POE::Component|POE::Component> classes are essentially Perl classes that use POE to\nperform tasks in a non-blocking or cooperative way.  This is a very\nbroad definition, and POE components are all over the abstraction map.\n\nMany components, such as L<POE::Component::Server::SMTP|POE::Component::Server::SMTP>, encapsulate the\ngeneric details of an entire application.  Others perform rather\nnarrow tasks, such as L<POE::Component::DirWatch::Object|POE::Component::DirWatch::Object>.\n\nPOE components are often just plain Perl objects.  The previously\nmentioned L<POE::Component::DirWatch::Object|POE::Component::DirWatch::Object> uses L<Moose|Moose>.  Other object\nand meta-object frameworks are compatible.\n\nAlso of interest is L<POE::Component::Generic|POE::Component::Generic>, which allows you to create\na POE component from nearly any blocking module.\n\nThere are quite a lot of components on the CPAN.  \nL<http://search.cpan.org/search?query=poe+component&mode=all>\n\n=head2 Layer 4 and Beyond: Frameworks and Object Metaphors\n\nIt's possible to abstract POE entirely behind a different framework.\nIn fact we encourage people to write domain-specific abstractions that\nentirely hide POE if necessary.  The nice thing here is that even at\nthese high levels of abstraction, things will continue to interoperate\nall the way down to layer 1.\n\nTwo examples of ultra-high level abstraction are L<Sprocket>, a networking\nframework that does its own thing, and L<POE::Stage|POE::Stage>, which is POE's\ncreator's attempt to formalize and standardize POE components.\n\nIt is also possible to communicate between POE processes.  This is called\nIKC, for I<Inter-Kernel Communication>.  There are a few IKC components on\nthe CPAN (L<http://search.cpan.org/search?query=IKC&mode=all>), notably\nL<POE::Component::IKC|POE::Component::IKC> and L<POE::TIKC|POE::TIKC>.\n\n=head2 Layer 0: POE's Internals\n\nPOE's layered architecture continues below the surface.  POE's guts\nare broken into specific L<POE::Loop|POE::Loop> classes for each event\nloop it supports.  Internals are divided up by type, giving\nL<POE::Resource|POE::Resource> classes for Aliases, Controls, Events,\nExtrefs, FileHandles, SIDs, Sessions and Signals.\n\nPOE::Kernel's APIs are extensible through POE::API mix-", 8192) = 8192
09:01:56.850292 stat("modules/Carp.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.850371 stat("modules/Carp.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.850435 stat("modules/Carp.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.850492 stat("modules/Carp.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.850551 stat("/etc/perl/Carp.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.850608 stat("/etc/perl/Carp.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.850668 stat("/usr/local/lib/perl/5.14.2/Carp.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.850730 stat("/usr/local/lib/perl/5.14.2/Carp.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.850793 stat("/usr/local/share/perl/5.14.2/Carp.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.850854 stat("/usr/local/share/perl/5.14.2/Carp.pm", {st_mode=S_IFREG|0444, st_size=30436, ...}) = 0
09:01:56.850962 open("/usr/local/share/perl/5.14.2/Carp.pm", O_RDONLY) = 5
09:01:56.851021 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.851065 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.851136 read(5, "package Carp;\n\n{ use 5.006; }\nuse strict;\nuse warnings;\nBEGIN {\n    # Very old versions of warnings.pm load Carp.  This can go wrong due\n    # to the circular dependency.  If warnings is invoked before Carp,\n    # then warnings starts by loading Carp, then Carp (above) tries to\n    # invoke warnings, and gets nothing because warnings is in the process\n    # of loading and hasn't defined its import method yet.  If we were\n    # only turning on warnings (\"use warnings\" above) this wouldn't be too\n    # bad, because Carp would just gets the state of the -w switch and so\n    # might not get some warnings that it wanted.  The real problem is\n    # that we then want to turn off Unicode warnings, but \"no warnings\n    # 'utf8'\" won't be effective if we're in this circular-dependency\n    # situation.  So, if warnings.pm is an affected version, we turn\n    # off all warnings ourselves by directly setting ${^WARNING_BITS}.\n    # On unaffected versions, we turn off just Unicode warnings, via\n    # the proper API.\n    if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {\n\t${^WARNING_BITS} = \"\";\n    } else {\n\t\"warnings\"->unimport(\"utf8\");\n    }\n}\n\nsub _fetch_sub { # fetch sub without autovivifying\n    my($pack, $sub) = @_;\n    $pack .= '::';\n    # only works with top-level packages\n    return unless exists($::{$pack});\n    for ($::{$pack}) {\n\treturn unless ref \\$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};\n\tfor ($$_{$sub}) {\n\t    return ref \\$_ eq 'GLOB' ? *$_{CODE} : undef\n\t}\n    }\n}\n\n# UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp\n# must avoid applying a regular expression to an upgraded (is_utf8)\n# string.  There are multiple problems, on different Perl versions,\n# that require this to be avoided.  All versions prior to 5.13.8 will\n# load utf8_heavy.pl for the swash system, even if the regexp doesn't\n# use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit\n# specific problems when Carp is being invoked in the aftermath of a\n# syntax error.\nBEGIN {\n    if(\"$]\" < 5.013011) {\n\t*UTF8_REGEXP_PROBLEM = sub () { 1 };\n    } else {\n\t*UTF8_REGEXP_PROBLEM = sub () { 0 };\n    }\n}\n\n# is_utf8() is essentially the utf8::is_utf8() function, which indicates\n# whether a string is represented in the upgraded form (using UTF-8\n# internally).  As utf8::is_utf8() is only available from Perl 5.8\n# onwards, extra effort is required here to make it work on Perl 5.6.\nBEGIN {\n    if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {\n\t*is_utf8 = $sub;\n    } else {\n\t# black magic for perl 5.6\n\t*is_utf8 = sub { unpack(\"C\", \"\\xaa\".$_[0]) != 170 };\n    }\n}\n\n# The downgrade() function defined here is to be used for attempts to\n# downgrade where it is acceptable to fail.  It must be called with a\n# second argument that is a true value.\nBEGIN {\n    if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {\n\t*downgrade = \\&{\"utf8::downgrade\"};\n    } else {\n\t*downgrade = sub {\n\t    my $r = \"\";\n\t    my $l = length($_[0]);\n\t    for(my $i = 0; $i != $l; $i++) {\n\t\tmy $o = ord(substr($_[0], $i, 1));\n\t\treturn if $o > 255;\n\t\t$r .= chr($o);\n\t    }\n\t    $_[0] = $r;\n\t};\n    }\n}\n\nour $VERSION = '1.38';\n$VERSION =~ tr/_//d;\n\nour $MaxEvalLen = 0;\nour $Verbose    = 0;\nour $CarpLevel  = 0;\nour $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.\nour $MaxArgNums = 8;     # How many arguments to print. 0 = all.\nour $RefArgFormatter = undef; # allow caller to format reference arguments\n\nrequire Exporter;\nour @ISA       = ('Exporter');\nour @EXPORT    = qw(confess croak carp);\nour @EXPORT_OK = qw(cluck verbose longmess shortmess);\nour @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl's warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\nour %CarpInternal;\nour %Internal;\n\n# disable these by default, so they can live w/o require Carp\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$Internal{Exporter}++;\n$Internal{'Exporter::Heavy'}++;\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# 'verbose'.\n\nsub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }\n\nsub _cgc {\n    no strict 'refs';\n    return \\&{\"CORE::GLOBAL::caller\"} if defined &{\"CORE::GLOBAL::caller\"};\n    return;\n}\n\nsub longmess {\n    local($!, $^E);\n    # Icky backwards compatibility wrapper. :-(\n    #\n    # The story is that the original implementation hard-coded the\n    # number of call levels to go back, so calls to longmess were off\n    # by one.  Other code began calling longmess and expecting this\n    # behaviour, so the replacement has to emulate that behaviour.\n    my $cgc = _cgc();\n    my $call_pack = $cgc ? $cgc->() : caller();\n    if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {\n        return longmess_heavy(@_);\n    }\n    else {\n        local $CarpLevel = $CarpLevel + 1;\n        return longmess_heavy(@_);\n    }\n}\n\nour @CARP_NOT;\n\nsub shortmess {\n    local($!, $^E);\n    my $cgc = _cgc();\n\n    # Icky backwards compatibility wrapper. :-(\n    local @CARP_NOT = $cgc ? $cgc->() : caller();\n    shortmess_heavy(@_);\n}\n\nsub croak   { die shortmess @_ }\nsub confess { die longmess @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn longmess @_ }\n\nBEGIN {\n    if(\"$]\" >= 5.015002 || (\"$]\" >= 5.014002 && \"$]\" < 5.015) ||\n\t    (\"$]\" >= 5.012005 && \"$]\" < 5.013)) {\n\t*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };\n    } else {\n\t*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };\n    }\n}\n\nsub caller_info {\n    my $i = shift(@_) + 1;\n    my %call_info;\n    my $cgc = _cgc();\n    {\n\t# Some things override caller() but forget to implement the\n\t# @DB::args part of it, which we need.  We check for this by\n\t# pre-populating @DB::args with a sentinel which no-one else\n\t# has the address of, so that we can detect whether @DB::args\n\t# has been properly populated.  However, on earlier versions\n\t# of perl this check tickles a bug in CORE::caller() which\n\t# leaks memory.  So we only check on fixed perls.\n        @DB::args = \\$i if CALLER_OVERRIDE_CHECK_OK;\n        package DB;\n        @call_info{\n            qw(pack file line sub has_args wantarray evaltext is_require) }\n            = $cgc ? $cgc->($i) : caller($i);\n    }\n\n    unless ( defined $call_info{file} ) {\n        return ();\n    }\n\n    my $sub_name = Carp::get_subname( \\%call_info );\n    if ( $call_info{has_args} ) {\n        my @args;\n        if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1\n            && ref $DB::args[0] eq ref \\$i\n            && $DB::args[0] == \\$i ) {\n            @DB::args = ();    # Don't let anyone see the address of $i\n            local $@;\n            my $where = eval {\n                my $func    = $cgc or return '';\n                my $gv      =\n                    (_fetch_sub B => 'svref_2object' or return '')\n                        ->($func)->GV;\n                my $package = $gv->STASH->NAME;\n                my $subname = $gv->NAME;\n                return unless defined $package && defined $subname;\n\n                # returning CORE::GLOBAL::caller isn't useful for tracing the cause:\n                return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';\n                \" in &${package}::$subname\";\n            } || '';\n            @args\n                = \"** Incomplete caller override detected$where; \\@DB::args were not set **\";\n        }\n        else {\n            @args = @DB::args;\n            my $overflow;\n            if ( $MaxArgNums and @args > $MaxArgNums )\n            {    # More than we want to show?\n                $#args = $MaxArgNums - 1;\n                $overflow = 1;\n            }\n\n            @args = map { Carp::format_arg($_) ", 8192) = 8192
09:01:56.852066 brk(0x6c2000)           = 0x6c2000
09:01:56.852398 stat("modules/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.852474 stat("modules/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.852535 stat("modules/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.852591 stat("modules/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.852650 stat("/etc/perl/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.852707 stat("/etc/perl/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.852768 stat("/usr/local/lib/perl/5.14.2/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.852830 stat("/usr/local/lib/perl/5.14.2/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.852895 stat("/usr/local/share/perl/5.14.2/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.852956 stat("/usr/local/share/perl/5.14.2/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.853020 stat("/usr/lib/perl5/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.853079 stat("/usr/lib/perl5/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.853141 stat("/usr/share/perl5/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.853212 stat("/usr/share/perl5/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.853270 stat("/usr/lib/perl/5.14/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.853328 stat("/usr/lib/perl/5.14/warnings.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.853387 stat("/usr/share/perl/5.14/warnings.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.853463 stat("/usr/share/perl/5.14/warnings.pm", {st_mode=S_IFREG|0644, st_size=15015, ...}) = 0
09:01:56.853546 open("/usr/share/perl/5.14/warnings.pm", O_RDONLY) = 6
09:01:56.853614 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.853683 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.853779 read(6, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file is built by regen/warnings.pl.\n# Any changes made here will be lost!\n\npackage warnings;\n\nour $VERSION = '1.12';\n\n# Verify that we're called correctly so that warnings will work.\n# see also strict.pm.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    'all'\t\t=> 0,\n    'closure'\t\t=> 2,\n    'deprecated'\t=> 4,\n    'exiting'\t\t=> 6,\n    'glob'\t\t=> 8,\n    'io'\t\t=> 10,\n    'closed'\t\t=> 12,\n    'exec'\t\t=> 14,\n    'layer'\t\t=> 16,\n    'newline'\t\t=> 18,\n    'pipe'\t\t=> 20,\n    'unopened'\t\t=> 22,\n    'misc'\t\t=> 24,\n    'numeric'\t\t=> 26,\n    'once'\t\t=> 28,\n    'overflow'\t\t=> 30,\n    'pack'\t\t=> 32,\n    'portable'\t\t=> 34,\n    'recursion'\t\t=> 36,\n    'redefine'\t\t=> 38,\n    'regexp'\t\t=> 40,\n    'severe'\t\t=> 42,\n    'debugging'\t\t=> 44,\n    'inplace'\t\t=> 46,\n    'internal'\t\t=> 48,\n    'malloc'\t\t=> 50,\n    'signal'\t\t=> 52,\n    'substr'\t\t=> 54,\n    'syntax'\t\t=> 56,\n    'ambiguous'\t\t=> 58,\n    'bareword'\t\t=> 60,\n    'digit'\t\t=> 62,\n    'parenthesis'\t=> 64,\n    'precedence'\t=> 66,\n    'printf'\t\t=> 68,\n    'prototype'\t\t=> 70,\n    'qw'\t\t=> 72,\n    'reserved'\t\t=> 74,\n    'semicolon'\t\t=> 76,\n    'taint'\t\t=> 78,\n    'threads'\t\t=> 80,\n    'uninitialized'\t=> 82,\n    'unpack'\t\t=> 84,\n    'untie'\t\t=> 86,\n    'utf8'\t\t=> 88,\n    'void'\t\t=> 90,\n\n    # Warnings Categories added in Perl 5.011\n\n    'imprecision'\t=> 92,\n    'illegalproto'\t=> 94,\n\n    # Warnings Categories added in Perl 5.013\n\n    'non_unicode'\t=> 96,\n    'nonchar'\t\t=> 98,\n    'surrogate'\t\t=> 100,\n  );\n\nour %Bits = (\n    'all'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..50]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecated'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'glob'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    'layer'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x40\\x00\", # [28..38,47]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x15\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [45]\n  );\n\nour %DeadBits = (\n    'all'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..50]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecated'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'glob'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    'layer'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x", 8192) = 8192
09:01:56.855687 read(6, "08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x80\\x00\", # [28..38,47]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x2a\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [45]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 102 ;\n$BYTES    = 13 ;\n\n$All = \"\" ; vec($All, $Offsets{'all'}, 2) = 3 ;\n\nsub Croaker\n{\n    require Carp; # this initializes %CarpInternal\n    local $Carp::CarpInternal{'warnings'};\n    delete $Carp::CarpInternal{'warnings'};\n    Carp::croak(@_);\n}\n\nsub _bits {\n    my $mask = shift ;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq 'NONFATAL') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    return $mask ;\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n    push @_, 'all' unless @_ ;\n    return _bits(undef, @_) ;\n}\n\nsub import \n{\n    shift;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n    \n    # Empty @_ is equivalent to @_ = 'all' ;\n    ${^WARNING_BITS} = @_ ? _bits($mask, @_) : $mask | $Bits{all} ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n\n    push @_, 'all' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub MESSAGE () { 4 };\nsub FATAL () { 2 };\nsub NORMAL () { 1 };\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n    my $wanted = shift;\n    my $has_message = $wanted & MESSAGE;\n\n    unless (@_ == 1 || @_ == ($has_message ? 2 : 0)) {\n\tmy $sub = (caller 1)[3];\n\tmy $syntax = $has_message ? \"[category,] 'message'\" : '[category]';\n\tCroaker(\"Usage: $sub($syntax)\");\n    }\n\n    my $message = pop if $has_message;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category '$category'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package '$category' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $i;\n\n    if ($isobj) {\n        my $pkg;\n        $i = 2;\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        $i = _error_loc(); # see where Carp will allocate the error\n    }\n\n    # Defaulting this to 0 reduces complexity in code paths below.\n    my $callers_bitmask = (caller($i))[9] || 0 ;\n\n    my @results;\n    foreach my $type (FATAL, NORMAL) {\n\tnext unless $wanted & $type;\n\n\tpush @results, (vec($callers_bitmask, $offset + $type - 1, 1) ||\n\t\t\tvec($callers_bitmask, $Offsets{'all'} + $type - 1, 1));\n    }\n\n    # &enabled and &fatal_enabled\n    return $results[0] unless $has_message;\n\n    # &warnif, and the category is neither enabled as warning nor as fatal\n    return if $wanted == (NORMAL | FATAL | MESSAGE)\n\t&& !($results[0] || $results[1]);\n\n    require Carp;\n    Carp::croak($message) if $results[0];\n    # will always get here for &warn. will only get here for &warnif if the\n    # category is enabled\n    Carp::carp($message);\n}\n\nsub _mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub register_categories\n{\n    my @names = @_;\n\n    for my $name (@names) {\n\tif (! defined $Bits{$name}) {\n\t    $Bits{$name}     = _mkMask($LAST_BIT);\n\t    vec($Bits{'all'}, $LAST_BIT, 1) = 1;\n\t    $Offsets{$name}  = $LAST_BIT ++;\n\t    foreach my $k (keys %Bits) {\n\t\tvec($Bits{$k}, $LAST_BIT, 1) = 0;\n\t    }\n\t    $DeadBits{$name} = _mkMask($LAST_BIT);\n\t    vec($DeadBits{'all'}, $LAST_BIT++, 1) = 1;\n\t}\n    }\n}\n\nsub _error_loc {\n    require Carp;\n    goto &Carp::short_error_loc; # don't introduce another stack frame\n}\n\nsub enabled\n{\n    return __chk(NORMAL, @_);\n}\n\nsub fatal_enabled\n{\n    return __chk(FATAL, @_);\n}\n\nsub warn\n{\n    return __chk(FATAL | MESSAGE, @_);\n}\n\nsub warnif\n{\n    return __chk(NORMAL | FATAL | MESSAGE, @_);\n}\n\n# These are not part of any public interface, so we can delete them to save\n# space.\ndelete $warnings::{$_} foreach qw(NORMAL FATAL MESSAGE);\n\n1;\n\n# ex: set ro:\n", 8192) = 6823
09:01:56.857675 brk(0x6e3000)           = 0x6e3000
09:01:56.858884 read(6, "", 8192)       = 0
09:01:56.859034 close(6)                = 0
09:01:56.861377 read(5, "} @args;\n\n            if ($overflow) {\n                push @args, '...';\n            }\n        }\n\n        # Push the args onto the subroutine\n        $sub_name .= '(' . join( ', ', @args ) . ')';\n    }\n    $call_info{sub_name} = $sub_name;\n    return wantarray() ? %call_info : \\%call_info;\n}\n\n# Transform an argument to a function into a string.\nour $in_recurse;\nsub format_arg {\n    my $arg = shift;\n\n    if ( ref($arg) ) {\n         # legitimate, let's not leak it.\n        if (!$in_recurse &&\n\t    do {\n                local $@;\n\t        local $in_recurse = 1;\n\t\tlocal $SIG{__DIE__} = sub{};\n                eval {$arg->can('CARP_TRACE') }\n            })\n        {\n            return $arg->CARP_TRACE();\n        }\n        elsif (!$in_recurse &&\n\t       defined($RefArgFormatter) &&\n\t       do {\n                local $@;\n\t        local $in_recurse = 1;\n\t\tlocal $SIG{__DIE__} = sub{};\n                eval {$arg = $RefArgFormatter->($arg); 1}\n                })\n        {\n            return $arg;\n        }\n        else\n        {\n\t    my $sub = _fetch_sub(overload => 'StrVal');\n\t    return $sub ? &$sub($arg) : \"$arg\";\n        }\n    }\n    return \"undef\" if !defined($arg);\n    downgrade($arg, 1);\n    return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&\n\t    $arg =~ /\\A-?[0-9]+(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\\z/;\n    my $suffix = \"\";\n    if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {\n        substr ( $arg, $MaxArgLen - 3 ) = \"\";\n\t$suffix = \"...\";\n    }\n    if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {\n\tfor(my $i = length($arg); $i--; ) {\n\t    my $c = substr($arg, $i, 1);\n\t    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}\n\t    if($c eq \"\\\"\" || $c eq \"\\\\\" || $c eq \"\\$\" || $c eq \"\\@\") {\n\t\tsubstr $arg, $i, 0, \"\\\\\";\n\t\tnext;\n\t    }\n\t    my $o = ord($c);\n\n            # This code is repeated in Regexp::CARP_TRACE()\n            if ($] ge 5.007_003) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n\t\t  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)\n                  || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);\n            } elsif (ord(\"A\") == 65) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < 0x20 || $o > 0x7e;\n            } else { # Early EBCDIC\n\n                # 3 EBCDIC code pages supported then;  all controls but one\n                # are the code points below SPACE.  The other one is 0x5F on\n                # POSIX-BC; FF on the other two.\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < ord(\" \") || ((ord (\"^\") == 106)\n                                          ? $o == 0x5f\n                                          : $o == 0xff);\n            }\n\t}\n    } else {\n\t$arg =~ s/([\\\"\\\\\\$\\@])/\\\\$1/g;\n        # This is all the ASCII printables spelled-out.  It is portable to all\n        # Perl versions and platforms (such as EBCDIC).  There are other more\n        # compact ways to do this, but may not work everywhere every version.\n        $arg =~ s/([^ !\"\\$\\%#'()*+,\\-.\\/0123456789:;<=>?\\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]^_`abcdefghijklmnopqrstuvwxyz\\{|}~])/sprintf(\"\\\\x{%x}\",ord($1))/eg;\n    }\n    downgrade($arg, 1);\n    return \"\\\"\".$arg.\"\\\"\".$suffix;\n}\n\nsub Regexp::CARP_TRACE {\n    my $arg = \"$_[0]\";\n    downgrade($arg, 1);\n    if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {\n\tfor(my $i = length($arg); $i--; ) {\n\t    my $o = ord(substr($arg, $i, 1));\n\t    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}\n\n            # This code is repeated in format_arg()\n            if ($] ge 5.007_003) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n\t\t  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)\n                  || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);\n            } elsif (ord(\"A\") == 65) {\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < 0x20 || $o > 0x7e;\n            } else { # Early EBCDIC\n                substr $arg, $i, 1, sprintf(\"\\\\x{%x}\", $o)\n                    if $o < ord(\" \") || ((ord (\"^\") == 106)\n                                          ? $o == 0x5f\n                                          : $o == 0xff);\n            }\n\t}\n    } else {\n        # See comment in format_arg() about this same regex.\n        $arg =~ s/([^ !\"\\$\\%#'()*+,\\-.\\/0123456789:;<=>?\\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]^_`abcdefghijklmnopqrstuvwxyz\\{|}~])/sprintf(\"\\\\x{%x}\",ord($1))/eg;\n    }\n    downgrade($arg, 1);\n    my $suffix = \"\";\n    if($arg =~ /\\A\\(\\?\\^?([a-z]*)(?:-[a-z]*)?:(.*)\\)\\z/s) {\n\t($suffix, $arg) = ($1, $2);\n    }\n    if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {\n        substr ( $arg, $MaxArgLen - 3 ) = \"\";\n\t$suffix = \"...\".$suffix;\n    }\n    return \"qr($arg)$suffix\";\n}\n\n# Takes an inheritance cache and a package and returns\n# an anon hash of known inheritances and anon array of\n# inheritances which consequences have not been figured\n# for.\nsub get_status {\n    my $cache = shift;\n    my $pkg   = shift;\n    $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];\n    return @{ $cache->{$pkg} };\n}\n\n# Takes the info from caller() and figures out the name of\n# the sub/require/eval\nsub get_subname {\n    my $info = shift;\n    if ( defined( $info->{evaltext} ) ) {\n        my $eval = $info->{evaltext};\n        if ( $info->{is_require} ) {\n            return \"require $eval\";\n        }\n        else {\n            $eval =~ s/([\\\\\\'])/\\\\$1/g;\n            return \"eval '\" . str_len_trim( $eval, $MaxEvalLen ) . \"'\";\n        }\n    }\n\n    # this can happen on older perls when the sub (or the stash containing it)\n    # has been deleted\n    if ( !defined( $info->{sub} ) ) {\n        return '__ANON__::__ANON__';\n    }\n\n    return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};\n}\n\n# Figures out what call (from the point of view of the caller)\n# the long error backtrace should start at.\nsub long_error_loc {\n    my $i;\n    my $lvl = $CarpLevel;\n    {\n        ++$i;\n        my $cgc = _cgc();\n        my @caller = $cgc ? $cgc->($i) : caller($i);\n        my $pkg = $caller[0];\n        unless ( defined($pkg) ) {\n\n            # This *shouldn't* happen.\n            if (%Internal) {\n                local %Internal;\n                $i = long_error_loc();\n                last;\n            }\n            elsif (defined $caller[2]) {\n                # this can happen when the stash has been deleted\n                # in that case, just assume that it's a reasonable place to\n                # stop (the file and line data will still be intact in any\n                # case) - the only issue is that we can't detect if the\n                # deleted package was internal (so don't do that then)\n                # -doy\n                redo unless 0 > --$lvl;\n                last;\n            }\n            else {\n                return 2;\n            }\n        }\n        redo if $CarpInternal{$pkg};\n        redo unless 0 > --$lvl;\n        redo if $Internal{$pkg};\n    }\n    return $i - 1;\n}\n\nsub longmess_heavy {\n    return @_ if ref( $_[0] );    # don't break references as exceptions\n    my $i = long_error_loc();\n    return ret_backtrace( $i, @_ );\n}\n\n# Returns a full stack backtrace starting from where it is\n# told.\nsub ret_backtrace {\n    my ( $i, @error ) = @_;\n    my $mess;\n    my $err = join '', @error;\n    $i++;\n\n    my $tid_msg = '';\n    if ( defined &threads::tid ) {\n        my $tid = threads->tid;\n        $tid_msg = \" thread $tid\" if $tid;\n    }\n\n    my %i = caller_info($i);\n    $mess = \"$err at $i{file} line $i{line}$tid_msg\";\n    if( defined $. ) {\n        local $@ = '';\n        local $SIG{__DIE__};\n        eval {\n            CORE::die;\n        };\n        if($@ =~ /^Died at .*(, <.*?> line \\d+).$/ ) {\n            $mess .= $1;\n        }\n    }\n    $mess .= \"\\.\\n\";\n\n    while ( my %i = caller_info( ++$i ) ) {\n        $mess .= \"\\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\\n\";\n    }\n\n    return $mess;\n}\n\nsub ret_summary {\n    my ( $i, @error ) = @_;\n    my $err = join '', @error;\n    $i++;\n\n    my $tid_msg = '';\n    if ( defined &threads::tid ) {\n        my $tid = threads->tid;\n        $tid_msg = \" thread $tid\" if $tid;\n    }\n\n    my %i ", 8192) = 8192
09:01:56.863162 brk(0x704000)           = 0x704000
09:01:56.865174 read(5, "= caller_info($i);\n    return \"$err at $i{file} line $i{line}$tid_msg\\.\\n\";\n}\n\nsub short_error_loc {\n    # You have to create your (hash)ref out here, rather than defaulting it\n    # inside trusts *on a lexical*, as you want it to persist across calls.\n    # (You can default it on $_[2], but that gets messy)\n    my $cache = {};\n    my $i     = 1;\n    my $lvl   = $CarpLevel;\n    {\n        my $cgc = _cgc();\n        my $called = $cgc ? $cgc->($i) : caller($i);\n        $i++;\n        my $caller = $cgc ? $cgc->($i) : caller($i);\n\n        if (!defined($caller)) {\n            my @caller = $cgc ? $cgc->($i) : caller($i);\n            if (@caller) {\n                # if there's no package but there is other caller info, then\n                # the package has been deleted - treat this as a valid package\n                # in this case\n                redo if defined($called) && $CarpInternal{$called};\n                redo unless 0 > --$lvl;\n                last;\n            }\n            else {\n                return 0;\n            }\n        }\n        redo if $Internal{$caller};\n        redo if $CarpInternal{$caller};\n        redo if $CarpInternal{$called};\n        redo if trusts( $called, $caller, $cache );\n        redo if trusts( $caller, $called, $cache );\n        redo unless 0 > --$lvl;\n    }\n    return $i - 1;\n}\n\nsub shortmess_heavy {\n    return longmess_heavy(@_) if $Verbose;\n    return @_ if ref( $_[0] );    # don't break references as exceptions\n    my $i = short_error_loc();\n    if ($i) {\n        ret_summary( $i, @_ );\n    }\n    else {\n        longmess_heavy(@_);\n    }\n}\n\n# If a string is too long, trims it with ...\nsub str_len_trim {\n    my $str = shift;\n    my $max = shift || 0;\n    if ( 2 < $max and $max < length($str) ) {\n        substr( $str, $max - 3 ) = '...';\n    }\n    return $str;\n}\n\n# Takes two packages and an optional cache.  Says whether the\n# first inherits from the second.\n#\n# Recursive versions of this have to work to avoid certain\n# possible endless loops, and when following long chains of\n# inheritance are less efficient.\nsub trusts {\n    my $child  = shift;\n    my $parent = shift;\n    my $cache  = shift;\n    my ( $known, $partial ) = get_status( $cache, $child );\n\n    # Figure out consequences until we have an answer\n    while ( @$partial and not exists $known->{$parent} ) {\n        my $anc = shift @$partial;\n        next if exists $known->{$anc};\n        $known->{$anc}++;\n        my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );\n        my @found = keys %$anc_knows;\n        @$known{@found} = ();\n        push @$partial, @$anc_partial;\n    }\n    return exists $known->{$parent};\n}\n\n# Takes a package and gives a list of those trusted directly\nsub trusts_directly {\n    my $class = shift;\n    no strict 'refs';\n    my $stash = \\%{\"$class\\::\"};\n    for my $var (qw/ CARP_NOT ISA /) {\n        # Don't try using the variable until we know it exists,\n        # to avoid polluting the caller's namespace.\n        if ( $stash->{$var} && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {\n           return @{$stash->{$var}}\n        }\n    }\n    return;\n}\n\nif(!defined($warnings::VERSION) ||\n\tdo { no warnings \"numeric\"; $warnings::VERSION < 1.03 }) {\n    # Very old versions of warnings.pm import from Carp.  This can go\n    # wrong due to the circular dependency.  If Carp is invoked before\n    # warnings, then Carp starts by loading warnings, then warnings\n    # tries to import from Carp, and gets nothing because Carp is in\n    # the process of loading and hasn't defined its import method yet.\n    # So we work around that by manually exporting to warnings here.\n    no strict \"refs\";\n    *{\"warnings::$_\"} = \\&$_ foreach @EXPORT;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nCarp - alternative warn and die for modules\n\n=head1 SYNOPSIS\n\n    use Carp;\n\n    # warn user (from perspective of caller)\n    carp \"string trimmed to 80 chars\";\n\n    # die of errors (from perspective of caller)\n    croak \"We're outta here!\";\n\n    # die of errors with stack backtrace\n    confess \"not implemented\";\n\n    # cluck, longmess and shortmess not exported by default\n    use Carp qw(cluck longmess shortmess);\n    cluck \"This is how we got here!\";\n    $long_message   = longmess( \"message from cluck() or confess()\" );\n    $short_message  = shortmess( \"message from carp() or croak()\" );\n\n=head1 DESCRIPTION\n\nThe Carp routines are useful in your own modules because\nthey act like C<die()> or C<warn()>, but with a message which is more\nlikely to be useful to a user of your module.  In the case of\nC<cluck()> and C<confess()>, that context is a summary of every\ncall in the call-stack; C<longmess()> returns the contents of the error\nmessage.\n\nFor a shorter message you can use C<carp()> or C<croak()> which report the\nerror as being from where your module was called.  C<shortmess()> returns the\ncontents of this error message.  There is no guarantee that that is where the\nerror was, but it is a good educated guess.\n\nC<Carp> takes care not to clobber the status variables C<$!> and C<$^E>\nin the course of assembling its error messages.  This means that a\nC<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error\ninformation held in those variables, if it is required to augment the\nerror message, and if the code calling C<Carp> left useful values there.\nOf course, C<Carp> can't guarantee the latter.\n\nYou can also alter the way the output and logic of C<Carp> works, by\nchanging some global variables in the C<Carp> namespace. See the\nsection on C<GLOBAL VARIABLES> below.\n\nHere is a more complete description of how C<carp> and C<croak> work.\nWhat they do is search the call-stack for a function call stack where\nthey have not been told that there shouldn't be an error.  If every\ncall is marked safe, they give up and give a full stack backtrace\ninstead.  In other words they presume that the first likely looking\npotential suspect is guilty.  Their rules for telling whether\na call shouldn't generate errors work as follows:\n\n=over 4\n\n=item 1.\n\nAny call from a package to itself is safe.\n\n=item 2.\n\nPackages claim that there won't be errors on calls to or from\npackages explicitly marked as safe by inclusion in C<@CARP_NOT>, or\n(if that array is empty) C<@ISA>.  The ability to override what\n@ISA says is new in 5.8.\n\n=item 3.\n\nThe trust in item 2 is transitive.  If A trusts B, and B\ntrusts C, then A trusts C.  So if you do not override C<@ISA>\nwith C<@CARP_NOT>, then this trust relationship is identical to,\n\"inherits from\".\n\n=item 4.\n\nAny call from an internal Perl module is safe.  (Nothing keeps\nuser modules from marking themselves as internal to Perl, but\nthis practice is discouraged.)\n\n=item 5.\n\nAny call to Perl's warning system (eg Carp itself) is safe.\n(This rule is what keeps it from reporting the error at the\npoint where you call C<carp> or C<croak>.)\n\n=item 6.\n\nC<$Carp::CarpLevel> can be set to skip a fixed number of additional\ncall levels.  Using this is not recommended because it is very\ndifficult to get it to behave correctly.\n\n=back\n\n=head2 Forcing a Stack Trace\n\nAs a debugging aid, you can force Carp to treat a croak as a confess\nand a carp as a cluck across I<all> modules. In other words, force a\ndetailed stack trace to be given.  This can be very helpful when trying\nto understand why, or from where, a warning or error is being generated.\n\nThis feature is enabled by 'importing' the non-existent symbol\n'verbose'. You would typically enable it by saying\n\n    perl -MCarp=verbose script.pl\n\nor by including the string C<-MCarp=verbose> in the PERL5OPT\nenvironment variable.\n\nAlternately, you can set the global variable C<$Carp::Verbose> to true.\nSee the C<GLOBAL VARIABLES> section below.\n\n=head2 Stack Trace formatting\n\nAt each stack level, the subroutine's name is displayed along with\nits parameters.  For simple scalars, this is sufficient.  For complex\ndata types, such as objects and other references, this can simply\ndisplay C<'HASH(0x1ab36d8)'>.\n\nCarp gives two ways to control this.\n\n=over 4\n\n=item 1.\n\nFor objects, a method, C<CARP_TRACE>, will be called, if it exists.  If\nthis method doesn't exist, or it recurses into C<Carp>, or it otherwise\nthrows an exception, this is skipped, and C", 8192) = 8192
09:01:56.867078 brk(0x725000)           = 0x725000
09:01:56.867367 lseek(5, 20098, SEEK_SET) = 20098
09:01:56.867480 lseek(5, 0, SEEK_CUR)   = 20098
09:01:56.867585 close(5)                = 0
09:01:56.867780 stat("modules/Exporter.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.867992 stat("modules/Exporter.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.868140 stat("modules/Exporter.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.868296 stat("modules/Exporter.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.868450 stat("/etc/perl/Exporter.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.868604 stat("/etc/perl/Exporter.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.868758 stat("/usr/local/lib/perl/5.14.2/Exporter.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.868915 stat("/usr/local/lib/perl/5.14.2/Exporter.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.869086 stat("/usr/local/share/perl/5.14.2/Exporter.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.869293 stat("/usr/local/share/perl/5.14.2/Exporter.pm", {st_mode=S_IFREG|0444, st_size=18746, ...}) = 0
09:01:56.869477 open("/usr/local/share/perl/5.14.2/Exporter.pm", O_RDONLY) = 5
09:01:56.869642 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.869800 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.869937 read(5, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict 'refs';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = '5.72';\nour (%Cache);\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my $exports = \\@{\"$pkg\\::EXPORT\"};\n  # But, avoid creating things if they don't exist, which saves a couple of\n  # hundred bytes per package processed.\n  my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \\@{\"$pkg\\::EXPORT_FAIL\"};\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or $fail && @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or $fail and @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp} if not $SIG{__WARN__};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n=head1 NAME\n\nExporter - Implements default import method for modules\n\n=head1 SYNOPSIS\n\nIn module F<YourModule.pm>:\n\n  package YourModule;\n  require Exporter;\n  @ISA = qw(Exporter);\n  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request\n\nor\n\n  package YourModule;\n  use Exporter 'import'; # gives you Exporter's import() method directly\n  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request\n\nIn other files which wish to use C<YourModule>:\n\n  use YourModule qw(frobnicate);      # import listed symbols\n  frobnicate ($left, $right)          # calls YourModule::frobnicate\n\nTake a look at L</Good Practices> for some variants\nyou will like to use in modern Perl code.\n\n=head1 DESCRIPTION\n\nThe Exporter module implements an C<import> method which allows a module\nto export functions and variables to its users' namespaces.  Many modules\nuse Exporter rather than implementing their own C<import> method because\nExporter provides a highly flexible interface, with an implementation optimised\nfor the common case.\n\nPerl automatically calls the C<import> method when processing a\nC<use> statement for a module.  Modules and C<use> are documented\nin L<perlfunc> and L<perlmod>.  Understanding the concept of\nmodules and how the C<use> statement operates is important to\nunderstanding the Exporter.\n\n=head2 How to Export\n\nThe arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of\nsymbols that are going to be exported into the users name space by\ndefault, or which they can request to be exported, respectively.  The\nsymbols can represent functions, scalars, arrays, hashes, or typeglobs.\nThe symbols must be given by full name with the exception that the\nampersand in front of a function is optional, e.g.\n\n    @EXPORT    = qw(afunc $scalar @array);   # afunc is a function\n    @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc\n\nIf you are only exporting function names it is recommended to omit the\nampersand, as the implementation is faster this way.\n\n=head2 Selecting What to Export\n\nDo B<not> export method names!\n\nDo B<not> export anything else by default without a good reason!\n\nExports pollute the namespace of the module user.  If you must export\ntry to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or\ncommon symbol names to reduce the risk of name clashes.\n\nGenerally anything not exported is still accessible from outside the\nmodule using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)\nsyntax.  By convention you can use a leading underscore on names to\ninformally indicate that they are 'internal' and not for public use.\n\n(It is actually possible to get private functions by saying:\n\n  my $subref = sub { ... };\n  $subref->(@args);            # Call it as a function\n  $obj->$subref(@args);        # Use it as a method\n\nHowever if you use them for methods it is up to you to figure out\nhow to make inheritance work.)\n\nAs a general rule, if the module is trying to be object oriented\nthen export nothing.  If it's just a collection of functions then\nC<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and\nmethod names use barewords in preference to names prefixed with\nampersands for the export lists.\n\nOther module design guidelines can be found in L<perlmod>.\n\n=head2 How to Import\n\nIn other files which wish to use your module there are three basic ways for\nthem to load your module and import its symbols:\n\n=over 4\n\n=item C<use YourModule;>\n\nThis imports all the symbols from YourModule's C<@EXPORT> into the namespace\nof the C<use> statement.\n\n=item C<use YourModule ();>\n\nThis causes perl to load your module but does not import any symbols.\n\n=item C<use YourModule qw(...);>\n\nThis imports only the symbols listed by the caller into their namespace.\nAll listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error\noccurs.  The advanced export features of Exporter are accessed like this,\nbut with list entries that are syntactically distinct from symbol names.\n\n=back\n\nUnless you want to use its advanced features, this is probably all you\nneed to know to use Exporter.\n\n=head1 Advanced Features\n\n=head2 Specialised Import Lists\n\nIf any of the entries in an import list begins with !, : or / then\nthe list is treated as a series of specifications which either add to\nor delete from the list of names to import.  They are processed left to\nright. Specifications are in the form:\n\n    [!]name         This name only\n    [!]:DEFAULT     All names in @EXPORT\n    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array\n    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match\n\nA leading ! indicates that matching names should be deleted from the\nlist of names to import.  If the first specification is a deletion it\nis treated as though preceded by :DEFAULT.  If you just want to import\nextra names in addition to the default set you will still need to\ninclude :DEFAULT explicitly.\n\ne.g., F<Module.pm> defines:\n\n    @EXPORT      = qw(A1 A2 A3 A4 A5);\n    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);\n    %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);\n\nNote that you cannot use tags in @EXPORT or @EXPORT_OK.\n\nNames in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.\n\nAn application using Module can say something like:\n\n    use Module qw(:DEFAULT :T2 !B3 A3);\n\nOther examples include:\n\n    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);\n    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);\n\nRemember that most patterns (using //) will need to be anchored\nwith a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.\n\nYou can say C<BEGIN { $Exporter::Verbose=1 }> to see how the\nspecifications are being processed and what is actually being imported\ninto modules.\n\n=head2 Exporting Without Using Exporter's import Method\n\nExporter has a special method, 'expo", 8192) = 8192
09:01:56.871696 lseek(5, 2366, SEEK_SET) = 2366
09:01:56.871810 lseek(5, 0, SEEK_CUR)   = 2366
09:01:56.871938 close(5)                = 0
09:01:56.872276 stat("modules/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.872401 stat("modules/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.872517 stat("modules/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.872629 stat("modules/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.872742 stat("/etc/perl/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.872855 stat("/etc/perl/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.872968 stat("/usr/local/lib/perl/5.14.2/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.873085 stat("/usr/local/lib/perl/5.14.2/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.873215 stat("/usr/local/share/perl/5.14.2/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.873332 stat("/usr/local/share/perl/5.14.2/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.873451 stat("/usr/lib/perl5/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.873565 stat("/usr/lib/perl5/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.873686 stat("/usr/share/perl5/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.873814 stat("/usr/share/perl5/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.873928 stat("/usr/lib/perl/5.14/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.874064 stat("/usr/lib/perl/5.14/vars.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:56.874194 stat("/usr/share/perl/5.14/vars.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.874313 stat("/usr/share/perl/5.14/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
09:01:56.874448 open("/usr/share/perl/5.14/vars.pm", O_RDONLY) = 5
09:01:56.874571 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.874678 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.874813 read(5, "package vars;\n\nuse 5.006;\n\nour $VERSION = '1.02';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my (undef, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can't declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits('vars'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"'$_' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"'$_' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"'$_' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 8192) = 1149
09:01:56.875159 stat("modules/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.875280 stat("modules/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.875395 stat("modules/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.875507 stat("modules/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.875621 stat("/etc/perl/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.875735 stat("/etc/perl/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.875854 stat("/usr/local/lib/perl/5.14.2/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.875977 stat("/usr/local/lib/perl/5.14.2/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.876095 stat("/usr/local/share/perl/5.14.2/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.876211 stat("/usr/local/share/perl/5.14.2/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.876328 stat("/usr/lib/perl5/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.876442 stat("/usr/lib/perl5/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.876558 stat("/usr/share/perl5/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.876676 stat("/usr/share/perl5/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.876794 stat("/usr/lib/perl/5.14/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.876913 stat("/usr/lib/perl/5.14/warnings/register.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.877028 stat("/usr/share/perl/5.14/warnings/register.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.877166 stat("/usr/share/perl/5.14/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=481, ...}) = 0
09:01:56.877306 open("/usr/share/perl/5.14/warnings/register.pm", O_RDONLY) = 6
09:01:56.877429 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.877536 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.877689 read(6, "package warnings::register;\n\nour $VERSION = '1.02';\n\nrequire warnings;\n\n# left here as cruft in case other users were using this undocumented routine\n# -- rjbs, 2010-09-08\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my @categories = @_;\n\n    my $package = (caller(0))[0];\n    warnings::register_categories($package);\n\n    warnings::register_categories($package . \"::$_\") for @categories;\n}\n\n1;\n", 8192) = 481
09:01:56.878052 read(6, "", 8192)       = 0
09:01:56.878175 close(6)                = 0
09:01:56.878791 lseek(5, 1148, SEEK_SET) = 1148
09:01:56.878899 lseek(5, 0, SEEK_CUR)   = 1148
09:01:56.879001 close(5)                = 0
09:01:56.879214 stat("modules/POE/Resource/Clock.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:56.879336 stat("modules/POE/Resource/Clock.pm", {st_mode=S_IFREG|0600, st_size=14222, ...}) = 0
09:01:56.879471 open("modules/POE/Resource/Clock.pm", O_RDONLY) = 5
09:01:56.879590 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.879696 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.879821 read(5, "# Manage a platonic, monotonic clock to keep the event queue ordered\n\npackage POE::Resource::Clock;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse strict;\n\nuse Config;\nuse POSIX;\nuse POE::Pipe::OneWay;\nuse File::Spec;\n\nrequire Exporter;\nour @EXPORT_OK = qw( monotime sleep walltime wall2mono mono2wall time );\nour @ISA = qw( Exporter );\n\nsub DEBUG () { 0 }\n\nsub CLK_TIMEOUT () { 0 }\nsub CLK_SKEW    () { 1 }\n\nsub CLK_EN_READ () { \"rt-lock-read\" }\n\n\n# Perform a runtime check for a compile-time flag.\n#\n# TODO - Enable compiler optimization of all calls to this function.\n# The customary way to do this is to migrate the environment variable\n# value into a constant at compile time, then for all callers to check\n# the constant directly.  This is such a common thing to do that POE\n# should define a utility library for it.\n\nsub _do_X \n{\n    my( $X, $default ) = @_;\n    my $m = $X;\n    return POE::Kernel->can( $m )->() if POE::Kernel->can( $m );\n    my $k = \"POE_$X\";\n    return $ENV{$k} if exists $ENV{$k};\n    return $default if defined $default;\n    return 1;\n}\n\n\n# Try to get the exact difference between the monotonic clock's epoch\n# and the system clock's epoch.  We do this by comparing the 2 for\n# 0.25 second or 10 samples.  To compensate for delays between calling\n# time and get_time, we run in both order.  Even so, I still see up to\n# 10 mS divergence in my dev VM between invocations.\n#\n# Only called once, at compile time.\n\nsub _exact_epoch\n{\n    my( $monoclock ) = @_;\n\n    my $N=0;\n    my $total = 0;\n    my $end = $monoclock->get_time() + 0.25;\n    while( $end > $monoclock->get_time() or $N < 20) {\n        my $hr = Time::HiRes::time();\n        my $mono = $monoclock->get_time();\n        $total += $hr - $mono;\n        $N++;\n        $mono = $monoclock->get_time();\n        $hr = Time::HiRes::time();\n        $total += $hr - $mono;\n        $N++;\n    }\n    DEBUG and POE::Kernel::_warn( \"<ck> RT clock samples=$N\" );\n    return $total/$N;\n}\n\n\n#########################################\nsub _get_epoch\n{\n    my( $monoclock, $wallclock ) = @_;\n    return $wallclock->get_time() - $monoclock->get_time();\n}\n\n\n#########################################\nour $FORMAT = 'iF';\nour $LENGTH = length pack $FORMAT, 0, 0;\nsub _pipe_write\n{\n    my( $write, $op, $skew ) = @_;\n    DEBUG and POE::Kernel::_warn( \"<ck> write op=$op\" );\n    my $buffer = pack $FORMAT, $op, $skew;\n    syswrite( $write, $buffer, $LENGTH );\n}\n\n\n#########################################\nsub _pipe_read\n{\n    my( $read ) = @_;\n    my $buffer;\n    sysread( $read, $buffer, $LENGTH );\n    return unless length $buffer;\n    return unpack $FORMAT, $buffer;\n}\n\n\nour( $SIGACT, $SIGSET );\nsub _build_sig\n{\n    my( $write ) = @_;\n    my $handler = sub {\n            DEBUG and POE::Kernel::_warn( \"<ck> timeout\" );\n            _pipe_write( $write, CLK_TIMEOUT, 0 );\n        };\n    my $default = eval { _sig_number( 'RTMIN' ) } ||\n                  eval { _sig_number( 'RTALRM' ) } ||\n                  SIGALRM;\n\n    my $signal = _do_X( 'CLOCK_SIGNAL', $default ) || $default;\n    $SIGSET = POSIX::SigSet->new( $signal );\n    $SIGACT = POSIX::SigAction->new( $handler, $SIGSET, 0 );\n    $SIGACT->safe(1);\n    POSIX::sigaction( $signal, $SIGACT );\n    return $signal;\n}\n\n\n#########################################\nsub _rt_setup\n{\n    my( $read, $kernel ) = @_;\n    $kernel->loop_pause_time_watcher();\n    DEBUG and POE::Kernel::_warn( \"<ck> Setup RT pipe\" );\n    # Add to the select list\n    $kernel->_data_handle_condition( $read );\n    $kernel->loop_watch_filehandle( $read, POE::Kernel::MODE_RD() );\n}\n\n\nour $EPSILON = 0.0001;\nsub _rt_resume\n{\n    my( $what, $timer, $kernel, $pri ) = @_;\n    DEBUG and POE::Kernel::_warn( \"<ck> $what pri=$pri\" );\n    $kernel->loop_pause_time_watcher();\n    if( $pri <= monotime() ) {\n        $timer->set_timeout( $EPSILON );\n    }\n    else {\n        $timer->set_timeout( $pri, 0, 1 );\n    }\n}\n\n\nsub _rt_pause\n{\n    my( $timer, $kernel ) = @_;\n    DEBUG and POE::Kernel::_warn( \"<ck> Pause\" );\n    $timer->set_timeout( 60 );\n    $kernel->loop_pause_time_watcher();\n}\n\n\n#########################################\nsub _rt_read_pipe\n{\n    my( $kernel, $read ) = @_;\n    my $dispatch_once;\n    while( 1 ) {\n        my( $op, $skew ) = _pipe_read( $read );\n        return unless defined $op;\n        DEBUG and POE::Kernel::_warn( \"<ck> Read pipe op=$op\" );\n        if( $op == CLK_TIMEOUT ) {\n            next unless $dispatch_once;\n            $kernel->_data_ev_dispatch_due();\n            $dispatch_once = 1;\n        }\n        elsif( $op == CLK_SKEW ) {\n            rt_skew( $kernel );\n            $dispatch_once = 0;\n        }\n        elsif( DEBUG ) {\n            POE::Kernel::_warn( \"<ck> Unknown op=$op\" );\n        }\n    }\n}\n\n\n#########################################\nsub _rt_ready\n{\n    my( $read, $frd, $kernel, $fileno ) = @_;\n    return 0 unless $frd == $fileno;\n    _rt_read_pipe( $kernel, $read );\n    return 1;\n}\n\n\n#########################################\nmy %SIGnames;\nsub _sig_number\n{\n    my( $name ) = @_;\n    return $name if $name =~ /^\\d+$/;\n    my $X = 0;\n    $X = $1 if $name =~ s/\\+(\\d+)$//;\n    unless( %SIGnames ) {\n        # this code is lifted from Config pod\n        die \"Config is missing either sig_name or sig_num;  You must use a numeric signal\"\n            unless $Config{sig_name} and $Config{sig_num};\n        my @names = split ' ', $Config{sig_name};\n        @SIGnames{@names} = split ' ', $Config{sig_num};\n    }\n    return $SIGnames{ $name }+$X;\n}\n\n\n#########################################\nBEGIN {\n    my $done;\n    my $have_clock;\n    if( _do_X( 'USE_POSIXRT' ) ) {\n        eval {\n            require File::Spec->catfile( qw( POSIX RT Clock.pm ) );\n            require File::Spec->catfile( qw( POSIX RT Timer.pm ) );\n            my $monoclock = POSIX::RT::Clock->new( 'monotonic' );\n            my $wallclock = POSIX::RT::Clock->new( 'realtime' );\n            *monotime = sub { return $monoclock->get_time(); };\n            *walltime = sub { return $wallclock->get_time(); };\n            *sleep = sub { $monoclock->sleep_deeply(@_) };\n            if( _do_X( 'USE_STATIC_EPOCH' ) ) {\n                # This is where we cheat:  without a static epoch the tests fail\n                # because they expect alarm(), alarm_set() to arrive in order\n                # Calling _get_epoch() each time would preclude this\n                my $epoch = 0;\n                if( _do_X( 'USE_EXACT_EPOCH', 0 ) ) {\n                    $epoch = _exact_epoch( $monoclock, $wallclock );\n                }\n                else {\n                    $epoch = _get_epoch( $monoclock, $wallclock );\n                }\n                DEBUG and warn( \"<ck> epoch=$epoch\" );\n                *wall2mono = sub { $_[0] - $epoch };\n                *mono2wall = sub { $_[0] + $epoch };\n            }\n            else {\n                *wall2mono = sub { $_[0] - _get_epoch($monoclock, $wallclock) };\n                *mono2wall = sub { $_[0] + _get_epoch($monoclock, $wallclock) };\n\n                my ($rd, $wr) = POE::Pipe::OneWay->new();\n                die \"Unable to build pipe: $!\" unless defined $rd;\n\n                my $signal = _build_sig( $wr );\n\n                my $timer = POSIX::RT::Timer->new(\n                  value    => 0,\n                  interval => 0,\n                  clock    => 'monotonic',\n                  signal   => $signal\n                );\n\n                $EPSILON = $monoclock->get_resolution();\n                DEBUG and warn( \"<ck> epsilon=$EPSILON\" );\n                #*clock_pause  = sub { _rt_pause( $timer, @_ ); };\n                #*clock_reset  = sub { _rt_resume( Reset           = > $timer, @_ ); };\n                #*clock_resume = sub { _rt_resume( Resume          = > $timer, @_ ); };\n                #*clock_setup  = sub { _rt_setup( $rd, @_ ) };\n                my $frd = fileno( $rd );\n                #*clock_read = sub { _rt_ready( $rd, $frd, @_ ) };\n                $have_clock = 1;\n            }\n            $done = 1;\n        };\n        if( DEBUG ) {\n            warn( \"<ck> POSIX::RT::Clock not installed: $@\" ) if $@;\n            warn( \"<ck> using POSIX::RT::Clock\" ) if $done;\n ", 8192) = 8192
09:01:56.880859 stat("modules/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.880981 stat("modules/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.881097 stat("modules/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.881217 stat("modules/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.881332 stat("/etc/perl/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.881447 stat("/etc/perl/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.881563 stat("/usr/local/lib/perl/5.14.2/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.881698 stat("/usr/local/lib/perl/5.14.2/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.881811 stat("/usr/local/share/perl/5.14.2/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.881920 stat("/usr/local/share/perl/5.14.2/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.882045 stat("/usr/lib/perl5/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.882171 stat("/usr/lib/perl5/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.882284 stat("/usr/share/perl5/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.882391 stat("/usr/share/perl5/Config.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.882500 stat("/usr/lib/perl/5.14/Config.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.882609 stat("/usr/lib/perl/5.14/Config.pm", {st_mode=S_IFREG|0644, st_size=3171, ...}) = 0
09:01:56.882737 open("/usr/lib/perl/5.14/Config.pm", O_RDONLY) = 6
09:01:56.882852 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.882951 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.883082 read(6, "# This file was created by configpm when Perl was built. Any changes\n# made to this file will be lost the next time perl is built.\n\n# for a description of the variables, please have a look at the\n# Glossary file, as written in the Porting folder, or use the url:\n# http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary\n\npackage Config;\nuse strict;\nuse warnings;\nuse vars '%Config';\n\n# Skip @Config::EXPORT because it only contains %Config, which we special\n# case below as it's not a function. @Config::EXPORT won't change in the\n# lifetime of Perl 5.\nmy %Export_Cache = (myconfig => 1, config_sh => 1, config_vars => 1,\n\t\t    config_re => 1, compile_date => 1, local_patches => 1,\n\t\t    bincompat_options => 1, non_bincompat_options => 1,\n\t\t    header_files => 1);\n\n@Config::EXPORT = qw(%Config);\n@Config::EXPORT_OK = keys %Export_Cache;\n\n# Need to stub all the functions to make code such as print Config::config_sh\n# keep working\n\nsub bincompat_options;\nsub compile_date;\nsub config_re;\nsub config_sh;\nsub config_vars;\nsub header_files;\nsub local_patches;\nsub myconfig;\nsub non_bincompat_options;\n\n# Define our own import method to avoid pulling in the full Exporter:\nsub import {\n    shift;\n    @_ = @Config::EXPORT unless @_;\n\n    my @funcs = grep $_ ne '%Config', @_;\n    my $export_Config = @funcs < @_ ? 1 : 0;\n\n    no strict 'refs';\n    my $callpkg = caller(0);\n    foreach my $func (@funcs) {\n\tdie qq{\"$func\" is not exported by the Config module\\n}\n\t    unless $Export_Cache{$func};\n\t*{$callpkg.'::'.$func} = \\&{$func};\n    }\n\n    *{\"$callpkg\\::Config\"} = \\%Config if $export_Config;\n    return;\n}\n\ndie \"Perl lib version (5.14.2) doesn't match executable '$0' version ($])\"\n    unless $^V;\n\n$^V eq 5.14.2\n    or die \"Perl lib version (5.14.2) doesn't match executable '$0' version (\" .\n\tsprintf(\"v%vd\",$^V) . \")\";\n\nsub FETCH {\n    my($self, $key) = @_;\n\n    # check for cached value (which may be undef so we use exists not defined)\n    return exists $self->{$key} ? $self->{$key} : $self->fetch_string($key);\n}\n\nsub TIEHASH {\n    bless $_[1], $_[0];\n}\n\nsub DESTROY { }\n\nsub AUTOLOAD {\n    require 'Config_heavy.pl';\n    goto \\&launcher unless $Config::AUTOLOAD =~ /launcher$/;\n    die \"&Config::AUTOLOAD failed on $Config::AUTOLOAD\";\n}\n\n# tie returns the object, so the value returned to require will be true.\ntie %Config, 'Config', {\n    archlibexp => '/usr/lib/perl/5.14',\n    archname => 'x86_64-linux-gnu-thread-multi',\n    cc => 'cc',\n    d_readlink => 'define',\n    d_symlink => 'define',\n    dlext => 'so',\n    dlsrc => 'dl_dlopen.xs',\n    dont_use_nlink => undef,\n    exe_ext => '',\n    inc_version_list => '',\n    intsize => '4',\n    ldlibpthname => 'LD_LIBRARY_PATH',\n    libpth => '/usr/local/lib /lib/x86_64-linux-gnu /lib/../lib /usr/lib/x86_64-linux-gnu /usr/lib/../lib /lib /usr/lib',\n    osname => 'linux',\n    osvers => '3.2.0-4-amd64',\n    path_sep => ':',\n    privlibexp => '/usr/share/perl/5.14',\n    scriptdir => '/usr/bin',\n    sitearchexp => '/usr/local/lib/perl/5.14.2',\n    sitelibexp => '/usr/local/share/perl/5.14.2',\n    so => 'so',\n    useithreads => 'define',\n    usevendorprefix => 'define',\n    version => '5.14.2',\n};\n", 8192) = 3171
09:01:56.884015 brk(0x746000)           = 0x746000
09:01:56.884324 read(6, "", 8192)       = 0
09:01:56.884429 close(6)                = 0
09:01:56.884691 stat("modules/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.884803 stat("modules/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.884912 stat("modules/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.885017 stat("modules/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.885123 stat("/etc/perl/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.885235 stat("/etc/perl/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.885344 stat("/usr/local/lib/perl/5.14.2/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.885455 stat("/usr/local/lib/perl/5.14.2/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.885576 stat("/usr/local/share/perl/5.14.2/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.885693 stat("/usr/local/share/perl/5.14.2/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.885805 stat("/usr/lib/perl5/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.885911 stat("/usr/lib/perl5/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.886018 stat("/usr/share/perl5/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.886156 stat("/usr/share/perl5/POSIX.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.886268 stat("/usr/lib/perl/5.14/POSIX.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.886380 stat("/usr/lib/perl/5.14/POSIX.pm", {st_mode=S_IFREG|0644, st_size=1556, ...}) = 0
09:01:56.886507 open("/usr/lib/perl/5.14/POSIX.pm", O_RDONLY) = 6
09:01:56.886621 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.886721 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.886854 read(6, "package POSIX;\nuse strict;\nuse warnings;\n\nour(@ISA, %EXPORT_TAGS, @EXPORT_OK, @EXPORT, $AUTOLOAD, %SIGRT) = ();\n\nour $VERSION = \"1.24\";\n\nuse AutoLoader;\n\nrequire XSLoader;\n\nuse Fcntl qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK F_SETFD\n\t     F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK O_ACCMODE O_APPEND\n\t     O_CREAT O_EXCL O_NOCTTY O_NONBLOCK O_RDONLY O_RDWR O_TRUNC\n\t     O_WRONLY SEEK_CUR SEEK_END SEEK_SET\n\t     S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG\n\t     S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU S_ISGID S_ISUID\n\t     S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR);\n\n# Grandfather old foo_h form to new :foo_h form\nmy $loaded;\n\nsub import {\n    load_imports() unless $loaded++;\n    my $this = shift;\n    my @list = map { m/^\\w+_h$/ ? \":$_\" : $_ } @_;\n    local $Exporter::ExportLevel = 1;\n    Exporter::import($this,@list);\n}\n\nsub croak { require Carp;  goto &Carp::croak }\n# declare usage to assist AutoLoad\nsub usage;\n\nXSLoader::load();\n\nsub AUTOLOAD {\n    no warnings 'uninitialized';\n    if ($AUTOLOAD =~ /::(_?[a-z])/) {\n\t# require AutoLoader;\n\t$AutoLoader::AUTOLOAD = $AUTOLOAD;\n\tgoto &AutoLoader::AUTOLOAD\n    }\n    my $constname = $AUTOLOAD;\n    $constname =~ s/.*:://;\n    constant($constname);\n}\n\npackage POSIX::SigAction;\n\nuse AutoLoader 'AUTOLOAD';\n\npackage POSIX::SigRt;\n\nuse AutoLoader 'AUTOLOAD';\n\nuse Tie::Hash;\n\nuse vars qw($SIGACTION_FLAGS $_SIGRTMIN $_SIGRTMAX $_sigrtn @ISA);\n@POSIX::SigRt::ISA = qw(Tie::StdHash);\n\n$SIGACTION_FLAGS = 0;\n\ntie %POSIX::SIGRT, 'POSIX::SigRt';\n\nsub DESTROY {};\n\npackage POSIX;\n\n1;\n", 8192) = 1556
09:01:56.887236 stat("modules/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.887347 stat("modules/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.887457 stat("modules/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.887562 stat("modules/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.887669 stat("/etc/perl/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.887778 stat("/etc/perl/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.887894 stat("/usr/local/lib/perl/5.14.2/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.888005 stat("/usr/local/lib/perl/5.14.2/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.888117 stat("/usr/local/share/perl/5.14.2/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.888227 stat("/usr/local/share/perl/5.14.2/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.888337 stat("/usr/lib/perl5/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.888445 stat("/usr/lib/perl5/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.888565 stat("/usr/share/perl5/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.888675 stat("/usr/share/perl5/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.888783 stat("/usr/lib/perl/5.14/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.888894 stat("/usr/lib/perl/5.14/AutoLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.889004 stat("/usr/share/perl/5.14/AutoLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.889114 stat("/usr/share/perl/5.14/AutoLoader.pm", {st_mode=S_IFREG|0644, st_size=5404, ...}) = 0
09:01:56.889250 open("/usr/share/perl/5.14/AutoLoader.pm", O_RDONLY) = 7
09:01:56.889365 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.889465 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.889596 read(7, "package AutoLoader;\n\nuse strict;\nuse 5.006_001;\n\nour($VERSION, $AUTOLOAD);\n\nmy $is_dosish;\nmy $is_epoc;\nmy $is_vms;\nmy $is_macos;\n\nBEGIN {\n    $is_dosish = $^O eq 'dos' || $^O eq 'os2' || $^O eq 'MSWin32' || $^O eq 'NetWare';\n    $is_epoc = $^O eq 'epoc';\n    $is_vms = $^O eq 'VMS';\n    $is_macos = $^O eq 'MacOS';\n    $VERSION = '5.71';\n}\n\nAUTOLOAD {\n    my $sub = $AUTOLOAD;\n    my $filename = AutoLoader::find_filename( $sub );\n\n    my $save = $@;\n    local $!; # Do not munge the value. \n    eval { local $SIG{__DIE__}; require $filename };\n    if ($@) {\n\tif (substr($sub,-9) eq '::DESTROY') {\n\t    no strict 'refs';\n\t    *$sub = sub {};\n\t    $@ = undef;\n\t} elsif ($@ =~ /^Can't locate/) {\n\t    # The load might just have failed because the filename was too\n\t    # long for some old SVR3 systems which treat long names as errors.\n\t    # If we can successfully truncate a long name then it's worth a go.\n\t    # There is a slight risk that we could pick up the wrong file here\n\t    # but autosplit should have warned about that when splitting.\n\t    if ($filename =~ s/(\\w{12,})\\.al$/substr($1,0,11).\".al\"/e){\n\t\teval { local $SIG{__DIE__}; require $filename };\n\t    }\n\t}\n\tif ($@){\n\t    $@ =~ s/ at .*\\n//;\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::croak($error);\n\t}\n    }\n    $@ = $save;\n    goto &$sub;\n}\n\nsub find_filename {\n    my $sub = shift;\n    my $filename;\n    # Braces used to preserve $1 et al.\n    {\n\t# Try to find the autoloaded file from the package-qualified\n\t# name of the sub. e.g., if the sub needed is\n\t# Getopt::Long::GetOptions(), then $INC{Getopt/Long.pm} is\n\t# something like '/usr/lib/perl5/Getopt/Long.pm', and the\n\t# autoload file is '/usr/lib/perl5/auto/Getopt/Long/GetOptions.al'.\n\t#\n\t# However, if @INC is a relative path, this might not work.  If,\n\t# for example, @INC = ('lib'), then $INC{Getopt/Long.pm} is\n\t# 'lib/Getopt/Long.pm', and we want to require\n\t# 'auto/Getopt/Long/GetOptions.al' (without the leading 'lib').\n\t# In this case, we simple prepend the 'auto/' and let the\n\t# C<require> take care of the searching for us.\n\n\tmy ($pkg,$func) = ($sub =~ /(.*)::([^:]+)$/);\n\t$pkg =~ s#::#/#g;\n\tif (defined($filename = $INC{\"$pkg.pm\"})) {\n\t    if ($is_macos) {\n\t\t$pkg =~ tr#/#:#;\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto:$pkg:$func.al#s;\n\t    } else {\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto/$pkg/$func.al#s;\n\t    }\n\n\t    # if the file exists, then make sure that it is a\n\t    # a fully anchored path (i.e either '/usr/lib/auto/foo/bar.al',\n\t    # or './lib/auto/foo/bar.al'.  This avoids C<require> searching\n\t    # (and failing) to find the 'lib/auto/foo/bar.al' because it\n\t    # looked for 'lib/lib/auto/foo/bar.al', given @INC = ('lib').\n\n\t    if (defined $filename and -r $filename) {\n\t\tunless ($filename =~ m|^/|s) {\n\t\t    if ($is_dosish) {\n\t\t\tunless ($filename =~ m{^([a-z]:)?[\\\\/]}is) {\n\t\t\t    if ($^O ne 'NetWare') {\n\t\t\t\t$filename = \"./$filename\";\n\t\t\t    } else {\n\t\t\t\t$filename = \"$filename\";\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_epoc) {\n\t\t\tunless ($filename =~ m{^([a-z?]:)?[\\\\/]}is) {\n\t\t\t     $filename = \"./$filename\";\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_vms) {\n\t\t\t# XXX todo by VMSmiths\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t    elsif (!$is_macos) {\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\t$filename = undef;\n\t    }\n\t}\n\tunless (defined $filename) {\n\t    # let C<require> do the searching\n\t    $filename = \"auto/$sub.al\";\n\t    $filename =~ s#::#/#g;\n\t}\n    }\n    return $filename;\n}\n\nsub import {\n    my $pkg = shift;\n    my $callpkg = caller;\n\n    #\n    # Export symbols, but not by accident of inheritance.\n    #\n\n    if ($pkg eq 'AutoLoader') {\n\tif ( @_ and $_[0] =~ /^&?AUTOLOAD$/ ) {\n\t    no strict 'refs';\n\t    *{ $callpkg . '::AUTOLOAD' } = \\&AUTOLOAD;\n\t}\n    }\n\n    #\n    # Try to find the autosplit index file.  Eg., if the call package\n    # is POSIX, then $INC{POSIX.pm} is something like\n    # '/usr/local/lib/perl5/POSIX.pm', and the autosplit index file is in\n    # '/usr/local/lib/perl5/auto/POSIX/autosplit.ix', so we require that.\n    #\n    # However, if @INC is a relative path, this might not work.  If,\n    # for example, @INC = ('lib'), then\n    # $INC{POSIX.pm} is 'lib/POSIX.pm', and we want to require\n    # 'auto/POSIX/autosplit.ix' (without the leading 'lib').\n    #\n\n    (my $calldir = $callpkg) =~ s#::#/#g;\n    my $path = $INC{$calldir . '.pm'};\n    if (defined($path)) {\n\t# Try absolute path name, but only eval it if the\n        # transformation from module path to autosplit.ix path\n        # succeeded!\n\tmy $replaced_okay;\n\tif ($is_macos) {\n\t    (my $malldir = $calldir) =~ tr#/#:#;\n\t    $replaced_okay = ($path =~ s#^(.*)$malldir\\.pm\\z#$1auto:$malldir:autosplit.ix#s);\n\t} else {\n\t    $replaced_okay = ($path =~ s#^(.*)$calldir\\.pm\\z#$1auto/$calldir/autosplit.ix#);\n\t}\n\n\teval { require $path; } if $replaced_okay;\n\t# If that failed, try relative path with normal @INC searching.\n\tif (!$replaced_okay or $@) {\n\t    $path =\"auto/$calldir/autosplit.ix\";\n\t    eval { require $path; };\n\t}\n\tif ($@) {\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::carp($error);\n\t}\n    } \n}\n\nsub unimport {\n    my $callpkg = caller;\n\n    no strict 'refs';\n\n    for my $exported (qw( AUTOLOAD )) {\n\tmy $symname = $callpkg . '::' . $exported;\n\tundef *{ $symname } if \\&{ $symname } == \\&{ $exported };\n\t*{ $symname } = \\&{ $symname };\n    }\n}\n\n1;\n\n__END__\n\n", 8192) = 5404
09:01:56.891578 lseek(7, 5403, SEEK_SET) = 5403
09:01:56.891685 lseek(7, 0, SEEK_CUR)   = 5403
09:01:56.891783 close(7)                = 0
09:01:56.891966 stat("/usr/lib/perl/5.14/auto/POSIX/autosplit.ix", {st_mode=S_IFREG|0644, st_size=2463, ...}) = 0
09:01:56.892104 open("/usr/lib/perl/5.14/auto/POSIX/autosplit.ix", O_RDONLY) = 7
09:01:56.892220 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.892320 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.892440 read(7, "# Index created by AutoSplit for ../../lib/POSIX.pm\n#    (file acts as timestamp)\npackage POSIX;\nsub usage  ;\nsub redef  ;\nsub unimpl  ;\nsub assert  ;\nsub tolower  ;\nsub toupper  ;\nsub closedir  ;\nsub opendir  ;\nsub readdir  ;\nsub rewinddir  ;\nsub errno  ;\nsub creat  ;\nsub fcntl  ;\nsub getgrgid  ;\nsub getgrnam  ;\nsub atan2  ;\nsub cos  ;\nsub exp  ;\nsub fabs  ;\nsub log  ;\nsub pow  ;\nsub sin  ;\nsub sqrt  ;\nsub getpwnam  ;\nsub getpwuid  ;\nsub longjmp  ;\nsub setjmp  ;\nsub siglongjmp  ;\nsub sigsetjmp  ;\nsub kill  ;\nsub raise  ;\nsub offsetof  ;\nsub clearerr  ;\nsub fclose  ;\nsub fdopen  ;\nsub feof  ;\nsub fgetc  ;\nsub fgets  ;\nsub fileno  ;\nsub fopen  ;\nsub fprintf  ;\nsub fputc  ;\nsub fputs  ;\nsub fread  ;\nsub freopen  ;\nsub fscanf  ;\nsub fseek  ;\nsub fsync  ;\nsub ferror  ;\nsub fflush  ;\nsub fgetpos  ;\nsub fsetpos  ;\nsub ftell  ;\nsub fwrite  ;\nsub getc  ;\nsub getchar  ;\nsub gets  ;\nsub perror  ;\nsub printf  ;\nsub putc  ;\nsub putchar  ;\nsub puts  ;\nsub remove  ;\nsub rename  ;\nsub rewind  ;\nsub scanf  ;\nsub sprintf  ;\nsub sscanf  ;\nsub tmpfile  ;\nsub ungetc  ;\nsub vfprintf  ;\nsub vprintf  ;\nsub vsprintf  ;\nsub abs  ;\nsub atexit  ;\nsub atof  ;\nsub atoi  ;\nsub atol  ;\nsub bsearch  ;\nsub calloc  ;\nsub div  ;\nsub exit  ;\nsub free  ;\nsub getenv  ;\nsub labs  ;\nsub ldiv  ;\nsub malloc  ;\nsub qsort  ;\nsub rand  ;\nsub realloc  ;\nsub srand  ;\nsub system  ;\nsub memchr  ;\nsub memcmp  ;\nsub memcpy  ;\nsub memmove  ;\nsub memset  ;\nsub strcat  ;\nsub strchr  ;\nsub strcmp  ;\nsub strcpy  ;\nsub strcspn  ;\nsub strerror  ;\nsub strlen  ;\nsub strncat  ;\nsub strncmp  ;\nsub strncpy  ;\nsub strpbrk  ;\nsub strrchr  ;\nsub strspn  ;\nsub strstr  ;\nsub strtok  ;\nsub chmod  ;\nsub fstat  ;\nsub mkdir  ;\nsub stat  ;\nsub umask  ;\nsub wait  ;\nsub waitpid  ;\nsub gmtime  ;\nsub localtime  ;\nsub time  ;\nsub alarm  ;\nsub chdir  ;\nsub chown  ;\nsub execl  ;\nsub execle  ;\nsub execlp  ;\nsub execv  ;\nsub execve  ;\nsub execvp  ;\nsub fork  ;\nsub getegid  ;\nsub geteuid  ;\nsub getgid  ;\nsub getgroups  ;\nsub getlogin  ;\nsub getpgrp  ;\nsub getpid  ;\nsub getppid  ;\nsub getuid  ;\nsub isatty  ;\nsub link  ;\nsub rmdir  ;\nsub setbuf  ;\nsub setvbuf  ;\nsub sleep  ;\nsub unlink  ;\nsub utime  ;\nsub load_imports  ;\npackage POSIX::SigAction;\nsub new  ;\nsub handler  ;\nsub mask     ;\nsub flags    ;\nsub safe     ;\npackage POSIX::SigRt;\nsub _init  ;\nsub _croak  ;\nsub _getsig  ;\nsub _exist  ;\nsub _check  ;\nsub new  ;\nsub EXISTS  ;\nsub FETCH   ;\nsub STORE   ;\nsub DELETE  ;\nsub CLEAR   ;\nsub SCALAR  ;\n1;\n", 8192) = 2463
09:01:56.893506 read(7, "", 8192)       = 0
09:01:56.893613 close(7)                = 0
09:01:56.893801 stat("modules/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.893890 stat("modules/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.893978 stat("modules/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894082 stat("modules/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.894173 stat("/etc/perl/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894260 stat("/etc/perl/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.894348 stat("/usr/local/lib/perl/5.14.2/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894438 stat("/usr/local/lib/perl/5.14.2/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.894527 stat("/usr/local/share/perl/5.14.2/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894616 stat("/usr/local/share/perl/5.14.2/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.894706 stat("/usr/lib/perl5/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894792 stat("/usr/lib/perl5/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.894879 stat("/usr/share/perl5/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.894967 stat("/usr/share/perl5/Fcntl.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.895055 stat("/usr/lib/perl/5.14/Fcntl.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.895144 stat("/usr/lib/perl/5.14/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=2036, ...}) = 0
09:01:56.895246 open("/usr/lib/perl/5.14/Fcntl.pm", O_RDONLY) = 7
09:01:56.895339 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.895419 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.895511 brk(0x768000)           = 0x768000
09:01:56.895605 read(7, "package Fcntl;\n\nuse strict;\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nrequire Exporter;\nrequire XSLoader;\n@ISA = qw(Exporter);\n$VERSION = '1.11';\n\nXSLoader::load();\n\n# Named groups of exports\n%EXPORT_TAGS = (\n    'flock'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    'Fcompat' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    'seek'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    'mode'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = (qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_MAND\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n), map {@{$_}} values %EXPORT_TAGS);\n\n1;\n", 8192) = 2036
09:01:56.896103 read(7, "", 8192)       = 0
09:01:56.896191 close(7)                = 0
09:01:56.896301 stat("modules/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.896390 stat("modules/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.896479 stat("modules/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.896564 stat("modules/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.896650 stat("/etc/perl/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.896736 stat("/etc/perl/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.896824 stat("/usr/local/lib/perl/5.14.2/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.896913 stat("/usr/local/lib/perl/5.14.2/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.897002 stat("/usr/local/share/perl/5.14.2/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.897093 stat("/usr/local/share/perl/5.14.2/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.897191 stat("/usr/lib/perl5/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.897280 stat("/usr/lib/perl5/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.897367 stat("/usr/share/perl5/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.897454 stat("/usr/share/perl5/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.897542 stat("/usr/lib/perl/5.14/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.897630 stat("/usr/lib/perl/5.14/XSLoader.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.897743 stat("/usr/share/perl/5.14/XSLoader.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.897850 stat("/usr/share/perl/5.14/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=2991, ...}) = 0
09:01:56.897993 open("/usr/share/perl/5.14/XSLoader.pm", O_RDONLY) = 7
09:01:56.898149 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.898250 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.898386 read(7, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.13\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\npackage DynaLoader;\n\n# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    my ($module, $modlibname) = caller();\n\n    if (@_) {\n\t$module = $_[0];\n    } else {\n\t$_[0] = $module;\n    }\n\n    # work with static linking too\n    my $boots = \"$module\\::bootstrap\";\n    goto &$boots if defined &$boots;\n\n    goto \\&XSLoader::bootstrap_inherit unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join('/',@modparts);\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.so\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs 'beside' the library\n\n    if (-s $bs) { # only read file if it's not empty\n#       print STDERR \"BS: $bs ($^O, $dlsrc)\\n\" if $dl_debug;\n        eval { do $bs; };\n        warn \"$bs: $@\\n\" if $@;\n    }\n\n    goto \\&XSLoader::bootstrap_inherit if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can't load '$file' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can't find '$bootname' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub($boots, $boot_symbol_ref, $file);\n\n    # See comment block above\n    push(@DynaLoader::dl_shared_objects, $file); # record files loaded\n    return &$xs(@_);\n}\n\nsub bootstrap_inherit {\n    require DynaLoader;\n    goto \\&DynaLoader::bootstrap_inherit;\n}\n\n1;\n\n__END__\n\n", 8192) = 2991
09:01:56.899267 lseek(7, 2990, SEEK_SET) = 2990
09:01:56.899383 lseek(7, 0, SEEK_CUR)   = 2990
09:01:56.899477 close(7)                = 0
09:01:56.899688 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.899821 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=18672, ...}) = 0
09:01:56.899962 stat("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.900103 futex(0x7f74369990ec, FUTEX_WAKE_PRIVATE, 2147483647) = 0
09:01:56.900234 open("/usr/lib/perl/5.14/auto/Fcntl/Fcntl.so", O_RDONLY) = 7
09:01:56.900358 read(7, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\35\0\0\0\0\0\0@\0\0\0\0\0\0\0\360A\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2140\0\0\0\0\0\0\2140\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\3601\0\0\0\0\0\0\3601 \0\0\0\0\0\3601 \0\0\0\0\0\370\16\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320=\0\0\0\0\0\0\320= \0\0\0\0\0\320= \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\340.\0\0\0\0\0\0\340.\0\0\0\0\0\0\340.\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\3601\0\0\0\0\0\0\3601 \0\0\0\0\0\3601 \0\0\0\0\0\20\16\0\0\0\0\0\0\20\16\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\3370o+!\26#\244_\317\375\275`p\7J\31\302\206\7\0\0\0\0%\0\0\0,\0\0\0\0\0\0\0\30\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\31\0\0\0\r\0\0\0\21\0\0\0\0\0\0\0\17\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\37\0\0\0\6\0\0\0#\0\0\0*\0\0\0!\0\0\0\0\0\0\0\0\0\0\0(\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0'\0\0\0 \0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\27\0\0\0\"\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\0\0\0\0\7\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\23\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\t\0\0\0\24\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\16\0\0\0\25\0\0\0\20\0\0\0\0\0\0\0)\0\0\0\3\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\f\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.900654 fstat(7, {st_mode=S_IFREG|0644, st_size=18672, ...}) = 0
09:01:56.900784 mmap(NULL, 2113776, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 7, 0) = 0x7f743593c000
09:01:56.900872 mprotect(0x7f7435940000, 2093056, PROT_NONE) = 0
09:01:56.900990 mmap(0x7f7435b3f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 7, 0x3000) = 0x7f7435b3f000
09:01:56.901124 close(7)                = 0
09:01:56.901260 mprotect(0x7f7435b3f000, 4096, PROT_READ) = 0
09:01:56.902135 stat("modules/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.902233 stat("modules/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.902321 stat("modules/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.902406 stat("modules/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.902493 stat("/etc/perl/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.902580 stat("/etc/perl/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.902667 stat("/usr/local/lib/perl/5.14.2/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.902758 stat("/usr/local/lib/perl/5.14.2/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.902846 stat("/usr/local/share/perl/5.14.2/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.902935 stat("/usr/local/share/perl/5.14.2/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.903023 stat("/usr/lib/perl5/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.903110 stat("/usr/lib/perl5/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.903198 stat("/usr/share/perl5/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.903284 stat("/usr/share/perl5/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.903372 stat("/usr/lib/perl/5.14/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.903462 stat("/usr/lib/perl/5.14/Tie/Hash.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.903551 stat("/usr/share/perl/5.14/Tie/Hash.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.903641 stat("/usr/share/perl/5.14/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=2037, ...}) = 0
09:01:56.903758 open("/usr/share/perl/5.14/Tie/Hash.pm", O_RDONLY) = 7
09:01:56.903859 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.903943 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.904044 brk(0x78a000)           = 0x78a000
09:01:56.904144 read(7, "package Tie::Hash;\n\nour $VERSION = '1.04';\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    my $pkg_new = $pkg -> can ('new');\n\n    if ($pkg_new and $pkg ne __PACKAGE__) {\n        my $my_new = __PACKAGE__ -> can ('new');\n        if ($pkg_new == $my_new) {  \n            #\n            # Prevent recursion\n            #\n            croak \"$pkg must define either a TIEHASH() or a new() method\";\n        }\n\n\twarnings::warnif (\"WARNING: calling ${pkg}->new since \" .\n                          \"${pkg}->TIEHASH is missing\");\n\t$pkg -> new (@_);\n    }\n    else {\n\tcroak \"$pkg doesn't define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn't define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 8192) = 2037
09:01:56.905107 read(7, "", 8192)       = 0
09:01:56.905199 close(7)                = 0
09:01:56.905421 read(6, "", 8192)       = 0
09:01:56.905507 close(6)                = 0
09:01:56.905645 stat("/usr/lib/perl/5.14/auto/POSIX/POSIX.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.905766 stat("/usr/lib/perl/5.14/auto/POSIX/POSIX.so", {st_mode=S_IFREG|0644, st_size=109888, ...}) = 0
09:01:56.905898 stat("/usr/lib/perl/5.14/auto/POSIX/POSIX.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.906018 open("/usr/lib/perl/5.14/auto/POSIX/POSIX.so", O_RDONLY) = 6
09:01:56.906150 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\177\0\0\0\0\0\0@\0\0\0\0\0\0\0@\246\1\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0ln\1\0\0\0\0\0ln\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\10|\1\0\0\0\0\0\10|!\0\0\0\0\0\10|!\0\0\0\0\0000)\0\0\0\0\0\0008)\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0000\232\1\0\0\0\0\0000\232!\0\0\0\0\0000\232!\0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\370T\1\0\0\0\0\0\370T\1\0\0\0\0\0\370T\1\0\0\0\0\0\254\3\0\0\0\0\0\0\254\3\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\10|\1\0\0\0\0\0\10|!\0\0\0\0\0\10|!\0\0\0\0\0\370#\0\0\0\0\0\0\370#\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\261V\263\16\352\1\224\375'\v\301\211\207sI\4\261\225Lx\0\0\0\0\7\1\0\0&\1\0\0\r\1\0\0\342\0\0\0\357\0\0\0\0\0\0\0(\0\0\0\312\0\0\0\21\1\0\0|\0\0\0{\0\0\0\10\0\0\0v\0\0\0\0\0\0\0\360\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\245\0\0\0\20\1\0\0I\0\0\0\216\0\0\0^\0\0\0\0\0\0\0\242\0\0\0\275\0\0\0/\0\0\0\0\0\0\0\225\0\0\0\0\1\0\0\234\0\0\0\211\0\0\0\314\0\0\0!\1\0\0\260\0\0\0\210\0\0\0\364\0\0\0\302\0\0\0\235\0\0\0\303\0\0\0\0\0\0\0\253\0\0\0\333\0\0\0\0\0\0\0\0\0\0\0j\0\0\0\0\0\0\0\250\0\0\0V\0\0\0\236\0\0\0\354\0\0\0\22\1\0\0#\1\0\0\363\0\0\0\334\0\0\0t\0\0\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b\0\0\0y\0\0\0c\0\0\0\221\0\0\0>\0\0\0\331\0\0\0l\0\0\0}\0\0\0C\0\0\0L\0\0\0\321\0\0\0G\0\0\0U\0\0\0\0\0\0\0p\0\0\0\352\0\0\0\0\0\0\0\265\0\0\0z\0\0\0'\0\0\0\0\0\0\0", 832) = 832
09:01:56.906457 fstat(6, {st_mode=S_IFREG|0644, st_size=109888, ...}) = 0
09:01:56.906589 mmap(NULL, 2204992, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f7435721000
09:01:56.906690 mprotect(0x7f7435738000, 2097152, PROT_NONE) = 0
09:01:56.906790 mmap(0x7f7435938000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x17000) = 0x7f7435938000
09:01:56.906919 close(6)                = 0
09:01:56.907104 mprotect(0x7f7435938000, 12288, PROT_READ) = 0
09:01:56.907556 brk(0x7ac000)           = 0x7ac000
09:01:56.907833 stat("/usr/lib/perl/5.14/auto/POSIX/load_imports.al", {st_mode=S_IFREG|0644, st_size=6950, ...}) = 0
09:01:56.908001 getgroups(0, NULL)      = 2
09:01:56.908107 getgroups(2, [1000, 1164]) = 2
09:01:56.908253 open("/usr/share/locale/locale.alias", O_RDONLY) = 6
09:01:56.908402 fstat(6, {st_mode=S_IFREG|0644, st_size=2570, ...}) = 0
09:01:56.908527 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f37000
09:01:56.908611 read(6, "# Locale name alias data base.\n# Copyright (C) 1996-2001,2003,2007 Free Software Foundation, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2, or (at your option)\n# any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n# The format of this file is the same as for the corresponding file of\n# the X Window System, which normally can be found in\n#\t/usr/lib/X11/locale/locale.alias\n# A single line contains two fields: an alias and a substitution value.\n# All entries are case independent.\n\n# Note: This file is obsolete and is kept around for the time being for\n# backward compatibility.  Nobody should rely on the names defined here.\n# Locales should always be specified by their full name.\n\nbokmal\t\tnb_NO.ISO-8859-1\nbokm\303\245l\t\tnb_NO.ISO-8859-1\ncatalan\t\tca_ES.ISO-8859-1\ncroatian\thr_HR.ISO-8859-2\nczech\t\tcs_CZ.ISO-8859-2\ndanish          da_DK.ISO-8859-1\ndansk\t\tda_DK.ISO-8859-1\ndeutsch\t\tde_DE.ISO-8859-1\ndutch\t\tnl_NL.ISO-8859-1\neesti\t\tet_EE.ISO-8859-15\nestonian\tet_EE.ISO-8859-15\nfinnish         fi_FI.ISO-8859-1\nfran\303\247ais\tfr_FR.ISO-8859-1\nfrench\t\tfr_FR.ISO-8859-1\ngalego\t\tgl_ES.ISO-8859-1\ngalician\tgl_ES.ISO-8859-1\ngerman\t\tde_DE.ISO-8859-1\ngreek           el_GR.ISO-8859-7\nhebrew          he_IL.ISO-8859-8\nhrvatski\thr_HR.ISO-8859-2\nhungarian       hu_HU.ISO-8859-2\nicelandic       is_IS.ISO-8859-1\nitalian         it_IT.ISO-8859-1\njapanese\tja_JP.eucJP\njapanese.euc\tja_JP.eucJP\nja_JP\t\tja_JP.eucJP\nja_JP.ujis\tja_JP.eucJP\njapanese.sjis\tja_JP.SJIS\nkorean\t\tko_KR.eucKR\nkorean.euc \tko_KR.eucKR\nko_KR\t\tko_KR.eucKR\nlithuanian      lt_LT.ISO-8859-13\nno_NO\t\tnb_NO.ISO-8859-1\nno_NO.ISO-8859-1 nb_NO.ISO-8859-1\nnorwegian       nb_NO.ISO-8859-1\nnynorsk\t\tnn_NO.ISO-8859-1\npolish          pl_PL.ISO-8859-2\nportuguese      pt_PT.ISO-8859-1\nromanian        ro_RO.ISO-8859-2\nrussian         ru_RU.KOI8-R\nslovak          sk_SK.ISO-8859-2\nslovene         sl_SI.ISO-8859-2\nslovenian       sl_SI.ISO-8859-2\nspanish         es_ES.ISO-8859-1\nswedish         sv_SE.ISO-8859-1\nthai\t\tth_TH.TIS-620\nturkish         tr_TR.ISO-8859-9\n", 4096) = 2570
09:01:56.908998 read(6, "", 4096)       = 0
09:01:56.909115 close(6)                = 0
09:01:56.909216 munmap(0x7f7436f37000, 4096) = 0
09:01:56.909348 open("/usr/share/locale/en_GB.UTF-8/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:56.909475 open("/usr/share/locale/en_GB.utf8/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:56.909596 open("/usr/share/locale/en_GB/LC_MESSAGES/libc.mo", O_RDONLY) = 6
09:01:56.909734 fstat(6, {st_mode=S_IFREG|0644, st_size=1474, ...}) = 0
09:01:56.909826 mmap(NULL, 1474, PROT_READ, MAP_PRIVATE, 6, 0) = 0x7f7436f37000
09:01:56.909908 close(6)                = 0
09:01:56.909999 open("/usr/share/locale/en.UTF-8/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:56.910111 open("/usr/share/locale/en.utf8/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:56.910203 open("/usr/share/locale/en/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:56.910312 stat("/usr/lib/perl/5.14/auto/POSIX/load_imports.al", {st_mode=S_IFREG|0644, st_size=6950, ...}) = 0
09:01:56.910419 open("/usr/lib/perl/5.14/auto/POSIX/load_imports.al", O_RDONLY) = 6
09:01:56.910513 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.910595 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.910704 read(6, "# NOTE: Derived from ../../lib/POSIX.pm.\n# Changes made here will be lost when autosplit is run again.\n# See AutoSplit.pm.\npackage POSIX;\n\n#line 753 \"../../lib/POSIX.pm (autosplit into ../../lib/auto/POSIX/load_imports.al)\"\nsub load_imports {\n%EXPORT_TAGS = (\n\n    assert_h =>\t[qw(assert NDEBUG)],\n\n    ctype_h =>\t[qw(isalnum isalpha iscntrl isdigit isgraph islower\n\t\tisprint ispunct isspace isupper isxdigit tolower toupper)],\n\n    dirent_h =>\t[],\n\n    errno_h =>\t[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT\n\t\tEAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED\n\t\tECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT\n\t\tEEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS\n\t\tEINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\t\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH\n\t\tENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM\n\t\tENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR\n\t\tENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\t\tEPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE\n\t\tERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT\n\t\tESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY\n\t\tEUSERS EWOULDBLOCK EXDEV errno)],\n\n    fcntl_h =>\t[qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK\n\t\tF_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK\n\t\tO_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK\n\t\tO_RDONLY O_RDWR O_TRUNC O_WRONLY\n\t\tcreat\n\t\tSEEK_CUR SEEK_END SEEK_SET\n\t\tS_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU\n\t\tS_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG S_ISUID\n\t\tS_IWGRP S_IWOTH S_IWUSR)],\n\n    float_h =>\t[qw(DBL_DIG DBL_EPSILON DBL_MANT_DIG\n\t\tDBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP\n\t\tDBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP\n\t\tFLT_DIG FLT_EPSILON FLT_MANT_DIG\n\t\tFLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP\n\t\tFLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP\n\t\tFLT_RADIX FLT_ROUNDS\n\t\tLDBL_DIG LDBL_EPSILON LDBL_MANT_DIG\n\t\tLDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP\n\t\tLDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP)],\n\n    grp_h =>\t[],\n\n    limits_h =>\t[qw( ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX\n\t\tINT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON\n\t\tMAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX\n\t\tPATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN\n\t\tSSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX\n\t\tULONG_MAX USHRT_MAX _POSIX_ARG_MAX _POSIX_CHILD_MAX\n\t\t_POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT\n\t\t_POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_OPEN_MAX\n\t\t_POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SSIZE_MAX\n\t\t_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],\n\n    locale_h =>\t[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES\n\t\t    LC_MONETARY LC_NUMERIC LC_TIME NULL\n\t\t    localeconv setlocale)],\n\n    math_h =>\t[qw(HUGE_VAL acos asin atan ceil cosh fabs floor fmod\n\t\tfrexp ldexp log10 modf pow sinh tan tanh)],\n\n    pwd_h =>\t[],\n\n    setjmp_h =>\t[qw(longjmp setjmp siglongjmp sigsetjmp)],\n\n    signal_h =>\t[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK\n\t\tSA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM\n\t\tSIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL\n\t\tSIGPIPE %SIGRT SIGRTMIN SIGRTMAX SIGQUIT SIGSEGV SIGSTOP\n\t\tSIGTERM SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2 SIGBUS\n\t\tSIGPOLL SIGPROF SIGSYS SIGTRAP SIGURG SIGVTALRM SIGXCPU SIGXFSZ\n\t\tSIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK SIG_UNBLOCK\n\t\traise sigaction signal sigpending sigprocmask sigsuspend)],\n\n    stdarg_h =>\t[],\n\n    stddef_h =>\t[qw(NULL offsetof)],\n\n    stdio_h =>\t[qw(BUFSIZ EOF FILENAME_MAX L_ctermid L_cuserid\n\t\tL_tmpname NULL SEEK_CUR SEEK_END SEEK_SET\n\t\tSTREAM_MAX TMP_MAX stderr stdin stdout\n\t\tclearerr fclose fdopen feof ferror fflush fgetc fgetpos\n\t\tfgets fopen fprintf fputc fputs fread freopen\n\t\tfscanf fseek fsetpos ftell fwrite getchar gets\n\t\tperror putc putchar puts remove rewind\n\t\tscanf setbuf setvbuf sscanf tmpfile tmpnam\n\t\tungetc vfprintf vprintf vsprintf)],\n\n    stdlib_h =>\t[qw(EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX NULL RAND_MAX\n\t\tabort atexit atof atoi atol bsearch calloc div\n\t\tfree getenv labs ldiv malloc mblen mbstowcs mbtowc\n\t\tqsort realloc strtod strtol strtoul wcstombs wctomb)],\n\n    string_h =>\t[qw(NULL memchr memcmp memcpy memmove memset strcat\n\t\tstrchr strcmp strcoll strcpy strcspn strerror strlen\n\t\tstrncat strncmp strncpy strpbrk strrchr strspn strstr\n\t\tstrtok strxfrm)],\n\n    sys_stat_h => [qw(S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU\n\t\tS_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG\n\t\tS_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR\n\t\tfstat mkfifo)],\n\n    sys_times_h => [],\n\n    sys_types_h => [],\n\n    sys_utsname_h => [qw(uname)],\n\n    sys_wait_h => [qw(WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED\n\t\tWNOHANG WSTOPSIG WTERMSIG WUNTRACED)],\n\n    termios_h => [qw( B0 B110 B1200 B134 B150 B1800 B19200 B200 B2400\n\t\tB300 B38400 B4800 B50 B600 B75 B9600 BRKINT CLOCAL\n\t\tCREAD CS5 CS6 CS7 CS8 CSIZE CSTOPB ECHO ECHOE ECHOK\n\t\tECHONL HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR\n\t\tINLCR INPCK ISIG ISTRIP IXOFF IXON NCCS NOFLSH OPOST\n\t\tPARENB PARMRK PARODD TCIFLUSH TCIOFF TCIOFLUSH TCION\n\t\tTCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW\n\t\tTOSTOP VEOF VEOL VERASE VINTR VKILL VMIN VQUIT VSTART\n\t\tVSTOP VSUSP VTIME\n\t\tcfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain\n\t\ttcflow tcflush tcgetattr tcsendbreak tcsetattr )],\n\n    time_h =>\t[qw(CLK_TCK CLOCKS_PER_SEC NULL asctime clock ctime\n\t\tdifftime mktime strftime tzset tzname)],\n\n    unistd_h =>\t[qw(F_OK NULL R_OK SEEK_CUR SEEK_END SEEK_SET\n\t\tSTDERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK\n\t\t_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON\n\t\t_PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX\n\t\t_PC_PIPE_BUF _PC_VDISABLE _POSIX_CHOWN_RESTRICTED\n\t\t_POSIX_JOB_CONTROL _POSIX_NO_TRUNC _POSIX_SAVED_IDS\n\t\t_POSIX_VDISABLE _POSIX_VERSION _SC_ARG_MAX\n\t\t_SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL\n\t\t_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS\n\t\t_SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION\n\t\t_exit access ctermid cuserid\n\t\tdup2 dup execl execle execlp execv execve execvp\n\t\tfpathconf fsync getcwd getegid geteuid getgid getgroups\n\t\tgetpid getuid isatty lseek pathconf pause setgid setpgid\n\t\tsetsid setuid sysconf tcgetpgrp tcsetpgrp ttyname)],\n\n    utime_h =>\t[],\n\n);\n\n# Exporter::export_tags();\n{\n  # De-duplicate the export list: \n  my %export;\n  @export{map {@$_} values %EXPORT_TAGS} = ();\n  # Doing the de-dup with a temporary hash has the advantage that the SVs in\n  # @EXPORT are actually shared hash key scalars, which will save some memory.\n  push @EXPORT, keys %export;\n}\n\n@EXPORT_OK = qw(\n\t\tabs\n\t\talarm\n\t\tatan2\n\t\tchdir\n\t\tchmod\n\t\tchown\n\t\tclose\n\t\tclosedir\n\t\tcos\n\t\texit\n\t\texp\n\t\tfcntl\n\t\tfileno\n\t\tfork\n\t\tgetc\n\t\tgetgrgid\n\t\tgetgrnam\n\t\tgetlogin\n\t\tgetpgrp\n\t\tgetppid\n\t\tgetpwnam\n\t\tgetpwuid\n\t\tgmtime\n\t\tisatty\n\t\tkill\n\t\tlchown\n\t\tlink\n\t\tlocaltime\n\t\tlog\n\t\tmkdir\n\t\tnice\n\t\topen\n\t\topendir\n\t\tpipe\n\t\tprintf\n\t\trand\n\t\tread\n\t\treaddir\n\t\trename\n\t\trewinddir\n\t\trmdir\n\t\tsin\n\t\tsleep\n\t\tsprintf\n\t\tsqrt\n\t\tsrand\n\t\tstat\n\t\tsystem\n\t\ttime\n\t\ttimes\n\t\tumask\n\t\tunlink\n\t\tutime\n\t\twait\n\t\twaitpid\n\t\twrite\n);\n\nrequire Exporter;\n}\n\n# end of POSIX::SigAction::load_imports\n1;\n", 8192) = 6950
09:01:56.911759 brk(0x7cd000)           = 0x7cd000
09:01:56.911933 read(6, "", 8192)       = 0
09:01:56.912018 close(6)                = 0
09:01:56.912577 brk(0x7ee000)           = 0x7ee000
09:01:56.912844 stat("modules/Exporter/Heavy.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.912935 stat("modules/Exporter/Heavy.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.913023 stat("modules/Exporter/Heavy.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.913108 stat("modules/Exporter/Heavy.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.913202 stat("/etc/perl/Exporter/Heavy.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.913290 stat("/etc/perl/Exporter/Heavy.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.913378 stat("/usr/local/lib/perl/5.14.2/Exporter/Heavy.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.913467 stat("/usr/local/lib/perl/5.14.2/Exporter/Heavy.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.913562 stat("/usr/local/share/perl/5.14.2/Exporter/Heavy.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.913662 stat("/usr/local/share/perl/5.14.2/Exporter/Heavy.pm", {st_mode=S_IFREG|0444, st_size=6551, ...}) = 0
09:01:56.913767 open("/usr/local/share/perl/5.14.2/Exporter/Heavy.pm", O_RDONLY) = 6
09:01:56.913861 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.913941 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.914087 read(6, "package Exporter::Heavy;\n\nuse strict;\nno strict 'refs';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n\n=head1 NAME\n\nExporter::Heavy - Exporter guts\n\n=head1 SYNOPSIS\n\n(internal use only)\n\n=head1 DESCRIPTION\n\nNo user-serviceable parts inside.\n\n=cut\n\n#\n# We go to a lot of trouble not to 'require Carp' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # Save the old __WARN__ handler in case it was defined\n    my $oldwarn = $SIG{__WARN__};\n\n    # First make import warnings look like they're coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\t# restore it back so proper stacking occurs\n\tlocal $SIG{__WARN__} = $oldwarn;\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq 'DEFAULT'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate 'use Foo ()' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, ''\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they've updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can't continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cache at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, '&'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can't continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\tno warnings 'once';\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq '&' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq '$' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq '@' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq '%' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq '*' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can't export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 8192) = 6551
09:01:56.915825 brk(0x80f000)           = 0x80f000
09:01:56.916301 read(6, "", 8192)       = 0
09:01:56.916387 close(6)                = 0
09:01:56.917684 brk(0x830000)           = 0x830000
09:01:56.918449 stat("modules/POE/Pipe/OneWay.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.918568 stat("modules/POE/Pipe/OneWay.pm", {st_mode=S_IFREG|0600, st_size=1034, ...}) = 0
09:01:56.918677 open("modules/POE/Pipe/OneWay.pm", O_RDONLY) = 6
09:01:56.918770 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.918854 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.918964 read(6, "# Deprecation notice: Read POE::Pipe's documentation.\n\npackage POE::Pipe::OneWay;\n\nuse warnings;\nuse strict;\n\nuse base qw( POE::Pipe );\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse IO::Pipely qw(pipely);\n\nsub new {\n  my ($class, $conduit_type) = @_;\n  return pipely(\n    debug => 0,\n    type  => $conduit_type,\n  );\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Pipe::OneWay - Deprecated and replaced with delegates to IO::Pipely.\n\n=head1 SYNOPSIS\n\nSee L<POE::Pipe> and L<IO::Pipely>.\n\n=head1 DESCRIPTION\n\nThis module is deprecated.  L<IO::Pipely> was released to CPAN as its\nreplacement.  Please see L<POE::Pipe> for details, including the\ndeprecation schedule.\n\n=head1 SEE ALSO\n\nL<POE::Pipe> and L<IO::Pipely>.\n\n=head1 AUTHOR & COPYRIGHT\n\nPOE::Pipe::OneWay is copyright 2001-2013 by Rocco Caputo.  All rights\nreserved.  POE::Pipe::OneWay is free software; you may redistribute it\nand/or modify it under the same terms as Perl itself.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 1034
09:01:56.919213 stat("modules/base.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.919304 stat("modules/base.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.919392 stat("modules/base.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.919477 stat("modules/base.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.919562 stat("/etc/perl/base.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.919650 stat("/etc/perl/base.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.919737 stat("/usr/local/lib/perl/5.14.2/base.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.919842 stat("/usr/local/lib/perl/5.14.2/base.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.919938 stat("/usr/local/share/perl/5.14.2/base.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.920029 stat("/usr/local/share/perl/5.14.2/base.pm", {st_mode=S_IFREG|0444, st_size=7390, ...}) = 0
09:01:56.920133 open("/usr/local/share/perl/5.14.2/base.pm", O_RDONLY) = 7
09:01:56.920229 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.920310 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.920415 read(7, "use 5.008;\npackage base;\n\nuse strict 'vars';\nuse vars qw($VERSION);\n$VERSION = '2.23';\n$VERSION =~ tr/_//d;\n\n# constant.pm is slow\nsub SUCCESS () { 1 }\n\nsub PUBLIC     () { 2**0  }\nsub PRIVATE    () { 2**1  }\nsub INHERITED  () { 2**2  }\nsub PROTECTED  () { 2**3  }\n\n\nmy $Fattr = \\%fields::attr;\n\nsub has_fields {\n    my($base) = shift;\n    my $fglob = ${\"$base\\::\"}{FIELDS};\n    return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );\n}\n\nsub has_attr {\n    my($proto) = shift;\n    my($class) = ref $proto || $proto;\n    return exists $Fattr->{$class};\n}\n\nsub get_attr {\n    $Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};\n    return $Fattr->{$_[0]};\n}\n\nif ($] < 5.009) {\n    *get_fields = sub {\n        # Shut up a possible typo warning.\n        () = \\%{$_[0].'::FIELDS'};\n        my $f = \\%{$_[0].'::FIELDS'};\n\n        # should be centralized in fields? perhaps\n        # fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }\n        # is used here anyway, it doesn't matter.\n        bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');\n\n        return $f;\n    }\n}\nelse {\n    *get_fields = sub {\n        # Shut up a possible typo warning.\n        () = \\%{$_[0].'::FIELDS'};\n        return \\%{$_[0].'::FIELDS'};\n    }\n}\n\nif ($] < 5.008) {\n    *_module_to_filename = sub {\n        (my $fn = $_[0]) =~ s!::!/!g;\n        $fn .= '.pm';\n        return $fn;\n    }\n}\nelse {\n    *_module_to_filename = sub {\n        (my $fn = $_[0]) =~ s!::!/!g;\n        $fn .= '.pm';\n        utf8::encode($fn);\n        return $fn;\n    }\n}\n\n\nsub import {\n    my $class = shift;\n\n    return SUCCESS unless @_;\n\n    # List of base classes from which we will inherit %FIELDS.\n    my $fields_base;\n\n    my $inheritor = caller(0);\n\n    my @bases;\n    foreach my $base (@_) {\n        if ( $inheritor eq $base ) {\n            warn \"Class '$inheritor' tried to inherit from itself\\n\";\n        }\n\n        next if grep $_->isa($base), ($inheritor, @bases);\n\n        # Following blocks help isolate $SIG{__DIE__} changes\n        {\n            my $sigdie;\n            {\n                local $SIG{__DIE__};\n                my $fn = _module_to_filename($base);\n                eval { require $fn };\n                # Only ignore \"Can't locate\" errors from our eval require.\n                # Other fatal errors (syntax etc) must be reported.\n                #\n                # changing the check here is fragile - if the check\n                # here isn't catching every error you want, you should\n                # probably be using parent.pm, which doesn't try to\n                # guess whether require is needed or failed,\n                # see [perl #118561]\n                die if $@ && $@ !~ /^Can't locate \\Q$fn\\E .*? at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\\.\\n\\z/s\n                          || $@ =~ /Compilation failed in require at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\\.\\n\\z/;\n                unless (%{\"$base\\::\"}) {\n                    require Carp;\n                    local $\" = \" \";\n                    Carp::croak(<<ERROR);\nBase class package \"$base\" is empty.\n    (Perhaps you need to 'use' the module which defines that package first,\n    or make that module available in \\@INC (\\@INC contains: @INC).\nERROR\n                }\n                $sigdie = $SIG{__DIE__} || undef;\n            }\n            # Make sure a global $SIG{__DIE__} makes it out of the localization.\n            $SIG{__DIE__} = $sigdie if defined $sigdie;\n        }\n        push @bases, $base;\n\n        if ( has_fields($base) || has_attr($base) ) {\n            # No multiple fields inheritance *suck*\n            if ($fields_base) {\n                require Carp;\n                Carp::croak(\"Can't multiply inherit fields\");\n            } else {\n                $fields_base = $base;\n            }\n        }\n    }\n    # Save this until the end so it's all or nothing if the above loop croaks.\n    push @{\"$inheritor\\::ISA\"}, @bases;\n\n    if( defined $fields_base ) {\n        inherit_fields($inheritor, $fields_base);\n    }\n}\n\n\nsub inherit_fields {\n    my($derived, $base) = @_;\n\n    return SUCCESS unless $base;\n\n    my $battr = get_attr($base);\n    my $dattr = get_attr($derived);\n    my $dfields = get_fields($derived);\n    my $bfields = get_fields($base);\n\n    $dattr->[0] = @$battr;\n\n    if( keys %$dfields ) {\n        warn <<\"END\";\n$derived is inheriting from $base but already has its own fields!\nThis will cause problems.  Be sure you use base BEFORE declaring fields.\nEND\n\n    }\n\n    # Iterate through the base's fields adding all the non-private\n    # ones to the derived class.  Hang on to the original attribute\n    # (Public, Private, etc...) and add Inherited.\n    # This is all too complicated to do efficiently with add_fields().\n    while (my($k,$v) = each %$bfields) {\n        my $fno;\n        if ($fno = $dfields->{$k} and $fno != $v) {\n            require Carp;\n            Carp::croak (\"Inherited fields can't override existing fields\");\n        }\n\n        if( $battr->[$v] & PRIVATE ) {\n            $dattr->[$v] = PRIVATE | INHERITED;\n        }\n        else {\n            $dattr->[$v] = INHERITED | $battr->[$v];\n            $dfields->{$k} = $v;\n        }\n    }\n\n    foreach my $idx (1..$#{$battr}) {\n        next if defined $dattr->[$idx];\n        $dattr->[$idx] = $battr->[$idx] & INHERITED;\n    }\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nbase - Establish an ISA relationship with base classes at compile time\n\n=head1 SYNOPSIS\n\n    package Baz;\n    use base qw(Foo Bar);\n\n=head1 DESCRIPTION\n\nUnless you are using the C<fields> pragma, consider this module discouraged\nin favor of the lighter-weight C<parent>.\n\nAllows you to both load one or more modules, while setting up inheritance from\nthose modules at the same time.  Roughly similar in effect to\n\n    package Baz;\n    BEGIN {\n        require Foo;\n        require Bar;\n        push @ISA, qw(Foo Bar);\n    }\n\nWhen C<base> tries to C<require> a module, it will not die if it cannot find\nthe module's file, but will die on any other error.  After all this, should\nyour base class be empty, containing no symbols, C<base> will die. This is\nuseful for inheriting from classes in the same file as yourself but where\nthe filename does not match the base module name, like so:\n\n        # in Bar.pm\n        package Foo;\n        sub exclaim { \"I can have such a thing?!\" }\n\n        package Bar;\n        use base \"Foo\";\n\nThere is no F<Foo.pm>, but because C<Foo> defines a symbol (the C<exclaim>\nsubroutine), C<base> will not die when the C<require> fails to load F<Foo.pm>.\n\nC<base> will also initialize the fields if one of the base classes has it.\nMultiple inheritance of fields is B<NOT> supported, if two or more base classes\neach have inheritable fields the 'base' pragma will croak. See L<fields>\nfor a description of this feature.\n\nThe base class' C<import> method is B<not> called.\n\n\n=head1 DIAGNOSTICS\n\n=over 4\n\n=item Base class package \"%s\" is empty.\n\nbase.pm was unable to require the base package, because it was not\nfound in your path.\n\n=item Class 'Foo' tried to inherit from itself\n\nAttempting to inherit from yourself generates a warning.\n\n    package Foo;\n    use base 'Foo';\n\n=back\n\n=head1 HISTORY\n\nThis module was introduced with Perl 5.004_04.\n\n=head1 CAVEATS\n\nDue to the limitations of the implementation, you must use\nbase I<before> you declare any of your own fields.\n\n\n=head1 SEE ALSO\n\nL<fields>\n\n=cut\n", 8192) = 7390
09:01:56.921872 brk(0x851000)           = 0x851000
09:01:56.922301 lseek(7, 5344, SEEK_SET) = 5344
09:01:56.922387 lseek(7, 0, SEEK_CUR)   = 5344
09:01:56.922463 close(7)                = 0
09:01:56.922609 stat("modules/POE/Pipe.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.922696 stat("modules/POE/Pipe.pm", {st_mode=S_IFREG|0600, st_size=1748, ...}) = 0
09:01:56.922794 open("modules/POE/Pipe.pm", O_RDONLY) = 7
09:01:56.922880 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.922958 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.923053 read(7, "# Deprecation notice: Read the documentation.\n\npackage POE::Pipe;\n\nuse warnings;\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse IO::Pipely;\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Pipe - Deprecated and replaced with delegates to IO::Pipely.\n\n=head1 SYNOPSIS\n\nSee L<IO::Pipely>.\n\n=head1 DESCRIPTION\n\nOn June 29, 2012, POE::Pipe and its subclasses, POE::Pipe::OneWay and\nPOE::Pipe::TwoWay were released to CPAN as IO::Pipely.  The POE::Pipe\nfamily of modules remained unchanged in POE's distribution.\n\nOn August 18, 2013, POE::Pipe and its subclasses were gutted.  Their\nimplementations were replaced with delegates to IO::Pipely.  All tests\npass, although the delegates add slight overhead.  The documentation\nwas replaced by this deprecation schedule.\n\nA mandatory deprecation warning is scheduled to be released after\nSeptember 2014.  POE will begin using IO::Pipely directly.  This\ndocumentation will be updated to schedule the next deprecation step.\n\nThe mandatory warning will become a mandatory error a year or so\nlater.  Ideally this will occur in August 2015, but it may be delayed\ndue to POE's release schedule.  This documentation will be updated to\nschedule the final deprecation step.\n\nFinally, in August 2016 or later, POE::Pipe and its subclasses will be\nremoved from POE's distribution altogether.  Users will have had at\nleast four years to update their code.  That seems fair.\n\n=head1 SEE ALSO\n\nL<IO::Pipely>\n\n=head1 AUTHOR & COPYRIGHT\n\nThe POE::Pipe is copyright 2001-2013 by Rocco Caputo.  All rights\nreserved.  POE::Pipe is free software; you may redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 1748
09:01:56.923369 stat("modules/IO/Pipely.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:56.923455 stat("modules/IO/Pipely.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:56.923538 stat("modules/IO/Pipely.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:56.923619 stat("modules/IO/Pipely.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:56.923701 stat("/etc/perl/IO/Pipely.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:56.923784 stat("/etc/perl/IO/Pipely.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:56.923873 stat("/usr/local/lib/perl/5.14.2/IO/Pipely.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:56.923960 stat("/usr/local/lib/perl/5.14.2/IO/Pipely.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:56.924045 stat("/usr/local/share/perl/5.14.2/IO/Pipely.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:56.924131 stat("/usr/local/share/perl/5.14.2/IO/Pipely.pm", {st_mode=S_IFREG|0444, st_size=19402, ...}) = 0
09:01:56.924230 open("/usr/local/share/perl/5.14.2/IO/Pipely.pm", O_RDONLY) = 8
09:01:56.924319 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.924397 lseek(8, 0, SEEK_CUR)   = 0
09:01:56.924495 read(8, "package IO::Pipely;\n{\n  $IO::Pipely::VERSION = '0.005';\n}\n\nuse warnings;\nuse strict;\n\nuse Symbol qw(gensym);\nuse IO::Socket qw(\n  AF_UNIX\n  PF_INET\n  PF_UNSPEC\n  SOCK_STREAM\n  SOL_SOCKET\n  SOMAXCONN\n  SO_ERROR\n  SO_REUSEADDR\n  inet_aton\n  pack_sockaddr_in\n  unpack_sockaddr_in\n);\nuse Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);\nuse Errno qw(EINPROGRESS EWOULDBLOCK);\n\nour @EXPORT_OK = qw(pipely socketpairly);\nuse base qw(Exporter);\n\n# The order of pipe primitives depends on the platform.\n\n# It's not always safe to assume that a function can be used if it's\n# present.\n\nmy (@oneway_pipe_types, @twoway_pipe_types);\nif ($^O eq \"MSWin32\" or $^O eq \"MacOS\") {\n  @oneway_pipe_types = qw(inet socketpair pipe);\n  @twoway_pipe_types = qw(inet socketpair pipe);\n}\nelsif ($^O eq \"cygwin\") {\n  @oneway_pipe_types = qw(pipe inet socketpair);\n  @twoway_pipe_types = qw(inet pipe socketpair);\n}\nelse {\n  @oneway_pipe_types = qw(pipe socketpair inet);\n  @twoway_pipe_types = qw(socketpair inet pipe);\n}\n\n# Provide dummy constants so things at least compile.  These constants\n# aren't used if we're RUNNING_IN_HELL, but Perl needs to see them.\n\nBEGIN {\n  # older perls than 5.10 needs a kick in the arse to AUTOLOAD the constant...\n  eval \"F_GETFL\" if $] < 5.010;\n\n  if ( ! defined &Fcntl::F_GETFL ) {\n    if ( ! defined prototype \"F_GETFL\" ) {\n      *F_GETFL = sub { 0 };\n      *F_SETFL = sub { 0 };\n    } else {\n      *F_GETFL = sub () { 0 };\n      *F_SETFL = sub () { 0 };\n    }\n  }\n}\n\n# Make a socket.  This is a homebrew socketpair() for systems that\n# don't support it.  The things I must do to make Windows happy.\n\nsub _make_socket {\n\n  ### Server side.\n\n  my $acceptor = gensym();\n  my $accepted = gensym();\n\n  my $tcp = getprotobyname('tcp') or die \"getprotobyname: $!\";\n  socket( $acceptor, PF_INET, SOCK_STREAM, $tcp ) or die \"socket: $!\";\n\n  setsockopt( $acceptor, SOL_SOCKET, SO_REUSEADDR, 1) or die \"reuse: $!\";\n\n  my $server_addr = inet_aton('127.0.0.1') or die \"inet_aton: $!\";\n  $server_addr = pack_sockaddr_in(0, $server_addr)\n    or die \"sockaddr_in: $!\";\n\n  bind( $acceptor, $server_addr ) or die \"bind: $!\";\n\n  $acceptor->blocking(0);\n\n  $server_addr = getsockname($acceptor);\n\n  listen( $acceptor, SOMAXCONN ) or die \"listen: $!\";\n\n  ### Client side.\n\n  my $connector = gensym();\n\n  socket( $connector, PF_INET, SOCK_STREAM, $tcp ) or die \"socket: $!\";\n\n  $connector->blocking(0);\n\n  unless (connect( $connector, $server_addr )) {\n    die \"connect: $!\" if $! and ($! != EINPROGRESS) and ($! != EWOULDBLOCK);\n  }\n\n  my $connector_address = getsockname($connector);\n  my ($connector_port, $connector_addr) =\n    unpack_sockaddr_in($connector_address);\n\n  ### Loop around 'til it's all done.  I thought I was done writing\n  ### select loops.  Damnit.\n\n  my $in_read  = '';\n  my $in_write = '';\n\n  vec( $in_read,  fileno($acceptor),  1 ) = 1;\n  vec( $in_write, fileno($connector), 1 ) = 1;\n\n  my $done = 0;\n  while ($done != 0x11) {\n    my $hits = select( my $out_read   = $in_read,\n                       my $out_write  = $in_write,\n                       undef,\n                       5\n                     );\n    unless ($hits) {\n      next if ($! and ($! == EINPROGRESS) or ($! == EWOULDBLOCK));\n      die \"select: $!\" unless $hits;\n    }\n\n    # Accept happened.\n    if (vec($out_read, fileno($acceptor), 1)) {\n      my $peer = accept($accepted, $acceptor);\n      my ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);\n\n      if ( $peer_port == $connector_port and\n           $peer_addr eq $connector_addr\n         ) {\n        vec($in_read, fileno($acceptor), 1) = 0;\n        $done |= 0x10;\n      }\n    }\n\n    # Connect happened.\n    if (vec($out_write, fileno($connector), 1)) {\n      $! = unpack('i', getsockopt($connector, SOL_SOCKET, SO_ERROR));\n      die \"connect: $!\" if $!;\n\n      vec($in_write, fileno($connector), 1) = 0;\n      $done |= 0x01;\n    }\n  }\n\n  # Turn blocking back on, damnit.\n  $accepted->blocking(1);\n  $connector->blocking(1);\n\n  return ($accepted, $connector);\n}\n\nsub pipely {\n  my %arg = @_;\n\n  my $conduit_type = delete($arg{type});\n  my $debug        = delete($arg{debug}) || 0;\n\n  # Generate symbols to be used as filehandles for the pipe's ends.\n  #\n  # Filehandle autovivification isn't used for portability with older\n  # versions of Perl.\n\n  my ($a_read, $b_write)  = (gensym(), gensym());\n\n  # Try the specified conduit type only.  No fallback.\n\n  if (defined $conduit_type) {\n    return ($a_read, $b_write) if _try_oneway_type(\n      $conduit_type, $debug, \\$a_read, \\$b_write\n    );\n  }\n\n  # Otherwise try all available conduit types until one works.\n  # Conduit types that fail are discarded for speed.\n\n  while (my $try_type = $oneway_pipe_types[0]) {\n    return ($a_read, $b_write) if _try_oneway_type(\n      $try_type, $debug, \\$a_read, \\$b_write\n    );\n    shift @oneway_pipe_types;\n  }\n\n  # There's no conduit type left.  Bummer!\n\n  $debug and warn \"nothing worked\";\n  return;\n}\n\nsub socketpairly {\n  my %arg = @_;\n\n  my $conduit_type = delete($arg{type});\n  my $debug        = delete($arg{debug}) || 0;\n\n  # Generate symbols to be used as filehandles for the pipe's ends.\n  #\n  # Filehandle autovivification isn't used for portability with older\n  # versions of Perl.\n\n  my ($a_read, $a_write) = (gensym(), gensym());\n  my ($b_read, $b_write) = (gensym(), gensym());\n\n  if (defined $conduit_type) {\n    return ($a_read, $a_write, $b_read, $b_write) if _try_twoway_type(\n      $conduit_type, $debug,\n      \\$a_read, \\$a_write,\n      \\$b_read, \\$b_write\n    );\n  }\n\n  while (my $try_type = $twoway_pipe_types[0]) {\n    return ($a_read, $a_write, $b_read, $b_write) if _try_twoway_type(\n      $try_type, $debug,\n      \\$a_read, \\$a_write,\n      \\$b_read, \\$b_write\n    );\n    shift @oneway_pipe_types;\n  }\n\n  # There's no conduit type left.  Bummer!\n\n  $debug and warn \"nothing worked\";\n  return;\n}\n\n# Try a pipe by type.\n\nsub _try_oneway_type {\n  my ($type, $debug, $a_read, $b_write) = @_;\n\n  # Try a pipe().\n  if ($type eq \"pipe\") {\n    eval {\n      pipe($$a_read, $$b_write) or die \"pipe failed: $!\";\n    };\n\n    # Pipe failed.\n    if (length $@) {\n      warn \"pipe failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using a pipe\";\n      warn \"ar($$a_read) bw($$b_write)\\n\";\n    };\n\n    # Turn off buffering.  POE::Kernel does this for us, but\n    # someone might want to use the pipe class elsewhere.\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  # Try a UNIX-domain socketpair.\n  if ($type eq \"socketpair\") {\n    eval {\n      socketpair($$a_read, $$b_write, AF_UNIX, SOCK_STREAM, PF_UNSPEC)\n        or die \"socketpair failed: $!\";\n    };\n\n    if (length $@) {\n      warn \"socketpair failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using a UNIX domain socketpair\";\n      warn \"ar($$a_read) bw($$b_write)\\n\";\n    };\n\n    # It's one-way, so shut down the unused directions.\n    shutdown($$a_read,  1);\n    shutdown($$b_write, 0);\n\n    # Turn off buffering.  POE::Kernel does this for us, but someone\n    # might want to use the pipe class elsewhere.\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  # Try a pair of plain INET sockets.\n  if ($type eq \"inet\") {\n    eval {\n      ($$a_read, $$b_write) = _make_socket();\n    };\n\n    if (length $@) {\n      warn \"make_socket failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using a plain INET socket\";\n      warn \"ar($$a_read) bw($$b_write)\\n\";\n    };\n\n    # It's one-way, so shut down the unused directions.\n    shutdown($$a_read,  1);\n    shutdown($$b_write, 0);\n\n    # Turn off buffering.  POE::Kernel does this for us, but someone\n    # might want to use the pipe class elsewhere.\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  # There's nothing left to try.\n  $debug and warn \"unknown pipely() socket type ``$type''\";\n  return;\n}\n\n# Try a pipe by type.\n\nsub _try_twoway_type {\n  my ($type, $debug, $a_read, $a_write, $b_read, $b_write) = @_;\n\n  # Try a socketpair().\n  if ($type eq \"socketpair\") {\n    eval {\n      socketpair($$a_read, $$b_read, AF_UNIX, SOCK_STREAM, PF_UNSPEC)\n        or die \"socketpair 1 failed: $!\";\n    };\n\n    # Socketpair failed.\n    i", 8192) = 8192
09:01:56.925264 stat("modules/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.925351 stat("modules/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.925435 stat("modules/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.925516 stat("modules/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.925598 stat("/etc/perl/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.925689 stat("/etc/perl/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.925773 stat("/usr/local/lib/perl/5.14.2/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.925858 stat("/usr/local/lib/perl/5.14.2/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.925941 stat("/usr/local/share/perl/5.14.2/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.926024 stat("/usr/local/share/perl/5.14.2/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.926138 stat("/usr/lib/perl5/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.926223 stat("/usr/lib/perl5/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.926308 stat("/usr/share/perl5/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.926391 stat("/usr/share/perl5/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.926474 stat("/usr/lib/perl/5.14/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.926561 stat("/usr/lib/perl/5.14/Symbol.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.926646 stat("/usr/share/perl/5.14/Symbol.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.926731 stat("/usr/share/perl/5.14/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
09:01:56.926830 open("/usr/share/perl/5.14/Symbol.pm", O_RDONLY) = 9
09:01:56.926918 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.926996 lseek(9, 0, SEEK_CUR)   = 0
09:01:56.927098 read(9, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = '1.07';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn't work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, '::') == -1 && index($name, \"'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/'qq(\\c'.$1.')'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= '::'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 8192) = 2099
09:01:56.927897 read(9, "", 8192)       = 0
09:01:56.927982 close(9)                = 0
09:01:56.928170 stat("modules/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.928256 stat("modules/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.928339 stat("modules/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.928421 stat("modules/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.928503 stat("/etc/perl/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.928584 stat("/etc/perl/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.928668 stat("/usr/local/lib/perl/5.14.2/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.928753 stat("/usr/local/lib/perl/5.14.2/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.928837 stat("/usr/local/share/perl/5.14.2/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.928923 stat("/usr/local/share/perl/5.14.2/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.929009 stat("/usr/lib/perl5/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.929094 stat("/usr/lib/perl5/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.929185 stat("/usr/share/perl5/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.929271 stat("/usr/share/perl5/IO/Socket.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.929355 stat("/usr/lib/perl/5.14/IO/Socket.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.929443 stat("/usr/lib/perl/5.14/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=8836, ...}) = 0
09:01:56.929543 open("/usr/lib/perl/5.14/IO/Socket.pm", O_RDONLY) = 9
09:01:56.929631 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.929715 lseek(9, 0, SEEK_CUR)   = 0
09:01:56.929816 read(9, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.32\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast\n\tExporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export 'Socket', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak 'IO::Socket: Cannot configure a generic socket'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain '$domain'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{'io_socket_domain'} = $domain;\n    ${*$sock}{'io_socket_type'}   = $type;\n    ${*$sock}{'io_socket_proto'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;\n    ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak 'usage: $sock->connect(NAME)';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{'io_socket_timeout'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    undef $!;\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) &&\n                not ($!{EISCONN} || ($! == 10022 && $^O eq 'MSWin32'))\n            ) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t# Windows sets errno to WSAEINVAL (10022)\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\n# Enable/disable blocking IO on sockets.\n# Without args return the current status of blocking,\n# with args change the mode as appropriate, returning the\n# old setting, or in case of error during the mode change\n# undef.\n\nsub blocking {\n    my $sock = shift;\n\n    return $sock->SUPER::blocking(@_)\n        if $^O ne 'MSWin32';\n\n    # Windows handles blocking differently\n    #\n    # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f\n    # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp\n    #\n    # 0x8004667e is FIONBIO\n    #\n    # which is used to set blocking behaviour.\n\n    # NOTE: \n    # This is a little confusing, the perl keyword for this is\n    # 'blocking' but the OS level behaviour is 'non-blocking', probably\n    # because sockets are blocking by default.\n    # Therefore internally we have to reverse the semantics.\n\n    my $orig= !${*$sock}{io_sock_nonblocking};\n        \n    return $orig unless @_;\n\n    my $block = shift;\n    \n    if ( !$block != !$orig ) {\n        ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;\n        ioctl($sock, 0x8004667e, pack(\"L!\",${*$sock}{io_sock_nonblocking}))\n            or return undef;\n    }\n    \n    return $orig;        \n}\n\nsub close {\n    @_ == 1 or croak 'usage: $sock->close()';\n    my $sock = shift;\n    ${*$sock}{'io_socket_peername'} = undef;\n    $sock->SUPER::close();\n}\n\nsub bind {\n    @_ == 2 or croak 'usage: $sock->bind(NAME)';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{'io_socket_timeout'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = 'accept: timeout';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak 'usage: $sock->sockname()';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak 'usage: $sock->peername()';\n    my($sock) = @_;\n    ${*$sock}{'io_socket_peername'} ||= getpeername($sock);\n}\n\nsub connected {\n    @_ == 1 or croak 'usage: $sock->connected()';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak 'send: Cannot determine peer address'\n\t unless(defined $peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{'io_socket_peername'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv'd from\n    ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak 'usage: $sock->shutdown(HOW)';\n    my($sock, $how) = @_;\n    ${*$sock}{'io_socket_peername'} = undef;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak 'usage: $sock->atmark()';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{'io_socket_timeout'};\n\n    ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak 'usage: $sock->sockdomain()';\n    my $sock = shift;\n    if (!defined(${*$sock}{'io_socket_domain'})) {\n\tmy $addr = $sock->sockname();\n\t${*$sock}{'io_socket_domain'} = soc", 8192) = 8192
09:01:56.930555 stat("modules/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.930642 stat("modules/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.930726 stat("modules/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.930807 stat("modules/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.930888 stat("/etc/perl/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.930969 stat("/etc/perl/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.931051 stat("/usr/local/lib/perl/5.14.2/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.931135 stat("/usr/local/lib/perl/5.14.2/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.931219 stat("/usr/local/share/perl/5.14.2/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.931312 stat("/usr/local/share/perl/5.14.2/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.931397 stat("/usr/lib/perl5/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.931479 stat("/usr/lib/perl5/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.931562 stat("/usr/share/perl5/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.931644 stat("/usr/share/perl5/IO/Handle.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.931728 stat("/usr/lib/perl/5.14/IO/Handle.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.931814 stat("/usr/lib/perl/5.14/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=8079, ...}) = 0
09:01:56.931919 open("/usr/lib/perl/5.14/IO/Handle.pm", O_RDONLY) = 10
09:01:56.932007 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339a80) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.932084 lseek(10, 0, SEEK_CUR)  = 0
09:01:56.932183 read(10, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.31\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    say\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    if (@_ != 1) {\n\t# Since perl will automatically require IO::File if needed, but\n\t# also initialises IO::File's @ISA as part of the core we must\n\t# ensure IO::File is loaded if IO::Handle is. This avoids effect-\n\t# ively \"half-loading\" IO::File.\n\tif ($] > 5.013 && $class eq 'IO::File' && !$INC{\"IO/File.pm\"}) {\n\t    require IO::File;\n\t    shift;\n\t    return IO::File::->new(@_);\n\t}\n\tcroak \"usage: $class->new()\";\n    }\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: $class->new_from_fd(FD, MODE)\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It's a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It's an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . '&' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak 'usage: $io->close()';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak 'usage: $io->opened()';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak 'usage: $io->fileno()';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak 'usage: $io->getc()';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak 'usage: $io->eof()';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak 'usage: $io->print(ARGS)';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub say {\n    @_ or croak 'usage: $io->say(ARGS)';\n    my $this = shift;\n    local $\\ = \"\\n\";\n    print $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak 'usage: $io->getline()';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak 'usage: $io->getlines()';\n    wantarray or\n\tcroak 'Can\\'t call $io->getlines in a scalar context, use $io->getline';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak 'usage: $io->truncate(LEN)';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak 'usage: $io->stat()';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name(qualify($fmt,caller));\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\nsub fcntl {\n    @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\nsub ioctl {\n    @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatibility with older releases of IO that used\n# a sub called constant to determine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict 'refs';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 8192) = 8079
09:01:56.932857 brk(0x873000)           = 0x873000
09:01:56.933142 stat("modules/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.933230 stat("modules/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.933315 stat("modules/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.933396 stat("modules/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.933478 stat("/etc/perl/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.933563 stat("/etc/perl/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.933652 stat("/usr/local/lib/perl/5.14.2/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.933738 stat("/usr/local/lib/perl/5.14.2/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.933823 stat("/usr/local/share/perl/5.14.2/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.933907 stat("/usr/local/share/perl/5.14.2/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.933991 stat("/usr/lib/perl5/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.934094 stat("/usr/lib/perl5/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.934181 stat("/usr/share/perl5/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.934266 stat("/usr/share/perl5/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.934351 stat("/usr/lib/perl/5.14/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.934436 stat("/usr/lib/perl/5.14/SelectSaver.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.934522 stat("/usr/share/perl/5.14/SelectSaver.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.934607 stat("/usr/share/perl/5.14/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=344, ...}) = 0
09:01:56.934706 open("/usr/share/perl/5.14/SelectSaver.pm", O_RDONLY) = 11
09:01:56.934796 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339450) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.934873 lseek(11, 0, SEEK_CUR)  = 0
09:01:56.934976 read(11, "package SelectSaver;\n\nour $VERSION = '1.02';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak 'usage: SelectSaver->new( [FILEHANDLE] )';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 8192) = 344
09:01:56.935296 read(11, "", 8192)      = 0
09:01:56.935379 close(11)               = 0
09:01:56.935511 stat("modules/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.935596 stat("modules/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.935680 stat("modules/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.935760 stat("modules/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.935844 stat("/etc/perl/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.935928 stat("/etc/perl/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.936011 stat("/usr/local/lib/perl/5.14.2/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.936095 stat("/usr/local/lib/perl/5.14.2/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.936180 stat("/usr/local/share/perl/5.14.2/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.936263 stat("/usr/local/share/perl/5.14.2/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.936348 stat("/usr/lib/perl5/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.936431 stat("/usr/lib/perl5/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.936515 stat("/usr/share/perl5/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.936597 stat("/usr/share/perl5/IO.pm", 0x7ffe123396c0) = -1 ENOENT (No such file or directory)
09:01:56.936681 stat("/usr/lib/perl/5.14/IO.pmc", 0x7ffe12339770) = -1 ENOENT (No such file or directory)
09:01:56.936766 stat("/usr/lib/perl/5.14/IO.pm", {st_mode=S_IFREG|0644, st_size=416, ...}) = 0
09:01:56.936862 open("/usr/lib/perl/5.14/IO.pm", O_RDONLY) = 11
09:01:56.936949 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339450) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.937027 lseek(11, 0, SEEK_CUR)  = 0
09:01:56.937125 read(11, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.25_04\";\nXSLoader::load 'IO', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif('deprecated', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 8192) = 416
09:01:56.937456 lseek(11, 415, SEEK_SET) = 415
09:01:56.937534 lseek(11, 0, SEEK_CUR)  = 415
09:01:56.937609 close(11)               = 0
09:01:56.937749 stat("/usr/lib/perl/5.14/auto/IO/IO.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.937841 stat("/usr/lib/perl/5.14/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=18704, ...}) = 0
09:01:56.937934 stat("/usr/lib/perl/5.14/auto/IO/IO.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.938026 open("/usr/lib/perl/5.14/auto/IO/IO.so", O_RDONLY) = 11
09:01:56.938134 read(11, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\30\0\0\0\0\0\0@\0\0\0\0\0\0\0PB\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2645\0\0\0\0\0\0\2645\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0h=\0\0\0\0\0\0h= \0\0\0\0\0h= \0\0\0\0\0\360\3\0\0\0\0\0\0\370\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\200=\0\0\0\0\0\0\200= \0\0\0\0\0\200= \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\00082\0\0\0\0\0\00082\0\0\0\0\0\00082\0\0\0\0\0\0\214\0\0\0\0\0\0\0\214\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0h=\0\0\0\0\0\0h= \0\0\0\0\0h= \0\0\0\0\0\230\2\0\0\0\0\0\0\230\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0(/\243M?O6\313\301\273\255\357=\376\2134^\210Z5\0\0\0\0%\0\0\0D\0\0\0A\0\0\0&\0\0\0%\0\0\0\0\0\0\0?\0\0\0-\0\0\0\22\0\0\0'\0\0\0\27\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0)\0\0\0000\0\0\0,\0\0\0\10\0\0\0\35\0\0\0003\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0004\0\0\0001\0\0\0\0\0\0\0+\0\0\0\16\0\0\0C\0\0\0.\0\0\0*\0\0\0\5\0\0\0\0\0\0\0\37\0\0\0005\0\0\0\33\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\r\0\0\0\f\0\0\0\17\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\v\0\0\0\20\0\0\0\0\0\0\0\24\0\0\0\26\0\0\0\n\0\0\0\6\0\0\0=\0\0\0\0\0\0\0009\0\0\0006\0\0\0\23\0\0\0\0\0\0\0\34\0\0\0\30\0\0\0B\0\0\0@\0\0\0\0\0\0\0>\0\0\0007\0\0\0002\0\0\0\0\0\0\0(\0\0\0\25\0\0\0!\0\0\0", 832) = 832
09:01:56.938359 fstat(11, {st_mode=S_IFREG|0644, st_size=18704, ...}) = 0
09:01:56.938451 mmap(NULL, 2113888, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 11, 0) = 0x7f743551c000
09:01:56.938531 mprotect(0x7f7435520000, 2093056, PROT_NONE) = 0
09:01:56.938608 mmap(0x7f743571f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 11, 0x3000) = 0x7f743571f000
09:01:56.938698 close(11)               = 0
09:01:56.938793 mprotect(0x7f743571f000, 4096, PROT_READ) = 0
09:01:56.939943 brk(0x894000)           = 0x894000
09:01:56.940909 read(10, "", 8192)      = 0
09:01:56.940987 close(10)               = 0
09:01:56.941185 stat("modules/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.941268 stat("modules/Socket.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.941350 stat("modules/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.941428 stat("modules/Socket.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.941506 stat("/etc/perl/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.941586 stat("/etc/perl/Socket.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.941675 stat("/usr/local/lib/perl/5.14.2/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.941757 stat("/usr/local/lib/perl/5.14.2/Socket.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.941838 stat("/usr/local/share/perl/5.14.2/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.941918 stat("/usr/local/share/perl/5.14.2/Socket.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.941998 stat("/usr/lib/perl5/Socket.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.942100 stat("/usr/lib/perl5/Socket.pm", {st_mode=S_IFREG|0644, st_size=35267, ...}) = 0
09:01:56.942196 open("/usr/lib/perl5/Socket.pm", O_RDONLY) = 10
09:01:56.942281 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339a80) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.942355 lseek(10, 0, SEEK_CUR)  = 0
09:01:56.942451 read(10, "package Socket;\n\nuse strict;\n{ use 5.006001; }\n\nour $VERSION = '2.002';\n\n=head1 NAME\n\nC<Socket> - networking constants and support functions\n\n=head1 SYNOPSIS\n\nC<Socket> a low-level module used by, among other things, the L<IO::Socket>\nfamily of modules. The following examples demonstrate some low-level uses but\na practical program would likely use the higher-level API provided by\nC<IO::Socket> or similar instead.\n\n use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);\n\n socket(my $socket, PF_INET, SOCK_STREAM, 0)\n     or die \"socket: $!\";\n\n my $port = getservbyname \"echo\", \"tcp\";\n connect($socket, pack_sockaddr_in($port, inet_aton(\"localhost\")))\n     or die \"connect: $!\";\n\n print $socket \"Hello, world!\\n\";\n print <$socket>;\n\nSee also the L</EXAMPLES> section.\n\n=head1 DESCRIPTION\n\nThis module provides a variety of constants, structure manipulators and other\nfunctions related to socket-based networking. The values and functions\nprovided are useful when used in conjunction with Perl core functions such as\nsocket(), setsockopt() and bind(). It also provides several other support\nfunctions, mostly for dealing with conversions of network addresses between\nhuman-readable and native binary forms, and for hostname resolver operations.\n\nSome constants and functions are exported by default by this module; but for\nbackward-compatibility any recently-added symbols are not exported by default\nand must be requested explicitly. When an import list is provided to the\nC<use Socket> line, the default exports are not automatically imported. It is\ntherefore best practice to always to explicitly list all the symbols required.\n\nAlso, some common socket \"newline\" constants are provided: the constants\nC<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map\nto C<\\015>, C<\\012>, and C<\\015\\012>. If you do not want to use the literal\ncharacters in your programs, then use the constants provided here. They are\nnot exported by default, but can be imported individually, and with the\nC<:crlf> export tag:\n\n use Socket qw(:DEFAULT :crlf);\n\n $sock->print(\"GET / HTTP/1.0$CRLF\");\n\nThe entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;\nthis exports the getaddrinfo() and getnameinfo() functions, and all the\nC<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.\n\n=cut\n\n=head1 CONSTANTS\n\nIn each of the following groups, there may be many more constants provided\nthan just the ones given as examples in the section heading. If the heading\nends C<...> then this means there are likely more; the exact constants\nprovided will depend on the OS and headers found at compile-time.\n\n=cut\n\n=head2 PF_INET, PF_INET6, PF_UNIX, ...\n\nProtocol family constants to use as the first argument to socket() or the\nvalue of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.\n\n=head2 AF_INET, AF_INET6, AF_UNIX, ...\n\nAddress family constants used by the socket address structures, to pass to\nsuch functions as inet_pton() or getaddrinfo(), or are returned by such\nfunctions as sockaddr_family().\n\n=head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...\n\nSocket type constants to use as the second argument to socket(), or the value\nof the C<SO_TYPE> socket option.\n\n=head2 SOCK_NONBLOCK. SOCK_CLOEXEC\n\nLinux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags\nduring a C<socket(2)> call.\n\n socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )\n\n=head2 SOL_SOCKET\n\nSocket option level constant for setsockopt() and getsockopt().\n\n=head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...\n\nSocket option name constants for setsockopt() and getsockopt() at the\nC<SOL_SOCKET> level.\n\n=head2 IP_OPTIONS, IP_TOS, IP_TTL, ...\n\nSocket option name constants for IPv4 socket options at the C<IPPROTO_IP>\nlevel.\n\n=head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...\n\nMessage flag constants for send() and recv().\n\n=head2 SHUT_RD, SHUT_RDWR, SHUT_WR\n\nDirection constants for shutdown().\n\n=head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE\n\nConstants giving the special C<AF_INET> addresses for wildcard, broadcast,\nlocal loopback, and invalid addresses.\n\nNormally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),\ninet_aton('localhost') and inet_aton('255.255.255.255') respectively.\n\n=head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...\n\nIP protocol constants to use as the third argument to socket(), the level\nargument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>\nsocket option.\n\n=head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...\n\nSocket option name constants for TCP socket options at the C<IPPROTO_TCP>\nlevel.\n\n=head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK\n\nConstants giving the special C<AF_INET6> addresses for wildcard and local\nloopback.\n\nNormally equivalent to inet_pton(AF_INET6, \"::\") and\ninet_pton(AF_INET6, \"::1\") respectively.\n\n=head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...\n\nSocket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>\nlevel.\n\n=cut\n\n# Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV\n\n=head1 STRUCTURE MANIPULATORS\n\nThe following functions convert between lists of Perl values and packed binary\nstrings representing structures.\n\n=cut\n\n=head2 $family = sockaddr_family $sockaddr\n\nTakes a packed socket address (as returned by pack_sockaddr_in(),\npack_sockaddr_un() or the perl builtin functions getsockname() and\ngetpeername()). Returns the address family tag. This will be one of the\nC<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or\nC<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to\nuse for a sockaddr of unknown type.\n\n=head2 $sockaddr = pack_sockaddr_in $port, $ip_address\n\nTakes two arguments, a port number and an opaque string (as returned by\ninet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those\narguments packed in and C<AF_INET> filled in. For Internet domain sockets,\nthis structure is normally what you need for the arguments in bind(),\nconnect(), and send().\n\n=head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr\n\nTakes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),\ngetpeername() or recv()). Returns a list of two elements: the port and an\nopaque string representing the IP address (you can use inet_ntoa() to convert\nthe address to the four-dotted numeric format). Will croak if the structure\ndoes not represent an C<AF_INET> address.\n\n=head2 $sockaddr = sockaddr_in $port, $ip_address\n\n=head2 ($port, $ip_address) = sockaddr_in $sockaddr\n\nA wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,\nunpacks its argument and returns a list consisting of the port and IP address.\nIn scalar context, packs its port and IP address arguments as a C<sockaddr_in>\nand returns it.\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_in() or unpack_sockaddr_in() explicitly.\n\n=head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]\n\nTakes two to four arguments, a port number, an opaque string (as returned by\ninet_pton()), optionally a scope ID number, and optionally a flow label\nnumber. Returns the C<sockaddr_in6> structure with those arguments packed in\nand C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().\n\n=head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr\n\nTakes a C<sockaddr_in6> structure. Returns a list of four elements: the port\nnumber, an opaque string representing the IPv6 address, the scope ID, and the\nflow label. (You can use inet_ntop() to convert the address to the usual\nstring format). Will croak if the structure does not represent an C<AF_INET6>\naddress.\n\n=head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]\n\n=head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr\n\nA wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,\nunpacks its argument according to unpack_sockaddr_in6(). In scalar context,\npacks its arguments according to pack_sockaddr_in6().\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.\n\n=head2 $sockaddr = pack_sockaddr_un $path\n\nTakes one argument, a pathname. Returns the C<sockaddr_", 8192) = 8192
09:01:56.943215 read(10, "un> structure with that\npath packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this\nstructure is normally what you need for the arguments in bind(), connect(),\nand send().\n\n=head2 ($path) = unpack_sockaddr_un $sockaddr\n\nTakes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),\ngetpeername() or recv()). Returns a list of one element: the pathname. Will\ncroak if the structure does not represent an C<AF_UNIX> address.\n\n=head2 $sockaddr = sockaddr_un $path\n\n=head2 ($path) = sockaddr_un $sockaddr\n\nA wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,\nunpacks its argument and returns a list consisting of the pathname. In a\nscalar context, packs its pathname as a C<sockaddr_un> and returns it.\n\nProvided largely for legacy compatibility; it is better to use\npack_sockaddr_un() or unpack_sockaddr_un() explicitly.\n\nThese are only supported if your system has E<lt>F<sys/un.h>E<gt>.\n\n=head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface\n\nTakes an IPv4 multicast address and optionally an interface address (or\nC<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed\nin. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>\nsockopts.\n\n=head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq\n\nTakes an C<ip_mreq> structure. Returns a list of two elements; the IPv4\nmulticast address and interface address.\n\n=head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex\n\nTakes an IPv6 multicast address and an interface number. Returns the\nC<ipv6_mreq> structure with those arguments packed in. Suitable for use with\nthe C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.\n\n=head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq\n\nTakes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6\naddress and an interface number.\n\n=cut\n\n=head1 FUNCTIONS\n\n=cut\n\n=head2 $ip_address = inet_aton $string\n\nTakes a string giving the name of a host, or a textual representation of an IP\naddress and translates that to an packed binary address structure suitable to\npass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,\nreturns C<undef>. For multi-homed hosts (hosts with more than one address),\nthe first address found is returned.\n\nFor portability do not assume that the result of inet_aton() is 32 bits wide,\nin other words, that it would contain only the IPv4 address in network order.\n\nThis IPv4-only function is provided largely for legacy reasons. Newly-written\ncode should use getaddrinfo() or inet_pton() instead for IPv6 support.\n\n=head2 $string = inet_ntoa $ip_address\n\nTakes a packed binary address structure such as returned by\nunpack_sockaddr_in() (or a v-string representing the four octets of the IPv4\naddress in network order) and translates it into a string of the form\nC<d.d.d.d> where the C<d>s are numbers less than 256 (the normal\nhuman-readable four dotted number notation for Internet addresses).\n\nThis IPv4-only function is provided largely for legacy reasons. Newly-written\ncode should use getnameinfo() or inet_ntop() instead for IPv6 support.\n\n=head2 $address = inet_pton $family, $string\n\nTakes an address family (such as C<AF_INET> or C<AF_INET6>) and a string\ncontaining a textual representation of an address in that family and\ntranslates that to an packed binary address structure.\n\nSee also getaddrinfo() for a more powerful and flexible function to look up\nsocket addresses given hostnames or textual addresses.\n\n=head2 $string = inet_ntop $family, $address\n\nTakes an address family and a packed binary address structure and translates\nit into a human-readable textual representation of the address; typically in\nC<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.\n\nSee also getnameinfo() for a more powerful and flexible function to turn\nsocket addresses into human-readable textual representations.\n\n=head2 ($err, @result) = getaddrinfo $host, $service, [$hints]\n\nGiven both a hostname and service name, this function attempts to resolve the\nhost name into a list of network addresses, and the service name into a\nprotocol and port number, and then returns a list of address structures\nsuitable to connect() to it.\n\nGiven just a host name, this function attempts to resolve it to a list of\nnetwork addresses, and then returns a list of address structures giving these\naddresses.\n\nGiven just a service name, this function attempts to resolve it to a protocol\nand port number, and then returns a list of address structures that represent\nit suitable to bind() to. This use should be combined with the C<AI_PASSIVE>\nflag; see below.\n\nGiven neither name, it generates an error.\n\nIf present, $hints should be a reference to a hash, where the following keys\nare recognised:\n\n=over 4\n\n=item flags => INT\n\nA bitfield containing C<AI_*> constants; see below.\n\n=item family => INT\n\nRestrict to only generating addresses in this address family\n\n=item socktype => INT\n\nRestrict to only generating addresses of this socket type\n\n=item protocol => INT\n\nRestrict to only generating addresses for this protocol\n\n=back\n\nThe return value will be a list; the first value being an error indication,\nfollowed by a list of address structures (if no error occurred).\n\nThe error value will be a dualvar; comparable to the C<EI_*> error constants,\nor printable as a human-readable error message string. If no error occurred it\nwill be zero numerically and an empty string.\n\nEach value in the results list will be a hash reference containing the following\nfields:\n\n=over 4\n\n=item family => INT\n\nThe address family (e.g. C<AF_INET>)\n\n=item socktype => INT\n\nThe socket type (e.g. C<SOCK_STREAM>)\n\n=item protocol => INT\n\nThe protocol (e.g. C<IPPROTO_TCP>)\n\n=item addr => STRING\n\nThe address in a packed string (such as would be returned by\npack_sockaddr_in())\n\n=item canonname => STRING\n\nThe canonical name for the host if the C<AI_CANONNAME> flag was provided, or\nC<undef> otherwise. This field will only be present on the first returned\naddress.\n\n=back\n\nThe following flag constants are recognised in the $hints hash. Other flag\nconstants may exist as provided by the OS.\n\n=over 4\n\n=item AI_PASSIVE\n\nIndicates that this resolution is for a local bind() for a passive (i.e.\nlistening) socket, rather than an active (i.e. connecting) socket.\n\n=item AI_CANONNAME\n\nIndicates that the caller wishes the canonical hostname (C<canonname>) field\nof the result to be filled in.\n\n=item AI_NUMERICHOST\n\nIndicates that the caller will pass a numeric address, rather than a hostname,\nand that getaddrinfo() must not perform a resolve operation on this name. This\nflag will prevent a possibly-slow network lookup operation, and instead return\nan error if a hostname is passed.\n\n=back\n\n=head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]\n\nGiven a packed socket address (such as from getsockname(), getpeername(), or\nreturned by getaddrinfo() in a C<addr> field), returns the hostname and\nsymbolic service name it represents. $flags may be a bitmask of C<NI_*>\nconstants, or defaults to 0 if unspecified.\n\nThe return value will be a list; the first value being an error condition,\nfollowed by the hostname and service name.\n\nThe error value will be a dualvar; comparable to the C<EI_*> error constants,\nor printable as a human-readable error message string. The host and service\nnames will be plain strings.\n\nThe following flag constants are recognised as $flags. Other flag constants may\nexist as provided by the OS.\n\n=over 4\n\n=item NI_NUMERICHOST\n\nRequests that a human-readable string representation of the numeric address be\nreturned directly, rather than performing a name resolve operation that may\nconvert it into a hostname. This will also avoid potentially-blocking network\nIO.\n\n=item NI_NUMERICSERV\n\nRequests that the port number be returned directly as a number representation\nrather than performing a name resolve operation that may convert it into a\nservice name.\n\n=item NI_NAMEREQD\n\nIf a name resolve operation fails to provide a name, then this flag will cause\ngetnameinfo() to indicate an error, rather than returning the numeric\nrepresentation as a human-readable string.\n\n=item NI_DGRAM\n\nIndicates that the sock", 8192) = 8192
09:01:56.943899 read(10, "et address relates to a C<SOCK_DGRAM> socket, for the\nservices whose name differs between TCP and UDP protocols.\n\n=back\n\nThe following constants may be supplied as $xflags.\n\n=over 4\n\n=item NIx_NOHOST\n\nIndicates that the caller is not interested in the hostname of the result, so\nit does not have to be converted. C<undef> will be returned as the hostname.\n\n=item NIx_NOSERV\n\nIndicates that the caller is not interested in the service name of the result,\nso it does not have to be converted. C<undef> will be returned as the service\nname.\n\n=back\n\n=head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS\n\nThe following constants may be returned by getaddrinfo() or getnameinfo().\nOthers may be provided by the OS.\n\n=over 4\n\n=item EAI_AGAIN\n\nA temporary failure occurred during name resolution. The operation may be\nsuccessful if it is retried later.\n\n=item EAI_BADFLAGS\n\nThe value of the C<flags> hint to getaddrinfo(), or the $flags parameter to\ngetnameinfo() contains unrecognised flags.\n\n=item EAI_FAMILY\n\nThe C<family> hint to getaddrinfo(), or the family of the socket address\npassed to getnameinfo() is not supported.\n\n=item EAI_NODATA\n\nThe host name supplied to getaddrinfo() did not provide any usable address\ndata.\n\n=item EAI_NONAME\n\nThe host name supplied to getaddrinfo() does not exist, or the address\nsupplied to getnameinfo() is not associated with a host name and the\nC<NI_NAMEREQD> flag was supplied.\n\n=item EAI_SERVICE\n\nThe service name supplied to getaddrinfo() is not available for the socket\ntype given in the $hints.\n\n=back\n\n=cut\n\n=head1 EXAMPLES\n\n=head2 Lookup for connect()\n\nThe getaddrinfo() function converts a hostname and a service name into a list\nof structures, each containing a potential way to connect() to the named\nservice on the named host.\n\n use IO::Socket;\n use Socket qw(SOCK_STREAM getaddrinfo);\n\n my %hints = (socktype => SOCK_STREAM);\n my ($err, @res) = getaddrinfo(\"localhost\", \"echo\", \\%hints);\n die \"Cannot getaddrinfo - $err\" if $err;\n\n my $sock;\n\n foreach my $ai (@res) {\n     my $candidate = IO::Socket->new();\n\n     $candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})\n         or next;\n\n     $candidate->connect($ai->{addr})\n         or next;\n\n     $sock = $candidate;\n     last;\n }\n\n die \"Cannot connect to localhost:echo\" unless $sock;\n\n $sock->print(\"Hello, world!\\n\");\n print <$sock>;\n\nBecause a list of potential candidates is returned, the C<while> loop tries\neach in turn until it it finds one that succeeds both the socket() and\nconnect() calls.\n\nThis function performs the work of the legacy functions gethostbyname(),\ngetservbyname(), inet_aton() and pack_sockaddr_in().\n\nIn practice this logic is better performed by L<IO::Socket::IP>.\n\n=head2 Making a human-readable string out of an address\n\nThe getnameinfo() function converts a socket address, such as returned by\ngetsockname() or getpeername(), into a pair of human-readable strings\nrepresenting the address and service name.\n\n use IO::Socket::IP;\n use Socket qw(getnameinfo);\n\n my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or\n     die \"Cannot listen - $@\";\n\n my $socket = $server->accept or die \"accept: $!\";\n\n my ($err, $hostname, $servicename) = getnameinfo($socket->peername);\n die \"Cannot getnameinfo - $err\" if $err;\n\n print \"The peer is connected from $hostname\\n\";\n\nSince in this example only the hostname was used, the redundant conversion of\nthe port number into a service name may be omitted by passing the\nC<NIx_NOSERV> flag.\n\n use Socket qw(getnameinfo NIx_NOSERV);\n\n my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);\n\nThis function performs the work of the legacy functions unpack_sockaddr_in(),\ninet_ntoa(), gethostbyaddr() and getservbyport().\n\nIn practice this logic is better performed by L<IO::Socket::IP>.\n\n=head2 Resolving hostnames into IP addresses\n\nTo turn a hostname into a human-readable plain IP address use getaddrinfo()\nto turn the hostname into a list of socket structures, then getnameinfo() on\neach one to make it a readable IP address again.\n\n use Socket qw(:addrinfo SOCK_RAW);\n\n my ($err, @res) = getaddrinfo($hostname, \"\", {socktype => SOCK_RAW});\n die \"Cannot getaddrinfo - $err\" if $err;\n\n while( my $ai = shift @res ) {\n     my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);\n     die \"Cannot getnameinfo - $err\" if $err;\n\n     print \"$ipaddr\\n\";\n }\n\nThe C<socktype> hint to getaddrinfo() filters the results to only include one\nsocket type and protocol. Without this most OSes return three combinations,\nfor C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate\noutput of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to\nreturn a string-formatted plain IP address, rather than reverse resolving it\nback into a hostname.\n\nThis combination performs the work of the legacy functions gethostbyname()\nand inet_ntoa().\n\n=head2 Accessing socket options\n\nThe many C<SO_*> and other constants provide the socket option names for\ngetsockopt() and setsockopt().\n\n use IO::Socket::INET;\n use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);\n\n my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')\n     or die \"Cannot create socket: $@\";\n\n $socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or\n     die \"setsockopt: $!\";\n\n print \"Receive buffer is \", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),\n     \" bytes\\n\";\n\n print \"IP TTL is \", $socket->getsockopt(IPPROTO_IP, IP_TTL), \"\\n\";\n\nAs a convenience, L<IO::Socket>'s setsockopt() method will convert a number\ninto a packed byte buffer, and getsockopt() will unpack a byte buffer of the\ncorrect size back into a number.\n\n=cut\n\n=head1 AUTHOR\n\nThis module was originally maintained in Perl core by the Perl 5 Porters.\n\nIt was extracted to dual-life on CPAN at version 1.95 by\nPaul Evans <leonerd@leonerd.org.uk>\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nrequire XSLoader;\nour @ISA = qw(Exporter);\n\n# <@Nicholas> you can't change @EXPORT without breaking the implicit API\n# Please put any new constants in @EXPORT_OK!\n\n# List re-ordered to match documentation above. Try to keep the ordering\n# consistent so it's easier to see which ones are or aren't documented.\nour @EXPORT = qw(\n\tPF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT\n\tPF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6\n\tPF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI\n\tPF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN\n\tPF_X25\n\n\tAF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT\n\tAF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6\n\tAF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI\n\tAF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN\n\tAF_X25\n\n\tSOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM\n\n\tSOL_SOCKET\n\n\tSO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON\n\tSO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER\n\tSO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE\n\tSO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE\n\tSO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO\n\tSO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE\n\n\tIP_OPTIONS IP_HDRINCL IP_TOS IP_TTL IP_RECVOPTS IP_RECVRETOPTS\n\tIP_RETOPTS\n\n\tMSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE\n\tMSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FIN\n\tMSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST\n\tMSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE\n\n\tSHUT_RD SHUT_RDWR SHUT_WR\n\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\n\tSCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP\n\n\tSOMAXCONN\n\n\tIOV_MAX\n\tUIO_MAXIOV\n\n\tsockaddr_family\n\tpack_sockaddr_in  unpack_sockaddr_in  sockaddr_in\n\tpack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6\n\tpack_sockaddr_un  unpack_sockaddr_un  sockaddr_un \n\n\tinet_aton inet_ntoa\n);\n\n# List re-ordered to match documentation above. Try to keep the ordering\n# consistent so it's easier to see which on", 8192) = 8192
09:01:56.944793 read(10, "es are or aren't documented.\nour @EXPORT_OK = qw(\n\tCR LF CRLF $CR $LF $CRLF\n\n\tSOCK_NONBLOCK SOCK_CLOEXEC\n\n\tIP_ADD_MEMBERSHIP IP_DROP_MEMBERSHIP IP_MULTICAST_IF\n\tIP_MULTICAST_LOOP IP_MULTICAST_TTL\n\n\tIPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_TCP\n\tIPPROTO_UDP\n\n\tTCP_CONGESTION TCP_CORK TCP_DEFER_ACCEPT TCP_INFO TCP_KEEPALIVE\n\tTCP_KEEPCNT TCP_KEEPIDLE TCP_KEEPINTVL TCP_LINGER2 TCP_MAXRT TCP_MAXSEG\n\tTCP_MD5SIG TCP_NODELAY TCP_QUICKACK TCP_STDURG TCP_SYNCNT\n\tTCP_WINDOW_CLAMP \n\n\tIN6ADDR_ANY IN6ADDR_LOOPBACK\n\n\tIPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_MTU IPV6_MTU_DISCOVER\n\tIPV6_MULTICAST_HOPS IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP\n\tIPV6_UNICAST_HOPS IPV6_V6ONLY\n\n\tpack_ip_mreq unpack_ip_mreq\n\n\tpack_ipv6_mreq unpack_ipv6_mreq\n\n\tinet_pton inet_ntop\n\n\tgetaddrinfo getnameinfo\n\n\tAI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN\n\tAI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST\n\tAI_NUMERICSERV AI_PASSIVE AI_V4MAPPED\n\n\tNI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES\n\tNI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV\n\n\tNIx_NOHOST NIx_NOSERV\n\n\tEAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY\n\tEAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM\n);\n\nour %EXPORT_TAGS = (\n    crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],\n    addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],\n    all      => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n\n    # These are not gni() constants; they're extensions for the perl API\n    # The definitions in Socket.pm and Socket.xs must match\n    sub NIx_NOHOST() {1 << 0}\n    sub NIx_NOSERV() {1 << 1}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join('.', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_in6 {\n    if (wantarray) {\n\tcroak \"usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)\" unless @_ == 1;\n\tunpack_sockaddr_in6(@_);\n    }\n    else {\n\tcroak \"usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])\" unless @_ >= 2 and @_ <= 4;\n\tpack_sockaddr_in6(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nXSLoader::load(__PACKAGE__, $VERSION);\n\nmy %errstr;\n\nif( defined &getaddrinfo ) {\n    # These are not part of the API, nothing uses them, and deleting them\n    # reduces the size of %Socket:: by about 12K\n    delete $Socket::{fake_getaddrinfo};\n    delete $Socket::{fake_getnameinfo};\n} else {\n    require Scalar::Util;\n\n    *getaddrinfo = \\&fake_getaddrinfo;\n    *getnameinfo = \\&fake_getnameinfo;\n\n    # These numbers borrowed from GNU libc's implementation, but since\n    # they're only used by our emulation, it doesn't matter if the real\n    # platform's values differ\n    my %constants = (\n\tAI_PASSIVE     => 1,\n\tAI_CANONNAME   => 2,\n\tAI_NUMERICHOST => 4,\n\tAI_V4MAPPED    => 8,\n\tAI_ALL         => 16,\n\tAI_ADDRCONFIG  => 32,\n\t# RFC 2553 doesn't define this but Linux does - lets be nice and\n\t# provide it since we can\n\tAI_NUMERICSERV => 1024,\n\n\tEAI_BADFLAGS   => -1,\n\tEAI_NONAME     => -2,\n\tEAI_NODATA     => -5,\n\tEAI_FAMILY     => -6,\n\tEAI_SERVICE    => -8,\n\n\tNI_NUMERICHOST => 1,\n\tNI_NUMERICSERV => 2,\n\tNI_NOFQDN      => 4,\n\tNI_NAMEREQD    => 8,\n\tNI_DGRAM       => 16,\n\n\t# Constants we don't support. Export them, but croak if anyone tries to\n\t# use them\n\tAI_IDN                      => 64,\n\tAI_CANONIDN                 => 128,\n\tAI_IDN_ALLOW_UNASSIGNED     => 256,\n\tAI_IDN_USE_STD3_ASCII_RULES => 512,\n\tNI_IDN                      => 32,\n\tNI_IDN_ALLOW_UNASSIGNED     => 64,\n\tNI_IDN_USE_STD3_ASCII_RULES => 128,\n\n\t# Error constants we'll never return, so it doesn't matter what value\n\t# these have, nor that we don't provide strings for them\n\tEAI_SYSTEM   => -11,\n\tEAI_BADHINTS => -1000,\n\tEAI_PROTOCOL => -1001\n    );\n\n    foreach my $name ( keys %constants ) {\n\tmy $value = $constants{$name};\n\n\tno strict 'refs';\n\tdefined &$name or *$name = sub () { $value };\n    }\n\n    %errstr = (\n\t# These strings from RFC 2553\n\tEAI_BADFLAGS()   => \"invalid value for ai_flags\",\n\tEAI_NONAME()     => \"nodename nor servname provided, or not known\",\n\tEAI_NODATA()     => \"no address associated with nodename\",\n\tEAI_FAMILY()     => \"ai_family not supported\",\n\tEAI_SERVICE()    => \"servname not supported for ai_socktype\",\n    );\n}\n\n# The following functions are used if the system does not have a\n# getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET\n# family\n\n# Borrowed from Regexp::Common::net\nmy $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|1?[0-9][0-9]{1,2}/;\nmy $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL\\.$REGEXP_IPv4_DECIMAL/;\n\nsub fake_makeerr\n{\n    my ( $errno ) = @_;\n    my $errstr = $errno == 0 ? \"\" : ( $errstr{$errno} || $errno );\n    return Scalar::Util::dualvar( $errno, $errstr );\n}\n\nsub fake_getaddrinfo\n{\n    my ( $node, $service, $hints ) = @_;\n\n    $node = \"\" unless defined $node;\n\n    $service = \"\" unless defined $service;\n\n    my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};\n\n    $family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too\n    $family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );\n\n    $socktype ||= 0;\n\n    $protocol ||= 0;\n\n    $flags ||= 0;\n\n    my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();\n    my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();\n    my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();\n    my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();\n\n    # These constants don't apply to AF_INET-only lookups, so we might as well\n    # just ignore them. For AI_ADDRCONFIG we just presume the host has ability\n    # to talk AF_INET. If not we'd have to return no addresses at all. :)\n    $flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());\n\n    $flags & (AI_IDN()|AI_CANONIDN()|AI_IDN_ALLOW_UNASSIGNED()|AI_IDN_USE_STD3_ASCII_RULES()) and\n\tcroak \"Socket::getaddrinfo() does not support IDN\";\n\n    $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );\n\n    $node eq \"\" and $service eq \"\" and return fake_makeerr( EAI_NONAME() );\n\n    my $canonname;\n    my @addrs;\n    if( $node ne \"\" ) {\n\treturn fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );\n\t( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );\n\tdefined $canonname or return fake_makeerr( EAI_NONAME() );\n\n\tundef $canonname unless $flag_canonname;\n    }\n    else {\n\t$addrs[0] = $flag_passive ? Socket::inet_aton( \"0.0.0.0\" )\n\t\t\t\t  : Socket::inet_aton( \"127.0.0.1\" );\n    }\n\n    my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]\n    my $protname = \"\";\n    if( $protocol ) {\n\t$protname = getprotobynumber( $protocol );\n    }\n\n    if( $service ne \"\" and $service !~ m/^\\d+$/ ) {\n\treturn fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );\n\tgetservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );\n    }\n\n    foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {\n\tnext if $socktype and $this_socktype != $socktype;\n\n\tmy $this_protname = \"raw\";\n\t$this_socktype == Socket::SOCK_STREAM() and $this_protname = \"tcp\";\n\t$this_socktype == Socket::SOCK_DGRAM()  and $this_protname = \"udp\";\n\n\tnext if $protname and $this_protname ne $protname;\n\n\tmy $port;\n\tif( $service ne \"\" ) {\n\t    if( $service =~ m/^\\d+$/ ) {\n\t\t$port = \"$service\";\n\t    }\n\t    else {\n\t\t(", 8192) = 8192
09:01:56.945547 brk(0x8b5000)           = 0x8b5000
09:01:56.946723 read(10, " undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );\n\t\tnext unless defined $port;\n\t    }\n\t}\n\telse {\n\t    $port = 0;\n\t}\n\n\tpush @ports, [ $this_socktype, scalar getprotobyname( $this_protname ) || 0, $port ];\n    }\n\n    my @ret;\n    foreach my $addr ( @addrs ) {\n\tforeach my $portspec ( @ports ) {\n\t    my ( $socktype, $protocol, $port ) = @$portspec;\n\t    push @ret, {\n\t\tfamily    => $family,\n\t\tsocktype  => $socktype,\n\t\tprotocol  => $protocol,\n\t\taddr      => Socket::pack_sockaddr_in( $port, $addr ),\n\t\tcanonname => undef,\n\t    };\n\t}\n    }\n\n    # Only supply canonname for the first result\n    if( defined $canonname ) {\n\t$ret[0]->{canonname} = $canonname;\n    }\n\n    return ( fake_makeerr( 0 ), @ret );\n}\n\nsub fake_getnameinfo\n{\n    my ( $addr, $flags, $xflags ) = @_;\n\n    my ( $port, $inetaddr );\n    eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }\n\tor return fake_makeerr( EAI_FAMILY() );\n\n    my $family = Socket::AF_INET();\n\n    $flags ||= 0;\n\n    my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();\n    my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();\n    my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();\n    my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();\n    my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();\n\n    $flags & (NI_IDN()|NI_IDN_ALLOW_UNASSIGNED()|NI_IDN_USE_STD3_ASCII_RULES()) and\n\tcroak \"Socket::getnameinfo() does not support IDN\";\n\n    $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );\n\n    $xflags ||= 0;\n\n    my $node;\n    if( $xflags & NIx_NOHOST ) {\n\t$node = undef;\n    }\n    elsif( $flag_numerichost ) {\n\t$node = Socket::inet_ntoa( $inetaddr );\n    }\n    else {\n\t$node = gethostbyaddr( $inetaddr, $family );\n\tif( !defined $node ) {\n\t    return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;\n\t    $node = Socket::inet_ntoa( $inetaddr );\n\t}\n\telsif( $flag_nofqdn ) {\n\t    my ( $shortname ) = split m/\\./, $node;\n\t    my ( $fqdn ) = gethostbyname $shortname;\n\t    $node = $shortname if defined $fqdn and $fqdn eq $node;\n\t}\n    }\n\n    my $service;\n    if( $xflags & NIx_NOSERV ) {\n\t$service = undef;\n    }\n    elsif( $flag_numericserv ) {\n\t$service = \"$port\";\n    }\n    else {\n\tmy $protname = $flag_dgram ? \"udp\" : \"\";\n\t$service = getservbyport( $port, $protname );\n\tif( !defined $service ) {\n\t    $service = \"$port\";\n\t}\n    }\n\n    return ( fake_makeerr( 0 ), $node, $service );\n}\n\n1;\n", 8192) = 2499
09:01:56.947237 brk(0x8d6000)           = 0x8d6000
09:01:56.947559 read(10, "", 8192)      = 0
09:01:56.947638 close(10)               = 0
09:01:56.947936 stat("/usr/lib/perl5/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:56.948039 stat("/usr/lib/perl5/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=39256, ...}) = 0
09:01:56.948132 stat("/usr/lib/perl5/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:56.948238 open("/usr/lib/perl5/auto/Socket/Socket.so", O_RDONLY) = 10
09:01:56.948323 read(10, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\3002\0\0\0\0\0\0@\0\0\0\0\0\0\0\230\222\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324y\0\0\0\0\0\0\324y\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\200z\0\0\0\0\0\0\200z \0\0\0\0\0\200z \0\0\0\0\0000\27\0\0\0\0\0\0008\27\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0`\215\0\0\0\0\0\0`\215 \0\0\0\0\0`\215 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\340s\0\0\0\0\0\0\340s\0\0\0\0\0\0\340s\0\0\0\0\0\0\304\0\0\0\0\0\0\0\304\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\200z\0\0\0\0\0\0\200z \0\0\0\0\0\200z \0\0\0\0\0\200\25\0\0\0\0\0\0\200\25\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\311P\223\265b\356\325\340\334:BD\267\201Y\363\314\246p\357\0\0\0\0C\0\0\0R\0\0\0\0\0\0\0,\0\0\0005\0\0\0\0\0\0\0003\0\0\0\32\0\0\0\0\0\0\0#\0\0\0(\0\0\0H\0\0\0002\0\0\0<\0\0\0.\0\0\0\17\0\0\0\0\0\0\0009\0\0\0%\0\0\0\0\0\0\0006\0\0\0/\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0=\0\0\0\23\0\0\0Q\0\0\0A\0\0\0G\0\0\0\0\0\0\0D\0\0\0)\0\0\0M\0\0\0@\0\0\0;\0\0\0 \0\0\0\34\0\0\0008\0\0\0*\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0'\0\0\0!\0\0\0\16\0\0\0\7\0\0\0:\0\0\0\0\0\0\0I\0\0\0$\0\0\0001\0\0\0\35\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0J\0\0\0\21\0\0\0\"\0\0\0K\0\0\0\25\0\0\0F\0\0\0\0\0\0\0&\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.948547 fstat(10, {st_mode=S_IFREG|0644, st_size=39256, ...}) = 0
09:01:56.948643 mmap(NULL, 2134456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0x7f7435312000
09:01:56.948723 mprotect(0x7f743531a000, 2093056, PROT_NONE) = 0
09:01:56.948802 mmap(0x7f7435519000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x7000) = 0x7f7435519000
09:01:56.948894 close(10)               = 0
09:01:56.948995 mprotect(0x7f7435519000, 8192, PROT_READ) = 0
09:01:56.950127 stat("modules/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.950217 stat("modules/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.950300 stat("modules/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.950378 stat("modules/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.950457 stat("/etc/perl/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.950538 stat("/etc/perl/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.950619 stat("/usr/local/lib/perl/5.14.2/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.950701 stat("/usr/local/lib/perl/5.14.2/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.950783 stat("/usr/local/share/perl/5.14.2/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.950863 stat("/usr/local/share/perl/5.14.2/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.950945 stat("/usr/lib/perl5/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.951025 stat("/usr/lib/perl5/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.951105 stat("/usr/share/perl5/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.951186 stat("/usr/share/perl5/Errno.pm", 0x7ffe12339cf0) = -1 ENOENT (No such file or directory)
09:01:56.951267 stat("/usr/lib/perl/5.14/Errno.pmc", 0x7ffe12339da0) = -1 ENOENT (No such file or directory)
09:01:56.951349 stat("/usr/lib/perl/5.14/Errno.pm", {st_mode=S_IFREG|0644, st_size=4883, ...}) = 0
09:01:56.951444 open("/usr/lib/perl/5.14/Errno.pm", O_RDONLY) = 10
09:01:56.951530 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339a80) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.951605 lseek(10, 0, SEEK_CUR)  = 0
09:01:56.951694 read(10, "# -*- buffer-read-only: t -*-\n#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nrequire Exporter;\nuse strict;\n\nour $VERSION = \"1.13\";\n$VERSION = eval $VERSION;\nour @ISA = 'Exporter';\n\nmy %err;\n\nBEGIN {\n    %err = (\n\tEPERM => 1,\n\tENOENT => 2,\n\tESRCH => 3,\n\tEINTR => 4,\n\tEIO => 5,\n\tENXIO => 6,\n\tE2BIG => 7,\n\tENOEXEC => 8,\n\tEBADF => 9,\n\tECHILD => 10,\n\tEWOULDBLOCK => 11,\n\tEAGAIN => 11,\n\tENOMEM => 12,\n\tEACCES => 13,\n\tEFAULT => 14,\n\tENOTBLK => 15,\n\tEBUSY => 16,\n\tEEXIST => 17,\n\tEXDEV => 18,\n\tENODEV => 19,\n\tENOTDIR => 20,\n\tEISDIR => 21,\n\tEINVAL => 22,\n\tENFILE => 23,\n\tEMFILE => 24,\n\tENOTTY => 25,\n\tETXTBSY => 26,\n\tEFBIG => 27,\n\tENOSPC => 28,\n\tESPIPE => 29,\n\tEROFS => 30,\n\tEMLINK => 31,\n\tEPIPE => 32,\n\tEDOM => 33,\n\tERANGE => 34,\n\tEDEADLOCK => 35,\n\tEDEADLK => 35,\n\tENAMETOOLONG => 36,\n\tENOLCK => 37,\n\tENOSYS => 38,\n\tENOTEMPTY => 39,\n\tELOOP => 40,\n\tENOMSG => 42,\n\tEIDRM => 43,\n\tECHRNG => 44,\n\tEL2NSYNC => 45,\n\tEL3HLT => 46,\n\tEL3RST => 47,\n\tELNRNG => 48,\n\tEUNATCH => 49,\n\tENOCSI => 50,\n\tEL2HLT => 51,\n\tEBADE => 52,\n\tEBADR => 53,\n\tEXFULL => 54,\n\tENOANO => 55,\n\tEBADRQC => 56,\n\tEBADSLT => 57,\n\tEBFONT => 59,\n\tENOSTR => 60,\n\tENODATA => 61,\n\tETIME => 62,\n\tENOSR => 63,\n\tENONET => 64,\n\tENOPKG => 65,\n\tEREMOTE => 66,\n\tENOLINK => 67,\n\tEADV => 68,\n\tESRMNT => 69,\n\tECOMM => 70,\n\tEPROTO => 71,\n\tEMULTIHOP => 72,\n\tEDOTDOT => 73,\n\tEBADMSG => 74,\n\tEOVERFLOW => 75,\n\tENOTUNIQ => 76,\n\tEBADFD => 77,\n\tEREMCHG => 78,\n\tELIBACC => 79,\n\tELIBBAD => 80,\n\tELIBSCN => 81,\n\tELIBMAX => 82,\n\tELIBEXEC => 83,\n\tEILSEQ => 84,\n\tERESTART => 85,\n\tESTRPIPE => 86,\n\tEUSERS => 87,\n\tENOTSOCK => 88,\n\tEDESTADDRREQ => 89,\n\tEMSGSIZE => 90,\n\tEPROTOTYPE => 91,\n\tENOPROTOOPT => 92,\n\tEPROTONOSUPPORT => 93,\n\tESOCKTNOSUPPORT => 94,\n\tENOTSUP => 95,\n\tEOPNOTSUPP => 95,\n\tEPFNOSUPPORT => 96,\n\tEAFNOSUPPORT => 97,\n\tEADDRINUSE => 98,\n\tEADDRNOTAVAIL => 99,\n\tENETDOWN => 100,\n\tENETUNREACH => 101,\n\tENETRESET => 102,\n\tECONNABORTED => 103,\n\tECONNRESET => 104,\n\tENOBUFS => 105,\n\tEISCONN => 106,\n\tENOTCONN => 107,\n\tESHUTDOWN => 108,\n\tETOOMANYREFS => 109,\n\tETIMEDOUT => 110,\n\tECONNREFUSED => 111,\n\tEHOSTDOWN => 112,\n\tEHOSTUNREACH => 113,\n\tEALREADY => 114,\n\tEINPROGRESS => 115,\n\tESTALE => 116,\n\tEUCLEAN => 117,\n\tENOTNAM => 118,\n\tENAVAIL => 119,\n\tEISNAM => 120,\n\tEREMOTEIO => 121,\n\tEDQUOT => 122,\n\tENOMEDIUM => 123,\n\tEMEDIUMTYPE => 124,\n\tECANCELED => 125,\n\tENOKEY => 126,\n\tEKEYEXPIRED => 127,\n\tEKEYREVOKED => 128,\n\tEKEYREJECTED => 129,\n\tEOWNERDEAD => 130,\n\tENOTRECOVERABLE => 131,\n\tERFKILL => 132,\n\tEHWPOISON => 133,\n    );\n    # Generate proxy constant subroutines for all the values.\n    # Well, almost all the values. Unfortunately we can't assume that at this\n    # point that our symbol table is empty, as code such as if the parser has\n    # seen code such as C<exists &Errno::EINVAL>, it will have created the\n    # typeglob.\n    # Doing this before defining @EXPORT_OK etc means that even if a platform is\n    # crazy enough to define EXPORT_OK as an error constant, everything will\n    # still work, because the parser will upgrade the PCS to a real typeglob.\n    # We rely on the subroutine definitions below to update the internal caches.\n    # Don't use %each, as we don't want a copy of the value.\n    foreach my $name (keys %err) {\n        if ($Errno::{$name}) {\n            # We expect this to be reached fairly rarely, so take an approach\n            # which uses the least compile time effort in the common case:\n            eval \"sub $name() { $err{$name} }; 1\" or die $@;\n        } else {\n            $Errno::{$name} = \\$err{$name};\n        }\n    }\n}\n\nour @EXPORT_OK = keys %err;\n\nour %EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub TIEHASH { bless \\%err }\n\nsub FETCH {\n    my (undef, $errname) = @_;\n    return \"\" unless exists $err{$errname};\n    my $errno = $err{$errname};\n    return $errno == $! ? $errno : 0;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = *DELETE = \\*STORE; # Typeglob aliasing uses less space\n\nsub NEXTKEY {\n    each %err;\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %err;\t# initialize iterator\n    each %err;\n}\n\nsub EXISTS {\n    my (undef, $errname) = @_;\n    exists $err{$errname};\n}\n\ntie %!, __PACKAGE__; # Returns an object, objects are true.\n\n__END__\n\n# ex: set ro:\n", 8192) = 4883
09:01:56.952734 lseek(10, 4868, SEEK_SET) = 4868
09:01:56.952812 lseek(10, 0, SEEK_CUR)  = 4868
09:01:56.952884 close(10)               = 0
09:01:56.953674 brk(0x8f7000)           = 0x8f7000
09:01:56.954565 read(9, "kaddr_family($addr)\n\t   if (defined($addr));\n    }\n    ${*$sock}{'io_socket_domain'};\n}\n\nsub socktype {\n    @_ == 1 or croak 'usage: $sock->socktype()';\n    my $sock = shift;\n    ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)\n\tif (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));\n    ${*$sock}{'io_socket_type'}\n}\n\nsub protocol {\n    @_ == 1 or croak 'usage: $sock->protocol()';\n    my($sock) = @_;\n    ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)\n\tif (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));\n    ${*$sock}{'io_socket_proto'};\n}\n\n1;\n\n__END__\n\n", 8192) = 644
09:01:56.954857 lseek(9, 8835, SEEK_SET) = 8835
09:01:56.954929 lseek(9, 0, SEEK_CUR)   = 8835
09:01:56.954998 close(9)                = 0
09:01:56.955101 stat("modules/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955179 stat("modules/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.955255 stat("modules/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955329 stat("modules/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.955404 stat("/etc/perl/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955479 stat("/etc/perl/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.955555 stat("/usr/local/lib/perl/5.14.2/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955632 stat("/usr/local/lib/perl/5.14.2/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.955709 stat("/usr/local/share/perl/5.14.2/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955788 stat("/usr/local/share/perl/5.14.2/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.955871 stat("/usr/lib/perl5/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.955949 stat("/usr/lib/perl5/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.956025 stat("/usr/share/perl5/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.956102 stat("/usr/share/perl5/IO/Socket/INET.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.956179 stat("/usr/lib/perl/5.14/IO/Socket/INET.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.956259 stat("/usr/lib/perl/5.14/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=7456, ...}) = 0
09:01:56.956350 open("/usr/lib/perl/5.14/IO/Socket/INET.pm", O_RDONLY) = 9
09:01:56.956432 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.956502 lseek(9, 0, SEEK_CUR)   = 0
09:01:56.956593 read(9, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.31\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\nmy %proto_number;\n$proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;\n$proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;\n$proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;\nmy %proto_name = reverse %proto_number;\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _cache_proto {\n    my @proto = @_;\n    for (map lc($_), $proto[0], split(' ', $proto[1])) {\n\t$proto_number{$_} = $proto[2];\n    }\n    $proto_name{$proto[2]} = $proto[0];\n}\n\nsub _get_proto_number {\n    my $name = lc(shift);\n    return undef unless defined $name;\n    return $proto_number{$name} if exists $proto_number{$name};\n\n    my @proto = getprotobyname($name);\n    return undef unless @proto;\n    _cache_proto(@proto);\n\n    return $proto[2];\n}\n\nsub _get_proto_name {\n    my $num = shift;\n    return undef unless defined $num;\n    return $proto_name{$num} if exists $proto_name{$num};\n\n    my @proto = getprotobynumber($num);\n    return undef unless @proto;\n    _cache_proto(@proto);\n\n    return $proto[0];\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    my $num = _get_proto_number($proto);\n    unless (defined $num) {\n      $@ = \"Bad protocol '$proto'\";\n      return;\n    }\n    $proto = $num;\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, _get_proto_name($proto) || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service '$origport'\";\n\treturn;\n    }\n\n    $proto = _get_proto_number($serv[3]) if @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      $sock->close()\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname '\",$arg->{LocalAddr},\"'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= _get_proto_number('tcp');\n\n    $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname '\",$arg->{PeerAddr},\"'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don't try to connect unless we're given a PeerAddr\n \tlast unless exists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, 'Cannot determine remote port')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname '\",$arg->{PeerAddr},\"'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{'io_socket_timeout'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{'io_socket_timeout'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{'io_socket_timeout'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak 'usage: $sock->sockaddr()';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak 'usage: $sock->sockport()';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak 'usage: $sock->sockhost()';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak 'usage: $sock->peeraddr()';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak 'usage: $sock->peerport()';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak 'usage: $sock->peerhost()';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 8192) = 7456
09:01:56.957378 brk(0x918000)           = 0x918000
09:01:56.959249 brk(0x939000)           = 0x939000
09:01:56.960025 lseek(9, 7455, SEEK_SET) = 7455
09:01:56.960099 lseek(9, 0, SEEK_CUR)   = 7455
09:01:56.960169 close(9)                = 0
09:01:56.960300 stat("modules/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.960381 stat("modules/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.960458 stat("modules/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.960541 stat("modules/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.960618 stat("/etc/perl/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.960695 stat("/etc/perl/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.960771 stat("/usr/local/lib/perl/5.14.2/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.960850 stat("/usr/local/lib/perl/5.14.2/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.960928 stat("/usr/local/share/perl/5.14.2/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.961005 stat("/usr/local/share/perl/5.14.2/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.961084 stat("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.961163 stat("/usr/lib/perl5/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.961243 stat("/usr/share/perl5/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.961322 stat("/usr/share/perl5/IO/Socket/UNIX.pm", 0x7ffe1233a320) = -1 ENOENT (No such file or directory)
09:01:56.961403 stat("/usr/lib/perl/5.14/IO/Socket/UNIX.pmc", 0x7ffe1233a3d0) = -1 ENOENT (No such file or directory)
09:01:56.961483 stat("/usr/lib/perl/5.14/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1375, ...}) = 0
09:01:56.961574 open("/usr/lib/perl/5.14/IO/Socket/UNIX.pm", O_RDONLY) = 9
09:01:56.961658 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.961731 lseek(9, 0, SEEK_CUR)   = 0
09:01:56.961825 read(9, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.23\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak 'usage: $sock->hostpath()';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak 'usage: $sock->peerpath()';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 8192) = 1375
09:01:56.962781 lseek(9, 1374, SEEK_SET) = 1374
09:01:56.962859 lseek(9, 0, SEEK_CUR)   = 1374
09:01:56.962928 close(9)                = 0
09:01:56.963603 brk(0x95a000)           = 0x95a000
09:01:56.964748 read(8, "f (length $@) {\n      warn \"socketpair failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using UNIX domain socketpairs\";\n      warn \"ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\\n\";\n    };\n\n    # It's two-way, so each reader is also a writer.\n    $$a_write = $$a_read;\n    $$b_write = $$b_read;\n\n    # Turn off buffering.  POE::Kernel does this for us, but someone\n    # might want to use the pipe class elsewhere.\n    select((select($$a_write), $| = 1)[0]);\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  # Try a couple pipe() calls.\n  if ($type eq \"pipe\") {\n    eval {\n      pipe($$a_read, $$b_write) or die \"pipe 1 failed: $!\";\n      pipe($$b_read, $$a_write) or die \"pipe 2 failed: $!\";\n    };\n\n    # Pipe failed.\n    if (length $@) {\n      warn \"pipe failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using a pipe\";\n      warn \"ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\\n\";\n    };\n\n    # Turn off buffering.  POE::Kernel does this for us, but someone\n    # might want to use the pipe class elsewhere.\n    select((select($$a_write), $| = 1)[0]);\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  # Try a pair of plain INET sockets.\n  if ($type eq \"inet\") {\n    eval {\n      ($$a_read, $$b_read) = _make_socket();\n    };\n\n    # Sockets failed.\n    if (length $@) {\n      warn \"make_socket failed: $@\" if $debug;\n      return;\n    }\n\n    $debug and do {\n      warn \"using a plain INET socket\";\n      warn \"ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\\n\";\n    };\n\n    $$a_write = $$a_read;\n    $$b_write = $$b_read;\n\n    # Turn off buffering.  POE::Kernel does this for us, but someone\n    # might want to use the pipe class elsewhere.\n    select((select($$a_write), $| = 1)[0]);\n    select((select($$b_write), $| = 1)[0]);\n    return 1;\n  }\n\n  $debug and warn \"unknown pipely(2) socket type ``$type''\";\n  return;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nIO::Pipely - Portably create pipe() or pipe-like handles, one way or another.\n\n=head1 VERSION\n\nversion 0.005\n\n=head1 SYNOPSIS\n\nPlease read DESCRIPTION for detailed semantics and caveats.\n\n  use IO::Pipely qw(pipely socketpairly);\n\n  # Create a one-directional pipe() or pipe-like thing\n  # the best conduit type available.\n\n  my ($read, $write) = pipely();\n\n  # Create a one-directional pipe-like thing using an\n  # INET socket specifically.  Other types are available.\n\n  my ($read, $write) = pipely(type => 'inet');\n\n  # Create a bidirectional pipe-like thing using\n  # the best conduit type available.\n\n  my (\n    $side_a_read,  $side_b_read,\n    $side_a_write, $side_b_write,\n  ) = socketpairly();\n\n  # Create a bidirectional pipe-like thing using an INET socket\n  # specifically.\n\n  my (\n    $side_a_read,  $side_b_read,\n    $side_a_write, $side_b_write,\n  ) = socketpairly(type => 'inet');\n\n=head1 DESCRIPTION\n\nPipes are troublesome beasts because there are a few different,\nincompatible ways to create them.  Not all platforms support all ways,\nand some platforms may have hidden difficulties like incomplete or\nbuggy support.\n\nIO::Pipely provides a couple functions to portably create one- and\ntwo-way pipes and pipe-like socket pairs.  It acknowledges and works\naround known platform issues so you don't have to.\n\nOn the other hand, it doesn't work around unknown issues, so please\nreport any problems early and often.\n\nIO::Pipely currently understands pipe(), UNIX-domain socketpair() and\nregular IPv4 localhost sockets.  This covers every platform tested so\nfar, but it's hardly complete.  Please help support other mechanisms,\nsuch as INET-domain socketpair() and IPv6 localhost sockets.\n\nIO::Pipely will use different kinds of pipes or sockets depending on\nthe operating system's capabilities and the number of directions\nrequested.  The autodetection may be overridden by specifying a\nparticular pipe type.\n\n=head2 pipely\n\npipely() creates a one-directional pipe() or socket.  It's modeled\nafter Perl's built-in pipe() function, but it creates and returns\nhandles rather than opening ones given to it.\n\nOn success, pipely() returns two file handles, the first to read from\nthe pipe, and the second writes into the pipe.  It returns nothing on\nfailure.\n\n  use IO::Pipely qw(pipely);\n  my ($a_read, $b_write) = pipely();\n  die \"pipely() failed: $!\" unless $a_read;\n\nWhen given a choice, it will prefer to use leaner pipe() calls instead\nof socketpair() and socket().\n\npipely()'s choice can be forced using an optional named \"type\"\nparameter.  See L</PIPE TYPES> for the types that can be used.\n\n  my ($a_read, $b_write) = pipely(\n    type => 'pipe',\n  );\n\nOn most systems, pipely() will prefer to open a pipe() first.  It will\nfall back to a UNIX socketpair() or two localhost Internet sockets, in\nthat order.\n\nOn Windows (ActiveState and Strawberry Perl), pipely() prefers two\nlocalhost Internet sockets.  It will fall back to socketpair() and\npipe(), both of which will probably fail.\n\nCygwin Perl prefers pipe() first, localhost Internet sockets, and then\nsocketpair().  socketpair() has been known to have problems on Cygwin.\n\nMacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.\n\n=head2 socketpairly\n\nsocketpairly() creates a two-directional socket pair.  It's modeled\nafter Perl's built-in socketpair(), but it creates and returns handles\nrather than opening ones given to it.\n\nOn success, socketpairly() returns four file handles, read and write\nfor one end, and read and write for the other.  On failure, it returns\nnothing.\n\n  use IO::Pipely qw(socketpairly);\n  my ($a_read, $b_read, $a_write, $b_write) = socketpairly();\n  die \"socketpairly() failed: $!\" unless $a_read;\n\nsocketpairly() returns two extra \"writer\" handles.  They exist for the\nfallback case where two pipe() calls are needed instead of one socket\npair.  The extra handles can be ignored whenever pipe() will never be\nused.  For example:\n\n  use IO::Pipely qw(socketpairly);\n  my ($side_a, $side_b) = socketpairly( type => 'socketpair' );\n  die \"socketpairly() failed: $!\" unless $side_a;\n\nWhen given a choice, it will prefer bidirectional sockets instead of\npipe() calls.\n\nsocketpairly()'s choice can be forced using an optional named \"type\"\nparameter.  See L</PIPE TYPES> for the types that can be used.  In\nthis example, two unidirectional pipes wil be used instead of a more\nefficient pair of sockets:\n\n  my ($a_read, $a_write, $b_read, $b_write) = pipely(\n    type => 'pipe',\n  );\n\nOn most systems, socketpairly() will try to open a UNIX socketpair()\nfirst.  It will then fall back to a pair of localhost Internet\nsockets, and finally it will try a pair of pipe() calls.\n\nOn Windows (ActiveState and Strawberry Perl), socketpairly() prefers a\npair of localhost Internet sockets first.  It will then fall back to a\nUNIX socketpair(), and finally a couple of pipe() calls.  The fallback\noptions will probably fail, but the code remains hopeful.\n\nCygwin Perl prefers localhost Internet sockets first, followed by a\npair of pipe() calls, and finally a UNIX socketpair().  Those who know\nmay find this counter-intuitive, but it works around known issues in\nsome versions of Cygwin socketpair().\n\nMacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.\n\n=head2 PIPE TYPES\n\nIO::Pipely currently supports three types of pipe and socket.  Other\ntypes are possible, but these three cover all known uses so far.\nPlease ask (or send patches) if additional types are needed.\n\n=head3 pipe\n\nAttempt to establish a one-way pipe using one pipe() filehandle pair\n(2 file descriptors), or a two-way pipe-like connection using two\npipe() pairs (4 file descriptors).\n\nIO::Pipely prefers to use pipe() for one-way pipes and some form of\nsocket pair for two-way pipelike things.\n\n=head3 socketpair\n\nAttempt to establish a one- or two-way pipelike connection using a\nsingle socketpair() call.  This uses two file descriptors regardless\nwhether the connection is one- or two-way.\n\nIO::Pipely prefers socketpair() for two-way connections, unless the\ncurrent platform has known issues with the socketpair() call.\n\nSocket pairs are UNIX domain only for now.  INET domain may be added\nif it improves compatibility on some platform, or if someon", 8192) = 8192
09:01:56.965642 brk(0x97b000)           = 0x97b000
09:01:56.965752 lseek(8, 10137, SEEK_SET) = 10137
09:01:56.965823 lseek(8, 0, SEEK_CUR)   = 10137
09:01:56.965892 close(8)                = 0
09:01:56.966039 lseek(7, 215, SEEK_SET) = 215
09:01:56.966121 lseek(7, 0, SEEK_CUR)   = 215
09:01:56.966191 close(7)                = 0
09:01:56.966426 lseek(6, 383, SEEK_SET) = 383
09:01:56.966499 lseek(6, 0, SEEK_CUR)   = 383
09:01:56.966568 close(6)                = 0
09:01:56.966676 stat("modules/File/Spec.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.966756 stat("modules/File/Spec.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.966832 stat("modules/File/Spec.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.966907 stat("modules/File/Spec.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.966982 stat("/etc/perl/File/Spec.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.967058 stat("/etc/perl/File/Spec.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.967134 stat("/usr/local/lib/perl/5.14.2/File/Spec.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.967215 stat("/usr/local/lib/perl/5.14.2/File/Spec.pm", {st_mode=S_IFREG|0444, st_size=10520, ...}) = 0
09:01:56.967306 open("/usr/local/lib/perl/5.14.2/File/Spec.pm", O_RDONLY) = 6
09:01:56.967388 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.967459 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.967548 read(6, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = '3.62';\n$VERSION =~ tr/_//d;\n\nmy %module = (MacOS   => 'Mac',\n\t      MSWin32 => 'Win32',\n\t      os2     => 'OS2',\n\t      VMS     => 'VMS',\n\t      epoc    => 'Epoc',\n\t      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => 'Cygwin',\n\t      amigaos => 'AmigaOS');\n\n\nmy $module = $module{$^O} || 'Unix';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n=head1 NAME\n\nFile::Spec - portably perform operations on file names\n\n=head1 SYNOPSIS\n\n\tuse File::Spec;\n\n\t$x=File::Spec->catfile('a', 'b', 'c');\n\nwhich returns 'a/b/c' under Unix. Or:\n\n\tuse File::Spec::Functions;\n\n\t$x = catfile('a', 'b', 'c');\n\n=head1 DESCRIPTION\n\nThis module is designed to support operations commonly performed on file\nspecifications (usually called \"file names\", but not to be confused with the\ncontents of a file, or Perl's file handles), such as concatenating several\ndirectory and file names into a single path, or determining whether a path\nis rooted. It is based on code directly taken from MakeMaker 5.17, code\nwritten by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya\nZakharevich, Paul Schinder, and others.\n\nSince these functions are different for most operating systems, each set of\nOS specific routines is available in a separate module, including:\n\n\tFile::Spec::Unix\n\tFile::Spec::Mac\n\tFile::Spec::OS2\n\tFile::Spec::Win32\n\tFile::Spec::VMS\n\nThe module appropriate for the current OS is automatically loaded by\nFile::Spec. Since some modules (like VMS) make use of facilities available\nonly under that OS, it may not be possible to load all modules under all\noperating systems.\n\nSince File::Spec is object oriented, subroutines should not be called directly,\nas in:\n\n\tFile::Spec::catfile('a','b');\n\nbut rather as class methods:\n\n\tFile::Spec->catfile('a','b');\n\nFor simple uses, L<File::Spec::Functions> provides convenient functional\nforms of these methods.\n\n=head1 METHODS\n\n=over 2\n\n=item canonpath\nX<canonpath>\n\nNo physical check on the filesystem, but a logical cleanup of a\npath.\n\n    $cpath = File::Spec->canonpath( $path ) ;\n\nNote that this does *not* collapse F<x/../y> sections into F<y>.  This\nis by design.  If F</foo> on your system is a symlink to F</bar/baz>,\nthen F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive\nF<../>-removal would give you.  If you want to do this kind of\nprocessing, you probably want C<Cwd>'s C<realpath()> function to\nactually traverse the filesystem cleaning up paths like this.\n\n=item catdir\nX<catdir>\n\nConcatenate two or more directory names to form a complete path ending\nwith a directory. But remove the trailing slash from the resulting\nstring, because it doesn't look good, isn't necessary and confuses\nOS/2. Of course, if this is the root directory, don't cut off the\ntrailing slash :-)\n\n    $path = File::Spec->catdir( @directories );\n\n=item catfile\nX<catfile>\n\nConcatenate one or more directory names and a filename to form a\ncomplete path ending with a filename\n\n    $path = File::Spec->catfile( @directories, $filename );\n\n=item curdir\nX<curdir>\n\nReturns a string representation of the current directory.\n\n    $curdir = File::Spec->curdir();\n\n=item devnull\nX<devnull>\n\nReturns a string representation of the null device.\n\n    $devnull = File::Spec->devnull();\n\n=item rootdir\nX<rootdir>\n\nReturns a string representation of the root directory.\n\n    $rootdir = File::Spec->rootdir();\n\n=item tmpdir\nX<tmpdir>\n\nReturns a string representation of the first writable directory from a\nlist of possible temporary directories.  Returns the current directory\nif no writable temporary directories are found.  The list of directories\nchecked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>\n(unless taint is on) and F</tmp>.\n\n    $tmpdir = File::Spec->tmpdir();\n\n=item updir\nX<updir>\n\nReturns a string representation of the parent directory.\n\n    $updir = File::Spec->updir();\n\n=item no_upwards\n\nGiven a list of file names, strip out those that refer to a parent\ndirectory. (Does not strip symlinks, only '.', '..', and equivalents.)\n\n    @paths = File::Spec->no_upwards( @paths );\n\n=item case_tolerant\n\nReturns a true or false value indicating, respectively, that alphabetic\ncase is not or is significant when comparing file specifications.\nCygwin and Win32 accept an optional drive argument.\n\n    $is_case_tolerant = File::Spec->case_tolerant();\n\n=item file_name_is_absolute\n\nTakes as its argument a path, and returns true if it is an absolute path.\n\n    $is_absolute = File::Spec->file_name_is_absolute( $path );\n\nThis does not consult the local filesystem on Unix, Win32, OS/2, or\nMac OS (Classic).  It does consult the working environment for VMS\n(see L<File::Spec::VMS/file_name_is_absolute>).\n\n=item path\nX<path>\n\nTakes no argument.  Returns the environment variable C<PATH> (or the local\nplatform's equivalent) as a list.\n\n    @PATH = File::Spec->path();\n\n=item join\nX<join, path>\n\njoin is the same as catfile.\n\n=item splitpath\nX<splitpath> X<split, path>\n\nSplits a path in to volume, directory, and filename portions. On systems\nwith no concept of volume, returns '' for volume. \n\n    ($volume,$directories,$file) =\n                       File::Spec->splitpath( $path );\n    ($volume,$directories,$file) =\n                       File::Spec->splitpath( $path, $no_file );\n\nFor systems with no syntax differentiating filenames from directories, \nassumes that the last file is a path unless C<$no_file> is true or a\ntrailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>\ntrue makes this return ( '', $path, '' ).\n\nThe directory portion may or may not be returned with a trailing '/'.\n\nThe results can be passed to L</catpath()> to get back a path equivalent to\n(usually identical to) the original path.\n\n=item splitdir\nX<splitdir> X<split, dir>\n\nThe opposite of L</catdir>.\n\n    @dirs = File::Spec->splitdir( $directories );\n\nC<$directories> must be only the directory portion of the path on systems \nthat have the concept of a volume or that have path syntax that differentiates\nfiles from directories.\n\nUnlike just splitting the directories on the separator, empty\ndirectory names (C<''>) can be returned, because these are significant\non some OSes.\n\n=item catpath()\n\nTakes volume, directory and file portions and returns an entire path. Under\nUnix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is\ninserted if need be.  On other OSes, C<$volume> is significant.\n\n    $full_path = File::Spec->catpath( $volume, $directory, $file );\n\n=item abs2rel\nX<abs2rel> X<absolute, path> X<relative, path>\n\nTakes a destination path and an optional base path returns a relative path\nfrom the base path to the destination path:\n\n    $rel_path = File::Spec->abs2rel( $path ) ;\n    $rel_path = File::Spec->abs2rel( $path, $base ) ;\n\nIf C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is\nrelative, then it is converted to absolute form using\nL</rel2abs()>. This means that it is taken to be relative to\nL<Cwd::cwd()|Cwd>.\n\nOn systems with the concept of volume, if C<$path> and C<$base> appear to be\non two different volumes, we will not attempt to resolve the two\npaths, and we will instead simply return C<$path>.  Note that previous\nversions of this module ignored the volume of C<$base>, which resulted in\ngarbage results part of the time.\n\nOn systems that have a grammar that indicates filenames, this ignores the \nC<$base> filename as well. Otherwise all path components are assumed to be\ndirectories.\n\nIf C<$path> is relative, it is converted to absolute form using L</rel2abs()>.\nThis means that it is taken to be relative to L<Cwd::cwd()|Cwd>.\n\nNo checks against the filesystem are made.  On VMS, there is\ninteraction with the working environment, as logicals and\nmacros are expanded.\n\nBased on code written by Shigio Yamaguchi.\n\n=item rel2abs()\nX<rel2abs> X<absolute, path> X<relative, path>\n\nConverts a relative path to an absolute path. \n\n    $abs_path = File::Spec->rel2abs", 8192) = 8192
09:01:56.968313 lseek(6, 619, SEEK_SET) = 619
09:01:56.968387 lseek(6, 0, SEEK_CUR)   = 619
09:01:56.968456 close(6)                = 0
09:01:56.968553 stat("modules/File/Spec/Unix.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.968632 stat("modules/File/Spec/Unix.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.968708 stat("modules/File/Spec/Unix.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.968783 stat("modules/File/Spec/Unix.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.968858 stat("/etc/perl/File/Spec/Unix.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.968934 stat("/etc/perl/File/Spec/Unix.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.969010 stat("/usr/local/lib/perl/5.14.2/File/Spec/Unix.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.969090 stat("/usr/local/lib/perl/5.14.2/File/Spec/Unix.pm", {st_mode=S_IFREG|0444, st_size=16602, ...}) = 0
09:01:56.969185 open("/usr/local/lib/perl/5.14.2/File/Spec/Unix.pm", O_RDONLY) = 6
09:01:56.969268 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.969339 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.969426 read(6, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = '3.62';\nmy $xs_version = $VERSION;\n$VERSION =~ tr/_//d;\n\n#dont try to load XSLoader and DynaLoader only to ultimately fail on miniperl\nif(!defined &canonpath && defined &DynaLoader::boot_DynaLoader) {\n  eval {#eval is questionable since we are handling potential errors like\n        #\"Cwd object version 3.48 does not match bootstrap parameter 3.50\n        #at lib/DynaLoader.pm line 216.\" by having this eval\n    if ( $] >= 5.006 ) {\n\trequire XSLoader;\n\tXSLoader::load(\"Cwd\", $xs_version);\n    } else {\n\trequire Cwd;\n    }\n  };\n}\n\n=head1 NAME\n\nFile::Spec::Unix - File::Spec for Unix, base for other File::Spec modules\n\n=head1 SYNOPSIS\n\n require File::Spec::Unix; # Done automatically by File::Spec\n\n=head1 DESCRIPTION\n\nMethods for manipulating file specifications.  Other File::Spec\nmodules, such as File::Spec::Mac, inherit from File::Spec::Unix and\noverride specific methods.\n\n=head1 METHODS\n\n=over 2\n\n=item canonpath()\n\nNo physical check on the filesystem, but a logical cleanup of a\npath. On UNIX eliminates successive slashes and successive \"/.\".\n\n    $cpath = File::Spec->canonpath( $path ) ;\n\nNote that this does *not* collapse F<x/../y> sections into F<y>.  This\nis by design.  If F</foo> on your system is a symlink to F</bar/baz>,\nthen F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive\nF<../>-removal would give you.  If you want to do this kind of\nprocessing, you probably want C<Cwd>'s C<realpath()> function to\nactually traverse the filesystem cleaning up paths like this.\n\n=cut\n\nsub _pp_canonpath {\n    my ($self,$path) = @_;\n    return unless defined $path;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = '';\n    my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';\n\n\n    if ( $double_slashes_special\n         && ( $path =~ s{^(//[^/]+)/?\\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless ($^O eq 'cygwin');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn't get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx\n    $path =~ s{(?:/\\.)+(?:/|\\z)}{/}g;                # xx/././xx -> xx/xx\n    $path =~ s|^(?:\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(?:\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\z|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n*canonpath = \\&_pp_canonpath unless defined &canonpath;\n\n=item catdir()\n\nConcatenate two or more directory names to form a complete path ending\nwith a directory. But remove the trailing slash from the resulting\nstring, because it doesn't look good, isn't necessary and confuses\nOS2. Of course, if this is the root directory, don't cut off the\ntrailing slash :-)\n\n=cut\n\nsub _pp_catdir {\n    my $self = shift;\n\n    $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'\n}\n*catdir = \\&_pp_catdir unless defined &catdir;\n\n=item catfile\n\nConcatenate one or more directory names and a filename to form a\ncomplete path ending with a filename\n\n=cut\n\nsub _pp_catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n*catfile = \\&_pp_catfile unless defined &catfile;\n\n=item curdir\n\nReturns a string representation of the current directory.  \".\" on UNIX.\n\n=cut\n\nsub curdir { '.' }\nuse constant _fn_curdir => \".\";\n\n=item devnull\n\nReturns a string representation of the null device. \"/dev/null\" on UNIX.\n\n=cut\n\nsub devnull { '/dev/null' }\nuse constant _fn_devnull => \"/dev/null\";\n\n=item rootdir\n\nReturns a string representation of the root directory.  \"/\" on UNIX.\n\n=cut\n\nsub rootdir { '/' }\nuse constant _fn_rootdir => \"/\";\n\n=item tmpdir\n\nReturns a string representation of the first writable directory from\nthe following list or the current directory if none from the list are\nwritable:\n\n    $ENV{TMPDIR}\n    /tmp\n\nIf running under taint mode, and if $ENV{TMPDIR}\nis tainted, it is not used.\n\n=cut\n\nmy ($tmpdir, %tmpenv);\n# Cache and return the calculated tmpdir, recording which env vars\n# determined it.\nsub _cache_tmpdir {\n    @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};\n    return $tmpdir = $_[1];\n}\n# Retrieve the cached tmpdir, checking first whether relevant env vars have\n# changed and invalidated the cache.\nsub _cached_tmpdir {\n    shift;\n    local $^W;\n    return if grep $ENV{$_} ne $tmpenv{$_}, @_;\n    return $tmpdir;\n}\nsub _tmpdir {\n    my $self = shift;\n    my @dirlist = @_;\n    my $taint = do { no strict 'refs'; ${\"\\cTAINT\"} };\n    if ($taint) { # Check for taint mode on perl >= 5.8.0\n\trequire Scalar::Util;\n\t@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n    }\n    elsif ($] < 5.007) { # No ${^TAINT} before 5.8\n\t@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;\n    }\n    \n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    if ( !$self->file_name_is_absolute($tmpdir) ) {\n        # See [perl #120593] for the full details\n        # If possible, return a full path, rather than '.' or 'lib', but\n        # jump through some hoops to avoid returning a tainted value.\n        ($tmpdir) = grep {\n            $taint     ? ! Scalar::Util::tainted($_) :\n            $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1\n        } $self->rel2abs($tmpdir), $tmpdir;\n    }\n    return $tmpdir;\n}\n\nsub tmpdir {\n    my $cached = $_[0]->_cached_tmpdir('TMPDIR');\n    return $cached if defined $cached;\n    $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" ), 'TMPDIR');\n}\n\n=item updir\n\nReturns a string representation of the parent directory.  \"..\" on UNIX.\n\n=cut\n\nsub updir { '..' }\nuse constant _fn_updir => \"..\";\n\n=item no_upwards\n\nGiven a list of file names, strip out those that refer to a parent\ndirectory. (Does not strip symlinks, only '.', '..', and equivalents.)\n\n=cut\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\z/s, @_);\n}\n\n=item case_tolerant\n\nReturns a true or false value indicating, respectively, that alphabetic\nis not or is significant when comparing file specifications.\n\n=cut\n\nsub case_tolerant { 0 }\nuse constant _fn_case_tolerant => 0;\n\n=item file_name_is_absolute\n\nTakes as argument a path and returns true if it is an absolute path.\n\nThis does not consult the local filesystem on Unix, Win32, OS/2 or Mac \nOS (Classic).  It does consult the working environment for VMS (see\nL<File::Spec::VMS/file_name_is_absolute>).\n\n=cut\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\n=item path\n\nTakes no argument, returns the environment variable PATH as an array.\n\n=cut\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(':', $ENV{PATH});\n    foreach (@path) { $_ = '.' if $_ eq '' }\n    return @path;\n}\n\n=item join\n\njoin is the same as catfile.\n\n=cut\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\n=item splitpath\n\n    ($volume,$directories,$file) = File::Spec->splitpath( $path );\n    ($volume,$directories,$file) = File::Spec->splitpath( $path,\n                                                          $no_file );\n\nSplits a path into volume, directory, and filename portions. On systems\nwith no concept of volume, returns '' for volume. \n\nFor systems with no syntax differentiating filenames from directories, \nassumes that the last file is a path unless $no_file is true or a \ntrailing separator or /. or /.. is present. On Unix this means that $no_file\ntrue makes this return ( '', $path, '' ).\n\nThe", 8192) = 8192
09:01:56.970478 stat("modules/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.970564 stat("modules/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.970642 stat("modules/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.970716 stat("modules/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.970791 stat("/etc/perl/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.970867 stat("/etc/perl/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.970943 stat("/usr/local/lib/perl/5.14.2/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971024 stat("/usr/local/lib/perl/5.14.2/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.971108 stat("/usr/local/share/perl/5.14.2/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971195 stat("/usr/local/share/perl/5.14.2/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.971275 stat("/usr/lib/perl5/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971353 stat("/usr/lib/perl5/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.971430 stat("/usr/share/perl5/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971507 stat("/usr/share/perl5/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.971585 stat("/usr/lib/perl/5.14/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971665 stat("/usr/lib/perl/5.14/constant.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:56.971744 stat("/usr/share/perl/5.14/constant.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:56.971822 stat("/usr/share/perl/5.14/constant.pm", {st_mode=S_IFREG|0644, st_size=4441, ...}) = 0
09:01:56.971919 open("/usr/share/perl/5.14/constant.pm", O_RDONLY) = 7
09:01:56.972001 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.972072 lseek(7, 0, SEEK_CUR)   = 0
09:01:56.972166 read(7, "package constant;\nuse 5.005;\nuse strict;\nuse warnings::register;\n\nuse vars qw($VERSION %declared);\n$VERSION = '1.21';\n\n#=======================================================================\n\n# Some names are evil choices.\nmy %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };\n$keywords{UNITCHECK}++ if $] > 5.009;\n\nmy %forced_into_main = map +($_, 1),\n    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };\n\nmy %forbidden = (%keywords, %forced_into_main);\n\nmy $str_end = $] >= 5.006 ? \"\\\\z\" : \"\\\\Z\";\nmy $normal_constant_name = qr/^_?[^\\W_0-9]\\w*$str_end/;\nmy $tolerable = qr/^[A-Za-z_]\\w*$str_end/;\nmy $boolean = qr/^[01]?$str_end/;\n\nBEGIN {\n    # We'd like to do use constant _CAN_PCS => $] > 5.009002\n    # but that's a bit tricky before we load the constant module :-)\n    # By doing this, we save 1 run time check for *every* call to import.\n    no strict 'refs';\n    my $const = $] > 5.009002;\n    *_CAN_PCS = sub () {$const};\n}\n\n#=======================================================================\n# import() - import symbols into user's namespace\n#\n# What we actually do is define a function in the caller's namespace\n# which returns the value. The function we create will normally\n# be inlined as a constant, thereby avoiding further sub calling \n# overhead.\n#=======================================================================\nsub import {\n    my $class = shift;\n    return unless @_;\t\t\t# Ignore 'use constant;'\n    my $constants;\n    my $multiple  = ref $_[0];\n    my $pkg = caller;\n    my $flush_mro;\n    my $symtab;\n\n    if (_CAN_PCS) {\n\tno strict 'refs';\n\t$symtab = \\%{$pkg . '::'};\n    };\n\n    if ( $multiple ) {\n\tif (ref $_[0] ne 'HASH') {\n\t    require Carp;\n\t    Carp::croak(\"Invalid reference type '\".ref(shift).\"' not 'HASH'\");\n\t}\n\t$constants = shift;\n    } else {\n\tunless (defined $_[0]) {\n\t    require Carp;\n\t    Carp::croak(\"Can't use undef as constant name\");\n\t}\n\t$constants->{+shift} = undef;\n    }\n\n    foreach my $name ( keys %$constants ) {\n\t# Normal constant name\n\tif ($name =~ $normal_constant_name and !$forbidden{$name}) {\n\t    # Everything is okay\n\n\t# Name forced into main, but we're not in main. Fatal.\n\t} elsif ($forced_into_main{$name} and $pkg ne 'main') {\n\t    require Carp;\n\t    Carp::croak(\"Constant name '$name' is forced into main::\");\n\n\t# Starts with double underscore. Fatal.\n\t} elsif ($name =~ /^__/) {\n\t    require Carp;\n\t    Carp::croak(\"Constant name '$name' begins with '__'\");\n\n\t# Maybe the name is tolerable\n\t} elsif ($name =~ $tolerable) {\n\t    # Then we'll warn only if you've asked for warnings\n\t    if (warnings::enabled()) {\n\t\tif ($keywords{$name}) {\n\t\t    warnings::warn(\"Constant name '$name' is a Perl keyword\");\n\t\t} elsif ($forced_into_main{$name}) {\n\t\t    warnings::warn(\"Constant name '$name' is \" .\n\t\t\t\"forced into package main::\");\n\t\t}\n\t    }\n\n\t# Looks like a boolean\n\t# use constant FRED == fred;\n\t} elsif ($name =~ $boolean) {\n            require Carp;\n\t    if (@_) {\n\t\tCarp::croak(\"Constant name '$name' is invalid\");\n\t    } else {\n\t\tCarp::croak(\"Constant name looks like boolean value\");\n\t    }\n\n\t} else {\n\t   # Must have bad characters\n            require Carp;\n\t    Carp::croak(\"Constant name '$name' has invalid characters\");\n\t}\n\n\t{\n\t    no strict 'refs';\n\t    my $full_name = \"${pkg}::$name\";\n\t    $declared{$full_name}++;\n\t    if ($multiple || @_ == 1) {\n\t\tmy $scalar = $multiple ? $constants->{$name} : $_[0];\n\n\t\t# Work around perl bug #xxxxx: Sub names (actually glob\n\t\t# names in general) ignore the UTF8 flag. So we have to\n\t\t# turn it off to get the \"right\" symbol table entry.\n\t\tutf8::is_utf8 $name and utf8::encode $name;\n\n\t\t# The constant serves to optimise this entire block out on\n\t\t# 5.8 and earlier.\n\t\tif (_CAN_PCS && $symtab && !exists $symtab->{$name}) {\n\t\t    # No typeglob yet, so we can use a reference as space-\n\t\t    # efficient proxy for a constant subroutine\n\t\t    # The check in Perl_ck_rvconst knows that inlinable\n\t\t    # constants from cv_const_sv are read only. So we have to:\n\t\t    Internals::SvREADONLY($scalar, 1);\n\t\t    $symtab->{$name} = \\$scalar;\n\t\t    ++$flush_mro;\n\t\t} else {\n\t\t    *$full_name = sub () { $scalar };\n\t\t}\n\t    } elsif (@_) {\n\t\tmy @list = @_;\n\t\t*$full_name = sub () { @list };\n\t    } else {\n\t\t*$full_name = sub () { };\n\t    }\n\t}\n    }\n    # Flush the cache exactly once if we make any direct symbol table changes.\n    mro::method_changed_in($pkg) if _CAN_PCS && $flush_mro;\n}\n\n1;\n\n__END__\n\n", 8192) = 4441
09:01:56.973396 lseek(7, 4440, SEEK_SET) = 4440
09:01:56.973469 lseek(7, 0, SEEK_CUR)   = 4440
09:01:56.973538 close(7)                = 0
09:01:56.974253 brk(0x99c000)           = 0x99c000
09:01:56.974489 read(6, " directory portion may or may not be returned with a trailing '/'.\n\nThe results can be passed to L</catpath()> to get back a path equivalent to\n(usually identical to) the original path.\n\n=cut\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = ('','','');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\z )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\n\n=item splitdir\n\nThe opposite of L</catdir()>.\n\n    @dirs = File::Spec->splitdir( $directories );\n\n$directories must be only the directory portion of the path on systems \nthat have the concept of a volume or that have path syntax that differentiates\nfiles from directories.\n\nUnlike just splitting the directories on the separator, empty\ndirectory names (C<''>) can be returned, because these are significant\non some OSs.\n\nOn Unix,\n\n    File::Spec->splitdir( \"/a/b//c/\" );\n\nYields:\n\n    ( '', 'a', 'b', '', 'c', '' )\n\n=cut\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\n\n=item catpath()\n\nTakes volume, directory and file portions and returns an entire path. Under\nUnix, $volume is ignored, and directory and file are concatenated.  A '/' is\ninserted if needed (though if the directory portion doesn't start with\n'/' it is not added).  On other OSs, $volume is significant.\n\n=cut\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne ''                && \n         $file ne ''                     && \n         substr( $directory, -1 ) ne '/' && \n         substr( $file, 0, 1 ) ne '/' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\n=item abs2rel\n\nTakes a destination path and an optional base path returns a relative path\nfrom the base path to the destination path:\n\n    $rel_path = File::Spec->abs2rel( $path ) ;\n    $rel_path = File::Spec->abs2rel( $path, $base ) ;\n\nIf $base is not present or '', then L<cwd()|Cwd> is used. If $base is\nrelative, then it is converted to absolute form using\nL</rel2abs()>. This means that it is taken to be relative to\nL<cwd()|Cwd>.\n\nOn systems that have a grammar that indicates filenames, this ignores the \n$base filename. Otherwise all path components are assumed to be\ndirectories.\n\nIf $path is relative, it is converted to absolute form using L</rel2abs()>.\nThis means that it is taken to be relative to L<cwd()|Cwd>.\n\nNo checks against the filesystem are made, so the result may not be correct if\nC<$base> contains symbolic links.  (Apply\nL<Cwd::abs_path()|Cwd/abs_path> beforehand if that\nis a concern.)  On VMS, there is interaction with the working environment, as\nlogicals and macros are expanded.\n\nBased on code written by Shigio Yamaguchi.\n\n=cut\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n    $base = $self->_cwd() unless defined $base and length $base;\n\n    ($path, $base) = map $self->canonpath($_), $path, $base;\n\n    my $path_directories;\n    my $base_directories;\n\n    if (grep $self->file_name_is_absolute($_), $path, $base) {\n\t($path, $base) = map $self->rel2abs($_), $path, $base;\n\n\tmy ($path_volume) = $self->splitpath($path, 1);\n\tmy ($base_volume) = $self->splitpath($base, 1);\n\n\t# Can't relativize across volumes\n\treturn $path unless $path_volume eq $base_volume;\n\n\t$path_directories = ($self->splitpath($path, 1))[1];\n\t$base_directories = ($self->splitpath($base, 1))[1];\n\n\t# For UNC paths, the user might give a volume like //foo/bar that\n\t# strictly speaking has no directory portion.  Treat it as if it\n\t# had the root directory for that volume.\n\tif (!length($base_directories) and $self->file_name_is_absolute($base)) {\n\t    $base_directories = $self->rootdir;\n\t}\n    }\n    else {\n\tmy $wd= ($self->splitpath($self->_cwd(), 1))[1];\n\t$path_directories = $self->catdir($wd, $path);\n\t$base_directories = $self->catdir($wd, $base);\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path_directories );\n    my @basechunks = $self->splitdir( $base_directories );\n\n    if ($base_directories eq $self->rootdir) {\n      return $self->curdir if $path_directories eq $self->rootdir;\n      shift @pathchunks;\n      return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );\n    }\n\n    my @common;\n    while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {\n        push @common, shift @pathchunks ;\n        shift @basechunks ;\n    }\n    return $self->curdir unless @pathchunks || @basechunks;\n\n    # @basechunks now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  If there\n    # are updir components, we must descend into the corresponding directories\n    # (this only works if they are no symlinks).\n    my @reverse_base;\n    while( defined(my $dir= shift @basechunks) ) {\n\tif( $dir ne $self->updir ) {\n\t    unshift @reverse_base, $self->updir;\n\t    push @common, $dir;\n\t}\n\telsif( @common ) {\n\t    if( @reverse_base && $reverse_base[0] eq $self->updir ) {\n\t\tshift @reverse_base;\n\t\tpop @common;\n\t    }\n\t    else {\n\t\tunshift @reverse_base, pop @common;\n\t    }\n\t}\n    }\n    my $result_dirs = $self->catdir( @reverse_base, @pathchunks );\n    return $self->canonpath( $self->catpath('', $result_dirs, '') );\n}\n\nsub _same {\n  $_[1] eq $_[2];\n}\n\n=item rel2abs()\n\nConverts a relative path to an absolute path. \n\n    $abs_path = File::Spec->rel2abs( $path ) ;\n    $abs_path = File::Spec->rel2abs( $path, $base ) ;\n\nIf $base is not present or '', then L<cwd()|Cwd> is used. If $base is\nrelative, then it is converted to absolute form using\nL</rel2abs()>. This means that it is taken to be relative to\nL<cwd()|Cwd>.\n\nOn systems that have a grammar that indicates filenames, this ignores\nthe $base filename. Otherwise all path components are assumed to be\ndirectories.\n\nIf $path is absolute, it is cleaned up and returned using L</canonpath()>.\n\nNo checks against the filesystem are made.  On VMS, there is\ninteraction with the working environment, as logicals and\nmacros are expanded.\n\nBased on code written by Shigio Yamaguchi.\n\n=cut\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq '' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n=back\n\n=head1 COPYRIGHT\n\nCopyright (c) 2004 by the Perl 5 Porters.  All rights reserved.\n\nThis program is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\nPlease submit bug reports and patches to perlbug@perl.org.\n\n=head1 SEE ALSO\n\nL<File::Spec>\n\n=cut\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::getcwd();\n}\n\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n    pop @dirs if @dirs && $dirs[-1] eq '';\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n       ", 8192) = 8192
09:01:56.975735 read(6, "     push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n\n1;\n", 8192) = 218
09:01:56.975893 read(6, "", 8192)       = 0
09:01:56.975966 close(6)                = 0
09:01:56.976090 stat("/usr/local/lib/perl/5.14.2/File/Spec/auto/Cwd/Cwd.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.976174 stat("/usr/local/lib/perl/5.14.2/File/Spec/auto/Cwd/Cwd.so", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.976257 stat("modules/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.976331 stat("modules/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.976405 stat("modules/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.976476 stat("modules/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.976548 stat("/etc/perl/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.976620 stat("/etc/perl/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.976694 stat("/usr/local/lib/perl/5.14.2/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.976768 stat("/usr/local/lib/perl/5.14.2/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.976843 stat("/usr/local/share/perl/5.14.2/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.976925 stat("/usr/local/share/perl/5.14.2/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.977002 stat("/usr/lib/perl5/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.977074 stat("/usr/lib/perl5/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.977154 stat("/usr/share/perl5/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.977228 stat("/usr/share/perl5/DynaLoader.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:56.977301 stat("/usr/lib/perl/5.14/DynaLoader.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:56.977378 stat("/usr/lib/perl/5.14/DynaLoader.pm", {st_mode=S_IFREG|0644, st_size=10643, ...}) = 0
09:01:56.977483 open("/usr/lib/perl/5.14/DynaLoader.pm", O_RDONLY) = 6
09:01:56.977563 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.977631 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.977722 read(6, "# Generated from DynaLoader_pm.PL\n\npackage DynaLoader;\n\n#   And Gandalf said: 'Many folk like to know beforehand what is to\n#   be set on the table; but those who have laboured to prepare the\n#   feast like to keep their secret; for wonder makes the words of\n#   praise louder.'\n\n#   (Quote from Tolkien suggested by Anno Siegel.)\n#\n# See pod text at end of file for documentation.\n# See also ext/DynaLoader/README in source tree for other information.\n#\n# Tim.Bunce@ig.co.uk, August 1994\n\nBEGIN {\n    $VERSION = '1.13';\n}\n\nuse Config;\n\n# enable debug/trace messages from DynaLoader perl code\n$dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n#\n# Flags to alter dl_load_file behaviour.  Assigned bits:\n#   0x01  make symbols available for linking later dl_load_file's.\n#         (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))\n#         (ignored under VMS; effect is built-in to image linking)\n#\n# This is called as a class method $module->dl_load_flags.  The\n# definition here will be inherited and result on \"default\" loading\n# behaviour unless a sub-class of DynaLoader defines its own version.\n#\n\nsub dl_load_flags { 0x00 }\n\n($dl_dlext, $dl_so, $dlsrc) = @Config::Config{qw(dlext so dlsrc)};\n\n$do_expand = 0;\n\n@dl_require_symbols = ();       # names of symbols we need\n@dl_resolve_using   = ();       # names of files to link with\n@dl_library_path    = ();       # path to look for files\n\n#XSLoader.pm may have added elements before we were required\n#@dl_shared_objects  = ();       # shared objects for symbols we have \n#@dl_librefs         = ();       # things we have loaded\n#@dl_modules         = ();       # Modules we have loaded\n\n# This is a fix to support DLD's unfortunate desire to relink -lc\n@dl_resolve_using = dl_findfile('-lc') if $dlsrc eq \"dl_dld.xs\";\n\n# Initialise @dl_library_path with the 'standard' library path\n# for this platform as determined by Configure.\n\npush(@dl_library_path, split(' ', $Config::Config{libpth}));\n\nmy $ldlibpthname         = $Config::Config{ldlibpthname};\nmy $ldlibpthname_defined = defined $Config::Config{ldlibpthname};\nmy $pthsep               = $Config::Config{path_sep};\n\n# Add to @dl_library_path any extra directories we can gather from environment\n# during runtime.\n\nif ($ldlibpthname_defined &&\n    exists $ENV{$ldlibpthname}) {\n    push(@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));\n}\n\n# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.\n\nif ($ldlibpthname_defined &&\n    $ldlibpthname ne 'LD_LIBRARY_PATH' &&\n    exists $ENV{LD_LIBRARY_PATH}) {\n    push(@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));\n}\n\n# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\n\nif ($dl_debug) {\n    print STDERR \"DynaLoader.pm loaded (@INC, @dl_library_path)\\n\";\n    print STDERR \"DynaLoader not linked into this perl\\n\"\n\t    unless defined(&boot_DynaLoader);\n}\n\n1; # End of main code\n\nsub croak   { require Carp; Carp::croak(@_)   }\n\nsub bootstrap_inherit {\n    my $module = $_[0];\n    local *isa = *{\"$module\\::ISA\"};\n    local @isa = (@isa, 'DynaLoader');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    bootstrap(@_);\n}\n\nsub bootstrap {\n    # use local vars to enable $module.bs script to edit values\n    local(@args) = @_;\n    local($module) = $args[0];\n    local(@dirs, $file);\n\n    unless ($module) {\n\trequire Carp;\n\tCarp::confess(\"Usage: DynaLoader::bootstrap(module)\");\n    }\n\n    # A common error on platforms which don't support dynamic loading.\n    # Since it's fatal and potentially confusing we give a detailed message.\n    croak(\"Can't load module $module, dynamic loading not available in this perl.\\n\".\n\t\"  (You may need to build a new perl executable which either supports\\n\".\n\t\"  dynamic loading or has the $module module statically linked into it.)\\n\")\n\tunless defined(&dl_load_file);\n\n    \n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    # Some systems have restrictions on files names for DLL's etc.\n    # mod2fname returns appropriate file base name (typically truncated)\n    # It may also edit @modparts if required.\n    $modfname = &mod2fname(\\@modparts) if defined &mod2fname;\n\n    \n\n    my $modpname = join('/',@modparts);\n\n    print STDERR \"DynaLoader::bootstrap for $module \",\n\t\t       \"(auto/$modpname/$modfname.$dl_dlext)\\n\"\n\tif $dl_debug;\n\n    foreach (@INC) {\n\t\n\t    my $dir = \"$_/auto/$modpname\";\n\t\n\tnext unless -d $dir; # skip over uninteresting directories\n\t\n\t# check for common cases to avoid autoload of dl_findfile\n\tmy $try = \"$dir/$modfname.$dl_dlext\";\n\tlast if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);\n\t\n\t# no luck here, save dir for possible later dl_findfile search\n\tpush @dirs, $dir;\n    }\n    # last resort, let dl_findfile have a go in all known locations\n    $file = dl_findfile(map(\"-L$_\",@dirs,@INC), $modfname) unless $file;\n\n    croak(\"Can't locate loadable object for module $module in \\@INC (\\@INC contains: @INC)\")\n\tunless $file;\t# wording similar to error from 'require'\n\n    \n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @dl_require_symbols = ($bootname);\n\n    # Execute optional '.bootstrap' perl script for this module.\n    # The .bs file can be used to configure @dl_resolve_using etc to\n    # match the needs of the individual module on this architecture.\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs 'beside' the library\n    if (-s $bs) { # only read file if it's not empty\n        print STDERR \"BS: $bs ($^O, $dlsrc)\\n\" if $dl_debug;\n        eval { do $bs; };\n        warn \"$bs: $@\\n\" if $@;\n    }\n\n    my $boot_symbol_ref;\n\n    \n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, $module->dl_load_flags) or\n\tcroak(\"Can't load '$file' for module $module: \".dl_error());\n\n    push(@dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n\trequire Carp;\n\tCarp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or\n         croak(\"Can't find '$bootname' symbol in $file\\n\");\n\n    push(@dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n\n\tpush(@dl_shared_objects, $file); # record files loaded\n\n    &$xs(@args);\n}\n\nsub dl_findfile {\n    # Read ext/DynaLoader/DynaLoader.doc for detailed information.\n    # This function does not automatically consider the architecture\n    # or the perl library auto directories.\n    my (@args) = @_;\n    my (@dirs,  $dir);   # which directories to search\n    my (@found);         # full paths to real files we have found\n    #my $dl_ext= 'so'; # $Config::Config{'dlext'} suffix for perl extensions\n    #my $dl_so = 'so'; # $Config::Config{'so'} suffix for shared libraries\n\n    print STDERR \"dl_findfile(@args)\\n\" if $dl_debug;\n\n    # accumulate directories but process files as they appear\n    arg: foreach(@args) {\n        #  Special fast case: full filepath requires no search\n\t\n\t\n        if (m:/: && -f $_) {\n\t    push(@found,$_);\n\t    last arg unless wantarray;\n\t    next;\n\t}\n\t\n\n        # Deal with directories first:\n        #  Using a -L prefix is the preferred option (faster and more robust)\n        if (m:^-L:) { s/^-L//; push(@dirs, $_); next; }\n\n        #  Otherwise we try to try to spot directories by a heuristic\n        #  (this is a more complicated issue than it first appears)\n        if (m:/: && -d $_) {   push(@dirs, $_); next; }\n\n\t\n\n        #  Only files should get this far...\n        my(@names, $name);    # what fil", 8192) = 8192
09:01:56.978737 brk(0x9bd000)           = 0x9bd000
09:01:56.979379 read(6, "enames to look for\n        if (m:-l: ) {          # convert -lname to appropriate library name\n            s/-l//;\n            push(@names,\"lib$_.$dl_so\");\n            push(@names,\"lib$_.a\");\n        } else {                # Umm, a bare name. Try various alternatives:\n            # these should be ordered with the most likely first\n            push(@names,\"$_.$dl_dlext\")    unless m/\\.$dl_dlext$/o;\n            push(@names,\"$_.$dl_so\")     unless m/\\.$dl_so$/o;\n\t    \n            push(@names,\"lib$_.$dl_so\")  unless m:/:;\n            push(@names,\"$_.a\")          if !m/\\.a$/ and $dlsrc eq \"dl_dld.xs\";\n            push(@names, $_);\n        }\n\tmy $dirsep = '/';\n\t\n        foreach $dir (@dirs, @dl_library_path) {\n            next unless -d $dir;\n\t    \n            foreach $name (@names) {\n\t\tmy($file) = \"$dir$dirsep$name\";\n                print STDERR \" checking in $dir for $name\\n\" if $dl_debug;\n\t\t$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);\n\t\t#$file = _check_file($file);\n\t\tif ($file) {\n                    push(@found, $file);\n                    next arg; # no need to look any further\n                }\n            }\n        }\n    }\n    if ($dl_debug) {\n        foreach(@dirs) {\n            print STDERR \" dl_findfile ignored non-existent directory: $_\\n\" unless -d $_;\n        }\n        print STDERR \"dl_findfile found: @found\\n\";\n    }\n    return $found[0] unless wantarray;\n    @found;\n}\n\nsub dl_expandspec {\n    my($spec) = @_;\n    # Optional function invoked if DynaLoader.pm sets $do_expand.\n    # Most systems do not require or use this function.\n    # Some systems may implement it in the dl_*.xs file in which case\n    # this Perl version should be excluded at build time.\n\n    # This function is designed to deal with systems which treat some\n    # 'filenames' in a special way. For example VMS 'Logical Names'\n    # (something like unix environment variables - but different).\n    # This function should recognise such names and expand them into\n    # full file paths.\n    # Must return undef if $spec is invalid or file does not exist.\n\n    my $file = $spec; # default output to input\n\n\treturn undef unless -f $file;\n    print STDERR \"dl_expandspec($spec) => $file\\n\" if $dl_debug;\n    $file;\n}\n\nsub dl_find_symbol_anywhere\n{\n    my $sym = shift;\n    my $libref;\n    foreach $libref (@dl_librefs) {\n\tmy $symref = dl_find_symbol($libref,$sym);\n\treturn $symref if $symref;\n    }\n    return undef;\n}\n\n__END__\n\n", 8192) = 2451
09:01:56.979991 lseek(6, 10642, SEEK_SET) = 10642
09:01:56.980062 lseek(6, 0, SEEK_CUR)   = 10642
09:01:56.980128 close(6)                = 0
09:01:56.980302 stat("modules/auto/Cwd", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.980383 stat("modules/auto/Cwd", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.980458 stat("/etc/perl/auto/Cwd", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.980534 stat("/usr/local/lib/perl/5.14.2/auto/Cwd", {st_mode=S_IFDIR|S_ISGID|0775, st_size=4096, ...}) = 0
09:01:56.980624 stat("/usr/local/lib/perl/5.14.2/auto/Cwd/Cwd.so", {st_mode=S_IFREG|0555, st_size=83388, ...}) = 0
09:01:56.980734 stat("/usr/local/lib/perl/5.14.2/auto/Cwd/Cwd.bs", {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
09:01:56.980836 open("/usr/local/lib/perl/5.14.2/auto/Cwd/Cwd.so", O_RDONLY) = 6
09:01:56.980914 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\200\25\0\0\0\0\0\0@\0\0\0\0\0\0\0\250,\1\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0$\0!\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f2\0\0\0\0\0\0\f2\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0202\0\0\0\0\0\0\0202 \0\0\0\0\0\0202 \0\0\0\0\0\264\3\0\0\0\0\0\0\270\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0(2\0\0\0\0\0\0(2 \0\0\0\0\0(2 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\370.\0\0\0\0\0\0\370.\0\0\0\0\0\0\370.\0\0\0\0\0\0t\0\0\0\0\0\0\0t\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\277m\30\330\313\7o\36\313\331>\334\345\361kA\2\217\347\312\0\0\0\0%\0\0\0<\0\0\0\0\0\0\0\"\0\0\0\23\0\0\0\20\0\0\0\16\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\27\0\0\0;\0\0\0\0\0\0\0:\0\0\0008\0\0\0$\0\0\0*\0\0\0\34\0\0\0(\0\0\0/\0\0\0005\0\0\0,\0\0\0!\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0007\0\0\0 \0\0\0)\0\0\0\n\0\0\0\4\0\0\0+\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\f\0\0\0#\0\0\0\30\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0003\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\3\0\0\0006\0\0\0\0\0\0\0\0\0\0\0-\0\0\0001\0\0\0\0\0\0\0\31\0\0\0002\0\0\0000\0\0\0\32\0\0\0\0\0\0\0\10\0\0\0\25\0\0\0004\0\0\0009\0\0\0\24\0\0\0\26\0\0\0\37\0\0\0.\0\0\0&\0\0\0\21\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0\v\0\0\0\0\0\0\0\t\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.981113 fstat(6, {st_mode=S_IFREG|0555, st_size=83388, ...}) = 0
09:01:56.981208 mmap(NULL, 2110920, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f743510e000
09:01:56.981281 mprotect(0x7f7435112000, 2093056, PROT_NONE) = 0
09:01:56.981352 mmap(0x7f7435311000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3000) = 0x7f7435311000
09:01:56.981432 close(6)                = 0
09:01:56.982649 brk(0x9de000)           = 0x9de000
09:01:56.982992 read(5, "       }\n    }\n    if( !$done and _do_X( 'USE_HIRES' ) ) {\n        eval {\n            require File::Spec->catfile( qw( Time HiRes.pm ) );\n            *monotime = \\&Time::HiRes::time;\n            *walltime = \\&Time::HiRes::time;\n            *sleep = \\&Time::HiRes::sleep;\n            *wall2mono = sub { return $_[0] };\n            *mono2wall = sub { return $_[0] };\n            $done = 1;\n        };\n        if( DEBUG ) {\n            warn( \"<ck> Time::HiRes not installed: $@\" )if $@;\n            warn( \"<ck> using Time::HiRes\" ) if $done;\n        }\n    }\n    unless( $done ) {\n        # \\&CORE::time fails :-(\n        *monotime = sub { CORE::time };\n        *walltime = sub { CORE::time };\n        *sleep = sub { CORE::sleep(@_) };\n        *wall2mono = sub { return $_[0] };\n        *mono2wall = sub { return $_[0] };\n        warn( \"<ck> using CORE::time\" )if DEBUG;\n    }\n\n    unless( $have_clock ) {\n        #*clock_pause  = sub { $_[0]->loop_pause_time_watcher() };\n        #*clock_reset  = sub { $_[0]->loop_reset_time_watcher(mono2wall($_[1])) };\n        #*clock_resume = sub { $_[0]->loop_resume_time_watcher(mono2wall($_[1])) };\n        #*clock_setup  = sub { 0 };\n        #*clock_read   = sub { 0 };\n    }\n\n    # *time = sub { Carp::confess( \"This should be monotime\" ) };\n    *time = \\&walltime;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Clock - internal clock used for ordering the queue\n\n=head1 SYNOPSIS\n\n    sub POE::Kernel::USE_POSIXRT { 0 }\n    use POE;\n\n=head1 DESCRIPTION\n\nPOE::Resource::Clock is a helper module for POE::Kernel.  It provides the\nfeatures to keep an internal monotonic clock and a wall clock.  It also\nconverts between this monotonic clock and the wall clock.\n\nThe monotonic clock is used to keep an ordered queue of events.  The wall\nclock is used to communicate the time with user code\n(L<POE::Kernel/alarm_set>, L<POE::Kernel/alarm_remove>).\n\nThere are 3 possible clock sources in order of preference:\nL<POSIX::RT::Clock>, L<Time::HiRes> and L<perlfunc/time>.  Only\nC<POSIX::RT::Clock> has a separate monotonic and wall clock; the other two use the\nsame source for both clocks.\n\nClock selection and behaviour is controlled with the following:\n\n=head2 USE_POSIXRT\n\n    export POE_USE_POSIXRT=0\n        or\n    sub POE::Kernel::USE_POSIXRT { 0 }\n\nUses the C<monotonic> clock source for queue priority and the C<realtime>\nclock source for wall clock.  Not used if POSIX::RT::Clock is not installed\nor your system does not have a C<monotonic> clock.\n\nDefaults to true.  If you want the old POE behaviour, set this to 0.\n\n=head2 USE_STATIC_EPOCH\n\n    export POE_USE_STATIC_EPOCH=0\n        or\n    sub POE::Kernel::USE_STATIC_EPOCH { 0 }\n\nThe epoch of the POSIX::RT::Clock monotonic is different from that of the\nrealtime clock.  For instance on Linux 2.6.18, the monotonic clock is the\nnumber of seconds since system boot.  This epoch is used to convert from\nwalltime into monotonic time for L<POE::Kernel/alarm>,\nL<POE::Kernel/alarm_add> and L<POE::Kernel/alarm_set>. If\nC<USE_STATIC_EPOCH> is true (the default), then the epoch is calculated at\nload time.  If false, the epoch is calculated each time it is needed.\n\nDefaults to true.  Only relevant for if using POSIX::RT::Clock. Long-running\nPOE servers should have this set to false so that system clock skew does\nmess up the queue.\n\nIt is important to point out that without a static epoch, the ordering of\nthe following two alarms is undefined.\n\n    $poe_kernel->alarm_set( a1 => $time );\n    $poe_kernel->alarm_set( a2 => $time );\n\n=head2 USE_EXACT_EPOCH\n\n    export POE_USE_EXACT_EPOCH=1\n        or\n    sub POE::Kernel::USE_EXACT_EPOCH { 1 }\n\nThere currently no way to exactly get the monotonic clock's epoch.  Instead\nthe difference between the current monotonic clock value to the realtime\nclock's value is used.  This is obviously inexact because there is a slight\ndelay between the 2 system calls.  Setting USE_EXACT_EPOCH to true will\ncalculate an average of this difference over 250 ms or at least 20 samples.\nWhat's more, the system calls are done in both orders (monotonic then\nrealtime, realtime then monotonic) to try and get a more exact value.\n\nDefaults to false.  Only relevant if L</USE_STATIC_EPOCH> is true.\n\n=head2 USE_HIRES\n\n    export POE_USE_HIRES=0\n        or\n    sub POE::Kernel::USE_HIRES { 0 }\n\nUse L<Time::HiRes> as both monotonic and wall clock source.  This was POE's\nprevious default clock.\n\nDefaults to true.  Only relevant if L</USE_POSIXRT> is false.  Set this to false to use\nL<perlfunc/time>.\n\n=head1 EXPORTS\n\nThis module optionally exports a few timekeeping helper functions.\n\n=head2 mono2wall\n\nmono2wall() converts a monotonic time to an epoch wall time.\n\n  my $wall = mono2wall( $monotonic );\n\n=head2 monotime\n\nmonotime() makes a best-effort attempt to return the time from a\nmonotonic system clock.  It may fall back to non-monotonic time if\nthere are no monotonic clocks available.\n\n  my $monotonic = monotime();\n\n=head2 sleep\n\nsleep() makes a best-effort attempt to sleep a particular amount of\nhigh-resolution time using a monotonic clock.  This feature will\ndegrade gracefully to non-monotonic high-resolution clocks, then\nlow-resolution clocks, depending on available libraries.\n\n  sleep( 3.141 );\n\n=head2 time\n\ntime() is a backwards compatible alias for walltime().  Please see\nwalltime()'s documentation for details.\n\n=head2 wall2mono\n\nwall2mono() makes a best-effort attempt to convert wall time to its\nequivalent monotonic-clock time.  Its feature degrades gracefully\ndepending on clock availability.\n\n  my $monotonic = wall2mono( $epoch );\n\n=head2 walltime\n\ntime() makes a best-effort attempt to return non-monotonic wall time\nat the highest available resolution known.\n\n  my $epoch = walltime();\n\n=head1 SEE ALSO\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 6030
09:01:56.983682 stat("modules/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.983762 stat("modules/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.983837 stat("modules/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.983912 stat("modules/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.983992 stat("/etc/perl/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984065 stat("/etc/perl/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984140 stat("/usr/local/lib/perl/5.14.2/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984217 stat("/usr/local/lib/perl/5.14.2/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984294 stat("/usr/local/share/perl/5.14.2/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984369 stat("/usr/local/share/perl/5.14.2/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984444 stat("/usr/lib/perl5/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984517 stat("/usr/lib/perl5/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984591 stat("/usr/share/perl5/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984665 stat("/usr/share/perl5/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984738 stat("/usr/lib/perl/5.14/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984814 stat("/usr/lib/perl/5.14/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.984889 stat("/usr/share/perl/5.14/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.984964 stat("/usr/share/perl/5.14/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985039 stat("/usr/local/lib/site_perl/POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985114 stat("/usr/local/lib/site_perl/POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985194 stat("./POSIX/RT/Clock.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985266 stat("./POSIX/RT/Clock.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985378 stat("modules/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985452 stat("modules/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985525 stat("modules/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985597 stat("modules/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985683 stat("/etc/perl/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985758 stat("/etc/perl/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985831 stat("/usr/local/lib/perl/5.14.2/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.985906 stat("/usr/local/lib/perl/5.14.2/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.985980 stat("/usr/local/share/perl/5.14.2/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.986071 stat("/usr/local/share/perl/5.14.2/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.986151 stat("/usr/lib/perl5/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.986225 stat("/usr/lib/perl5/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.986299 stat("/usr/share/perl5/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.986374 stat("/usr/share/perl5/Time/HiRes.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:56.986447 stat("/usr/lib/perl/5.14/Time/HiRes.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:56.986524 stat("/usr/lib/perl/5.14/Time/HiRes.pm", {st_mode=S_IFREG|0644, st_size=22230, ...}) = 0
09:01:56.986611 open("/usr/lib/perl/5.14/Time/HiRes.pm", O_RDONLY) = 6
09:01:56.986690 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b390) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.986759 lseek(6, 0, SEEK_CUR)   = 0
09:01:56.986850 read(6, "package Time::HiRes;\n\nuse strict;\nuse vars qw($VERSION $XS_VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);\n\nrequire Exporter;\nrequire DynaLoader;\n\n@ISA = qw(Exporter DynaLoader);\n\n@EXPORT = qw( );\n@EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval\n\t\t getitimer setitimer nanosleep clock_gettime clock_getres\n\t\t clock clock_nanosleep\n\t\t CLOCK_HIGHRES CLOCK_MONOTONIC CLOCK_PROCESS_CPUTIME_ID\n\t\t CLOCK_REALTIME CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID\n\t\t CLOCK_TIMEOFDAY CLOCKS_PER_SEC\n\t\t ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF\n\t\t TIMER_ABSTIME\n\t\t d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer\n\t\t d_nanosleep d_clock_gettime d_clock_getres\n\t\t d_clock d_clock_nanosleep\n\t\t stat\n\t\t);\n\n$VERSION = '1.9721_01';\n$XS_VERSION = $VERSION;\n$VERSION = eval $VERSION;\n\nsub AUTOLOAD {\n    my $constname;\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    # print \"AUTOLOAD: constname = $constname ($AUTOLOAD)\\n\";\n    die \"&Time::HiRes::constant not defined\" if $constname eq 'constant';\n    my ($error, $val) = constant($constname);\n    # print \"AUTOLOAD: error = $error, val = $val\\n\";\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    {\n\tno strict 'refs';\n\t*$AUTOLOAD = sub { $val };\n    }\n    goto &$AUTOLOAD;\n}\n\nsub import {\n    my $this = shift;\n    for my $i (@_) {\n\tif (($i eq 'clock_getres'    && !&d_clock_getres)    ||\n\t    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||\n\t    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||\n\t    ($i eq 'clock'           && !&d_clock)           ||\n\t    ($i eq 'nanosleep'       && !&d_nanosleep)       ||\n\t    ($i eq 'usleep'          && !&d_usleep)          ||\n\t    ($i eq 'ualarm'          && !&d_ualarm)) {\n\t    require Carp;\n\t    Carp::croak(\"Time::HiRes::$i(): unimplemented in this platform\");\n\t}\n    }\n    Time::HiRes->export_to_level(1, $this, @_);\n}\n\nbootstrap Time::HiRes;\n\n# Preloaded methods go here.\n\nsub tv_interval {\n    # probably could have been done in C\n    my ($a, $b) = @_;\n    $b = [gettimeofday()] unless defined($b);\n    (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);\n}\n\n# Autoload methods go after =cut, and are processed by the autosplit program.\n\n1;\n__END__\n\n=head1 NAME\n\nTime::HiRes - High resolution alarm, sleep, gettimeofday, interval timers\n\n=head1 SYNOPSIS\n\n  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep\n\t\t      clock_gettime clock_getres clock_nanosleep clock\n                      stat );\n\n  usleep ($microseconds);\n  nanosleep ($nanoseconds);\n\n  ualarm ($microseconds);\n  ualarm ($microseconds, $interval_microseconds);\n\n  $t0 = [gettimeofday];\n  ($seconds, $microseconds) = gettimeofday;\n\n  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);\n  $elapsed = tv_interval ( $t0, [gettimeofday]);\n  $elapsed = tv_interval ( $t0 );\n\n  use Time::HiRes qw ( time alarm sleep );\n\n  $now_fractions = time;\n  sleep ($floating_seconds);\n  alarm ($floating_seconds);\n  alarm ($floating_seconds, $floating_interval);\n\n  use Time::HiRes qw( setitimer getitimer );\n\n  setitimer ($which, $floating_seconds, $floating_interval );\n  getitimer ($which);\n\n  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep\n\t\t      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );\n\n  $realtime   = clock_gettime(CLOCK_REALTIME);\n  $resolution = clock_getres(CLOCK_REALTIME);\n\n  clock_nanosleep(CLOCK_REALTIME, 1.5e9);\n  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);\n\n  my $ticktock = clock();\n\n  use Time::HiRes qw( stat );\n\n  my @stat = stat(\"file\");\n  my @stat = stat(FH);\n\n=head1 DESCRIPTION\n\nThe C<Time::HiRes> module implements a Perl interface to the\nC<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and\nC<setitimer>/C<getitimer> system calls, in other words, high\nresolution time and timers. See the L</EXAMPLES> section below and the\ntest scripts for usage; see your system documentation for the\ndescription of the underlying C<nanosleep> or C<usleep>, C<ualarm>,\nC<gettimeofday>, and C<setitimer>/C<getitimer> calls.\n\nIf your system lacks C<gettimeofday()> or an emulation of it you don't\nget C<gettimeofday()> or the one-argument form of C<tv_interval()>.\nIf your system lacks all of C<nanosleep()>, C<usleep()>,\nC<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,\nC<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.\nIf your system lacks both C<ualarm()> and C<setitimer()> you don't get\nC<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.\n\nIf you try to import an unimplemented function in the C<use> statement\nit will fail at compile time.\n\nIf your subsecond sleeping is implemented with C<nanosleep()> instead\nof C<usleep()>, you can mix subsecond sleeping with signals since\nC<nanosleep()> does not use signals.  This, however, is not portable,\nand you should first check for the truth value of\nC<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and\nthen carefully read your C<nanosleep()> C API documentation for any\npeculiarities.\n\nIf you are using C<nanosleep> for something else than mixing sleeping\nwith signals, give some thought to whether Perl is the tool you should\nbe using for work requiring nanosecond accuracies.\n\nRemember that unless you are working on a I<hard realtime> system,\nany clocks and timers will be imprecise, especially so if you are working\nin a pre-emptive multiuser system.  Understand the difference between\nI<wallclock time> and process time (in UNIX-like systems the sum of\nI<user> and I<system> times).  Any attempt to sleep for X seconds will\nmost probably end up sleeping B<more> than that, but don't be surpised\nif you end up sleeping slightly B<less>.\n\nThe following functions can be imported from this module.\nNo functions are exported by default.\n\n=over 4\n\n=item gettimeofday ()\n\nIn array context returns a two-element array with the seconds and\nmicroseconds since the epoch.  In scalar context returns floating\nseconds like C<Time::HiRes::time()> (see below).\n\n=item usleep ( $useconds )\n\nSleeps for the number of microseconds (millionths of a second)\nspecified.  Returns the number of microseconds actually slept.\nCan sleep for more than one second, unlike the C<usleep> system call.\nCan also sleep for zero seconds, which often works like a I<thread yield>.\nSee also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and\nC<Time::HiRes::clock_nanosleep()>.\n\nDo not expect usleep() to be exact down to one microsecond.\n\n=item nanosleep ( $nanoseconds )\n\nSleeps for the number of nanoseconds (1e9ths of a second) specified.\nReturns the number of nanoseconds actually slept (accurate only to\nmicroseconds, the nearest thousand of them).  Can sleep for more than\none second.  Can also sleep for zero seconds, which often works like\na I<thread yield>.  See also C<Time::HiRes::sleep()>,\nC<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.\n\nDo not expect nanosleep() to be exact down to one nanosecond.\nGetting even accuracy of one thousand nanoseconds is good.\n\n=item ualarm ( $useconds [, $interval_useconds ] )\n\nIssues a C<ualarm> call; the C<$interval_useconds> is optional and\nwill be zero if unspecified, resulting in C<alarm>-like behaviour.\n\nReturns the remaining time in the alarm in microseconds, or C<undef>\nif an error occurred.\n\nualarm(0) will cancel an outstanding ualarm().\n\nNote that the interaction between alarms and sleeps is unspecified.\n\n=item tv_interval \n\ntv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )\n\nReturns the floating seconds between the two times, which should have\nbeen returned by C<gettimeofday()>. If the second argument is omitted,\nthen the current time is used.\n\n=item time ()\n\nReturns a floating seconds since the epoch. This function can be\nimported, resulting in a nice drop-in replacement for the C<time>\nprovided with core Perl; see the L</EXAMPLES> below.\n\nB<NOTE 1>: This higher resolution timer can return values either less\nor more than the core C<time()>, depending on whether your platform\nrounds the higher resolution timer values up, down, or to the nearest second\nto get the core C<time()>, but naturally the difference should be never\nmore than half a second.  See also L</clock_getres>, if ", 8192) = 8192
09:01:56.987933 lseek(6, 2239, SEEK_SET) = 2239
09:01:56.988004 lseek(6, 0, SEEK_CUR)   = 2239
09:01:56.988070 close(6)                = 0
09:01:56.988206 stat("modules/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988285 stat("modules/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988361 stat("/etc/perl/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988438 stat("/usr/local/lib/perl/5.14.2/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988518 stat("/usr/local/share/perl/5.14.2/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988598 stat("/usr/lib/perl5/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988675 stat("/usr/share/perl5/auto/Time/HiRes", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.988753 stat("/usr/lib/perl/5.14/auto/Time/HiRes", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:56.988844 stat("/usr/lib/perl/5.14/auto/Time/HiRes/HiRes.so", {st_mode=S_IFREG|0644, st_size=22784, ...}) = 0
09:01:56.988958 stat("/usr/lib/perl/5.14/auto/Time/HiRes/HiRes.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.989051 open("/usr/lib/perl/5.14/auto/Time/HiRes/HiRes.so", O_RDONLY) = 6
09:01:56.989133 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\31\0\0\0\0\0\0@\0\0\0\0\0\0\0@R\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,K\0\0\0\0\0\0,K\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0@M\0\0\0\0\0\0@M \0\0\0\0\0@M \0\0\0\0\0\10\4\0\0\0\0\0\0\20\4\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0XM\0\0\0\0\0\0XM \0\0\0\0\0XM \0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\200F\0\0\0\0\0\0\200F\0\0\0\0\0\0\200F\0\0\0\0\0\0\264\0\0\0\0\0\0\0\264\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0@M\0\0\0\0\0\0@M \0\0\0\0\0@M \0\0\0\0\0\300\2\0\0\0\0\0\0\300\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\3s\242\307\253\213?mR3ln\322\10\346Z[\267\36\374\0\0\0\0C\0\0\0F\0\0\0\0\0\0\0\"\0\0\0+\0\0\0\0\0\0\0(\0\0\0\0\0\0\0&\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\24\0\0\0$\0\0\0\0\0\0\0\0\0\0\0.\0\0\0 \0\0\0*\0\0\0\6\0\0\0D\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\16\0\0\0\7\0\0\0,\0\0\0>\0\0\0\0\0\0\0004\0\0\0007\0\0\0:\0\0\0\0\0\0\0\31\0\0\0%\0\0\0008\0\0\0\21\0\0\0-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\0\0\0\37\0\0\0\n\0\0\0!\0\0\0@\0\0\0\0\0\0\0\0\0\0\0\34\0\0\0006\0\0\0\23\0\0\0\32\0\0\0/\0\0\0\0\0\0\0\35\0\0\0009\0\0\0\4\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\30\0\0\0)\0\0\0\33\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0000\0\0\0\0\0\0\0", 832) = 832
09:01:56.989341 fstat(6, {st_mode=S_IFREG|0644, st_size=22784, ...}) = 0
09:01:56.989426 mmap(NULL, 2117968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f7434f08000
09:01:56.989499 mprotect(0x7f7434f0d000, 2093056, PROT_NONE) = 0
09:01:56.989571 mmap(0x7f743510c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x4000) = 0x7f743510c000
09:01:56.989659 close(6)                = 0
09:01:56.989745 open("/etc/ld.so.cache", O_RDONLY) = 6
09:01:56.989819 fstat(6, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:56.989893 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 6, 0) = 0x7f7436f01000
09:01:56.989958 close(6)                = 0
09:01:56.990025 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:56.990126 open("/lib/x86_64-linux-gnu/librt.so.1", O_RDONLY) = 6
09:01:56.990205 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220!\0\0\0\0\0\0@\0\0\0\0\0\0\0\300s\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0!\0 \0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\0Y\0\0\0\0\0\0\0Y\0\0\0\0\0\0\0Y\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0008i\0\0\0\0\0\0008i\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\220m\0\0\0\0\0\0\220m \0\0\0\0\0\220m \0\0\0\0\0\334\4\0\0\0\0\0\0H\16\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\310m\0\0\0\0\0\0\310m \0\0\0\0\0\310m \0\0\0\0\0\360\1\0\0\0\0\0\0\360\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\34Y\0\0\0\0\0\0\34Y\0\0\0\0\0\0\34Y\0\0\0\0\0\0<\2\0\0\0\0\0\0<\2\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\220m\0\0\0\0\0\0\220m \0\0\0\0\0\220m \0\0\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\365\215]\343\347\242\230\236\221T\"\272B\3\376S\333\244I\240\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0b\0\0\0?\0\0\0\10\0\0\0\t\0\0\0\1\0\204!0\0\10@\0\20P\213\340\6\22 \0\10\202@\0(\200 \t\3\0\4@\1@#\2\20\0\2\240\4 \0\10\0\0\2\0\4\0\200\210\206D\20\0\0\20\4P\20\2\322\4\1\4\206\0\0\0\0\0\0\0\0?\0\0\0@\0\0\0A\0\0\0\0\0\0\0B\0\0\0\0\0\0\0C\0\0\0\0\0\0\0E\0\0\0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\0\0\0\0\0\0\0I\0\0\0", 832) = 832
09:01:56.990394 fstat(6, {st_mode=S_IFREG|0644, st_size=31744, ...}) = 0
09:01:56.990473 mmap(NULL, 2128856, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f7434d00000
09:01:56.990542 mprotect(0x7f7434d07000, 2093056, PROT_NONE) = 0
09:01:56.990611 mmap(0x7f7434f06000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x6000) = 0x7f7434f06000
09:01:56.990692 close(6)                = 0
09:01:56.990778 mprotect(0x7f7434f06000, 4096, PROT_READ) = 0
09:01:56.990857 mprotect(0x7f743510c000, 4096, PROT_READ) = 0
09:01:56.990929 munmap(0x7f7436f01000, 98904) = 0
09:01:56.991127 lseek(5, 9512, SEEK_SET) = 9512
09:01:56.991192 lseek(5, 0, SEEK_CUR)   = 9512
09:01:56.991264 close(5)                = 0
09:01:56.991657 lseek(4, 1568, SEEK_SET) = 1568
09:01:56.991723 lseek(4, 0, SEEK_CUR)   = 1568
09:01:56.991787 close(4)                = 0
09:01:56.991907 stat("modules/POE/Kernel.pmc", 0x7ffe1233bca0) = -1 ENOENT (No such file or directory)
09:01:56.991981 stat("modules/POE/Kernel.pm", {st_mode=S_IFREG|0600, st_size=174736, ...}) = 0
09:01:56.992063 open("modules/POE/Kernel.pm", O_RDONLY) = 4
09:01:56.992136 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b980) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.992201 lseek(4, 0, SEEK_CUR)   = 0
09:01:56.992278 read(4, "package POE::Kernel;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse POE::Resource::Clock qw( monotime sleep mono2wall wall2mono walltime time );\n\nuse POSIX qw(uname);\nuse Errno qw(ESRCH EINTR ECHILD EPERM EINVAL EEXIST EAGAIN EWOULDBLOCK);\nuse Carp qw(carp croak confess cluck);\nuse Sys::Hostname qw(hostname);\nuse IO::Handle ();\nuse File::Spec ();\n#use Time::HiRes qw(time sleep);\n\n# People expect these to be lexical.\n\nuse vars qw($poe_kernel $poe_main_window);\n\n#------------------------------------------------------------------------------\n# A cheezy exporter to avoid using Exporter.\n\nmy $queue_class;\n\nBEGIN {\n  eval {\n    require POE::XS::Queue::Array;\n    POE::XS::Queue::Array->import();\n    $queue_class = \"POE::XS::Queue::Array\";\n  };\n  unless ($queue_class) {\n    require POE::Queue::Array;\n    POE::Queue::Array->import();\n    $queue_class = \"POE::Queue::Array\";\n  }\n}\n\nsub import {\n  my ($class, $args) = ($poe_kernel, @_[1..$#_]);\n  my $package = caller();\n\n  croak \"POE::Kernel expects its arguments in a hash ref\"\n    if ($args && ref($args) ne 'HASH');\n\n  {\n    no strict 'refs';\n    *{ $package . '::poe_kernel'      } = \\$poe_kernel;\n    *{ $package . '::poe_main_window' } = \\$poe_main_window;\n  }\n\n  # Extract the import arguments we're interested in here.\n\n  my $loop = delete $args->{loop} || $ENV{POE_EVENT_LOOP};\n\n  # Don't accept unknown/mistyped arguments.\n\n  my @unknown = sort keys %$args;\n  croak \"Unknown POE::Kernel import arguments: @unknown\" if @unknown;\n\n  # Now do things with them.\n\n  unless (UNIVERSAL::can('POE::Kernel', 'poe_kernel_loop')) {\n    if (defined $loop) {\n      $loop =~ s/^(POE::)?(XS::)?(Loop::)?//;\n      if (defined $2) {\n        $loop = \"POE::XS::Loop::$loop\";\n      }\n      else {\n        $loop = \"POE::Loop::$loop\";\n      }\n    }\n    _test_loop($loop);\n    # Bootstrap the kernel.  This is inherited from a time when multiple\n    # kernels could be present in the same Perl process.\n    POE::Kernel->new() if UNIVERSAL::can('POE::Kernel', 'poe_kernel_loop');\n  }\n}\n\n#------------------------------------------------------------------------------\n# Perform some optional setup.\n\nBEGIN {\n  local $SIG{'__DIE__'} = 'DEFAULT';\n\n  {\n    no strict 'refs';\n    if ($^O eq 'MSWin32') {\n        *{ __PACKAGE__ . '::RUNNING_IN_HELL' } = sub { 1 };\n    } else {\n        *{ __PACKAGE__ . '::RUNNING_IN_HELL' } = sub { 0 };\n    }\n  }\n}\n\nBEGIN {\n  # The entire BEGIN block is a no-strict-refs zone.\n\n  no strict 'refs';\n\n  # Set up a constant that lets the user deactivate automatic\n  # exception handling.\n\n  unless (defined &CATCH_EXCEPTIONS) {\n    my $catch_exceptions = (\n      (exists $ENV{POE_CATCH_EXCEPTIONS})\n      ? $ENV{POE_CATCH_EXCEPTIONS}\n      : 1\n    );\n\n    if ($catch_exceptions) {\n      *CATCH_EXCEPTIONS = sub () { 1 };\n    }\n    else {\n      *CATCH_EXCEPTIONS = sub () { 0 };\n    }\n  }\n\n  unless (defined &CHILD_POLLING_INTERVAL) {\n    # That's one second, not a true value.\n    *CHILD_POLLING_INTERVAL = sub () { 1 };\n  }\n\n  unless (defined &USE_SIGCHLD) {\n    # Perl >= 5.7.3 has safe signals support\n    # perlipc.pod#Deferred_Signals_(Safe_Signals)\n    # We decided to target 5.8.1 just to be safe :)\n    if ( $] >= 5.008001 and not RUNNING_IN_HELL ) {\n      *USE_SIGCHLD = sub () { 1 };\n    } else {\n      *USE_SIGCHLD = sub () { 0 };\n    }\n  }\n\n  unless (defined &USE_SIGNAL_PIPE) {\n    my $use_signal_pipe;\n    if ( exists $ENV{POE_USE_SIGNAL_PIPE} ) {\n      $use_signal_pipe = $ENV{POE_USE_SIGNAL_PIPE};\n    }\n\n    if (RUNNING_IN_HELL) {\n      if ($use_signal_pipe) {\n        _warn(\n          \"Sorry, disabling USE_SIGNAL_PIPE on $^O.\\n\",\n          \"Programs are reported to hang when it's enabled.\\n\",\n        );\n      }\n\n      # Must be defined to supersede the default.\n      $use_signal_pipe = 0;\n    }\n\n    if ($use_signal_pipe or not defined $use_signal_pipe) {\n      *USE_SIGNAL_PIPE = sub () { 1 };\n    }\n    else {\n      *USE_SIGNAL_PIPE = sub () { 0 };\n    }\n  }\n}\n\n#==============================================================================\n# Globals, or at least package-scoped things.  Data structures were\n# moved into lexicals in 0.1201.\n\n# A reference to the currently active session.  Used throughout the\n# functions that act on the current session.\nmy $kr_active_session;\nmy $kr_active_event;\nmy $kr_active_event_type;\n\n# Needs to be lexical so that POE::Resource::Events can see it\n# change.  TODO - Something better?  Maybe we call a method in\n# POE::Resource::Events to trigger the exception there?\nuse vars qw($kr_exception);\n\n# The Kernel's master queue.\nmy $kr_queue;\n\n# The current PID, to detect when it changes\nmy $kr_pid;\n\n# Filehandle activity modes.  They are often used as list indexes.\nsub MODE_RD () { 0 }  # read\nsub MODE_WR () { 1 }  # write\nsub MODE_EX () { 2 }  # exception/expedite\n\n#------------------------------------------------------------------------------\n# Kernel structure.  This is the root of a large data tree.  Dumping\n# $poe_kernel with Data::Dumper or something will show most of the\n# data that POE keeps track of.  The exceptions to this are private\n# storage in some of the leaf objects, such as POE::Wheel.  All its\n# members are described in detail further on.\n\nmy $kr_id_seq = 0;\n\nsub KR_SESSIONS          () {  0 } # [ \\%kr_sessions,\nsub KR_FILENOS           () {  1 } #   \\%kr_filenos,\nsub KR_SIGNALS           () {  2 } #   \\%kr_signals,\nsub KR_ALIASES           () {  3 } #   \\%kr_aliases,\nsub KR_ACTIVE_SESSION    () {  4 } #   \\$kr_active_session,\nsub KR_QUEUE             () {  5 } #   \\$kr_queue,\nsub KR_ID                () {  6 } #   $unique_kernel_id,\nsub KR_SESSION_IDS       () {  7 } #   \\%kr_session_ids,\nsub KR_SID_SEQ           () {  8 } #   \\$kr_sid_seq,\nsub KR_EXTRA_REFS        () {  9 } #   \\$kr_extra_refs,\nsub KR_SIZE              () { 10 } #   XXX UNUSED ???\nsub KR_RUN               () { 11 } #   \\$kr_run_warning\nsub KR_ACTIVE_EVENT      () { 12 } #   \\$kr_active_event\nsub KR_PIDS              () { 13 } #   \\%kr_pids_to_events\nsub KR_ACTIVE_EVENT_TYPE () { 14 } #   \\$kr_active_event_type\n                                   # ]\n\n# This flag indicates that POE::Kernel's run() method was called.\n# It's used to warn about forgetting $poe_kernel->run().\n\nsub KR_RUN_CALLED  () { 0x01 }  # $kernel->run() called\nsub KR_RUN_SESSION () { 0x02 }  # sessions created\nsub KR_RUN_DONE    () { 0x04 }  # run returned\nmy $kr_run_warning = 0;\n\n#------------------------------------------------------------------------------\n# Events themselves.\n\nsub EV_SESSION    () { 0 }  # [ $destination_session,\nsub EV_SOURCE     () { 1 }  #   $sender_session,\nsub EV_NAME       () { 2 }  #   $event_name,\nsub EV_TYPE       () { 3 }  #   $event_type,\nsub EV_ARGS       () { 4 }  #   \\@event_parameters_arg0_etc,\n                            #\n                            #   (These fields go towards the end\n                            #   because they are optional in some\n                            #   cases.  TODO: Is this still true?)\n                            #\nsub EV_OWNER_FILE () { 5 }  #   $caller_filename_where_enqueued,\nsub EV_OWNER_LINE () { 6 }  #   $caller_line_where_enqueued,\nsub EV_FROMSTATE  () { 7 }  #   $fromstate\nsub EV_SEQ        () { 8 }  #   Maintained by POE::Queue (unique event ID)\nsub EV_WALLTIME   () { 9 }  #   Walltime when event was created (for alarms)\nsub EV_DELTA      () { 10 } #   Seconds past walltime for event (for alarms)\n                            # ]\n\n# These are the names of POE's internal events.  They're in constants\n# so we don't mistype them again.\n\nsub EN_CHILD  () { '_child'           }\nsub EN_GC     () { '_garbage_collect' }\nsub EN_PARENT () { '_parent'          }\nsub EN_SCPOLL () { '_sigchld_poll'    }\nsub EN_SIGNAL () { '_signal'          }\nsub EN_START  () { '_start'           }\nsub EN_STOP   () { '_stop'            }\n\n# These are POE's event classes (types).  They often shadow the event\n# names themselves, but they can encompass a large group of events.\n# For example, ET_ALARM describes anything enqueued as by an alarm\n# call.  Types are preferred over names because bitmask tests are\n# faster than string equality", 8192) = 8192
09:01:56.993356 stat("modules/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.993432 stat("modules/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.993504 stat("modules/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.993573 stat("modules/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.993643 stat("/etc/perl/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.993722 stat("/etc/perl/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.993792 stat("/usr/local/lib/perl/5.14.2/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.993864 stat("/usr/local/lib/perl/5.14.2/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.993935 stat("/usr/local/share/perl/5.14.2/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.994007 stat("/usr/local/share/perl/5.14.2/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.994097 stat("/usr/lib/perl5/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.994169 stat("/usr/lib/perl5/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.994240 stat("/usr/share/perl5/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.994313 stat("/usr/share/perl5/Sys/Hostname.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:56.994385 stat("/usr/lib/perl/5.14/Sys/Hostname.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:56.994460 stat("/usr/lib/perl/5.14/Sys/Hostname.pm", {st_mode=S_IFREG|0644, st_size=3644, ...}) = 0
09:01:56.994543 open("/usr/lib/perl/5.14/Sys/Hostname.pm", O_RDONLY) = 5
09:01:56.994620 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.994687 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.994767 brk(0x9ff000)           = 0x9ff000
09:01:56.994842 read(5, "package Sys::Hostname;\n\nuse strict;\n\nuse Carp;\n\nrequire Exporter;\n\nour @ISA     = qw/ Exporter /;\nour @EXPORT  = qw/ hostname /;\n\nour $VERSION;\n\nour $host;\n\nBEGIN {\n    $VERSION = '1.16';\n    {\n\tlocal $SIG{__DIE__};\n\teval {\n\t    require XSLoader;\n\t    XSLoader::load();\n\t};\n\twarn $@ if $@;\n    }\n}\n\n\nsub hostname {\n\n  # method 1 - we already know it\n  return $host if defined $host;\n\n  # method 1' - try to ask the system\n  $host = ghname() if defined &ghname;\n  return $host if defined $host;\n\n  if ($^O eq 'VMS') {\n\n    # method 2 - no sockets ==> return DECnet node name\n    eval { local $SIG{__DIE__}; $host = (gethostbyname('me'))[0] };\n    if ($@) { return $host = $ENV{'SYS$NODE'}; }\n\n    # method 3 - has someone else done the job already?  It's common for the\n    #    TCP/IP stack to advertise the hostname via a logical name.  (Are\n    #    there any other logicals which TCP/IP stacks use for the host name?)\n    $host = $ENV{'ARPANET_HOST_NAME'}  || $ENV{'INTERNET_HOST_NAME'} ||\n            $ENV{'MULTINET_HOST_NAME'} || $ENV{'UCX$INET_HOST'}      ||\n            $ENV{'TCPWARE_DOMAINNAME'} || $ENV{'NEWS_ADDRESS'};\n    return $host if $host;\n\n    # method 4 - does hostname happen to work?\n    my($rslt) = `hostname`;\n    if ($rslt !~ /IVVERB/) { ($host) = $rslt =~ /^(\\S+)/; }\n    return $host if $host;\n\n    # rats!\n    $host = '';\n    croak \"Cannot get host name of local machine\";  \n\n  }\n  elsif ($^O eq 'MSWin32') {\n    ($host) = gethostbyname('localhost');\n    chomp($host = `hostname 2> NUL`) unless defined $host;\n    return $host;\n  }\n  elsif ($^O eq 'epoc') {\n    $host = 'localhost';\n    return $host;\n  }\n  else {  # Unix\n    # is anyone going to make it here?\n\n    local $ENV{PATH} = '/usr/bin:/bin:/usr/sbin:/sbin'; # Paranoia.\n\n    # method 2 - syscall is preferred since it avoids tainting problems\n    # XXX: is it such a good idea to return hostname untainted?\n    eval {\n\tlocal $SIG{__DIE__};\n\trequire \"syscall.ph\";\n\t$host = \"\\0\" x 65; ## preload scalar\n\tsyscall(&SYS_gethostname, $host, 65) == 0;\n    }\n\n    # method 2a - syscall using systeminfo instead of gethostname\n    #           -- needed on systems like Solaris\n    || eval {\n\tlocal $SIG{__DIE__};\n\trequire \"sys/syscall.ph\";\n\trequire \"sys/systeminfo.ph\";\n\t$host = \"\\0\" x 65; ## preload scalar\n\tsyscall(&SYS_systeminfo, &SI_HOSTNAME, $host, 65) != -1;\n    }\n\n    # method 3 - trusty old hostname command\n    || eval {\n\tlocal $SIG{__DIE__};\n\tlocal $SIG{CHLD};\n\t$host = `(hostname) 2>/dev/null`; # bsdish\n    }\n\n    # method 4 - use POSIX::uname(), which strictly can't be expected to be\n    # correct\n    || eval {\n\tlocal $SIG{__DIE__};\n\trequire POSIX;\n\t$host = (POSIX::uname())[1];\n    }\n\n    # method 5 - sysV uname command (may truncate)\n    || eval {\n\tlocal $SIG{__DIE__};\n\t$host = `uname -n 2>/dev/null`; ## sysVish\n    }\n\n    # bummer\n    || croak \"Cannot get host name of local machine\";  \n\n    # remove garbage \n    $host =~ tr/\\0\\r\\n//d;\n    $host;\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nSys::Hostname - Try every conceivable way to get hostname\n\n=head1 SYNOPSIS\n\n    use Sys::Hostname;\n    $host = hostname;\n\n=head1 DESCRIPTION\n\nAttempts several methods of getting the system hostname and\nthen caches the result.  It tries the first available of the C\nlibrary's gethostname(), C<`$Config{aphostname}`>, uname(2),\nC<syscall(SYS_gethostname)>, C<`hostname`>, C<`uname -n`>,\nand the file F</com/host>.  If all that fails it C<croak>s.\n\nAll NULs, returns, and newlines are removed from the result.\n\n=head1 AUTHOR\n\nDavid Sundstrom E<lt>F<sunds@asictest.sc.ti.com>E<gt>\n\nTexas Instruments\n\nXS code added by Greg Bacon E<lt>F<gbacon@cs.uah.edu>E<gt>\n\n=cut\n\n", 8192) = 3644
09:01:56.995316 stat("/usr/lib/perl/5.14/auto/Sys/Hostname/Hostname.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.995402 stat("/usr/lib/perl/5.14/auto/Sys/Hostname/Hostname.so", {st_mode=S_IFREG|0644, st_size=10264, ...}) = 0
09:01:56.995487 stat("/usr/lib/perl/5.14/auto/Sys/Hostname/Hostname.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:56.995575 open("/usr/lib/perl/5.14/auto/Sys/Hostname/Hostname.so", O_RDONLY) = 6
09:01:56.995652 read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\t\0\0\0\0\0\0@\0\0\0\0\0\0\0X!\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\334\r\0\0\0\0\0\0\334\r\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\320\35\0\0\0\0\0\0\320\35 \0\0\0\0\0\320\35 \0\0\0\0\0\220\2\0\0\0\0\0\0\230\2\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\350\35\0\0\0\0\0\0\350\35 \0\0\0\0\0\350\35 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0$\r\0\0\0\0\0\0$\r\0\0\0\0\0\0$\r\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\320\35\0\0\0\0\0\0\320\35 \0\0\0\0\0\320\35 \0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\34N\251\206H\226\212\27\10*Lh\1\320P\377{\202\321\216\0\0\0\0\21\0\0\0\30\0\0\0\0\0\0\0\20\0\0\0\27\0\0\0\17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\24\0\0\0\25\0\0\0\10\0\0\0\23\0\0\0\v\0\0\0\22\0\0\0\t\0\0\0\6\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\5\0\0\0\21\0\0\0\n\0\0\0\f\0\0\0\r\0\0\0\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\21\0\0\0\1\0\0\0\6\0\0\0\210\3000\5\0\24@\t\21\0\0\0\23\0\0\0\26\0\0\0BE\325\354\273\343\222|\330qX\34\332`J\250\271\215\361\16\352\323\357\16\25\353$\335\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\n\0\350\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\33\1\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\266\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:56.995856 fstat(6, {st_mode=S_IFREG|0644, st_size=10264, ...}) = 0
09:01:56.995942 mmap(NULL, 2105448, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0x7f7434afd000
09:01:56.996012 mprotect(0x7f7434afe000, 2097152, PROT_NONE) = 0
09:01:56.996081 mmap(0x7f7434cfe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x1000) = 0x7f7434cfe000
09:01:56.996163 close(6)                = 0
09:01:56.996240 mprotect(0x7f7434cfe000, 4096, PROT_READ) = 0
09:01:56.996738 lseek(5, 2967, SEEK_SET) = 2967
09:01:56.996804 lseek(5, 0, SEEK_CUR)   = 2967
09:01:56.996868 close(5)                = 0
09:01:56.997095 stat("modules/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997174 stat("modules/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997246 stat("modules/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997316 stat("modules/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997386 stat("/etc/perl/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997458 stat("/etc/perl/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997529 stat("/usr/local/lib/perl/5.14.2/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997601 stat("/usr/local/lib/perl/5.14.2/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997679 stat("/usr/local/share/perl/5.14.2/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997750 stat("/usr/local/share/perl/5.14.2/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997824 stat("/usr/lib/perl5/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.997895 stat("/usr/lib/perl5/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.997967 stat("/usr/share/perl5/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998047 stat("/usr/share/perl5/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.998125 stat("/usr/lib/perl/5.14/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998200 stat("/usr/lib/perl/5.14/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.998273 stat("/usr/share/perl/5.14/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998345 stat("/usr/share/perl/5.14/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.998417 stat("/usr/local/lib/site_perl/POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998488 stat("/usr/local/lib/site_perl/POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.998560 stat("./POE/XS/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998637 stat("./POE/XS/Queue/Array.pm", 0x7ffe1233b610) = -1 ENOENT (No such file or directory)
09:01:56.998721 stat("modules/POE/Queue/Array.pmc", 0x7ffe1233b6c0) = -1 ENOENT (No such file or directory)
09:01:56.998793 stat("modules/POE/Queue/Array.pm", {st_mode=S_IFREG|0600, st_size=12566, ...}) = 0
09:01:56.998875 open("modules/POE/Queue/Array.pm", O_RDONLY) = 5
09:01:56.998949 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b3a0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:56.999015 lseek(5, 0, SEEK_CUR)   = 0
09:01:56.999093 read(5, "# Copyrights and documentation are at the end.\n\npackage POE::Queue::Array;\n\nuse strict;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n@ISA = qw(POE::Queue);\n\nuse Errno qw(ESRCH EPERM);\nuse Carp qw(confess);\n\nsub DEBUG () { 0 }\n\n### Helpful offsets.\n\nsub ITEM_PRIORITY () { 0 }\nsub ITEM_ID       () { 1 }\nsub ITEM_PAYLOAD  () { 2 }\n\nsub import {\n  my $package = caller();\n  no strict 'refs';\n  *{ $package . '::ITEM_PRIORITY' } = \\&ITEM_PRIORITY;\n  *{ $package . '::ITEM_ID'       } = \\&ITEM_ID;\n  *{ $package . '::ITEM_PAYLOAD'  } = \\&ITEM_PAYLOAD;\n}\n\n# Item IDs are unique across all queues.\n\nmy $queue_seq = 0;\nmy %item_priority;\n\n### A very simple constructor.\n\nsub new {\n  bless [], shift();\n}\n\n### Add an item to the queue.  Returns the new item's ID.\n\nsub enqueue {\n  my ($self, $priority, $payload) = @_;\n\n  # Get the next item ID.  This clever loop will hang indefinitely if\n  # you ever run out of integers to store things under.  Map the ID to\n  # its due time for search-by-ID functions.\n\n  my $item_id;\n  1 while exists $item_priority{$item_id = ++$queue_seq};\n  $item_priority{$item_id} = $priority;\n\n  my $item_to_enqueue = [\n    $priority, # ITEM_PRIORITY\n    $item_id,  # ITEM_ID\n    $payload,  # ITEM_PAYLOAD\n  ];\n\n  # Special case: No items in the queue.  The queue IS the item.\n  unless (@$self) {\n    $self->[0] = $item_to_enqueue;\n    DEBUG and warn $self->_dump_splice(0);\n    return $item_id;\n  }\n\n  # Special case: The new item belongs at the end of the queue.\n  if ($priority >= $self->[-1]->[ITEM_PRIORITY]) {\n    push @$self, $item_to_enqueue;\n    DEBUG and warn $self->_dump_splice(@$self-1);\n    return $item_id;\n  }\n\n  # Special case: The new item belongs at the head of the queue.\n  if ($priority < $self->[0]->[ITEM_PRIORITY]) {\n    unshift @$self, $item_to_enqueue;\n    DEBUG and warn $self->_dump_splice(0);\n    return $item_id;\n  }\n\n  # Special case: There are only two items in the queue.  This item\n  # naturally belongs between them.\n  if (@$self == 2) {\n    splice @$self, 1, 0, $item_to_enqueue;\n    DEBUG and warn $self->_dump_splice(1);\n    return $item_id;\n  }\n\n  # And finally we have a nontrivial queue.  Insert the item using a\n  # binary seek.\n\n  $self->_insert_item(0, $#$self, $priority, $item_to_enqueue);\n  return $item_id;\n}\n\n### Dequeue the next thing from the queue.  Returns an empty list if\n### the queue is empty.  There are different flavors of this\n### operation.\n\nsub dequeue_next {\n  my $self = shift;\n\n  return unless @$self;\n  my ($priority, $id, $stuff) = @{shift @$self};\n  delete $item_priority{$id};\n  return ($priority, $id, $stuff);\n}\n\n### Return the next item's priority, undef if the queue is empty.\n# This is POE's most-called method.  We could greatly benefit from\n# finding ways to reduce the number of calls.\n\nsub get_next_priority {\n  # This is Ton Hospel's optimization.\n  # He measured a 4% improvement by avoiding $self.\n  return (shift->[0] || return undef)->[ITEM_PRIORITY];\n}\n\n### Return the number of items currently in the queue.\n\nsub get_item_count {\n  return scalar @{$_[0]};\n}\n\n### Internal method to insert an item using a binary seek and splice.\n### We accept the bounds as parameters because the alarm adjustment\n### functions may also use it.\n\nsub _insert_item {\n  my ($self, $lower, $upper, $priority, $item) = @_;\n\n  while (1) {\n    my $midpoint = ($upper + $lower) >> 1;\n\n    # Upper and lower bounds crossed.  Insert at the lower point.\n    if ($upper < $lower) {\n      splice @$self, $lower, 0, $item;\n      DEBUG and warn $self->_dump_splice($lower);\n      return;\n    }\n\n    # We're looking for a priority lower than the one at the midpoint.\n    # Set the new upper point to just before the midpoint.\n    if ($priority < $self->[$midpoint]->[ITEM_PRIORITY]) {\n      $upper = $midpoint - 1;\n      next;\n    }\n\n    # We're looking for a priority greater or equal to the one at the\n    # midpoint.  The new lower bound is just after the midpoint.\n    $lower = $midpoint + 1;\n  }\n}\n\n### Internal method to find a queue item by its priority and ID.  We\n### assume the priority and ID have been verified already, so the item\n### must exist.  Returns the index of the item that matches the\n### priority/ID pair.\n\nsub _find_item {\n  my ($self, $id, $priority) = @_;\n\n  # Use a binary seek.\n\n  my $upper = $#$self; # Last index of @$self.\n  my $lower = 0;\n  while (1) {\n    my $midpoint = ($upper + $lower) >> 1;\n\n    # Upper and lower bounds crossed.  The lower point is aimed at an\n    # element with a priority higher than our target.\n    last if $upper < $lower;\n\n    # We're looking for a priority lower than the one at the midpoint.\n    # Set the new upper point to just before the midpoint.\n    if ($priority < $self->[$midpoint]->[ITEM_PRIORITY]) {\n      $upper = $midpoint - 1;\n      next;\n    }\n\n    # We're looking for a priority greater or equal to the one at the\n    # midpoint.  The new lower bound is just after the midpoint.\n    $lower = $midpoint + 1;\n  }\n\n  # The lower index is pointing to an element with a priority higher\n  # than our target.  Scan backwards until we find the item with the\n  # target ID.\n  while ($lower-- >= 0) {\n    return $lower if $self->[$lower]->[ITEM_ID] == $id;\n  }\n\n  die \"should never get here... maybe the queue is out of order\";\n}\n\n### Remove an item by its ID.  Takes a coderef filter, too, for\n### examining the payload to be sure it really wants to leave.  Sets\n### $! and returns undef on failure.\n\nsub remove_item {\n  my ($self, $id, $filter) = @_;\n\n  my $priority = $item_priority{$id};\n  unless (defined $priority) {\n    $! = ESRCH;\n    return;\n  }\n\n  # Find that darn item.\n  my $item_index = $self->_find_item($id, $priority);\n\n  # Test the item against the filter.\n  unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {\n    $! = EPERM;\n    return;\n  }\n\n  # Remove the item, and return it.\n  delete $item_priority{$id};\n  return @{splice @$self, $item_index, 1};\n}\n\n### Remove items matching a filter.  Regrettably, this must scan the\n### entire queue.  An optional count limits the number of items to\n### remove, and it may shorten execution times.  Returns a list of\n### references to priority/id/payload lists.  This is intended to\n### return all the items matching the filter, and the function's\n### behavior is undefined when $count is less than the number of\n### matching items.\n\nsub remove_items {\n  my ($self, $filter, $count) = @_;\n  $count = @$self unless $count;\n\n  my @items;\n  my $i = @$self;\n  while ($i--) {\n    if ($filter->($self->[$i]->[ITEM_PAYLOAD])) {\n      my $removed_item = splice(@$self, $i, 1);\n      delete $item_priority{$removed_item->[ITEM_ID]};\n      unshift @items, $removed_item;\n      last unless --$count;\n    }\n  }\n\n  return @items;\n}\n\n### Adjust the priority of an item by a relative amount.  Adds $delta\n### to the priority of the $id'd object (if it matches $filter), and\n### moves it in the queue.\n\nsub adjust_priority {\n  my ($self, $id, $filter, $delta) = @_;\n\n  my $old_priority = $item_priority{$id};\n  unless (defined $old_priority) {\n    $! = ESRCH;\n    return;\n  }\n\n  # Find that darn item.\n  my $item_index = $self->_find_item($id, $old_priority);\n\n  # Test the item against the filter.\n  unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {\n    $! = EPERM;\n    return;\n  }\n\n  # Nothing to do if the delta is zero.\n  # TODO Actually we may need to ensure that the item is moved to the\n  # end of its current priority bucket, since it should have \"moved\".\n  return $self->[$item_index]->[ITEM_PRIORITY] unless $delta;\n\n  # Remove the item, and adjust its priority.\n  my $item = splice(@$self, $item_index, 1);\n  my $new_priority = $item->[ITEM_PRIORITY] += $delta;\n  $item_priority{$id} = $new_priority;\n\n  $self->_reinsert_item($new_priority, $delta, $item_index, $item);\n}\n\n### Set the priority to a specific amount.  Replaces the item's\n### priority with $new_priority (if it matches $filter), and moves it\n### to the new location in the queue.\n\nsub set_priority {\n  my ($self, $id, $filter, $new_priority) = @_;\n\n  my $old_priority = $item_priority{$id};\n  unless (defined $old_priority) {\n    $! = ESRCH;\n    return;\n  }\n\n  # No", 8192) = 8192
09:01:57.000429 brk(0xa20000)           = 0xa20000
09:01:57.000743 read(5, "thing to do if the old and new priorities match.\n  # TODO Actually we may need to ensure that the item is moved to the\n  # end of its current priority bucket, since it should have \"moved\".\n  return $new_priority if $new_priority == $old_priority;\n\n  # Find that darn item.\n  my $item_index = $self->_find_item($id, $old_priority);\n\n  # Test the item against the filter.\n  unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {\n    $! = EPERM;\n    return;\n  }\n\n  # Remove the item, and calculate the delta.\n  my $item = splice(@$self, $item_index, 1);\n  my $delta = $new_priority - $old_priority;\n  $item->[ITEM_PRIORITY] = $item_priority{$id} = $new_priority;\n\n  $self->_reinsert_item($new_priority, $delta, $item_index, $item);\n}\n\n### Sanity-check the results of an item insert.  Verify that it\n### belongs where it was put.  Only called during debugging.\n\nsub _dump_splice {\n  my ($self, $index) = @_;\n  my @return;\n  my $at = $self->[$index]->[ITEM_PRIORITY];\n  if ($index > 0) {\n    my $before = $self->[$index-1]->[ITEM_PRIORITY];\n    push @return, \"before($before)\";\n    confess \"out of order: $before should be < $at\" if $before > $at;\n  }\n  push @return, \"at($at)\";\n  if ($index < $#$self) {\n    my $after = $self->[$index+1]->[ITEM_PRIORITY];\n    push @return, \"after($after)\";\n    my @priorities = map {$_->[ITEM_PRIORITY]} @$self;\n    confess \"out of order: $at should be < $after (@priorities)\" if (\n      $at >= $after\n    );\n  }\n  return \"@return\";\n}\n\n### Reinsert an item into the queue.  It has just been removed by\n### adjust_priority() or set_priority() and needs to be replaced.\n### This tries to be clever by not doing more work than necessary.\n\nsub _reinsert_item {\n  my ($self, $new_priority, $delta, $item_index, $item) = @_;\n\n  # Now insert it back.\n  # The special cases are duplicates from enqueue().  We use the delta\n  # (direction) of the move and the old item index to narrow down the\n  # subsequent nontrivial insert if none of the special cases apply.\n\n  # Special case: No events in the queue.  The queue IS the item.\n  unless (@$self) {\n    $self->[0] = $item;\n    DEBUG and warn $self->_dump_splice(0);\n    return $new_priority;\n  }\n\n  # Special case: The item belongs at the end of the queue.\n  if ($new_priority >= $self->[-1]->[ITEM_PRIORITY]) {\n    push @$self, $item;\n    DEBUG and warn $self->_dump_splice(@$self-1);\n    return $new_priority;\n  }\n\n  # Special case: The item belongs at the head of the queue.\n  if ($new_priority < $self->[0]->[ITEM_PRIORITY]) {\n    unshift @$self, $item;\n    DEBUG and warn $self->_dump_splice(0);\n    return $new_priority;\n  }\n\n  # Special case: There are only two items in the queue.  This item\n  # naturally belongs between them.\n\n  if (@$self == 2) {\n    splice @$self, 1, 0, $item;\n    DEBUG and warn $self->_dump_splice(1);\n    return $new_priority;\n  }\n\n  # The item has moved towards an end of the queue, but there are a\n  # lot of items into which it may be inserted.  We'll binary seek.\n\n  my ($upper, $lower);\n  if ($delta > 0) {\n    $upper = $#$self; # Last index in @$self.\n    $lower = $item_index;\n  }\n  else {\n    $upper = $item_index;\n    $lower = 0;\n  }\n\n  $self->_insert_item($lower, $upper, $new_priority, $item);\n  return $new_priority;\n}\n\n### Peek at items that match a filter.  Returns a list of payloads\n### that match the supplied coderef.\n\nsub peek_items {\n  my ($self, $filter, $count) = @_;\n  $count = @$self unless $count;\n\n  my @items;\n  my $i = @$self;\n  while ($i--) {\n    if ($filter->($self->[$i]->[ITEM_PAYLOAD])) {\n      unshift @items, $self->[$i];\n      last unless --$count;\n    }\n  }\n\n  return @items;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Queue::Array - a high-performance array-based priority queue\n\n=head1 SYNOPSIS\n\nSee L<POE::Queue>.\n\n=head1 DESCRIPTION\n\nThis class is an implementation of the abstract POE::Queue interface.\nAs such, its documentation may be found in L<POE::Queue>.\n\nPOE::Queue::Array implements a priority queue using Perl arrays,\nsplice, and copious application of cleverness.\n\nDespite its name, POE::Queue::Array may be used as a stand-alone\npriority queue without the rest of POE.\n\n=head1 SEE ALSO\n\nL<POE>, L<POE::Queue>\n\n=head1 BUGS\n\nNone currently known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors, contributors,\nand POE's licensing.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 4374
09:01:57.001528 lseek(5, 11828, SEEK_SET) = 11828
09:01:57.001597 lseek(5, 0, SEEK_CUR)   = 11828
09:01:57.001667 close(5)                = 0
09:01:57.002632 read(4, " tests.\n\nsub ET_POST   () { 0x0001 }  # User events (posted, yielded).\nsub ET_CALL   () { 0x0002 }  # User events that weren't enqueued.\nsub ET_START  () { 0x0004 }  # _start\nsub ET_STOP   () { 0x0008 }  # _stop\nsub ET_SIGNAL () { 0x0010 }  # _signal\nsub ET_GC     () { 0x0020 }  # _garbage_collect\nsub ET_PARENT () { 0x0040 }  # _parent\nsub ET_CHILD  () { 0x0080 }  # _child\nsub ET_SCPOLL () { 0x0100 }  # _sigchild_poll\nsub ET_ALARM  () { 0x0200 }  # Alarm events.\nsub ET_SELECT () { 0x0400 }  # File activity events.\nsub ET_SIGCLD () { 0x0800 }  # sig_child() events.\nsub ET_SIGDIE () { 0x1000 }  # SIGDIE exception events.\n\n# A mask for all events generated by/for users.\nsub ET_MASK_USER () { ~(ET_GC | ET_SCPOLL) }\n\n# A mask for all events that are delayed by a dispatch time.\nsub ET_MASK_DELAYED () { ET_ALARM | ET_SCPOLL }\n\n# Temporary signal subtypes, used during signal dispatch semantics\n# deprecation and reformation.\n\nsub ET_SIGNAL_RECURSIVE () { 0x2000 }  # Explicitly requested signal.\n\n# A hash of reserved names.  It's used to test whether someone is\n# trying to use an internal event directly.\n\nmy %poes_own_events = (\n  +EN_CHILD  => 1,\n  +EN_GC     => 1,\n  +EN_PARENT => 1,\n  +EN_SCPOLL => 1,\n  +EN_SIGNAL => 1,\n  +EN_START  => 1,\n  +EN_STOP   => 1,\n  +EN_STAT   => 1,\n);\n\n# These are ways a child may come or go.\n# TODO - It would be useful to split 'lose' into two types.  One to\n# indicate that the child has stopped, and one to indicate that it was\n# given away.\n\nsub CHILD_GAIN   () { 'gain'   }  # The session was inherited from another.\nsub CHILD_LOSE   () { 'lose'   }  # The session is no longer this one's child.\nsub CHILD_CREATE () { 'create' }  # The session was created as a child of this.\n\n# Argument offsets for different types of internally generated events.\n# TODO Exporting (EXPORT_OK) these would let people stop depending on\n# positions for them.\n\nsub EA_SEL_HANDLE () { 0 }\nsub EA_SEL_MODE   () { 1 }\nsub EA_SEL_ARGS   () { 2 }\n\n#------------------------------------------------------------------------------\n# Debugging and configuration constants.\n\n# Shorthand for defining a trace constant.\nsub _define_trace {\n  no strict 'refs';\n  foreach my $name (@_) {\n    next if defined *{\"TRACE_$name\"}{CODE};\n    my $trace_value = &TRACE_DEFAULT;\n    my $trace_name  = \"TRACE_$name\";\n    *$trace_name = sub () { $trace_value };\n  }\n}\n\n# Debugging flags for subsystems.  They're done as double evals here\n# so that someone may define them before using POE::Kernel (or POE),\n# and the pre-defined value will take precedence over the defaults\n# here.\n\nmy $trace_file_handle;\n\nBEGIN {\n  # Shorthand for defining an assert constant.\n  sub _define_assert {\n    no strict 'refs';\n    foreach my $name (@_) {\n      next if defined *{\"ASSERT_$name\"}{CODE};\n      my $assert_value = &ASSERT_DEFAULT;\n      my $assert_name  = \"ASSERT_$name\";\n      *$assert_name = sub () { $assert_value };\n    }\n  }\n\n  # Assimilate POE_TRACE_* and POE_ASSERT_* environment variables.\n  # Environment variables override everything else.\n  while (my ($var, $val) = each %ENV) {\n    next unless $var =~ /^POE_([A-Z_]+)$/;\n\n    my $const = $1;\n\n    next unless $const =~ /^(?:TRACE|ASSERT)_/ or do { no strict 'refs'; defined &$const };\n\n    # Copy so we don't hurt our environment.\n    my $value = $val;\n    ($value) = ($value =~ /^([-\\@\\w.]+)$/); # Untaint per rt.cpan.org 81550\n    $value =~ tr['\"][]d;\n    $value = 0 + $value if $value =~ /^\\s*-?\\d+(?:\\.\\d+)?\\s*$/;\n\n    no strict 'refs';\n    local $^W = 0;\n    local $SIG{__WARN__} = sub { }; # redefine\n    *$const = sub () { $value };\n  }\n\n  # TRACE_FILENAME is special.\n  {\n    no strict 'refs';\n    my $trace_filename = TRACE_FILENAME() if defined &TRACE_FILENAME;\n    if (defined $trace_filename) {\n      open $trace_file_handle, \">$trace_filename\"\n        or die \"can't open trace file `$trace_filename': $!\";\n      CORE::select((CORE::select($trace_file_handle), $| = 1)[0]);\n    }\n  }\n  # TRACE_DEFAULT changes the default value for other TRACE_*\n  # constants.  Since define_trace() uses TRACE_DEFAULT internally, it\n  # can't be used to define TRACE_DEFAULT itself.\n\n  defined &TRACE_DEFAULT or *TRACE_DEFAULT = sub () { 0 };\n\n  _define_trace qw(\n    EVENTS FILES PROFILE REFCNT RETVALS SESSIONS SIGNALS STATISTICS\n  );\n\n  # See the notes for TRACE_DEFAULT, except read ASSERT and assert\n  # where you see TRACE and trace.\n\n  defined &ASSERT_DEFAULT or *ASSERT_DEFAULT = sub () { 0 };\n\n  _define_assert qw(DATA EVENTS FILES RETVALS USAGE);\n}\n\n# An \"idle\" POE::Kernel may still have events enqueued.  These events\n# regulate polling for signals, profiling, and perhaps other aspects of\n# POE::Kernel's internal workings.\n#\n# XXX - There must be a better mechanism.\n#\nmy $idle_queue_size;\n\nsub _idle_queue_grow   { $idle_queue_size++;   }\nsub _idle_queue_shrink { $idle_queue_size--;   }\nsub _idle_queue_size   { $idle_queue_size;     }\nsub _idle_queue_reset  { $idle_queue_size = 0; }\n\n#------------------------------------------------------------------------------\n# Helpers to carp, croak, confess, cluck, warn and die with whatever\n# trace file we're using today.  _trap is reserved for internal\n# errors.\n\nsub _trap {\n  local $Carp::CarpLevel = $Carp::CarpLevel + 1;\n  local *STDERR = $trace_file_handle || *STDERR;\n\n  confess(\n    \"=== $$ === Please address any warnings or errors above this message,\\n\",\n    \"=== $$ === and try again.  If there are no previous messages, or they\\n\",\n    \"=== $$ === are from within POE, then please mail them along with the\\n\",\n    \"=== $$ === following information to bug-POE\\@rt.cpan.org:\\n\",\n    \"---\\n@_\\n-----\\n\"\n  );\n}\n\nsub _croak {\n  local $Carp::CarpLevel = $Carp::CarpLevel + 1;\n  local *STDERR = $trace_file_handle || *STDERR;\n  my $message = join(\"\", @_);\n  $message =~ s/^/=== $$ === /mg;\n  croak $message;\n}\n\nsub _confess {\n  local $Carp::CarpLevel = $Carp::CarpLevel + 1;\n  local *STDERR = $trace_file_handle || *STDERR;\n  my $message = join(\"\", @_);\n  $message =~ s/^/=== $$ === /mg;\n  confess $message;\n}\n\nsub _cluck {\n  local $Carp::CarpLevel = $Carp::CarpLevel + 1;\n  local *STDERR = $trace_file_handle || *STDERR;\n  my $message = join(\"\", @_);\n  $message =~ s/^/=== $$ === /mg;\n  cluck $message;\n}\n\nsub _carp {\n  local $Carp::CarpLevel = $Carp::CarpLevel + 1;\n  local *STDERR = $trace_file_handle || *STDERR;\n  my $message = join(\"\", @_);\n  $message =~ s/^/=== $$ === /mg;\n  carp $message;\n}\n\nsub _warn {\n  my ($package, $file, $line) = caller();\n  my $message = join(\"\", @_);\n  $message .= \" at $file line $line\\n\" unless $message =~ /\\n$/;\n  $message =~ s/^/=== $$ === /mg;\n  warn $message;\n}\n\nsub _die {\n  my ($package, $file, $line) = caller();\n  my $message = join(\"\", @_);\n  $message .= \" at $file line $line\\n\" unless $message =~ /\\n$/;\n  $message =~ s/^/=== $$ === /mg;\n  local *STDERR = $trace_file_handle || *STDERR;\n  die $message;\n}\n\n#------------------------------------------------------------------------------\n# Adapt POE::Kernel's personality to whichever event loop is present.\n\nmy @has_poe_loop;\nsub _find_loop {\n  my ($mod) = @_;\n\n  # Turns O(M*N) into O(M+N).  I've seen the old way take over 30\n  # seconds according to Devel::NYTProf, with egregiously long @INCs.\n  unless (@has_poe_loop) {\n    @has_poe_loop = (\n      grep { (-d \"$_/POE/Loop\") || (-d \"$_/POE/XS/Loop\") }\n      @INC\n    );\n  }\n\n  foreach my $dir (@has_poe_loop) {\n    return 1 if (-r \"$dir/$mod\");\n  }\n\n  return 0;\n}\n\nsub _load_loop {\n  my $loop = shift;\n\n  *poe_kernel_loop = sub { return \"$loop\" };\n\n  # Modules can die with \"not really dying\" if they've loaded\n  # something else.  This exception prevents the rest of the\n  # originally used module from being parsed, so the module it's\n  # handed off to takes over.\n  eval \"require $loop\";\n  if ($@ and $@ !~ /not really dying/) {\n    die(\n      \"*\\n\",\n      \"* POE can't use $loop:\\n\",\n      \"* $@\\n\",\n      \"*\\n\",\n    );\n  }\n}\n\nsub _test_loop {\n  my $used_first = shift;\n  local $SIG{__DIE__};\n\n  # First see if someone wants to load a POE::Loop or XS version\n  # explicitly.\n  if (defined $used_first) {\n    _load_loop($used_first);\n    return;\n  }\n\n  foreach my $file (keys %INC) {\n    next if (substr ($file, -3) ne ", 8192) = 8192
09:01:57.003637 brk(0xa41000)           = 0xa41000
09:01:57.004624 read(4, "'.pm');\n    my @split_dirs = File::Spec->splitdir($file);\n\n    # Create a module name by replacing the path separators with\n    # underscores and removing \".pm\"\n    my $module = join(\"_\", @split_dirs);\n    substr($module, -3) = \"\";\n\n    # Skip the module name if it isn't legal.\n    next if $module =~ /[^\\w\\.]/;\n\n    # Try for the XS version first.  If it fails, try the plain\n    # version.  If that fails, we're up a creek.\n    $module = \"POE/XS/Loop/$module.pm\";\n    unless (_find_loop($module)) {\n      $module =~ s|XS/||;\n      next unless (_find_loop($module));\n    }\n\n    if (defined $used_first and $used_first ne $module) {\n      die(\n        \"*\\n\",\n        \"* POE can't use multiple event loops at once.\\n\",\n        \"* You used $used_first and $module.\\n\",\n        \"* Specify the loop you want as an argument to POE\\n\",\n        \"*  use POE qw(Loop::Select);\\n\",\n        \"* or;\\n\",\n        \"*  use POE::Kernel { loop => 'Select' };\\n\",\n        \"*\\n\",\n      );\n    }\n\n    $used_first = $module;\n  }\n\n  # No loop found.  Default to our internal select() loop.\n  unless (defined $used_first) {\n    $used_first = \"POE/XS/Loop/Select.pm\";\n    unless (_find_loop($used_first)) {\n      $used_first =~ s/XS\\///;\n    }\n  }\n\n  substr($used_first, -3) = \"\";\n  $used_first =~ s|/|::|g;\n  _load_loop($used_first);\n}\n\n#------------------------------------------------------------------------------\n# Include resource modules here.  Later, when we have the option of XS\n# versions, we'll adapt this to include them if they're available.\n\nuse POE::Resources;\n\n###############################################################################\n# Helpers.\n\n### Resolve $whatever into a session reference, trying every method we\n### can until something succeeds.\n\nsub _resolve_session {\n  my ($self, $whatever) = @_;\n  my $session;\n\n  # Resolve against sessions.\n  $session = $self->_data_ses_resolve($whatever);\n  return $session if defined $session;\n\n  # Resolve against IDs.\n  $session = $self->_data_sid_resolve($whatever);\n  return $session if defined $session;\n\n  # Resolve against aliases.\n  $session = $self->_data_alias_resolve($whatever);\n  return $session if defined $session;\n\n  # Resolve against the Kernel itself.  Use \"eq\" instead of \"==\" here\n  # because $whatever is often a string.\n  return $whatever if $whatever eq $self;\n\n  # We don't know what it is.\n  return undef;\n}\n\n### Test whether POE has become idle.\n\nsub _test_if_kernel_is_idle {\n  my $self = shift;\n\n  if (TRACE_REFCNT) {\n    _warn(\n      \"<rc> ,----- Kernel Activity -----\\n\",\n      \"<rc> | Events : \", $kr_queue->get_item_count(),\n      \" (vs. idle size = \", $idle_queue_size, \")\\n\",\n      \"<rc> | Files  : \", $self->_data_handle_count(), \"\\n\",\n      \"<rc> | Extra  : \", $self->_data_extref_count(), \"\\n\",\n      \"<rc> | Procs  : \", $self->_data_sig_kernel_awaits_pids(), \"\\n\",\n      \"<rc> | Sess   : \", $self->_data_ses_count(), \"\\n\",\n      \"<rc> `---------------------------\\n\",\n      \"<rc> ...\"\n     );\n  }\n\n  if( ASSERT_DATA ) {\n    if( $kr_pid != $$ ) {\n      _trap(\n        \"New process detected. \" .\n        \"You must call ->has_forked() in the child process.\"\n      );\n    }\n  }\n\n  # Not yet idle, or SO idle that there's nothing to receive the\n  # event.  Try to order these from most to least likely to be true so\n  # that the tests short-circuit quickly.\n\n  return if (\n    $kr_queue->get_item_count() > $idle_queue_size or\n    $self->_data_handle_count() or\n    $self->_data_extref_count() or\n    $self->_data_sig_kernel_awaits_pids() or\n    !$self->_data_ses_count()\n  );\n\n  $self->_data_ev_enqueue(\n    $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'IDLE' ],\n    __FILE__, __LINE__, undef\n  );\n}\n\n### Explain why a session could not be resolved.\n\nsub _explain_resolve_failure {\n  my ($self, $whatever, $nonfatal) = @_;\n  local $Carp::CarpLevel = 2;\n\n  if (ASSERT_DATA and !$nonfatal) {\n    _trap \"<dt> Cannot resolve ``$whatever'' into a session reference\";\n  }\n\n  $! = ESRCH;\n  TRACE_RETVALS  and _carp \"<rv> session not resolved: $!\";\n  ASSERT_RETVALS and _carp \"<rv> session not resolved: $!\";\n}\n\n### Explain why a function is returning unsuccessfully.\n\nsub _explain_return {\n  my ($self, $message) = @_;\n  local $Carp::CarpLevel = 2;\n\n  ASSERT_RETVALS and _confess \"<rv> $message\";\n  TRACE_RETVALS  and _carp    \"<rv> $message\";\n}\n\n### Explain how the user made a mistake calling a function.\n\nsub _explain_usage {\n  my ($self, $message) = @_;\n  local $Carp::CarpLevel = 2;\n\n  ASSERT_USAGE   and _confess \"<us> $message\";\n  ASSERT_RETVALS and _confess \"<rv> $message\";\n  TRACE_RETVALS  and _carp    \"<rv> $message\";\n}\n\n#==============================================================================\n# SIGNALS\n#==============================================================================\n\n#------------------------------------------------------------------------------\n# Register or remove signals.\n\n# Public interface for adding or removing signal handlers.\n\nsub sig {\n  my ($self, $signal, $event_name, @args) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call sig() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined signal in sig()\" unless defined $signal;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved assigning it to a signal\"\n    ) if defined($event_name) and exists($poes_own_events{$event_name});\n  };\n\n  if (defined $event_name) {\n    $self->_data_sig_add($kr_active_session, $signal, $event_name, \\@args);\n  }\n  else {\n    $self->_data_sig_remove($kr_active_session->ID, $signal);\n  }\n}\n\n# Public interface for posting signal events.\n# TODO - Like post(), signal() should return\n\nsub signal {\n  my ($self, $dest_session, $signal, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined destination in signal()\"\n      unless defined $dest_session;\n    _confess \"<us> undefined signal in signal()\" unless defined $signal;\n  };\n\n  my $session = $self->_resolve_session($dest_session);\n  unless (defined $session) {\n    $self->_explain_resolve_failure($dest_session);\n    return;\n  }\n\n  $self->_data_ev_enqueue(\n    $session, $kr_active_session,\n    EN_SIGNAL, ET_SIGNAL, [ $signal, @etc ],\n    (caller)[1,2], $kr_active_event\n  );\n  return 1;\n}\n\n# Public interface for flagging signals as handled.  This will replace\n# the handlers' return values as an implicit flag.  Returns undef so\n# it may be used as the last function in an event handler.\n\nsub sig_handled {\n  my $self = $poe_kernel;\n  $self->_data_sig_handled();\n\n  if ($kr_active_event eq EN_SIGNAL) {\n    _die(\n      \",----- DEPRECATION ERROR -----\\n\",\n      \"| \", $self->_data_alias_loggable($kr_active_session->ID), \":\\n\",\n      \"| handled a _signal event.  You must register a handler with sig().\\n\",\n      \"`-----------------------------\\n\",\n    );\n  }\n}\n\n# Attach a window or widget's destroy/closure to the UIDESTROY signal.\n\nsub signal_ui_destroy {\n  my ($self, $window) = @_;\n  $self->loop_attach_uidestroy($window);\n}\n\n# Handle child PIDs being reaped.  Added 2006-09-15.\n\nsub sig_child {\n  my ($self, $pid, $event_name, @args) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call sig_chld() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined process ID in sig_chld()\" unless defined $pid;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved assigning it to a signal\"\n    ) if defined($event_name) and exists($poes_own_events{$event_name});\n  };\n\n  if (defined $event_name) {\n    $self->_data_sig_pid_watch($kr_active_session, $pid, $event_name, \\@args);\n  }\n  elsif ($self->_data_sig_pids_is_ses_watching($kr_active_session->ID, $pid)) {\n    $self->_data_sig_pid_ignore($kr_active_session->ID, $pid);\n  }\n}\n\n#==============================================================================\n# KERNEL\n#==============================================================================\n\nsub new {\n  my $type = shift;\n\n  # Prevent multiple instances, no matter how many times it's called.\n  # This is a backward-compatibility enhancement for programs th", 8192) = 8192
09:01:57.005380 stat("modules/POE/Resources.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.005454 stat("modules/POE/Resources.pm", {st_mode=S_IFREG|0600, st_size=2101, ...}) = 0
09:01:57.005534 open("modules/POE/Resources.pm", O_RDONLY) = 5
09:01:57.005606 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.005677 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.005758 read(5, "package POE::Resources;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nmy @resources = qw(\n  POE::XS::Resource::Aliases\n  POE::XS::Resource::Events\n  POE::XS::Resource::Extrefs\n  POE::XS::Resource::FileHandles\n  POE::XS::Resource::SIDs\n  POE::XS::Resource::Sessions\n  POE::XS::Resource::Signals\n);\n\nsub load {\n  my $package = (caller())[0];\n\n  foreach my $resource (@resources) {\n    eval \"package $package; use $resource\";\n    if ($@) {\n      # Retry the resource, removing XS:: if it couldn't be loaded.\n      # If there's no XS:: to be removed, fall through and die.\n      redo if $@ =~ /Can't locate.*?in \\@INC/ and $resource =~ s/::XS::/::/;\n      die;\n    }\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resources - loader of POE resources\n\n=head1 SYNOPSIS\n\n  # Intended for internal use by POE::Kernel.\n  use POE::Resources;\n  POE::Resources->load();\n\n=head1 DESCRIPTION\n\nPOE::Kernel is internally split into different resources that are\nseparately managed by individual mix-in classes.\n\nPOE::Resources is designed as a high-level macro manager for\nPOE::Resource classes.  Currently it implements a single method,\nload(), which loads all the POE::Resource classes.\n\n=head1 METHODS\n\nPOE::Resources has a public interface, but it is intended to be used\ninternally by POE::Kernel.  Application programmers should never need\nto use POE::Resources directly.\n\n=head2 load\n\nPOE::Kernel calls load() to loads all the known POE::Resource modules.\n\nEach resource may be handled by a pure perl module, or by an XS\nmodule.  For each resource class, load() first tries to load the\nC<POE::XS::Resource::...> version of the module.  If that fails,\nload() falls back to C<POE::Resource::...>.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 AUTHORS & LICENSING\n\nPlease see L<POE> for more information about its authors,\ncontributors, and POE's licensing.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 2101
09:01:57.005952 brk(0xa62000)           = 0xa62000
09:01:57.006185 lseek(5, 742, SEEK_SET) = 742
09:01:57.006253 lseek(5, 0, SEEK_CUR)   = 742
09:01:57.006315 close(5)                = 0
09:01:57.007057 read(4, "at\n  # have used versions prior to 0.06.  It also provides a convenient\n  # single entry point into the entirety of POE's state: point a\n  # Dumper module at it, and you'll see a hideous tree of knowledge.\n  # Be careful, though.  Its apples bite back.\n  unless (defined $poe_kernel) {\n\n    # Create our master queue.\n    $kr_queue = $queue_class->new();\n\n    # Remember the PID\n    $kr_pid = $$;\n\n    # TODO - Should KR_ACTIVE_SESSIONS and KR_ACTIVE_EVENT be handled\n    # by POE::Resource::Sessions?\n    # TODO - Should the subsystems be split off into separate real\n    # objects, such as KR_QUEUE is?\n\n    my $self = $poe_kernel = bless [\n      undef,                  # KR_SESSIONS - from POE::Resource::Sessions\n      undef,                  # KR_FILENOS - from POE::Resource::FileHandles\n      undef,                  # KR_SIGNALS - from POE::Resource::Signals\n      undef,                  # KR_ALIASES - from POE::Resource::Aliases\n      \\$kr_active_session,    # KR_ACTIVE_SESSION\n      $kr_queue,              # KR_QUEUE - reference to an object\n      undef,                  # KR_ID\n      undef,                  # KR_SESSION_IDS - from POE::Resource::SIDS\n      undef,                  # KR_SID_SEQ - from POE::Resource::SIDS\n      undef,                  # KR_EXTRA_REFS\n      undef,                  # KR_SIZE\n      \\$kr_run_warning,       # KR_RUN\n      \\$kr_active_event,      # KR_ACTIVE_EVENT\n      undef,                  # KR_PIDS\n      \\$kr_active_event_type, # KR_ACTIVE_EVENT_TYPE\n    ], $type;\n\n    POE::Resources->load();\n\n    $self->_recalc_id();\n    $self->_data_sid_set($self->[KR_ID], $self);\n\n    # Initialize subsystems.  The order is important.\n\n    # We need events before sessions, and the kernel's session before\n    # it can start polling for signals.\n    $self->_data_ev_initialize($kr_queue);\n    $self->_initialize_kernel_session();\n    $self->_data_sig_initialize();\n    $self->_data_alias_initialize();\n\n    # These other subsystems don't have strange interactions.\n    $self->_data_handle_initialize($kr_queue);\n\n    _idle_queue_reset();\n  }\n\n  # Return the global instance.\n  $poe_kernel;\n}\n\nsub CLONE {\n  _data_ses_clone();\n}\n\n#------------------------------------------------------------------------------\n# Send an event to a session right now.  Used by _disp_select to\n# expedite select() events, and used by run() to deliver posted events\n# from the queue.\n\n# Dispatch an event to its session.  A lot of work goes on here.\n\nsub _dummy_sigdie_handler { 1 }\n\nsub _dispatch_signal_event {\n  my (\n    $self,\n    $session, $source_session, $event, $type, $etc,\n    $file, $line, $fromstate, $priority, $seq\n  ) = @_;\n\n  # TODO - Regrettably, duplicate checking code in:\n  # _dispatch_signal_event(), _dispatch_event().\n\n  if (ASSERT_EVENTS) {\n    _confess \"<ev> undefined dest session\" unless defined $session;\n    _confess \"<ev> undefined source session\" unless defined $source_session;\n  };\n\n  if (TRACE_EVENTS) {\n    my $log_session = $session;\n    $log_session =  $self->_data_alias_loggable($session->ID) unless (\n      $type & ET_START\n    );\n    my $string_etc = join(\" \", map { defined() ? $_ : \"(undef)\" } @$etc);\n    _warn(\n      \"<ev> Dispatching event $seq ``$event'' ($string_etc) from \",\n      $self->_data_alias_loggable($source_session->ID), \" to $log_session\"\n    );\n  }\n\n  my $signal = $etc->[0];\n\n  if (TRACE_SIGNALS) {\n    _warn(\n      \"<sg> dispatching ET_SIGNAL ($signal) to \",\n      $self->_data_alias_loggable($session->ID)\n    );\n  }\n\n  # Step 1a: Reset the handled-signal flags.\n\n  local @POE::Kernel::kr_signaled_sessions;\n  local $POE::Kernel::kr_signal_total_handled;\n  local $POE::Kernel::kr_signal_type;\n\n  $self->_data_sig_reset_handled($signal);\n\n  # Step 1b: Collect a list of sessions to receive the signal.\n\n  my @touched_sessions = ($session);\n  my $touched_index = 0;\n  while ($touched_index < @touched_sessions) {\n    my $next_target = $touched_sessions[$touched_index]->ID;\n    push @touched_sessions, $self->_data_ses_get_children($next_target);\n    $touched_index++;\n  }\n\n  # Step 1c: The DIE signal propagates up through parents, too.\n\n  if ($signal eq \"DIE\") {\n    my $next_target = $self->_data_ses_get_parent($session->ID);\n    while (defined($next_target) and $next_target != $self) {\n      unshift @touched_sessions, $next_target;\n      $next_target = $self->_data_ses_get_parent($next_target->ID);\n    }\n  }\n\n  # Step 2: Propagate the signal to the explicit watchers in the\n  # child tree.  Ensure the full tree is touched regardless\n  # whether there are explicit watchers.\n\n  if ($self->_data_sig_explicitly_watched($signal)) {\n    my %signal_watchers = $self->_data_sig_watchers($signal);\n\n    $touched_index = @touched_sessions;\n    while ($touched_index--) {\n      my $target_session = $touched_sessions[$touched_index];\n      $self->_data_sig_touched_session($target_session);\n\n      my $target_sid = $target_session->ID;\n      next unless exists $signal_watchers{$target_sid};\n      my ($target_event, $target_etc) = @{$signal_watchers{$target_sid}};\n\n      if (TRACE_SIGNALS) {\n        _warn(\n          \"<sg> propagating explicit signal $target_event ($signal) \",\n          \"(@$target_etc) to \", $self->_data_alias_loggable($target_sid)\n        );\n      }\n\n      # ET_SIGNAL_RECURSIVE is used here to avoid repropagating\n      # the signal ad nauseam.\n      $self->_dispatch_event(\n        $target_session, $self,\n        $target_event, ET_SIGNAL_RECURSIVE | $type, [ @$etc, @$target_etc ],\n        $file, $line, $fromstate, monotime(), -__LINE__\n      );\n    }\n  }\n  else {\n    $touched_index = @touched_sessions;\n    while ($touched_index--) {\n      $self->_data_sig_touched_session($touched_sessions[$touched_index]);\n    }\n  }\n\n  # Step 3: Check to see if the signal was handled.\n\n  $self->_data_sig_free_terminated_sessions();\n\n  # If the signal was SIGDIE, then propagate the exception.\n\n  my $handled_session_count = (_data_sig_handled_status())[0];\n  if ($signal eq \"DIE\" and !$handled_session_count) {\n    $kr_exception = $etc->[1]{error_str} . (\n      (defined $kr_exception)\n      ? \"Additional error thrown in handler for previous error:\\n$kr_exception\"\n      : ''\n    );\n  }\n\n  # Signal completely dispatched.  Thanks for flying!\n  return;\n}\n\nsub _dispatch_event {\n  my (\n    $self,\n    $session, $source_session, $event, $type, $etc,\n    $file, $line, $fromstate, $priority, $seq\n  ) = @_;\n\n  if (ASSERT_EVENTS) {\n    _confess \"<ev> undefined dest session\" unless defined $session;\n    _confess \"<ev> undefined source session\" unless defined $source_session;\n  };\n\n  if (TRACE_EVENTS) {\n    my $log_session = $session;\n    $log_session =  $self->_data_alias_loggable($session->ID) unless (\n      $type & ET_START\n    );\n    my $string_etc = join(\" \", map { defined() ? $_ : \"(undef)\" } @$etc);\n    _warn(\n      \"<ev> Dispatching event $seq ``$event'' ($string_etc) from \",\n      $self->_data_alias_loggable($source_session->ID), \" to $log_session\"\n    );\n  }\n\n  ### Pre-dispatch processing.\n\n  # Some sessions don't do anything in _start and expect their\n  # creators to provide a start-up event.  This means we can't\n  # &_collect_garbage at _start time.  Instead, an ET_GC event is\n  # posted as part of session allocation.  Simply dispatching it\n  # will trigger a GC sweep.\n\n  return 0 if $type & ET_GC;\n\n  # Preprocess signals.  This is where _signal is translated into\n  # its registered handler's event name, if there is one.\n\n  if (TRACE_EVENTS) {\n    _warn(\n    \"<ev> dispatching event $seq ``$event'' to \",\n      $self->_data_alias_loggable($session->ID)\n    );\n    if ($event eq EN_SIGNAL) {\n      _warn(\"<ev>     signal($etc->[0])\");\n    }\n  }\n\n  # Prepare to call the appropriate handler.  Push the current active\n  # session on Perl's call stack.\n\n  my ($hold_active_session, $hold_active_event, $hold_active_event_type) = (\n    $kr_active_session, $kr_active_event, $kr_active_event_type\n  );\n  (\n    $kr_active_session, $kr_active_event, $kr_active_event_type\n  ) = ($session, $event, $type);\n\n  # We only care about the return value and calling context if it's\n  # ET_CALL.\n\n  my $return;\n  my $wantarray = wantarray();\n\n  confess 'please report this stacktrac", 8192) = 8192
09:01:57.008312 read(4, "e to bug-poe@rt.cpan.org' unless (\n    defined $session\n  );\n\n  # Quiet SIGDIE if it's DEFAULT.  If it's something special, then\n  # someone had better know what they're doing.\n  # 'DEFAULT', undef and '' are all the same.\n\n  my $old_sig_die = $SIG{__DIE__};\n  $SIG{__DIE__} = \\&_dummy_sigdie_handler if (\n    not defined $old_sig_die or $old_sig_die eq 'DEFAULT' or $old_sig_die eq ''\n  );\n\n  eval {\n    if ($wantarray) {\n      $return = [\n        $session->_invoke_state(\n          $source_session, $event, $etc, $file, $line, $fromstate\n        )\n      ];\n    }\n    elsif (defined $wantarray) {\n      $return = $session->_invoke_state(\n        $source_session, $event, $etc, $file, $line, $fromstate\n      );\n    }\n    else {\n      $session->_invoke_state(\n        $source_session, $event, $etc, $file, $line, $fromstate\n      );\n    }\n  };\n\n  # An exception happened?\n  # It was intially thrown under the $SIG{__DIE__} conditions that the\n  # user wanted.  Any formatting, logging, etc. is already done.\n\n  if (ref($@) or $@ ne '') {\n    if (CATCH_EXCEPTIONS) {\n      if (TRACE_EVENTS) {\n        _warn(\n          \"<ev> exception occurred in $event when invoked on \",\n          $self->_data_alias_loggable($session->ID)\n        );\n      }\n\n      # Exceptions in _stop are rethrown unconditionally.\n      # We can't enqueue them--the session is about to go away.\n      # Also if the active session has been forced back to $self via\n      # POE::Kernel->stop().\n      if ($type & (ET_STOP | ET_SIGDIE) or $kr_active_session eq $self) {\n        # Propagate the exception up to the safe rethrow point.\n        $kr_exception = $@;\n      }\n      else {\n        $self->_data_ev_enqueue(\n          $session, $self, EN_SIGNAL, ET_SIGDIE, [\n            'DIE' => {\n              source_session => $source_session,\n              dest_session => $session,\n              event => $event,\n              file => $file,\n              line => $line,\n              from_state => $fromstate,\n              error_str => $@,\n            },\n          ], __FILE__, __LINE__, undef\n        );\n      }\n    }\n    else {\n      # Propagate the exception up to the safe rethrow point.\n      $kr_exception = $@;\n    }\n  }\n\n  # Global $sig{__DIE__} changed?  For shame!\n  # TODO - This warning is only needed if a SIGDIE handler is active.\n  # TODO - Likewise, setting a SIGDIE with a __DIE__ handler in play\n  # will be tricky or impossible.  There should be some message.\n\n  if (\n    (not defined $old_sig_die or $old_sig_die eq 'DEFAULT') and\n    $SIG{__DIE__} ne \\&_dummy_sigdie_handler\n  ) {\n    _warn(\n      \"<sg> Event handler redefined global __DIE__ signal handler.\\n\",\n      \"<sg> This may conflict with CATCH_EXCEPTIONS handling.\\n\",\n      \"<sg> If global redefinition is necessary, do it in global code.\\n\",\n    );\n\n    $SIG{__DIE__} = $old_sig_die;\n  }\n\n  # Clear out the event arguments list, in case there are POE-ish\n  # things in it. This allows them to destruct happily before we set\n  # the current session back.\n\n  @$etc = ( );\n\n  # Stringify the handler's return value if it belongs in the POE\n  # namespace.  $return's scope exists beyond the post-dispatch\n  # processing, which includes POE's garbage collection.  The scope\n  # bleed was known to break determinism in surprising ways.\n\n  if (defined $return and substr(ref($return), 0, 5) eq 'POE::') {\n    $return = \"$return\";\n  }\n\n  # Pop the active session and event, now that they're no longer\n  # active.\n\n  ($kr_active_session, $kr_active_event, $kr_active_event_type) = (\n    $hold_active_session, $hold_active_event, $hold_active_event_type\n  );\n\n  if (TRACE_EVENTS) {\n    my $string_ret = $return;\n    $string_ret = \"undef\" unless defined $string_ret;\n    _warn(\"<ev> event $seq ``$event'' returns ($string_ret)\\n\");\n  }\n\n  # Return doesn't matter unless ET_CALL, ET_START or ET_STOP.\n  return unless $type & (ET_CALL | ET_START | ET_STOP);\n\n  # Return what the handler did.  This is used for call().\n  return( $wantarray ? @$return : $return );\n}\n\n#------------------------------------------------------------------------------\n# POE's main loop!  Now with Tk and Event support!\n\n# Do pre-run start-up.  Initialize the event loop, and allocate a\n# session structure to represent the Kernel.\n\nsub _initialize_kernel_session {\n  my $self = shift;\n\n  $self->loop_initialize();\n\n  $kr_exception = undef;\n  $kr_active_session = $self;\n  $self->_data_ses_allocate($self, $self->[KR_ID], undef);\n}\n\n# Do post-run cleanup.\n\nsub _finalize_kernel {\n  my $self = shift;\n\n  # Disable signal watching since there's now no place for them to go.\n  foreach ($self->_data_sig_get_safe_signals()) {\n    $self->loop_ignore_signal($_);\n  }\n\n  # Remove the kernel session's signal watcher.\n  $self->_data_sig_remove($self->ID, \"IDLE\");\n\n  # The main loop is done, no matter which event library ran it.\n  # sig before loop so that it clears the signal_pipe file handler\n  $self->_data_sig_finalize();\n  $self->loop_finalize();\n  $self->_data_extref_finalize();\n  $self->_data_sid_finalize();\n  $self->_data_alias_finalize();\n  $self->_data_handle_finalize();\n  $self->_data_ev_finalize();\n  $self->_data_ses_finalize();\n}\n\nsub run_while {\n  my ($self, $scalar_ref) = ($poe_kernel, @_[1..$#_]);\n  1 while $$scalar_ref and $self->run_one_timeslice();\n}\n\nsub run_one_timeslice {\n  my $self = $poe_kernel;\n\n  unless ($self->_data_ses_count()) {\n    $self->_finalize_kernel();\n    $kr_run_warning |= KR_RUN_DONE;\n    $kr_exception and $self->_rethrow_kr_exception();\n    return;\n  }\n\n  $self->loop_do_timeslice();\n  $kr_exception and $self->_rethrow_kr_exception();\n\n  return 1;\n}\n\nsub run {\n  # So run() can be called as a class method.\n  POE::Kernel->new unless defined $poe_kernel;\n  my $self = $poe_kernel;\n\n  # Flag that run() was called.\n  $kr_run_warning |= KR_RUN_CALLED;\n\n  # TODO is this check expensive? ( do people run() more than 1 time? )\n  if( $kr_pid != $$ ) {\n    if ( ASSERT_USAGE ) {\n      _warn \"Detected a fork, automatically calling ->has_forked()\";\n    }\n    $self->has_forked;\n  }\n\n  # Don't run the loop if we have no sessions.\n  # Loop::Event will blow up, so we're doing this sanity check.\n  # It may never trigger, however: See rt.cpan.org 101227.\n  if ( $self->_data_ses_count() == 0 ) {\n    # Emit noise only if we are under debug mode\n    if ( ASSERT_DATA ) {\n      _warn(\"Not running the event loop because we have no sessions!\\n\");\n    }\n  } else {\n    # All signals must be explicitly watched now.  We do it here because\n    # it's too early in initialize_kernel_session.\n    $self->_data_sig_add($self, \"IDLE\", EN_SIGNAL);\n\n    # Run the loop!\n    $self->loop_run();\n\n    # Cleanup\n    $self->_finalize_kernel();\n  }\n\n  # Clean up afterwards.\n  $kr_run_warning |= KR_RUN_DONE;\n\n  $kr_exception and $self->_rethrow_kr_exception();\n}\n\nsub _rethrow_kr_exception {\n  my $self = shift;\n\n  # It's quite common to see people wrap POE::Kernel->run() in an eval\n  # block and start things again if an exception is caught.\n  #\n  # This little lexical dance is actually important.  It allows\n  # $kr_exception to be cleared if the die() is caught.\n\n  my $exception = $kr_exception;\n  $kr_exception = undef;\n\n  # The die is cast.\n  die $exception;\n}\n\n# Stops the kernel cold.  XXX Experimental!\n# No events happen as a result of this, all structures are cleaned up\n# except the kernel's.  Even the current session and POE::Kernel are\n# cleaned up, which may introduce inconsistencies in the current\n# session... as _dispatch_event() attempts to clean up for a defunct\n# session.\n\nsub stop {\n  # So stop() can be called as a class method.\n  my $self = $poe_kernel;\n\n  # May be called when the kernel's already stopped.  Avoid problems\n  # trying to find child sessions when the kernel isn't registered.\n  if ($self->_data_ses_exists($self->ID)) {\n    my @children = ($self);\n    foreach my $session (@children) {\n      push @children, $self->_data_ses_get_children($session->ID);\n    }\n\n    # Don't stop believin'.  Nor the POE::Kernel singleton.\n    shift @children;\n\n    # Walk backwards to avoid inconsistency errors.\n    foreach my $session (reverse @children) {\n      $self->_data_ses_stop($session->ID);\n    }\n  }\n\n  # Roll back whether ", 8192) = 8192
09:01:57.009248 brk(0xa83000)           = 0xa83000
09:01:57.009620 read(4, "sessions were started.\n  $kr_run_warning &= ~KR_RUN_SESSION;\n\n  # So new sessions will not be child of the current defunct session.\n  $kr_active_session = $self;\n\n  # The GC mark list may prevent sessions from DESTROYing.\n  # Clean it up.\n  $self->_data_ses_gc_sweep();\n\n  # Running stop() is recommended in a POE::Wheel::Run coderef\n  # Program, before setting up for the next POE::Kernel->run().  When\n  # the PID has changed, imply _data_sig_has_forked() during stop().\n\n  $poe_kernel->has_forked() if $kr_pid != $$;\n\n  # TODO - If we're polling for signals, then the reset gets it wrong.\n  # The reset doesn't count sigchld polling.  If we must put this\n  # back, it MUST account for all internal events currently in play,\n  # or the child process will stall if it reruns POE::Kernel's loop.\n  #_idle_queue_reset();\n\n  return;\n}\n\n# Less invasive form of ->stop() + ->run()\nsub has_forked {\n  if( $kr_pid == $$ ) {\n    if ( ASSERT_USAGE ) {\n      _warn \"You should only call ->has_forked() from the child process.\";\n    }\n    return;\n  }\n\n  # So has_forked() can be called as a class method.\n  my $self = $poe_kernel;\n\n  $kr_pid = $$;\n  $self->_recalc_id();\n\n  # reset some stuff for the signals\n  $poe_kernel->_data_sig_has_forked;\n}\n\n#------------------------------------------------------------------------------\n\nsub DESTROY {\n  my $self = shift;\n\n  # Warn that a session never had the opportunity to run if one was\n  # created but run() was never called.\n\n  unless ($kr_run_warning & KR_RUN_CALLED) {\n    if ($kr_run_warning & KR_RUN_SESSION) {\n      _warn(\n        \"Sessions were started, but POE::Kernel's run() method was never\\n\",\n        \"called to execute them.  This usually happens because an error\\n\",\n        \"occurred before POE::Kernel->run() could be called.  Please fix\\n\",\n        \"any errors above this notice, and be sure that POE::Kernel->run()\\n\",\n        \"is called.  See documentation for POE::Kernel's run() method for\\n\",\n        \"another way to disable this warning.\\n\",\n      );\n    }\n  }\n}\n\n#------------------------------------------------------------------------------\n# _invoke_state is what _dispatch_event calls to dispatch a transition\n# event.  This is the kernel's _invoke_state so it can receive events.\n# These are mostly signals, which are propagated down in\n# _dispatch_event.\n\nsub _invoke_state {\n  my ($self, $source_session, $event, $etc) = @_;\n\n  # This is an event loop to poll for child processes without needing\n  # to catch SIGCHLD.\n\n  if ($event eq EN_SCPOLL) {\n    $self->_data_sig_handle_poll_event($etc->[0]);\n  }\n\n  # A signal was posted.  Because signals propagate depth-first, this\n  # _invoke_state is called last in the dispatch.  If the signal was\n  # SIGIDLE, then post a SIGZOMBIE if the main queue is still idle.\n\n  elsif ($event eq EN_SIGNAL) {\n    if ($etc->[0] eq 'IDLE') {\n      unless (\n        $kr_queue->get_item_count() > $idle_queue_size or\n        $self->_data_handle_count()\n      ) {\n        $self->_data_ev_enqueue(\n          $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'ZOMBIE' ],\n          __FILE__, __LINE__, undef\n        );\n      }\n    }\n  }\n\n  return 0;\n}\n\n#==============================================================================\n# SESSIONS\n#==============================================================================\n\n# Dispatch _start to a session, allocating it in the kernel's data\n# structures as a side effect.\n\nsub session_alloc {\n  my ($self, $session, @args) = ($poe_kernel, @_[1..$#_]);\n\n  # If we already returned, then we must reinitialize.  This is so\n  # $poe_kernel->run() will work correctly more than once.\n  if ($kr_run_warning & KR_RUN_DONE) {\n    $kr_run_warning &= ~KR_RUN_DONE;\n    $self->_initialize_kernel_session();\n    $self->_data_sig_initialize();\n  }\n\n  if (ASSERT_DATA) {\n    if (defined $session->ID) {\n      _trap(\n        \"<ss> \", $self->_data_alias_loggable($session->ID),\n        \" already allocated\\a\"\n      );\n    }\n  }\n\n  # Register that a session was created.\n  $kr_run_warning |= KR_RUN_SESSION;\n\n  # Allocate the session's data structure.  This must be done before\n  # we dispatch anything regarding the new session.\n  my $new_sid = $self->_data_sid_allocate();\n  $session->_set_id($new_sid);\n  $self->_data_ses_allocate($session, $new_sid, $kr_active_session->ID);\n\n  my $loggable = $self->_data_alias_loggable($new_sid);\n\n  # Tell the new session that it has been created.  Catch the _start\n  # state's return value so we can pass it to the parent with the\n  # _child create.\n  #\n  # TODO - Void the context if the parent has no _child handler?\n\n  my $return = $self->_dispatch_event(\n    $session, $kr_active_session,\n    EN_START, ET_START, \\@args,\n    __FILE__, __LINE__, undef, monotime(), -__LINE__\n  );\n\n  unless($self->_data_ses_exists($new_sid)) {\n    if(TRACE_SESSIONS) {\n      _warn(\"<ss> \", $loggable, \" disappeared during \", EN_START);\n    }\n    return $return;\n  }\n\n  # If the child has not detached itself---that is, if its parent is\n  # the currently active session---then notify the parent with a\n  # _child create event.  Otherwise skip it, since we'd otherwise\n  # throw a create without a lose.\n  $self->_dispatch_event(\n    $self->_data_ses_get_parent($session->ID), $self,\n    EN_CHILD, ET_CHILD, [ CHILD_CREATE, $session, $return ],\n    __FILE__, __LINE__, undef, monotime(), -__LINE__\n  );\n\n  unless ($self->_data_ses_exists($new_sid)) {\n    if (TRACE_SESSIONS) {\n      _warn(\"<ss> \", $loggable, \" disappeared during \", EN_CHILD, \" dispatch\");\n    }\n    return $return;\n  }\n\n  # Enqueue a delayed garbage-collection event so the session has time\n  # to do its thing before it goes.\n  $self->_data_ev_enqueue(\n    $session, $session, EN_GC, ET_GC, [],\n    __FILE__, __LINE__, undef\n  );\n}\n\n# Detach a session from its parent.  This breaks the parent/child\n# relationship between the current session and its parent.  Basically,\n# the current session is given to the Kernel session.  Unlike with\n# _stop, the current session's children follow their parent.\n\nsub detach_myself {\n  my $self = $poe_kernel;\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call detach_myself() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  # Can't detach from the kernel.\n  if ($self->_data_ses_get_parent($kr_active_session->ID) == $self) {\n    $! = EPERM;\n    return;\n  }\n\n  my $old_parent = $self->_data_ses_get_parent($kr_active_session->ID);\n\n  # Tell the old parent session that the child is departing.\n  # But not if the active event is ET_START, since that would generate\n  # a CHILD_LOSE without a CHILD_CREATE.\n  $self->_dispatch_event(\n    $old_parent, $self,\n    EN_CHILD, ET_CHILD, [ CHILD_LOSE, $kr_active_session, undef ],\n    (caller)[1,2], undef, monotime(), -__LINE__\n  )\n  unless $kr_active_event_type & ET_START;\n\n  # Tell the new parent (kernel) that it's gaining a child.\n  # (Actually it doesn't care, so we don't do that here, but this is\n  # where the code would go if it ever does in the future.)\n\n  # Tell the current session that its parentage is changing.\n  $self->_dispatch_event(\n    $kr_active_session, $self,\n    EN_PARENT, ET_PARENT, [ $old_parent, $self ],\n    (caller)[1,2], undef, monotime(), -__LINE__\n  );\n\n  $self->_data_ses_move_child($kr_active_session->ID, $self->ID);\n\n  # Success!\n  return 1;\n}\n\n# Detach a child from this, the parent.  The session being detached\n# must be a child of the current session.\n\nsub detach_child {\n  my ($self, $child) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call detach_child() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  my $child_session = $self->_resolve_session($child);\n  unless (defined $child_session) {\n    $self->_explain_resolve_failure($child);\n    return;\n  }\n\n  # Can't detach if it belongs to the kernel.  TODO We shouldn't need\n  # to check for this.\n  if ($kr_active_session == $self) {\n    $! = EPERM;\n    return;\n  }\n\n  # Can't detach if it's not a child of the current session.\n  unless (\n    $self->_data_ses_is_child($kr_active_session->ID, $child_session->ID)\n  ) {\n    $! = EPERM;\n    return;\n  }\n\n  # Tell the current session that the child is departing.\n  $self->_dispatch_event", 8192) = 8192
09:01:57.010863 read(4, "(\n    $kr_active_session, $self,\n    EN_CHILD, ET_CHILD, [ CHILD_LOSE, $child_session, undef ],\n    (caller)[1,2], undef, monotime(), -__LINE__\n  );\n\n  # Tell the new parent (kernel) that it's gaining a child.\n  # (Actually it doesn't care, so we don't do that here, but this is\n  # where the code would go if it ever does in the future.)\n\n  # Tell the child session that its parentage is changing.\n  $self->_dispatch_event(\n    $child_session, $self,\n    EN_PARENT, ET_PARENT, [ $kr_active_session, $self ],\n    (caller)[1,2], undef, monotime(), -__LINE__\n  );\n\n  $self->_data_ses_move_child($child_session->ID, $self->ID);\n\n  # Success!\n  return 1;\n}\n\n### Helpful accessors.\n\nsub get_active_session {\n  return $kr_active_session;\n}\n\nsub get_active_event {\n  return $kr_active_event;\n}\n\n# FIXME - Should this exist?\nsub get_event_count {\n  return $kr_queue->get_item_count();\n}\n\n# FIXME - Should this exist?\nsub get_next_event_time {\n  return $kr_queue->get_next_priority();\n}\n\n#==============================================================================\n# EVENTS\n#==============================================================================\n\n#------------------------------------------------------------------------------\n# Post an event to the queue.\n\nsub post {\n  my ($self, $dest_session, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> destination is undefined in post()\"\n      unless defined $dest_session;\n    _confess \"<us> event is undefined in post()\" unless defined $event_name;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by posting it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  # Attempt to resolve the destination session reference against\n  # various things.\n\n  my $session = $self->_resolve_session($dest_session);\n  unless (defined $session) {\n    $self->_explain_resolve_failure($dest_session);\n    return;\n  }\n\n  # Enqueue the event for \"now\", which simulates FIFO in our\n  # time-ordered queue.\n\n  $self->_data_ev_enqueue(\n    $session, $kr_active_session, $event_name, ET_POST, \\@etc,\n    (caller)[1,2], $kr_active_event\n  );\n  return 1;\n}\n\n#------------------------------------------------------------------------------\n# Post an event to the queue for the current session.\n\nsub yield {\n  my ($self, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call yield() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> event name is undefined in yield()\"\n      unless defined $event_name;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by yielding it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  $self->_data_ev_enqueue(\n    $kr_active_session, $kr_active_session, $event_name, ET_POST, \\@etc,\n    (caller)[1,2], $kr_active_event\n  );\n\n  undef;\n}\n\n#------------------------------------------------------------------------------\n# Call an event handler directly.\n\nsub call {\n  my ($self, $dest_session, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> destination is undefined in call()\"\n      unless defined $dest_session;\n    _confess \"<us> event is undefined in call()\" unless defined $event_name;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by calling it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  # Attempt to resolve the destination session reference against\n  # various things.\n\n  my $session = $self->_resolve_session($dest_session);\n  unless (defined $session) {\n    $self->_explain_resolve_failure($dest_session);\n    return;\n  }\n\n  # Dispatch the event right now, bypassing the queue altogether.\n  # This tends to be a Bad Thing to Do.\n\n  # TODO The difference between synchronous and asynchronous events\n  # should be made more clear in the documentation, so that people\n  # have a tendency not to abuse them.  I discovered in xws that\n  # mixing the two types makes it harder than necessary to write\n  # deterministic programs, but the difficulty can be ameliorated if\n  # programmers set some base rules and stick to them.\n\n  if (wantarray) {\n    my @return_value = (\n      ($session == $kr_active_session)\n      ? $session->_invoke_state(\n        $session, $event_name, \\@etc, (caller)[1,2],\n        $kr_active_event\n      )\n      : $self->_dispatch_event(\n        $session, $kr_active_session,\n        $event_name, ET_CALL, \\@etc,\n        (caller)[1,2], $kr_active_event, monotime(), -__LINE__\n      )\n    );\n\n    $kr_exception and $self->_rethrow_kr_exception();\n\n    $! = 0;\n    return @return_value;\n  }\n\n  if (defined wantarray) {\n    my $return_value = (\n      $session == $kr_active_session\n      ? $session->_invoke_state(\n        $session, $event_name, \\@etc, (caller)[1,2],\n        $kr_active_event\n      )\n      : $self->_dispatch_event(\n        $session, $kr_active_session,\n        $event_name, ET_CALL, \\@etc,\n        (caller)[1,2], $kr_active_event, monotime(), -__LINE__\n      )\n    );\n\n    $kr_exception and $self->_rethrow_kr_exception();\n\n    $! = 0;\n    return $return_value;\n  }\n\n  if ($session == $kr_active_session) {\n    $session->_invoke_state(\n      $session, $event_name, \\@etc, (caller)[1,2],\n      $kr_active_event\n    );\n  }\n  else {\n    $self->_dispatch_event(\n      $session, $kr_active_session,\n      $event_name, ET_CALL, \\@etc,\n      (caller)[1,2], $kr_active_event, monotime(), -__LINE__\n    );\n  }\n\n  $kr_exception and $self->_rethrow_kr_exception();\n\n  $! = 0;\n  return;\n}\n\n#==============================================================================\n# DELAYED EVENTS\n#==============================================================================\n\nsub alarm {\n  my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> event name is undefined in alarm()\"\n      unless defined $event_name;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting an alarm for it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  unless (defined $event_name) {\n    $self->_explain_return(\"invalid parameter to alarm() call\");\n    return EINVAL;\n  }\n\n  $self->_data_ev_clear_alarm_by_name($kr_active_session->ID(), $event_name);\n\n  # Add the new alarm if it includes a time.  Calling _data_ev_enqueue\n  # directly is faster than calling alarm_set to enqueue it.\n  if (defined $time) {\n    $self->_data_ev_enqueue\n      ( $kr_active_session, $kr_active_session,\n        $event_name, ET_ALARM, [ @etc ],\n        (caller)[1,2], $kr_active_event, $time,\n      );\n  }\n  else {\n    # The event queue has become empty?  Stop the time watcher.\n    $self->loop_pause_time_watcher() unless $kr_queue->get_item_count();\n  }\n\n  return 0;\n}\n\n# Add an alarm without clobbering previous alarms of the same name.\nsub alarm_add {\n  my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm_add() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined event name in alarm_add()\"\n      unless defined $event_name;\n    _confess \"<us> undefined time in alarm_add()\" unless defined $time;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by adding an alarm for it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  unless (defined $event_name and defined $time) {\n    $self->_explain_return(\"invalid parameter to alarm_add() call\");\n    return EINVAL;\n  }\n\n  $self->_data_ev_enqueue\n    ( $kr_active_session, $kr_active_session,\n      $event_name, ET_ALARM, [ @etc ],\n      (caller)[1,2], $kr_active_event, $time,\n    );\n\n  return 0;\n}\n\n# Add a delay, which is like an alarm relative to the current time.\nsub delay {\n  my ($self, $event_name, $delay, @etc) = ($poe_kernel, @_[1..$#_]);\n  my $pri = monotime();\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call delay() from a", 8192) = 8192
09:01:57.011923 brk(0xaa4000)           = 0xaa4000
09:01:57.012344 read(4, " running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined event name in delay()\" unless defined $event_name;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting a delay for it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  unless (defined $event_name) {\n    $self->_explain_return(\"invalid parameter to delay() call\");\n    return EINVAL;\n  }\n\n  if (defined $delay) {\n    $self->_data_ev_clear_alarm_by_name($kr_active_session->ID(), $event_name);\n\n    # Add the new alarm if it includes a time.  Calling _data_ev_enqueue\n    # directly is faster than calling alarm_set to enqueue it.\n    $self->_data_ev_enqueue\n      ( $kr_active_session, $kr_active_session,\n        $event_name, ET_ALARM, [ @etc ],\n        (caller)[1,2], $kr_active_event, undef, $delay, $pri+$delay\n      );\n  }\n  else {\n    $self->alarm($event_name);\n  }\n\n  return 0;\n}\n\n# Add a delay without clobbering previous delays of the same name.\nsub delay_add {\n  my ($self, $event_name, $delay, @etc) = ($poe_kernel, @_[1..$#_]);\n  my $pri = monotime();\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call delay_add() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined event name in delay_add()\"\n      unless defined $event_name;\n    _confess \"<us> undefined time in delay_add()\" unless defined $delay;\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by adding a delay for it\"\n    ) if exists $poes_own_events{$event_name};\n  };\n\n  unless (defined $event_name and defined $delay) {\n    $self->_explain_return(\"invalid parameter to delay_add() call\");\n    return EINVAL;\n  }\n\n  $self->_data_ev_enqueue\n    ( $kr_active_session, $kr_active_session,\n      $event_name, ET_ALARM, [ @etc ],\n      (caller)[1,2], $kr_active_event, undef, $delay, $pri+$delay\n    );\n\n  return 0;\n}\n\n#------------------------------------------------------------------------------\n# New style alarms.\n\n# Set an alarm.  This does more *and* less than plain alarm().  It\n# only sets alarms (that's the less part), but it also returns an\n# alarm ID (that's the more part).\n\nsub alarm_set {\n  my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm_set() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  unless (defined $event_name) {\n    $self->_explain_usage(\"undefined event name in alarm_set()\");\n    $! = EINVAL;\n    return;\n  }\n\n  unless (defined $time) {\n    $self->_explain_usage(\"undefined time in alarm_set()\");\n    $! = EINVAL;\n    return;\n  }\n\n  if (ASSERT_USAGE) {\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting an alarm for it\"\n    ) if exists $poes_own_events{$event_name};\n  }\n\n  return $self->_data_ev_enqueue\n    ( $kr_active_session, $kr_active_session, $event_name, ET_ALARM, [ @etc ],\n      (caller)[1,2], $kr_active_event, $time,\n    );\n}\n\n# Remove an alarm by its ID.  TODO Now that alarms and events have\n# been recombined, this will remove an event by its ID.  However,\n# nothing returns an event ID, so nobody knows what to remove.\n\nsub alarm_remove {\n  my ($self, $alarm_id) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm_remove() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  unless (defined $alarm_id) {\n    $self->_explain_usage(\"undefined alarm id in alarm_remove()\");\n    $! = EINVAL;\n    return;\n  }\n\n  my ($time, $event) =\n    $self->_data_ev_clear_alarm_by_id($kr_active_session->ID(), $alarm_id);\n  return unless defined $time;\n\n  # In a list context, return the alarm that was removed.  In a scalar\n  # context, return a reference to the alarm that was removed.  In a\n  # void context, return nothing.  Either way this returns a defined\n  # value when someone needs something useful from it.\n\n  return unless defined wantarray;\n  return ( $event->[EV_NAME], $time, $event->[EV_ARGS] ) if wantarray;\n  return [ $event->[EV_NAME], $time, $event->[EV_ARGS] ];\n}\n\n# Move an alarm to a new time.  This virtually removes the alarm and\n# re-adds it somewhere else.  In reality, adjust_priority() is\n# optimized for this sort of thing.\n\nsub alarm_adjust {\n  my ($self, $alarm_id, $delta) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm_adjust() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  unless (defined $alarm_id) {\n    $self->_explain_usage(\"undefined alarm id in alarm_adjust()\");\n    $! = EINVAL;\n    return;\n  }\n\n  unless (defined $delta) {\n    $self->_explain_usage(\"undefined alarm delta in alarm_adjust()\");\n    $! = EINVAL;\n    return;\n  }\n\n  my $my_alarm = sub {\n    $_[0]->[EV_SESSION] == $kr_active_session;\n  };\n  \n  return $self->_data_ev_adjust( $alarm_id, $my_alarm, undef, $delta );\n}\n\n# A convenient function for setting alarms relative to now.  It also\n# uses whichever time() POE::Kernel can find, which may be\n# Time::HiRes'.\n\nsub delay_set {\n  # Always always always grab time() ASAP, so that the eventual\n  # time we set the delay for is as close as possible to the time\n  # at which they ASKED for the delay, not when we actually set it.\n  my $t = walltime();\n  my $pri = monotime();\n\n  # And now continue as normal\n  my ($self, $event_name, $seconds, @etc) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call delay_set() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  unless (defined $event_name) {\n    $self->_explain_usage(\"undefined event name in delay_set()\");\n    $! = EINVAL;\n    return;\n  }\n\n  if (ASSERT_USAGE) {\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting a delay for it\"\n    ) if exists $poes_own_events{$event_name};\n  }\n\n  unless (defined $seconds) {\n    $self->_explain_usage(\"undefined seconds in delay_set()\");\n    $! = EINVAL;\n    return;\n  }\n\n  return $self->_data_ev_enqueue\n    ( $kr_active_session, $kr_active_session, $event_name, ET_ALARM, [ @etc ],\n      (caller)[1,2], $kr_active_event, $t, $seconds, $pri+$seconds\n    );\n}\n\n# Move a delay to a new offset from time().  As with alarm_adjust(),\n# this is optimized internally for this sort of activity.\n\nsub delay_adjust {\n  # Always always always grab time() ASAP, so that the eventual\n  # time we set the delay for is as close as possible to the time\n  # at which they ASKED for the delay, not when we actually set it.\n  my $t = walltime();\n  my $pri = monotime();\n\n  # And now continue as normal\n  my ($self, $alarm_id, $seconds) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call delay_adjust() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  unless (defined $alarm_id) {\n    $self->_explain_usage(\"undefined delay id in delay_adjust()\");\n    $! = EINVAL;\n    return;\n  }\n\n  unless (defined $seconds) {\n    $self->_explain_usage(\"undefined delay seconds in delay_adjust()\");\n    $! = EINVAL;\n    return;\n  }\n\n  my $my_delay = sub {\n    $_[0]->[EV_SESSION] == $kr_active_session;\n  };\n\n  if (TRACE_EVENTS) {\n    _warn(\"<ev> adjusted event $alarm_id by $seconds seconds from $t\");\n  }\n\n  return $self->_data_ev_set($alarm_id, $my_delay, $t, $pri, $seconds );\n}\n\n# Remove all alarms for the current session.\n\nsub alarm_remove_all {\n  my $self = $poe_kernel;\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call alarm_remove_all() from a running session\"\n      if $kr_active_session == $self;\n  }\n\n  # This should never happen, actually.\n  _trap \"unknown session in alarm_remove_all call\" unless (\n    $self->_data_ses_exists($kr_active_session->ID)\n  );\n\n  # Free every alarm owned by the session.  This code is ripped off\n  # from the _stop code to flush everything.\n\n  my @removed = $self->_data_ev_clear_alarm_by_session(\n    $kr_active_session->ID()\n  );\n\n  return unless defined wantarray;\n  return @removed if wantarray;\n  return \\@removed;\n}\n\n#==============================================================================\n# SELECTS\n#==============", 8192) = 8192
09:01:57.013700 read(4, "================================================================\n\nsub _internal_select {\n  my ($self, $session, $handle, $event_name, $mode, $args) = @_;\n\n  # If an event is included, then we're defining a filehandle watcher.\n\n  if ($event_name) {\n    $self->_data_handle_add($handle, $mode, $session, $event_name, $args);\n  }\n  else {\n    $self->_data_handle_remove($handle, $mode, $session->ID);\n  }\n}\n\n# A higher-level select() that manipulates read, write and expedite\n# selects together.\n\nsub select {\n  my ($self, $handle, $event_r, $event_w, $event_e, @args) = (\n    $poe_kernel, @_[1..$#_]\n  );\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select()\" unless defined $handle;\n    _confess \"<us> invalid filehandle in select()\"\n      unless defined fileno($handle);\n    foreach ($event_r, $event_w, $event_e) {\n      next unless defined $_;\n      _carp(\n        \"<us> The '$_' event is one of POE's own.  Its \" .\n        \"effect cannot be achieved by setting a file watcher to it\"\n      ) if exists($poes_own_events{$_});\n    }\n  }\n\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_r, MODE_RD, \\@args\n  );\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_w, MODE_WR, \\@args\n  );\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_e, MODE_EX, \\@args\n  );\n  return 0;\n}\n\n# Only manipulate the read select.\nsub select_read {\n  my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_read() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_read()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_read()\"\n      unless defined fileno($handle);\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting a file watcher to it\"\n    ) if defined($event_name) and exists($poes_own_events{$event_name});\n  };\n\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_name, MODE_RD, \\@args\n  );\n  return 0;\n}\n\n# Only manipulate the write select.\nsub select_write {\n  my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_write() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_write()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_write()\"\n      unless defined fileno($handle);\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting a file watcher to it\"\n    ) if defined($event_name) and exists($poes_own_events{$event_name});\n  };\n\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_name, MODE_WR, \\@args\n  );\n  return 0;\n}\n\n# Only manipulate the expedite select.\nsub select_expedite {\n  my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_expedite() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_expedite()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_expedite()\"\n      unless defined fileno($handle);\n    _carp(\n      \"<us> The '$event_name' event is one of POE's own.  Its \" .\n      \"effect cannot be achieved by setting a file watcher to it\"\n    ) if defined($event_name) and exists($poes_own_events{$event_name});\n  };\n\n  $self->_internal_select(\n    $kr_active_session, $handle, $event_name, MODE_EX, \\@args\n  );\n  return 0;\n}\n\n# Turn off a handle's write mode bit without doing\n# garbage-collection things.\nsub select_pause_write {\n  my ($self, $handle) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_pause_write() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_pause_write()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_pause_write()\"\n      unless defined fileno($handle);\n  };\n\n  return 0 unless $self->_data_handle_is_good($handle, MODE_WR);\n\n  $self->_data_handle_pause($handle, MODE_WR);\n\n  return 1;\n}\n\n# Turn on a handle's write mode bit without doing garbage-collection\n# things.\nsub select_resume_write {\n  my ($self, $handle) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_resume_write() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_resume_write()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_resume_write()\"\n      unless defined fileno($handle);\n  };\n\n  return 0 unless $self->_data_handle_is_good($handle, MODE_WR);\n\n  $self->_data_handle_resume($handle, MODE_WR);\n\n  return 1;\n}\n\n# Turn off a handle's read mode bit without doing garbage-collection\n# things.\nsub select_pause_read {\n  my ($self, $handle) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_pause_read() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_pause_read()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_pause_read()\"\n      unless defined fileno($handle);\n  };\n\n  return 0 unless $self->_data_handle_is_good($handle, MODE_RD);\n\n  $self->_data_handle_pause($handle, MODE_RD);\n\n  return 1;\n}\n\n# Turn on a handle's read mode bit without doing garbage-collection\n# things.\nsub select_resume_read {\n  my ($self, $handle) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call select_resume_read() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined filehandle in select_resume_read()\"\n      unless defined $handle;\n    _confess \"<us> invalid filehandle in select_resume_read()\"\n      unless defined fileno($handle);\n  };\n\n  return 0 unless $self->_data_handle_is_good($handle, MODE_RD);\n\n  $self->_data_handle_resume($handle, MODE_RD);\n\n  return 1;\n}\n\n#==============================================================================\n# Aliases: These functions expose the internal alias accessors with\n# extra fun parameter/return value checking.\n#==============================================================================\n\n### Set an alias in the current session.\n\nsub alias_set {\n  my ($self, $name) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined alias in alias_set()\" unless defined $name;\n  };\n\n  # Don't overwrite another session's alias.\n  my $existing_session = $self->_data_alias_resolve($name);\n  if (defined $existing_session) {\n    if ($existing_session != $kr_active_session) {\n      $self->_explain_usage(\"alias '$name' is in use by another session\");\n      return EEXIST;\n    }\n    return 0;\n  }\n\n  $self->_data_alias_add($kr_active_session, $name);\n  return 0;\n}\n\n### Remove an alias from the current session.\n\nsub alias_remove {\n  my ($self, $name) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined alias in alias_remove()\" unless defined $name;\n  };\n\n  my $existing_session = $self->_data_alias_resolve($name);\n\n  unless (defined $existing_session) {\n    $self->_explain_usage(\"alias '$name' does not exist\");\n    return ESRCH;\n  }\n\n  if ($existing_session != $kr_active_session) {\n    $self->_explain_usage(\"alias '$name' does not belong to current session\");\n    return EPERM;\n  }\n\n  $self->_data_alias_remove($kr_active_session, $name);\n  return 0;\n}\n\n### Resolve an alias into a session.\n\nsub alias_resolve {\n  my ($self, $name) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined alias in alias_resolve()\" unless defined $name;\n  };\n\n  return $self->_resolve_session($name);\n}\n\n### List the aliases for a given session.\n\nsub alias_list {\n  my ($self, $search_session) = ($poe_kernel, @_[1..$#_]);\n  my $session =\n    $self->_resolve_session($search_session || $kr_active_se", 8192) = 8192
09:01:57.014542 brk(0xac5000)           = 0xac5000
09:01:57.015178 read(4, "ssion);\n\n  unless (defined $session) {\n    $self->_explain_resolve_failure($search_session, \"nonfatal\");\n    return;\n  }\n\n  # Return whatever can be found.\n  my @alias_list = $self->_data_alias_list($session->ID);\n  return wantarray() ? @alias_list : $alias_list[0];\n}\n\n#==============================================================================\n# Kernel and Session IDs\n#==============================================================================\n\n# Return the Kernel's \"unique\" ID.  There's only so much uniqueness\n# available; machines on separate private 10/8 networks may have\n# identical kernel IDs.  The chances of a collision are vanishingly\n# small.\n\n# The Kernel and Session IDs are based on Philip Gwyn's code.  I hope\n# he still can recognize it.\n\nsub _recalc_id {\n  my $self = shift;\n\n  my $old_id = $self->[KR_ID];\n\n  my $hostname = eval { (uname)[1] };\n  $hostname = hostname() unless defined $hostname;\n\n  my $new_id = $self->[KR_ID] = join(\n    \"-\", $hostname,\n    map { unpack \"H*\", $_ }\n    map { pack \"N\", $_ }\n    (monotime(), $$, ++$kr_id_seq)\n  );\n\n  if (defined $old_id) {\n    $self->_data_sig_relocate_kernel_id($old_id, $new_id);\n    $self->_data_ses_relocate_kernel_id($old_id, $new_id);\n    $self->_data_sid_relocate_kernel_id($old_id, $new_id);\n    $self->_data_handle_relocate_kernel_id($old_id, $new_id);\n    $self->_data_ev_relocate_kernel_id($old_id, $new_id);\n    $self->_data_alias_relocate_kernel_id($old_id, $new_id);\n  }\n}\n\nsub ID { $poe_kernel->[KR_ID] }\n\n# Resolve an ID to a session reference.  This function is virtually\n# moot now that _resolve_session does it too.  This explicit call will\n# be faster, though, so it's kept for things that can benefit from it.\n\nsub ID_id_to_session {\n  my ($self, $id) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined ID in ID_id_to_session()\" unless defined $id;\n  };\n\n  my $session = $self->_data_sid_resolve($id);\n  return $session if defined $session;\n\n  $self->_explain_return(\"ID does not exist\");\n  $! = ESRCH;\n  return;\n}\n\n# Resolve a session reference to its corresponding ID.\n\nsub ID_session_to_id {\n  my ($self, $session) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined session in ID_session_to_id()\"\n      unless defined $session;\n  };\n\n  my $id = $self->_data_ses_resolve_to_id($session);\n  if (defined $id) {\n    $! = 0;\n    return $id;\n  }\n\n  $self->_explain_return(\"session ($session) does not exist\");\n  $! = ESRCH;\n  return;\n}\n\n#==============================================================================\n# Extra reference counts, to keep sessions alive when things occur.\n# They take session IDs because they may be called from resources at\n# times where the session reference is otherwise unknown.\n#==============================================================================\n\nsub refcount_increment {\n  my ($self, $session_id, $tag) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined session ID in refcount_increment()\"\n      unless defined $session_id;\n    _confess \"<us> undefined reference count tag in refcount_increment()\"\n      unless defined $tag;\n  };\n\n  unless ($self->_data_ses_exists($session_id)) {\n    $self->_explain_return(\"session id $session_id does not exist\");\n    $! = ESRCH;\n    return;\n  }\n\n  my $refcount = $self->_data_extref_inc($session_id, $tag);\n  # TODO trace it here\n  return $refcount;\n}\n\nsub refcount_decrement {\n  my ($self, $session_id, $tag) = ($poe_kernel, @_[1..$#_]);\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> undefined session ID in refcount_decrement()\"\n      unless defined $session_id;\n    _confess \"<us> undefined reference count tag in refcount_decrement()\"\n      unless defined $tag;\n  };\n\n  unless ($self->_data_ses_exists($session_id)) {\n    $self->_explain_return(\"session id $session_id does not exist\");\n    $! = ESRCH;\n    return;\n  }\n\n  my $refcount = $self->_data_extref_dec($session_id, $tag);\n\n  # TODO trace it here\n  return $refcount;\n}\n\n#==============================================================================\n# HANDLERS\n#==============================================================================\n\n# Add or remove event handlers from sessions.\nsub state {\n  my ($self, $event, $state_code, $state_alias) = ($poe_kernel, @_[1..$#_]);\n  $state_alias = $event unless defined $state_alias;\n\n  if (ASSERT_USAGE) {\n    _confess \"<us> must call state() from a running session\"\n      if $kr_active_session == $self;\n    _confess \"<us> undefined event name in state()\" unless defined $event;\n    _confess \"<us> can't call state() outside a session\" if (\n      $kr_active_session == $self\n    );\n  };\n\n  if (\n    (ref($kr_active_session) ne '') &&\n    (ref($kr_active_session) ne 'POE::Kernel')\n  ) {\n    $kr_active_session->_register_state($event, $state_code, $state_alias);\n    return 0;\n  }\n\n  # TODO A terminal signal (such as UIDESTROY) kills a session.  The\n  # Kernel deallocates the session, which cascades destruction to its\n  # HEAP.  That triggers a Wheel's destruction, which calls\n  # $kernel->state() to remove a state from the session.  The session,\n  # though, is already gone.  If TRACE_RETVALS and/or ASSERT_RETVALS\n  # is set, this causes a warning or fatal error.\n\n  $self->_explain_return(\"session ($kr_active_session) does not exist\");\n  return ESRCH;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Kernel - an event-based application kernel in Perl\n\n=head1 SYNOPSIS\n\n  use POE; # auto-includes POE::Kernel and POE::Session\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub { $_[KERNEL]->yield(\"next\") },\n      next   => sub {\n        print \"tick...\\n\";\n        $_[KERNEL]->delay(next => 1);\n      },\n    },\n  );\n\n  POE::Kernel->run();\n  exit;\n\nIn the spirit of Perl, there are a lot of other ways to use POE.\n\n=head1 DESCRIPTION\n\nPOE::Kernel is the heart of POE.  It provides the lowest-level\nfeatures: non-blocking multiplexed I/O, timers, and signal watchers\nare the most significant.  Everything else is built upon this\nfoundation.\n\nPOE::Kernel is not an event loop in itself.  For that it uses one of\nseveral available POE::Loop interface modules.  See CPAN for modules\nin the POE::Loop namespace.\n\nPOE's documentation assumes the reader understands the @_ offset\nconstants (KERNEL, HEAP, ARG0, etc.).  The curious or confused reader\nwill find more detailed explanation in L<POE::Session>.\n\n=head1 USING POE\n\n=head2 Literally Using POE\n\nPOE.pm is little more than a class loader.  It implements some magic\nto cut down on the setup work.\n\nParameters to C<use POE> are not treated as normal imports.  Rather,\nthey're abbreviated modules to be included along with POE.\n\n  use POE qw(Component::Client::TCP).\n\nAs you can see, the leading \"POE::\" can be omitted this way.\n\nPOE.pm also includes POE::Kernel and POE::Session by default.  These\ntwo modules are used by nearly all POE-based programs.  So the above\nexample is actually the equivalent of:\n\n  use POE;\n  use POE::Kernel;\n  use POE::Session;\n  use POE::Component::Client::TCP;\n\n=head2 Using POE::Kernel\n\nPOE::Kernel needs to know which event loop you want to use.  This is\nsupported in three different ways:\n\nThe first way is to use an event loop module before using POE::Kernel\n(or POE, which loads POE::Kernel for you):\n\n  use Tk; # or one of several others\n  use POE::Kernel.\n\nPOE::Kernel scans the list of modules already loaded, and it loads an\nappropriate POE::Loop adapter if it finds a known event loop.\n\nThe next way is to explicitly load the POE::Loop class you want:\n\n  use POE qw(Loop::Gtk);\n\nFinally POE::Kernel's C<import()> supports more programmer-friendly\nconfiguration:\n\n  use POE::Kernel { loop => \"Gtk\" };\n  use POE::Session;\n\n=head2 Anatomy of a POE-Based Application\n\nPrograms using POE work like any other.  They load required modules,\nperform some setup, run some code, and eventually exit.  Halting\nProblem notwithstanding.\n\nA POE-based application loads some modules, sets up one or more\nsessions, runs the code in those sessions, and eventually exits.\n\n  use POE;\n  POE::Session->create( ... map events to code here ... );\n  POE::Kernel->run();\n  exit;\n\n=head2 POE::Kernel singleton\n\nThe POE::Kernel is a singleto", 8192) = 8192
09:01:57.016272 lseek(4, 79083, SEEK_SET) = 79083
09:01:57.016366 lseek(4, 0, SEEK_CUR)   = 79083
09:01:57.016440 close(4)                = 0
09:01:57.016594 stat("modules/POE/Loop", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
09:01:57.016677 stat("modules/POE/Loop", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
09:01:57.016751 stat("/etc/perl/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.016821 stat("/etc/perl/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.016889 stat("/usr/local/lib/perl/5.14.2/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.016959 stat("/usr/local/lib/perl/5.14.2/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017027 stat("/usr/local/share/perl/5.14.2/POE/Loop", {st_mode=S_IFDIR|S_ISGID|0755, st_size=4096, ...}) = 0
09:01:57.017107 stat("/usr/lib/perl5/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017180 stat("/usr/lib/perl5/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017248 stat("/usr/share/perl5/POE/Loop", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.017324 stat("/usr/lib/perl/5.14/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017394 stat("/usr/lib/perl/5.14/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017462 stat("/usr/share/perl/5.14/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017531 stat("/usr/share/perl/5.14/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017599 stat("/usr/local/lib/site_perl/POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017670 stat("/usr/local/lib/site_perl/POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017738 stat("./POE/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017804 stat("./POE/XS/Loop", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017873 stat("modules/POE/XS/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.017941 stat("modules/POE/XS/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018008 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018099 stat("/usr/share/perl5/POE/XS/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018159 stat("modules/POE/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018212 stat("modules/POE/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018262 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018333 stat("/usr/share/perl5/POE/Loop/IO_Handle.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018415 stat("modules/POE/XS/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018484 stat("modules/POE/XS/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018551 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018621 stat("/usr/share/perl5/POE/XS/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018696 stat("modules/POE/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018766 stat("modules/POE/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018833 stat("/usr/local/share/perl/5.14.2/POE/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018903 stat("/usr/share/perl5/POE/Loop/POSIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.018983 stat("modules/POE/XS/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019052 stat("modules/POE/XS/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019119 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019189 stat("/usr/share/perl5/POE/XS/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019264 stat("modules/POE/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019342 stat("modules/POE/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019410 stat("/usr/local/share/perl/5.14.2/POE/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019481 stat("/usr/share/perl5/POE/Loop/SelectSaver.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019562 stat("modules/POE/XS/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019630 stat("modules/POE/XS/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019697 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019767 stat("/usr/share/perl5/POE/XS/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019844 stat("modules/POE/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019912 stat("modules/POE/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.019963 stat("/usr/local/share/perl/5.14.2/POE/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020017 stat("/usr/share/perl5/POE/Loop/Tie_Hash.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020080 stat("modules/POE/XS/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020160 stat("modules/POE/XS/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020228 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020298 stat("/usr/share/perl5/POE/XS/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020372 stat("modules/POE/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020442 stat("modules/POE/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020509 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020580 stat("/usr/share/perl5/POE/Loop/IO_Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020659 stat("modules/POE/XS/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020727 stat("modules/POE/XS/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020795 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020864 stat("/usr/share/perl5/POE/XS/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.020938 stat("modules/POE/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021009 stat("modules/POE/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021076 stat("/usr/local/share/perl/5.14.2/POE/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021151 stat("/usr/share/perl5/POE/Loop/warnings.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021233 stat("modules/POE/XS/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021302 stat("modules/POE/XS/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021369 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021439 stat("/usr/share/perl5/POE/XS/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021513 stat("modules/POE/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021582 stat("modules/POE/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021653 stat("/usr/local/share/perl/5.14.2/POE/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021725 stat("/usr/share/perl5/POE/Loop/Fcntl.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021804 stat("modules/POE/XS/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021879 stat("modules/POE/XS/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.021947 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022015 stat("/usr/share/perl5/POE/XS/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022108 stat("modules/POE/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022161 stat("modules/POE/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022214 stat("/usr/local/share/perl/5.14.2/POE/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022267 stat("/usr/share/perl5/POE/Loop/Symbol.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022348 stat("modules/POE/XS/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022417 stat("modules/POE/XS/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022484 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022554 stat("/usr/share/perl5/POE/XS/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022629 stat("modules/POE/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022700 stat("modules/POE/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022768 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022837 stat("/usr/share/perl5/POE/Loop/IO_Socket_INET.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022917 stat("modules/POE/XS/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.022985 stat("modules/POE/XS/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023052 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023121 stat("/usr/share/perl5/POE/XS/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023195 stat("modules/POE/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023264 stat("modules/POE/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023331 stat("/usr/local/share/perl/5.14.2/POE/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023401 stat("/usr/share/perl5/POE/Loop/Exporter.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023481 stat("modules/POE/XS/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023549 stat("modules/POE/XS/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023615 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023685 stat("/usr/share/perl5/POE/XS/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023758 stat("modules/POE/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023827 stat("modules/POE/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023899 stat("/usr/local/share/perl/5.14.2/POE/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.023952 stat("/usr/share/perl5/POE/Loop/Errno.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024015 stat("modules/POE/XS/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024068 stat("modules/POE/XS/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024141 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024211 stat("/usr/share/perl5/POE/XS/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024285 stat("modules/POE/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024353 stat("modules/POE/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024428 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024500 stat("/usr/share/perl5/POE/Loop/POE_Queue_Array.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024581 stat("modules/POE/XS/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024650 stat("modules/POE/XS/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024717 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024786 stat("/usr/share/perl5/POE/XS/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024860 stat("modules/POE/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024929 stat("modules/POE/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.024996 stat("/usr/local/share/perl/5.14.2/POE/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025066 stat("/usr/share/perl5/POE/Loop/File_Spec.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025153 stat("modules/POE/XS/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025222 stat("modules/POE/XS/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025289 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025359 stat("/usr/share/perl5/POE/XS/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025434 stat("modules/POE/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025503 stat("modules/POE/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025571 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025641 stat("/usr/share/perl5/POE/Loop/POE_Pipe_OneWay.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025726 stat("modules/POE/XS/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025794 stat("modules/POE/XS/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025861 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.025930 stat("/usr/share/perl5/POE/XS/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026003 stat("modules/POE/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026095 stat("modules/POE/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026147 stat("/usr/local/share/perl/5.14.2/POE/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026201 stat("/usr/share/perl5/POE/Loop/Sys_Hostname.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026263 stat("modules/POE/XS/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026333 stat("modules/POE/XS/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026401 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026470 stat("/usr/share/perl5/POE/XS/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026545 stat("modules/POE/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026614 stat("modules/POE/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026681 stat("/usr/local/share/perl/5.14.2/POE/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026752 stat("/usr/share/perl5/POE/Loop/warnings_register.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026838 stat("modules/POE/XS/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026908 stat("modules/POE/XS/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.026975 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027044 stat("/usr/share/perl5/POE/XS/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027118 stat("modules/POE/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027186 stat("modules/POE/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027252 stat("/usr/local/share/perl/5.14.2/POE/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027322 stat("/usr/share/perl5/POE/Loop/XSLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027401 stat("modules/POE/XS/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027469 stat("modules/POE/XS/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027536 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027605 stat("/usr/share/perl5/POE/XS/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027679 stat("modules/POE/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027747 stat("modules/POE/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027814 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027892 stat("/usr/share/perl5/POE/Loop/IO_Pipely.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.027954 stat("modules/POE/XS/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028006 stat("modules/POE/XS/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028057 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028130 stat("/usr/share/perl5/POE/XS/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028204 stat("modules/POE/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028274 stat("modules/POE/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028341 stat("/usr/local/share/perl/5.14.2/POE/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028411 stat("/usr/share/perl5/POE/Loop/Time_HiRes.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028490 stat("modules/POE/XS/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028558 stat("modules/POE/XS/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028625 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028695 stat("/usr/share/perl5/POE/XS/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028769 stat("modules/POE/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028837 stat("modules/POE/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028904 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.028974 stat("/usr/share/perl5/POE/Loop/POE_Kernel.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029053 stat("modules/POE/XS/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029120 stat("modules/POE/XS/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029190 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029260 stat("/usr/share/perl5/POE/XS/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029335 stat("modules/POE/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029410 stat("modules/POE/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029477 stat("/usr/local/share/perl/5.14.2/POE/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029547 stat("/usr/share/perl5/POE/Loop/base.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029627 stat("modules/POE/XS/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029714 stat("modules/POE/XS/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029778 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029845 stat("/usr/share/perl5/POE/XS/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029917 stat("modules/POE/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.029982 stat("modules/POE/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030068 stat("/usr/local/share/perl/5.14.2/POE/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030125 stat("/usr/share/perl5/POE/Loop/Config.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030186 stat("modules/POE/XS/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030238 stat("modules/POE/XS/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030288 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030367 stat("/usr/share/perl5/POE/XS/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030438 stat("modules/POE/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030504 stat("modules/POE/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030568 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030636 stat("/usr/share/perl5/POE/Loop/IO.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030713 stat("modules/POE/XS/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030779 stat("modules/POE/XS/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030844 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030910 stat("/usr/share/perl5/POE/XS/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.030982 stat("modules/POE/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031050 stat("modules/POE/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031117 stat("/usr/local/share/perl/5.14.2/POE/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031185 stat("/usr/share/perl5/POE/Loop/IO_Socket_UNIX.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031261 stat("modules/POE/XS/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031327 stat("modules/POE/XS/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031391 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031444 stat("/usr/share/perl5/POE/XS/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031499 stat("modules/POE/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031551 stat("modules/POE/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031621 stat("/usr/local/share/perl/5.14.2/POE/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031688 stat("/usr/share/perl5/POE/Loop/Carp.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031765 stat("modules/POE/XS/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031831 stat("modules/POE/XS/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031907 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.031961 stat("/usr/share/perl5/POE/XS/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032017 stat("modules/POE/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032069 stat("modules/POE/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032143 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032210 stat("/usr/share/perl5/POE/Loop/POE_Resources.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032287 stat("modules/POE/XS/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032353 stat("modules/POE/XS/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032418 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032486 stat("/usr/share/perl5/POE/XS/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032565 stat("modules/POE/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032632 stat("modules/POE/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032697 stat("/usr/local/share/perl/5.14.2/POE/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032765 stat("/usr/share/perl5/POE/Loop/Exporter_Heavy.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032844 stat("modules/POE/XS/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032910 stat("modules/POE/XS/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.032975 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033042 stat("/usr/share/perl5/POE/XS/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033114 stat("modules/POE/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033184 stat("modules/POE/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033249 stat("/usr/local/share/perl/5.14.2/POE/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033316 stat("/usr/share/perl5/POE/Loop/File_Spec_Unix.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033394 stat("modules/POE/XS/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033460 stat("modules/POE/XS/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033524 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033592 stat("/usr/share/perl5/POE/XS/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033668 stat("modules/POE/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033733 stat("modules/POE/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033797 stat("/usr/local/share/perl/5.14.2/POE/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033863 stat("/usr/share/perl5/POE/Loop/vars.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.033938 stat("modules/POE/XS/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034003 stat("modules/POE/XS/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034087 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034141 stat("/usr/share/perl5/POE/XS/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034198 stat("modules/POE/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034250 stat("modules/POE/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034322 stat("/usr/local/share/perl/5.14.2/POE/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034390 stat("/usr/share/perl5/POE/Loop/strict.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034466 stat("modules/POE/XS/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034532 stat("modules/POE/XS/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034597 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034664 stat("/usr/share/perl5/POE/XS/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034735 stat("modules/POE/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034801 stat("modules/POE/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034866 stat("/usr/local/share/perl/5.14.2/POE/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.034933 stat("/usr/share/perl5/POE/Loop/constant.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035008 stat("modules/POE/XS/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035074 stat("modules/POE/XS/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035138 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035205 stat("/usr/share/perl5/POE/XS/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035275 stat("modules/POE/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035341 stat("modules/POE/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035405 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035472 stat("/usr/share/perl5/POE/Loop/POE.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035548 stat("modules/POE/XS/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035613 stat("modules/POE/XS/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035677 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035744 stat("/usr/share/perl5/POE/XS/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035816 stat("modules/POE/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035891 stat("modules/POE/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035942 stat("/usr/local/share/perl/5.14.2/POE/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.035994 stat("/usr/share/perl5/POE/Loop/Socket.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036055 stat("modules/POE/XS/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036125 stat("modules/POE/XS/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036190 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036256 stat("/usr/share/perl5/POE/XS/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036328 stat("modules/POE/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036394 stat("modules/POE/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036458 stat("/usr/local/share/perl/5.14.2/POE/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036525 stat("/usr/share/perl5/POE/Loop/AutoLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036601 stat("modules/POE/XS/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036666 stat("modules/POE/XS/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036731 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036805 stat("/usr/share/perl5/POE/XS/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036877 stat("modules/POE/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.036942 stat("modules/POE/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037007 stat("/usr/local/share/perl/5.14.2/POE/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037074 stat("/usr/share/perl5/POE/Loop/DynaLoader.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037157 stat("modules/POE/XS/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037224 stat("modules/POE/XS/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037289 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037356 stat("/usr/share/perl5/POE/XS/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037428 stat("modules/POE/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037495 stat("modules/POE/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037559 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037627 stat("/usr/share/perl5/POE/Loop/POE_Resource_Clock.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037708 stat("modules/POE/XS/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037774 stat("modules/POE/XS/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037837 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037904 stat("/usr/share/perl5/POE/XS/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.037974 stat("modules/POE/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038046 stat("modules/POE/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038121 stat("/usr/local/share/perl/5.14.2/POE/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038175 stat("/usr/share/perl5/POE/Loop/POE_Pipe.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038233 stat("modules/POE/XS/Loop/Select.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038285 stat("modules/POE/XS/Loop/Select.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038357 stat("/usr/local/share/perl/5.14.2/POE/XS/Loop/Select.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038424 stat("/usr/share/perl5/POE/XS/Loop/Select.pm", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.038531 stat("modules/POE/Loop/Select.pmc", 0x7ffe1233bca0) = -1 ENOENT (No such file or directory)
09:01:57.038596 stat("modules/POE/Loop/Select.pm", {st_mode=S_IFREG|0600, st_size=9464, ...}) = 0
09:01:57.038671 open("modules/POE/Loop/Select.pm", O_RDONLY) = 4
09:01:57.038738 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b980) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.038798 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.038876 read(4, "# Select loop bridge for POE::Kernel.\n\n# Empty package to appease perl.\npackage POE::Loop::Select;\n\nuse strict;\n\n# Include common signal handling.\nuse POE::Loop::PerlSignals;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n=for poe_tests\n\nsub skip_tests { return }\n\n=cut\n\n# Everything plugs into POE::Kernel.\npackage POE::Kernel;\n\nuse strict;\nuse Errno qw(EINPROGRESS EWOULDBLOCK EINTR);\n\n# select() vectors.  They're stored in an array so that the MODE_*\n# offsets can refer to them.  This saves some code at the expense of\n# clock cycles.\n#\n# [ $select_read_bit_vector,    (MODE_RD)\n#   $select_write_bit_vector,   (MODE_WR)\n#   $select_expedite_bit_vector (MODE_EX)\n# ];\nmy @loop_vectors = (\"\", \"\", \"\");\n\n# A record of the file descriptors we are actively watching.\nmy %loop_filenos;\n\n# Allow $^T to change without affecting our internals.\nmy $start_time = monotime();\n\n#------------------------------------------------------------------------------\n# Loop construction and destruction.\n\nsub loop_initialize {\n  my $self = shift;\n\n  # Initialize the vectors as vectors.\n  @loop_vectors = ( '', '', '' );\n  vec($loop_vectors[MODE_RD], 0, 1) = 0;\n  vec($loop_vectors[MODE_WR], 0, 1) = 0;\n  vec($loop_vectors[MODE_EX], 0, 1) = 0;\n}\n\nsub loop_finalize {\n  my $self = shift;\n\n  # This is \"clever\" in that it relies on each symbol on the left to\n  # be stringified by the => operator.\n  my %kernel_modes = (\n    MODE_RD => MODE_RD,\n    MODE_WR => MODE_WR,\n    MODE_EX => MODE_EX,\n  );\n\n  while (my ($mode_name, $mode_offset) = each(%kernel_modes)) {\n    my $bits = unpack('b*', $loop_vectors[$mode_offset]);\n    if (index($bits, '1') >= 0) {\n      POE::Kernel::_warn \"<rc> LOOP VECTOR LEAK: $mode_name = $bits\\a\\n\";\n    }\n  }\n\n  $self->loop_ignore_all_signals();\n}\n\n#------------------------------------------------------------------------------\n# Signal handler maintenance functions.\n\nsub loop_attach_uidestroy {\n  # does nothing\n}\n\n#------------------------------------------------------------------------------\n# Maintain time watchers.  For this loop, we simply save the next\n# event time in a scalar.  loop_do_timeslice() will use the saved\n# value.  A \"paused\" time watcher is just a timeout for some future\n# time.\n\nmy $_next_event_time = monotime();\n\nsub loop_resume_time_watcher {\n  $_next_event_time = $_[1];\n}\n\nsub loop_reset_time_watcher {\n  $_next_event_time = $_[1];\n}\n\nsub loop_pause_time_watcher {\n  $_next_event_time = monotime() + 3600;\n}\n\n#------------------------------------------------------------------------------\n# Maintain filehandle watchers.\n\nsub loop_watch_filehandle {\n  my ($self, $handle, $mode) = @_;\n  my $fileno = fileno($handle);\n\n  vec($loop_vectors[$mode], $fileno, 1) = 1;\n  $loop_filenos{$fileno} |= (1<<$mode);\n}\n\nsub loop_ignore_filehandle {\n  my ($self, $handle, $mode) = @_;\n  my $fileno = fileno($handle);\n\n  vec($loop_vectors[$mode], $fileno, 1) = 0;\n  delete $loop_filenos{$fileno} unless (\n    $loop_filenos{$fileno} and $loop_filenos{$fileno} &= ~(1<<$mode)\n  );\n}\n\nsub loop_pause_filehandle {\n  my ($self, $handle, $mode) = @_;\n  my $fileno = fileno($handle);\n\n  vec($loop_vectors[$mode], $fileno, 1) = 0;\n  delete $loop_filenos{$fileno} unless (\n    $loop_filenos{$fileno} and $loop_filenos{$fileno} &= ~(1<<$mode)\n  );\n}\n\nsub loop_resume_filehandle {\n  my ($self, $handle, $mode) = @_;\n  my $fileno = fileno($handle);\n\n  vec($loop_vectors[$mode], $fileno, 1) = 1;\n  $loop_filenos{$fileno} |= (1<<$mode);\n}\n\n#------------------------------------------------------------------------------\n# The event loop itself.\n\nsub loop_do_timeslice {\n  my $self = shift;\n\n  # Check for a hung kernel.\n  $self->_test_if_kernel_is_idle();\n\n  # Set the select timeout based on current queue conditions.  If\n  # there are FIFO events, then the timeout is zero to poll select and\n  # move on.  Otherwise set the select timeout until the next pending\n  # event, if there are any.  If nothing is waiting, set the timeout\n  # for some constant number of seconds.\n\n  my $timeout = $_next_event_time;\n\n  my $now = monotime();\n  if (defined $timeout) {\n    $timeout -= $now;\n    $timeout = 0 if $timeout < 0;\n\n    # Very large timeouts can trigger EINVAL on Mac OSX.\n    $timeout = 3600 if $timeout > 3600;\n  }\n  else {\n    die \"shouldn't happen\" if ASSERT_DATA;\n    $timeout = 3600;\n  }\n\n  # Tracing is relatively expensive, but it's not for live systems.\n  # We can get away with it being after the timeout calculation.\n  if (TRACE_EVENTS) {\n    POE::Kernel::_warn(\n      '<ev> Kernel::run() iterating.  ' .\n      sprintf(\n        \"now(%.4f) timeout(%.4f) then(%.4f)\\n\",\n        $now - $start_time, $timeout, ($now - $start_time) + $timeout\n      )\n    );\n  }\n\n  if (TRACE_FILES) {\n    POE::Kernel::_warn(\n      \"<fh> ,----- SELECT BITS IN -----\\n\",\n      \"<fh> | READ    : \", unpack('b*', $loop_vectors[MODE_RD]), \"\\n\",\n      \"<fh> | WRITE   : \", unpack('b*', $loop_vectors[MODE_WR]), \"\\n\",\n      \"<fh> | EXPEDITE: \", unpack('b*', $loop_vectors[MODE_EX]), \"\\n\",\n      \"<fh> `--------------------------\\n\"\n    );\n  }\n\n  # Avoid looking at filehandles if we don't need to.\n  # TODO The added code to make this sleep is non-optimal.  There is a\n  # way to do this in fewer tests.\n\n  if (scalar keys %loop_filenos) {\n    # There are filehandles to poll, so do so.\n\n    # Check filehandles, or wait for a period of time to elapse.\n    my $hits = CORE::select(\n      my $rout = $loop_vectors[MODE_RD],\n      my $wout = $loop_vectors[MODE_WR],\n      my $eout = $loop_vectors[MODE_EX],\n      $timeout,\n    );\n\n    if (ASSERT_FILES) {\n      if (\n        $hits < 0 and\n        $! != EINPROGRESS and\n        $! != EWOULDBLOCK and\n        $! != EINTR and\n        $! != 0                   # this is caused by SIGNAL_PIPE\n      ) {\n        POE::Kernel::_trap(\"<fh> select error: $! (hits=$hits)\");\n      }\n    }\n\n    if (TRACE_FILES) {\n      if ($hits > 0) {\n        POE::Kernel::_warn \"<fh> select hits = $hits\\n\";\n      }\n      elsif ($hits == 0) {\n        POE::Kernel::_warn \"<fh> select timed out...\\n\";\n      }\n      POE::Kernel::_warn(\n        \"<fh> ,----- SELECT BITS OUT -----\\n\",\n        \"<fh> | READ    : \", unpack('b*', $rout), \"\\n\",\n        \"<fh> | WRITE   : \", unpack('b*', $wout), \"\\n\",\n        \"<fh> | EXPEDITE: \", unpack('b*', $eout), \"\\n\",\n        \"<fh> `---------------------------\\n\"\n      );\n    }\n\n    # If select has seen filehandle activity, then gather up the\n    # active filehandles and synchronously dispatch events to the\n    # appropriate handlers.\n\n    if ($hits > 0) {\n\n      # This is where they're gathered.  It's a variant on a neat\n      # hack Silmaril came up with.\n\n      my (@rd_selects, @wr_selects, @ex_selects);\n      foreach (keys %loop_filenos) {\n        push(@rd_selects, $_) if vec($rout, $_, 1);\n        push(@wr_selects, $_) if vec($wout, $_, 1);\n        push(@ex_selects, $_) if vec($eout, $_, 1);\n      }\n\n      if (TRACE_FILES) {\n        if (@rd_selects) {\n          POE::Kernel::_warn(\n            \"<fh> found pending rd selects: \",\n            join( ', ', sort { $a <=> $b } @rd_selects ),\n            \"\\n\"\n          );\n        }\n        if (@wr_selects) {\n          POE::Kernel::_warn(\n            \"<sl> found pending wr selects: \",\n            join( ', ', sort { $a <=> $b } @wr_selects ),\n            \"\\n\"\n          );\n        }\n        if (@ex_selects) {\n          POE::Kernel::_warn(\n            \"<sl> found pending ex selects: \",\n            join( ', ', sort { $a <=> $b } @ex_selects ),\n            \"\\n\"\n          );\n        }\n      }\n\n      if (ASSERT_FILES) {\n        unless (@rd_selects or @wr_selects or @ex_selects) {\n          POE::Kernel::_trap(\n            \"<fh> found no selects, with $hits hits from select???\\n\"\n          );\n        }\n      }\n\n      # Enqueue the gathered selects, and flag them as temporarily\n      # paused.  They'll resume after dispatch.\n\n      @rd_selects and $self->_data_handle_enqueue_ready(MODE_RD, @rd_selects);\n      @wr_selects and $self->_data_handle_enqueue_ready(MODE_WR, @wr_selects);\n      @ex_selects and $self->_data_handle_enqueue_ready(MODE_EX, @ex_selects);\n    }\n  }\n  elsif ($timeout) {\n    # No filehandles to select on", 8192) = 8192
09:01:57.039431 stat("modules/POE/Loop/PerlSignals.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.039499 stat("modules/POE/Loop/PerlSignals.pm", {st_mode=S_IFREG|0600, st_size=5021, ...}) = 0
09:01:57.039573 open("modules/POE/Loop/PerlSignals.pm", O_RDONLY) = 5
09:01:57.039647 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.039707 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.039778 brk(0xae7000)           = 0xae7000
09:01:57.039850 read(5, "# Plain Perl signal handling is something shared by several event\n# loops.  The invariant code has moved out here so that each loop may\n# use it without reinventing it.  This will save maintenance and\n# shrink the distribution.  Yay!\n\npackage POE::Loop::PerlSignals;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# Everything plugs into POE::Kernel.\npackage POE::Kernel;\n\nuse strict;\nuse POE::Kernel;\n\n# Flag so we know which signals are watched.  Used to reset those\n# signals during finalization.\nmy %signal_watched;\n\n#------------------------------------------------------------------------------\n# Signal handlers/callbacks.\n\nsub _loop_signal_handler_generic {\n  if( USE_SIGNAL_PIPE ) {\n    POE::Kernel->_data_sig_pipe_send( $_[0] );\n  }\n  else {\n    _loop_signal_handler_generic_bottom( $_[0] );\n  }\n}\n\nsub _loop_signal_handler_generic_bottom {\n  if (TRACE_SIGNALS) {\n    POE::Kernel::_warn \"<sg> Enqueuing generic SIG$_[0] event\";\n  }\n\n  $poe_kernel->_data_ev_enqueue(\n    $poe_kernel, $poe_kernel, EN_SIGNAL, ET_SIGNAL, [ $_[0] ],\n    __FILE__, __LINE__, undef\n  );\n  $SIG{$_[0]} = \\&_loop_signal_handler_generic;\n}\n\n##\n\nsub _loop_signal_handler_pipe {\n  if( USE_SIGNAL_PIPE ) {\n    POE::Kernel->_data_sig_pipe_send( $_[0] );\n  }\n  else {\n    _loop_signal_handler_pipe_bottom( $_[0] );\n  }\n}\n\nsub _loop_signal_handler_pipe_bottom {\n  if (TRACE_SIGNALS) {\n    POE::Kernel::_warn \"<sg> Enqueuing PIPE-like SIG$_[0] event\";\n  }\n\n  $poe_kernel->_data_ev_enqueue(\n    $poe_kernel, $poe_kernel, EN_SIGNAL, ET_SIGNAL, [ $_[0] ],\n    __FILE__, __LINE__, undef\n  );\n  $SIG{$_[0]} = \\&_loop_signal_handler_pipe;\n}\n\n## only used under USE_SIGCHLD\n\nsub _loop_signal_handler_chld {\n  if( USE_SIGNAL_PIPE ) {\n    POE::Kernel->_data_sig_pipe_send( 'CHLD' );\n  }\n  else {\n    _loop_signal_handler_chld_bottom( $_[0] );\n  }\n}\n\nsub _loop_signal_handler_chld_bottom {\n  if (TRACE_SIGNALS) {\n    POE::Kernel::_warn \"<sg> Enqueuing CHLD-like SIG$_[0] event\";\n  }\n\n  $poe_kernel->_data_sig_enqueue_poll_event($_[0]);\n}\n\n#------------------------------------------------------------------------------\n# Signal handler maintenance functions.\n\nsub loop_watch_signal {\n  my ($self, $signal) = @_;\n\n  $signal_watched{$signal} = 1;\n\n  # Child process has stopped.\n  if ($signal eq 'CHLD' or $signal eq 'CLD') {\n    if ( USE_SIGCHLD ) {\n      # Poll once for signals.  Will set the signal handler when done.\n      # It would be more efficient to set $SIG{$signal} here and reap\n      # processes, but that would synchronously set the signal\n      # handler, and subsequent system() calls within the callback\n      # could fail with a -1 return value.  The polling event defers\n      # the setup until the current callback returns.\n      $self->_data_sig_enqueue_poll_event($signal);\n    } else {\n      # We should never twiddle $SIG{CH?LD} under POE, unless we want to\n      # override system() and friends. --hachi\n      # $SIG{$signal} = \"DEFAULT\";\n      $self->_data_sig_begin_polling($signal);\n    }\n    return;\n  }\n\n  # Broken pipe.\n  if ($signal eq 'PIPE') {\n    $SIG{$signal} = \\&_loop_signal_handler_pipe;\n    return;\n  }\n\n  # Everything else.\n  $SIG{$signal} = \\&_loop_signal_handler_generic;\n}\n\nsub loop_ignore_signal {\n  my ($self, $signal) = @_;\n\n  delete $signal_watched{$signal};\n\n  if ($signal eq 'CHLD' or $signal eq 'CLD') {\n    if ( USE_SIGCHLD ) {\n      if ($self->_data_sig_kernel_awaits_pids()) {\n        # We need SIGCHLD to stay around after shutdown, so that\n        # child processes may be reaped and kr_child_procs=0\n        if (TRACE_SIGNALS) {\n          POE::Kernel::_warn \"<sg> Keeping SIG$signal anyway!\";\n        }\n        return;\n      }\n    } else {\n      $self->_data_sig_cease_polling();\n      # We should never twiddle $SIG{CH?LD} under poe, unless we want to\n      # override system() and friends. --hachi\n      # $SIG{$signal} = \"IGNORE\";\n      return;\n    }\n  }\n\n  delete $signal_watched{$signal};\n\n  my $state = 'DEFAULT';\n  if ($signal eq 'PIPE') {\n    $state = \"IGNORE\";\n  }\n\n  if (TRACE_SIGNALS) {\n    POE::Kernel::_warn \"<sg> $state SIG$signal\";\n  }\n  $SIG{$signal} = $state;\n}\n\nsub loop_ignore_all_signals {\n  my $self = shift;\n  foreach my $signal (keys %signal_watched) {\n    $self->loop_ignore_signal($signal);\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Loop::PerlSignals - common signal handling routines for POE::Loop bridges\n\n=head1 SYNOPSIS\n\nSee L<POE::Loop>.\n\n=head1 DESCRIPTION\n\nPOE::Loop::PerlSignals implements common code to handle signals for\nmany different event loops.  Most loops don't handle signals natively,\nso this code has been abstracted into a reusable mix-in module.\n\nPOE::Loop::PerlSignals follows POE::Loop's public interface for signal\nhandling.  Therefore, please see L<POE::Loop> for more details.\n\n=head1 SEE ALSO\n\nL<POE>, L<POE::Loop>\n\n=head1 AUTHORS & LICENSING\n\nPlease see L<POE> for more information about authors, contributors,\nand POE's licensing.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 5021
09:01:57.040664 lseek(5, 4317, SEEK_SET) = 4317
09:01:57.040725 lseek(5, 0, SEEK_CUR)   = 4317
09:01:57.040781 close(5)                = 0
09:01:57.041634 read(4, ".  Four-argument select() fails on\n    # MSWin32 with all undef bitmasks.  Use sleep() there instead.\n\n    # Not unconditionally the Time::HiRes microsleep because\n    # Time::HiRes may not be installed.  This is only an issue until\n    # we can require versions of Perl that include Time::HiRes.\n    if ($^O eq 'MSWin32') {\n      sleep($timeout);\n    }\n    else {\n      CORE::select(undef, undef, undef, $timeout);\n    }\n  }\n\n  # Dispatch whatever events are due.\n  $self->_data_ev_dispatch_due();\n}\n\nsub loop_run {\n  my $self = shift;\n\n  # Run for as long as there are sessions to service.\n  while ($self->_data_ses_count()) {\n    $self->loop_do_timeslice();\n  }\n}\n\nsub loop_halt {\n  # does nothing\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Loop::Select - a bridge that allows POE to be driven by select(2)\n\n=head1 SYNOPSIS\n\nSee L<POE::Loop>.\n\n=head1 DESCRIPTION\n\nPOE::Loop::Select implements the interface documented in L<POE::Loop>.\nTherefore it has no documentation of its own.  Please see L<POE::Loop>\nfor more details.\n\n=head1 SEE ALSO\n\nL<POE>, L<POE::Loop>, L<select>, L<POE::Loop::PerlSignals>.\n\n=head1 AUTHORS & LICENSING\n\nPlease see L<POE> for more information about authors, contributors,\nand POE's licensing.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 1272
09:01:57.041872 lseek(4, 8908, SEEK_SET) = 8908
09:01:57.041931 lseek(4, 0, SEEK_CUR)   = 8908
09:01:57.041986 close(4)                = 0
09:01:57.042127 stat("modules/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042182 stat("modules/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042233 stat("modules/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042283 stat("modules/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042350 stat("/etc/perl/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042412 stat("/etc/perl/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042475 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042538 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042601 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042679 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042743 stat("/usr/lib/perl5/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042805 stat("/usr/lib/perl5/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042866 stat("/usr/share/perl5/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.042929 stat("/usr/share/perl5/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.042991 stat("/usr/lib/perl/5.14/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.043055 stat("/usr/lib/perl/5.14/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.043118 stat("/usr/share/perl/5.14/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.043182 stat("/usr/share/perl/5.14/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.043245 stat("/usr/local/lib/site_perl/POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.043308 stat("/usr/local/lib/site_perl/POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.043370 stat("./POE/XS/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.043431 stat("./POE/XS/Resource/Aliases.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.043540 stat("modules/POE/Resource/Aliases.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.043606 stat("modules/POE/Resource/Aliases.pm", {st_mode=S_IFREG|0600, st_size=4452, ...}) = 0
09:01:57.043678 open("modules/POE/Resource/Aliases.pm", O_RDONLY) = 4
09:01:57.043742 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.043799 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.043885 read(4, "# Manage the POE::Kernel data structures necessary to keep track of\n# session aliases.\n\npackage POE::Resource::Aliases;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\n### The table of session aliases, and the sessions they refer to.\n\nmy %kr_aliases;\n#  ( $alias => $session_ref,\n#    ...,\n#  );\n\nmy %kr_ses_to_alias;\n#  ( $session_id =>\n#    { $alias => $session_ref,\n#      ...,\n#    },\n#    ...,\n#  );\n\nsub _data_alias_initialize {\n  $poe_kernel->[KR_ALIASES] = \\%kr_aliases;\n}\n\nsub _data_alias_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n  return unless exists $kr_ses_to_alias{$old_id};\n  $kr_ses_to_alias{$new_id} = delete $kr_ses_to_alias{$old_id};\n}\n\n### End-run leak checking.  Returns true if finalization was ok, or\n### false if it failed.\n\nsub _data_alias_finalize {\n  my $finalized_ok = 1;\n  while (my ($alias, $ses) = each(%kr_aliases)) {\n    _warn \"!!! Leaked alias: $alias = $ses\\n\";\n    $finalized_ok = 0;\n  }\n  while (my ($ses_id, $alias_rec) = each(%kr_ses_to_alias)) {\n    my @aliases = keys(%$alias_rec);\n    _warn \"!!! Leaked alias cross-reference: $ses_id (@aliases)\\n\";\n    $finalized_ok = 0;\n  }\n  return $finalized_ok;\n}\n\n# Add an alias to a session.\n#\n# TODO This has a potential problem: setting the same alias twice on a\n# session will increase the session's reference count twice.  Removing\n# the alias will only decrement it once.  That potentially causes\n# reference counts that never go away.  The public interface for this\n# function, alias_set(), does not allow this to occur.  We should add\n# a test to make sure it never does.\n#\n# TODO It is possible to add aliases to sessions that do not exist.\n# The public alias_set() function prevents this from happening.\n\nsub _data_alias_add {\n  my ($self, $session, $alias) = @_;\n#  _warn( \"Session \", $session->ID, \" is alias $alias\\n\" );\n  $self->_data_ses_refcount_inc($session->ID);\n  $kr_aliases{$alias} = $session;\n  $kr_ses_to_alias{$session->ID}->{$alias} = $session;\n}\n\n# Remove an alias from a session.\n#\n# TODO Happily allows the removal of aliases from sessions that don't\n# exist.  This will cause problems with reference counting.\n\nsub _data_alias_remove {\n  my ($self, $session, $alias) = @_;\n#  _warn( \"Session \", $session->ID, \" was alias $alias\\n\" );\n  delete $kr_aliases{$alias};\n  delete $kr_ses_to_alias{$session->ID}->{$alias};\n  $self->_data_ses_refcount_dec($session->ID);\n}\n\n### Clear all the aliases from a session.\n\nsub _data_alias_clear_session {\n  my ($self, $sid) = @_;\n  return unless exists $kr_ses_to_alias{$sid}; # avoid autoviv\n  while (my ($alias, $ses_ref) = each %{$kr_ses_to_alias{$sid}}) {\n    $self->_data_alias_remove($ses_ref, $alias);\n  }\n  delete $kr_ses_to_alias{$sid};\n}\n\n### Resolve an alias.  Just an alias.\n\nsub _data_alias_resolve {\n  my ($self, $alias) = @_;\n  return undef unless exists $kr_aliases{$alias};\n  return $kr_aliases{$alias};\n}\n\n### Return a list of aliases for a session.\n\nsub _data_alias_list {\n  my ($self, $sid) = @_;\n  return () unless exists $kr_ses_to_alias{$sid};\n  return sort keys %{$kr_ses_to_alias{$sid}};\n}\n\n### Return the number of aliases for a session.\n\nsub _data_alias_count_ses {\n  my ($self, $sid) = @_;\n  return 0 unless exists $kr_ses_to_alias{$sid};\n  return scalar keys %{$kr_ses_to_alias{$sid}};\n}\n\n### Return a session's ID in a form suitable for logging.\n\nsub _data_alias_loggable {\n  my ($self, $sid) = @_;\n  \"session $sid\" . (\n    (exists $kr_ses_to_alias{$sid})\n    ? ( \" (\" . join(\", \", $self->_data_alias_list($sid)) . \")\" )\n    : \"\"\n  );\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Aliases - internal session alias manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::Aliases is a mix-in class for POE::Kernel.  It provides\nthe features to manage session aliases.  It is used internally by\nPOE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Session Identifiers (IDs and Aliases)> for the\npublic alias API.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 4452
09:01:57.044548 lseek(4, 3667, SEEK_SET) = 3667
09:01:57.044608 lseek(4, 0, SEEK_CUR)   = 3667
09:01:57.044664 close(4)                = 0
09:01:57.044766 stat("modules/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.044831 stat("modules/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.044893 stat("modules/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.044953 stat("modules/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045015 stat("/etc/perl/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045076 stat("/etc/perl/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045142 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045207 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045270 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045332 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045401 stat("/usr/lib/perl5/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045464 stat("/usr/lib/perl5/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045526 stat("/usr/share/perl5/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045588 stat("/usr/share/perl5/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045654 stat("/usr/lib/perl/5.14/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045718 stat("/usr/lib/perl/5.14/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045781 stat("/usr/share/perl/5.14/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045843 stat("/usr/share/perl/5.14/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.045905 stat("/usr/local/lib/site_perl/POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.045966 stat("/usr/local/lib/site_perl/POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.046039 stat("./POE/XS/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.046111 stat("./POE/XS/Resource/Events.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.046198 stat("modules/POE/Resource/Events.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.046250 stat("modules/POE/Resource/Events.pm", {st_mode=S_IFREG|0600, st_size=11720, ...}) = 0
09:01:57.046324 open("modules/POE/Resource/Events.pm", O_RDONLY) = 4
09:01:57.046389 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.046446 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.046513 read(4, "# Data and accessors to manage POE's events.\n\npackage POE::Resource::Events;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\n# A local copy of the queue so we can manipulate it directly.\nmy $kr_queue;\n\nmy %event_count;\n#  ( $session_id => $count,\n#    ...,\n#  );\n\nmy %post_count;\n#  ( $session_id => $count,\n#    ...,\n#  );\n\n### Begin-run initialization.\n\nsub _data_ev_initialize {\n  my ($self, $queue) = @_;\n  $kr_queue = $queue;\n}\n\n### End-run leak checking.\n\nsub _data_ev_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n\n  $event_count{$new_id} = delete $event_count{$old_id}\n    if exists $event_count{$old_id};\n  $post_count{$new_id} = delete $post_count{$old_id}\n    if exists $post_count{$old_id};\n}\n\nsub _data_ev_finalize {\n  my $finalized_ok = 1;\n  while (my ($ses_id, $cnt) = each(%event_count)) {\n    $finalized_ok = 0;\n    _warn(\"!!! Leaked event-to count: $ses_id = $cnt\\n\");\n  }\n\n  while (my ($ses_id, $cnt) = each(%post_count)) {\n    $finalized_ok = 0;\n    _warn(\"!!! Leaked event-from count: $ses_id = $cnt\\n\");\n  }\n  return $finalized_ok;\n}\n\n### Enqueue an event.\n\nsub FIFO_TIME_EPSILON () { 0.000001 }\nmy $last_fifo_time = monotime();\n\nsub _data_ev_enqueue {\n  my (\n    $self,\n    $session, $source_session, $event, $type, $etc,\n    $file, $line, $fromstate, $time, $delta, $priority\n  ) = @_;\n\n  my $sid = $session->ID;\n\n  if (ASSERT_DATA) {\n    unless ($self->_data_ses_exists($sid)) {\n      _trap(\n        \"<ev> can't enqueue event ``$event'' for nonexistent\",\n        $self->_data_alias_loggable($sid)\n      );\n    }\n  }\n\n  # This is awkward, but faster than using the fields individually.\n  my $event_to_enqueue = [ @_[(1+EV_SESSION) .. (1+EV_FROMSTATE)] ];\n  if( defined $time ) {\n    $event_to_enqueue->[EV_WALLTIME] = $time;\n    $event_to_enqueue->[EV_DELTA]    = $delta;\n    $priority ||= wall2mono( $time + ($delta||0) );\n  }\n  else {\n    $priority ||= monotime();\n  }\n\n  my $new_id;\n  my $old_head_priority = $kr_queue->get_next_priority();\n\n  unless ($type & ET_MASK_DELAYED) {\n    $priority = $last_fifo_time + FIFO_TIME_EPSILON if $priority <= $last_fifo_time;\n    $last_fifo_time = $priority;\n  }\n\n  $new_id = $kr_queue->enqueue($priority, $event_to_enqueue);\n  $event_to_enqueue->[EV_SEQ] = $new_id;\n\n  #_carp( Carp::longmess( \"<ev> priority is much to far in the future\" ) ) if $priority > 1354569908;\n  if (TRACE_EVENTS ) {\n    _warn(\n      \"<ev> enqueued event $new_id ``$event'' from \",\n      $self->_data_alias_loggable($source_session->ID), \" to \",\n      $self->_data_alias_loggable($sid),\n      \" at $time, priority=$priority\"\n    );\n  }\n\n  unless (defined $old_head_priority) {\n    $self->loop_resume_time_watcher($priority);\n  }\n  elsif ($priority < $old_head_priority) {\n    $self->loop_reset_time_watcher($priority);\n  }\n\n  # This is the counterpart to _data_ev_refcount_dec().  It's only\n  # used in one place, so it's not in its own function.\n\n  $self->_data_ses_refcount_inc($sid) unless $event_count{$sid}++;\n\n  return $new_id if $sid eq $source_session->ID();\n\n  $self->_data_ses_refcount_inc($source_session->ID) unless (\n    $post_count{$source_session->ID}++\n  );\n\n  return $new_id;\n}\n\nsub _data_ev_set\n{\n    my( $self, $alarm_id, $my_alarm, $time, $pri, $delta ) = @_;\n\n    my $event = (\n      grep { $_->[1] == $alarm_id }\n      $kr_queue->peek_items( $my_alarm )\n    )[0];\n\n    return unless $event;\n\n    my $payload = $event->[ITEM_PAYLOAD];\n\n    # XXX - However, if there has been a clock skew, the priority will\n    # have changed and we should recalculate priority from time+delta\n\n    $delta = $payload->[EV_DELTA] || 0 unless defined $delta;\n    $kr_queue->set_priority( $alarm_id, $my_alarm, $pri+$delta );\n    $payload->[EV_WALLTIME] = $time;\n    $payload->[EV_DELTA]    = $delta;\n\n    return( ($payload->[EV_WALLTIME] || 0) + ($payload->[EV_DELTA] || 0) );\n}\n\nsub _data_ev_adjust\n{\n    my( $self, $alarm_id, $my_alarm, $time, $delta ) = @_;\n\n    # XXX - However, if there has been a clock skew, the priority will\n    # have changed and we should recalculate priority from time+delta\n    if( $time ) {\n        # PG - We are never invoked with $time anyway.  \n        $kr_queue->set_priority( $alarm_id, $my_alarm, $time+$delta );\n    }\n    else {\n        $kr_queue->adjust_priority( $alarm_id, $my_alarm, $delta );\n    }\n\n    my $event = (\n      grep { $_->[1] == $alarm_id }\n      $kr_queue->peek_items( $my_alarm )\n    )[0];\n\n    return unless $event;\n\n    my $payload = $event->[ITEM_PAYLOAD];\n\n    $payload->[EV_WALLTIME] = $time if $time;\n    $payload->[EV_DELTA] += $delta  if $delta;\n\n    return( ($payload->[EV_WALLTIME] || 0) + ($payload->[EV_DELTA] || 0) );\n}\n\n### Remove events sent to or from a specific session.\n\nsub _data_ev_clear_session {\n  my ($self, $sid) = @_;\n\n  # Events sent to the session.\n  PENDING: {\n    my $pending_count = $event_count{$sid};\n    last PENDING unless $pending_count;\n\n    foreach (\n      $kr_queue->remove_items(\n        sub { $_[0][EV_SESSION]->ID() eq $sid },\n        $pending_count\n      )\n    ) {\n      $self->_data_ev_refcount_dec(\n        @{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]\n      );\n      $pending_count--;\n    }\n\n    # TODO - fork() can make this go negative on some systems.\n    last PENDING unless $pending_count;\n\n    croak \"lingering pending count: $pending_count\" if $pending_count;\n  }\n\n  # Events sent by the session.\n  SENT: {\n    my $sent_count = $post_count{$sid};\n    last SENT unless $sent_count;\n\n    foreach (\n      $kr_queue->remove_items(\n        sub { $_[0][EV_SOURCE]->ID() eq $sid },\n        $sent_count\n      )\n    ) {\n      $self->_data_ev_refcount_dec(\n        @{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]\n      );\n      $sent_count--;\n    }\n\n    last SENT unless $sent_count;\n\n    croak \"lingering sent count: $sent_count\" if $sent_count;\n  }\n\n  croak \"lingering event count\" if delete $event_count{$sid};\n  croak \"lingering post count\" if delete $post_count{$sid};\n}\n\n# TODO Alarm maintenance functions may move out to a separate\n# POE::Resource module in the future.  Why?  Because alarms may\n# eventually be managed by something other than the event queue.\n# Especially if we incorporate a proper Session scheduler.  Be sure to\n# move the tests to a corresponding t/res/*.t file.\n\n### Remove a specific alarm by its name.  This is in the events\n### section because alarms are currently implemented as events with\n### future due times.\n\nsub _data_ev_clear_alarm_by_name {\n  my ($self, $sid, $alarm_name) = @_;\n\n  my $my_alarm = sub {\n    return 0 unless $_[0]->[EV_TYPE] & ET_ALARM;\n    return 0 unless $_[0]->[EV_SESSION]->ID() eq $sid;\n    return 0 unless $_[0]->[EV_NAME] eq $alarm_name;\n    return 1;\n  };\n\n  foreach ($kr_queue->remove_items($my_alarm)) {\n    $self->_data_ev_refcount_dec(@{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]);\n  }\n}\n\n### Remove a specific alarm by its ID.  This is in the events section\n### because alarms are currently implemented as events with future due\n### times.  TODO It's possible to remove non-alarms; is that wrong?\n\nsub _data_ev_clear_alarm_by_id {\n  my ($self, $sid, $alarm_id) = @_;\n\n  my $my_alarm = sub {\n    $_[0]->[EV_SESSION]->ID() eq $sid;\n  };\n\n  my ($pri, $id, $event) = $kr_queue->remove_item($alarm_id, $my_alarm);\n  return unless defined $pri;\n\n  if (TRACE_EVENTS) {\n    _warn(\n      \"<ev> removed event $id ``\", $event->[EV_NAME], \"'' to \",\n      $self->_data_alias_loggable($sid), \" at $pri\"\n    );\n  }\n\n  $self->_data_ev_refcount_dec( @$event[EV_SOURCE, EV_SESSION] );\n  my $time = $event->[EV_WALLTIME] + ($event->[EV_DELTA]||0);\n  return ($time, $event);\n}\n\n### Remove all the alarms for a session.  Whoot!\n\nsub _data_ev_clear_alarm_by_session {\n  my ($self, $sid) = @_;\n\n  my $my_alarm = sub {\n    return 0 unless $_[0]->[EV_TYPE] & ET_ALARM;\n    return 0 unless $_[0]->[EV_SESSION]->ID() eq $sid;\n    return 1;\n  };\n\n  my @removed;\n  foreach ($kr_queue->remove_items($my_alarm)) {\n    my ($pri, $event) = @$_[ITEM_PRIORITY, ITEM_PAYLOAD];\n    $self->_data_ev_refcount_dec( @$event[EV_SOURCE, EV_SESSION] );\n    my $time = ($event->[EV_WALLTIME]||0", 8192) = 8192
09:01:57.046991 brk(0xb09000)           = 0xb09000
09:01:57.048003 read(4, ") + ($event->[EV_DELTA]||0);\n    push @removed, [ $event->[EV_NAME], $time, @{$event->[EV_ARGS]} ];\n  }\n\n  return @removed;\n}\n\n### Decrement a post refcount\n\nsub _data_ev_refcount_dec {\n  my ($self, $source_session, $dest_session) = @_;\n\n  my ($source_id, $dest_id) = ($source_session->ID, $dest_session->ID);\n\n  if (ASSERT_DATA) {\n    _trap $dest_session unless exists $event_count{$dest_id};\n  }\n\n  $self->_data_ses_refcount_dec($dest_id) unless --$event_count{$dest_id};\n\n  return if $dest_id eq $source_id;\n\n  if (ASSERT_DATA) {\n    _trap $source_session unless exists $post_count{$source_id};\n  }\n\n  $self->_data_ses_refcount_dec($source_id) unless --$post_count{$source_id};\n}\n\n### Fetch the number of pending events sent to a session.\n\nsub _data_ev_get_count_to {\n  my ($self, $sid) = @_;\n  return $event_count{$sid} || 0;\n}\n\n### Fetch the number of pending events sent from a session.\n\nsub _data_ev_get_count_from {\n  my ($self, $sid) = @_;\n  return $post_count{$sid} || 0;\n}\n\n### Dispatch events that are due for \"now\" or earlier.\n\nsub _data_ev_dispatch_due {\n  my $self = shift;\n\n  if (TRACE_EVENTS) {\n    foreach ($kr_queue->peek_items(sub { 1 })) {\n      my @event = map { defined() ? $_ : \"(undef)\" } @{$_->[ITEM_PAYLOAD]};\n      _warn(\n        \"<ev> time($_->[ITEM_PRIORITY]) id($_->[ITEM_ID]) \",\n        \"event(@event)\\n\"\n      );\n    }\n  }\n\n  my $now = monotime();\n  my $next_time;\n  while (\n    defined($next_time = $kr_queue->get_next_priority()) and\n    $next_time <= $now\n  ) {\n    my ($priority, $id, $event) = $kr_queue->dequeue_next();\n\n    if (TRACE_EVENTS) {\n      _warn(\"<ev> dispatching event $id ($event->[EV_NAME])\");\n    }\n\n    # TODO - Why can't we reverse these two lines?\n    # TODO - Reversing them could avoid entering and removing GC marks.\n    $self->_data_ev_refcount_dec($event->[EV_SOURCE], $event->[EV_SESSION]);\n\n    if ($event->[EV_TYPE] & (ET_SIGNAL | ET_SIGDIE)) {\n      $self->_dispatch_signal_event(@{$event}[EV_SESSION..EV_FROMSTATE], $priority, $id);\n    }\n    else {\n      $self->_dispatch_event(@{$event}[EV_SESSION..EV_FROMSTATE], $priority, $id);\n    }\n\n    # Stop the system if an unhandled exception occurred.\n    # This wipes out all sessions and associated resources.\n    next unless $POE::Kernel::kr_exception;\n    POE::Kernel->stop();\n  }\n\n  # Sweep for dead sessions.  The sweep may alter the next queue time.\n\n  $self->_data_ses_gc_sweep();\n  $next_time = $kr_queue->get_next_priority();\n\n  # Tell the event loop to wait for the next event, if there is one.\n  # Otherwise we're going to wait indefinitely for some other event.\n\n  if (defined $next_time) {\n    $self->loop_reset_time_watcher($next_time);\n  }\n  else {\n    $self->loop_pause_time_watcher();\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Events - internal event manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::Events is a mix-in class for POE::Kernel.  It hides the\ncomplexity of managing POE's events from even POE itself.  It is used\ninternally by POE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Asynchronous Messages (FIFO Events)> for one public\nevents API.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 3528
09:01:57.048399 brk(0xb2a000)           = 0xb2a000
09:01:57.048659 lseek(4, 10927, SEEK_SET) = 10927
09:01:57.048717 lseek(4, 0, SEEK_CUR)   = 10927
09:01:57.048773 close(4)                = 0
09:01:57.048881 stat("modules/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.048945 stat("modules/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049007 stat("modules/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049068 stat("modules/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049131 stat("/etc/perl/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049195 stat("/etc/perl/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049258 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049321 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049384 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049447 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049510 stat("/usr/lib/perl5/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049571 stat("/usr/lib/perl5/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049633 stat("/usr/share/perl5/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049699 stat("/usr/share/perl5/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049761 stat("/usr/lib/perl/5.14/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049823 stat("/usr/lib/perl/5.14/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.049893 stat("/usr/share/perl/5.14/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.049956 stat("/usr/share/perl/5.14/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.050018 stat("/usr/local/lib/site_perl/POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.050102 stat("/usr/local/lib/site_perl/POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.050154 stat("./POE/XS/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.050202 stat("./POE/XS/Resource/Extrefs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.050289 stat("modules/POE/Resource/Extrefs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.050362 stat("modules/POE/Resource/Extrefs.pm", {st_mode=S_IFREG|0600, st_size=5805, ...}) = 0
09:01:57.050433 open("modules/POE/Resource/Extrefs.pm", O_RDONLY) = 4
09:01:57.050497 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.050554 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.050624 read(4, "# The data necessary to manage tagged extra/external reference counts\n# on sessions, and the accessors to get at them sanely from other\n# files.\n\npackage POE::Resource::Extrefs;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\n### The count of all extra references used in the system.\n\nmy %kr_extra_refs;\n#  ( $session_id =>\n#    { $tag => $count,\n#       ...,\n#     },\n#     ...,\n#   );\n\nsub _data_extref_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n  return unless exists $kr_extra_refs{$old_id};\n  $kr_extra_refs{$new_id} = delete $kr_extra_refs{$old_id};\n}\n\n### End-run leak checking.\n\nsub _data_extref_finalize {\n  my $finalized_ok = 1;\n  foreach my $session_id (keys %kr_extra_refs) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked extref: $session_id\\n\";\n    foreach my $tag (keys %{$kr_extra_refs{$session_id}}) {\n      _warn \"!!!\\t`$tag' = $kr_extra_refs{$session_id}->{$tag}\\n\";\n    }\n  }\n  return $finalized_ok;\n}\n\n# Increment a session's tagged reference count.  If this is the first\n# time the tag is used in the session, then increment the session's\n# reference count as well.  Returns the tag's new reference count.\n#\n# TODO Allows incrementing reference counts on sessions that don't\n# exist, but the public interface catches that.\n#\n# TODO Need to track extref ownership for signal-based session\n# termination.  One problem seen is that signals terminate sessions\n# out of order.  Owners think extra refcounts exist for sessions that\n# are no longer around.  Ownership trees give us a few benefits: We\n# can make sure sessions destruct in a cleaner order.  We can detect\n# refcount loops and possibly prevent that.\n\nsub _data_extref_inc {\n  my ($self, $sid, $tag) = @_;\n  my $refcount = ++$kr_extra_refs{$sid}->{$tag};\n\n  # TODO We could probably get away with only incrementing the\n  # session's master refcount once, as long as any extra refcount is\n  # positive.  Then the session reference count would be a flag\n  # instead of a counter.\n  $self->_data_ses_refcount_inc($sid) if $refcount == 1;\n\n  if (TRACE_REFCNT) {\n    _warn(\n      \"<rc> incremented extref ``$tag'' (now $refcount) for \",\n      $self->_data_alias_loggable($sid)\n    );\n  }\n\n  return $refcount;\n}\n\n# Decrement a session's tagged reference count, removing it outright\n# if the count reaches zero.  Return the new reference count or undef\n# if the tag doesn't exist.\n#\n# TODO Allows negative reference counts, and the resulting hilarity.\n# Hopefully the public interface won't allow it.\n\nsub _data_extref_dec {\n  my ($self, $sid, $tag) = @_;\n\n  if (ASSERT_DATA) {\n    # Prevents autoviv.\n    _trap(\"<dt> decrementing extref for session without any\")\n      unless exists $kr_extra_refs{$sid};\n\n    unless (exists $kr_extra_refs{$sid}->{$tag}) {\n      _trap(\n        \"<dt> decrementing extref for nonexistent tag ``$tag'' in \",\n        $self->_data_alias_loggable($sid)\n      );\n    }\n  }\n\n  my $refcount = --$kr_extra_refs{$sid}->{$tag};\n\n  if (TRACE_REFCNT) {\n    _warn(\n      \"<rc> decremented extref ``$tag'' (now $refcount) for \",\n      $self->_data_alias_loggable($sid)\n    );\n  }\n\n  $self->_data_extref_remove($sid, $tag) unless $refcount;\n  return $refcount;\n}\n\n### Remove an extra reference from a session, regardless of its count.\n\nsub _data_extref_remove {\n  my ($self, $sid, $tag) = @_;\n\n  if (ASSERT_DATA) {\n    # Prevents autoviv.\n    _trap(\"<dt> removing extref from session without any\")\n      unless exists $kr_extra_refs{$sid};\n    unless (exists $kr_extra_refs{$sid}->{$tag}) {\n      _trap(\n        \"<dt> removing extref for nonexistent tag ``$tag'' in \",\n        $self->_data_alias_loggable($sid)\n      );\n    }\n  }\n\n  delete $kr_extra_refs{$sid}->{$tag};\n  delete $kr_extra_refs{$sid} unless scalar keys %{$kr_extra_refs{$sid}};\n  $self->_data_ses_refcount_dec($sid);\n}\n\n### Clear all the extra references from a session.\n\nsub _data_extref_clear_session {\n  my ($self, $sid) = @_;\n\n  # TODO - Should there be a _trap here if the session doesn't exist?\n\n  return unless exists $kr_extra_refs{$sid}; # avoid autoviv\n  foreach (keys %{$kr_extra_refs{$sid}}) {\n    $self->_data_extref_remove($sid, $_);\n  }\n\n  if (ASSERT_DATA) {\n    if (exists $kr_extra_refs{$sid}) {\n      _trap(\n        \"<dt> extref clear did not remove session \",\n        $self->_data_alias_loggable($sid)\n      );\n    }\n  }\n}\n\n# Fetch the number of sessions with extra references held in the\n# entire system.\n\nsub _data_extref_count {\n  return scalar keys %kr_extra_refs;\n}\n\n# Fetch whether a session has extra references.\n\nsub _data_extref_count_ses {\n  my ($self, $sid) = @_;\n  return 0 unless exists $kr_extra_refs{$sid};\n  return scalar keys %{$kr_extra_refs{$sid}};\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Extrefs - internal reference counts manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::Extrefs is a mix-in class for POE::Kernel.  It provides\nthe features to manage session reference counts, specifically the ones\nthat applications may use.  POE::Resource::Extrefs is used internally\nby POE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Public Reference Counters> for the public extref\nAPI.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nReference counters have no ownership information, so one entity's\nreference counts may conflict with another's.  This is usually not a\nproblem if all entities behave.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 5805
09:01:57.051485 lseek(4, 4795, SEEK_SET) = 4795
09:01:57.051546 lseek(4, 0, SEEK_CUR)   = 4795
09:01:57.051602 close(4)                = 0
09:01:57.051706 stat("modules/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.051770 stat("modules/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.051833 stat("modules/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.051899 stat("modules/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.051949 stat("/etc/perl/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052000 stat("/etc/perl/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052057 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052127 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052190 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052253 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052316 stat("/usr/lib/perl5/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052376 stat("/usr/lib/perl5/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052438 stat("/usr/share/perl5/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052500 stat("/usr/share/perl5/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052561 stat("/usr/lib/perl/5.14/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052625 stat("/usr/lib/perl/5.14/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052688 stat("/usr/share/perl/5.14/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052750 stat("/usr/share/perl/5.14/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052813 stat("/usr/local/lib/site_perl/POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052875 stat("/usr/local/lib/site_perl/POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.052937 stat("./POE/XS/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.052997 stat("./POE/XS/Resource/FileHandles.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.053102 stat("modules/POE/Resource/FileHandles.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.053170 stat("modules/POE/Resource/FileHandles.pm", {st_mode=S_IFREG|0600, st_size=23929, ...}) = 0
09:01:57.053245 open("modules/POE/Resource/FileHandles.pm", O_RDONLY) = 4
09:01:57.053310 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.053367 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.053440 read(4, "# Manage file handles, associated descriptors, and read/write modes\n# thereon.\n\npackage POE::Resource::FileHandles;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\nuse Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);\nuse IO::Handle ();\nuse FileHandle ();\n\n### Some portability things.\n\n# Provide dummy constants so things at least compile.  These constants\n# aren't used if we're RUNNING_IN_HELL, but Perl needs to see them.\n\nBEGIN {\n  # older perls than 5.10 needs a kick in the arse to AUTOLOAD the constant...\n  eval \"F_GETFL\" if $] < 5.010;\n\n  if ( ! defined &Fcntl::F_GETFL ) {\n    if ( ! defined prototype \"F_GETFL\" ) {\n      *F_GETFL = sub { 0 };\n      *F_SETFL = sub { 0 };\n    } else {\n      *F_GETFL = sub () { 0 };\n      *F_SETFL = sub () { 0 };\n    }\n  }\n}\n\n### A local reference to POE::Kernel's queue.\n\nmy $kr_queue;\n\n### Fileno structure.  This tracks the sessions that are watching a\n### file, by its file number.  It used to track by file handle, but\n### several handles can point to the same underlying fileno.  This is\n### more unique.\n\nmy %kr_filenos;\nBEGIN { $poe_kernel->[KR_FILENOS] = \\%kr_filenos; }\n\nsub FNO_MODE_RD      () { MODE_RD } # [ [ (fileno read mode structure)\n# --- BEGIN SUB STRUCT 1 ---        #\nsub FMO_REFCOUNT     () { 0      }  #     $fileno_total_use_count,\nsub FMO_ST_ACTUAL    () { 1      }  #     $requested_file_state (see HS_PAUSED)\nsub FMO_SESSIONS     () { 2      }  #     { $session_id =>\n                                    #       { $file_descriptor =>\n# --- BEGIN SUB STRUCT 2 ---        #\nsub HSS_HANDLE       () { 0      }  #         [ $blessed_handle,\nsub HSS_SESSION      () { 1      }  #           $blessed_session,\nsub HSS_STATE        () { 2      }  #           $event_name,\nsub HSS_ARGS         () { 3      }  #           \\@callback_arguments\n                                    #         ],\n                                    #       },\n# --- CEASE SUB STRUCT 2 ---        #     },\n# --- CEASE SUB STRUCT 1 ---        #   ],\n                                    #\nsub FNO_MODE_WR      () { MODE_WR } #   [ (write mode structure is the same)\n                                    #   ],\n                                    #\nsub FNO_MODE_EX      () { MODE_EX } #   [ (expedite mode struct is the same)\n                                    #   ],\n                                    #\nsub FNO_TOT_REFCOUNT () { 3      }  #   $total_number_of_file_watchers,\n                                    # ]\n\n### These are the values for FMO_ST_ACTUAL.\n\nsub HS_STOPPED   () { 0x00 }   # The file has stopped generating events.\nsub HS_PAUSED    () { 0x01 }   # The file temporarily stopped making events.\nsub HS_RUNNING   () { 0x02 }   # The file is running and can generate events.\n\n### Handle to session.\n\nmy %kr_ses_to_handle;\n                            #    { $session_id =>\n                            #      $fileno =>\n# --- BEGIN SUB STRUCT ---  #        [\nsub SH_HANDLE     () {  0 } #          $blessed_file_handle,\nsub SH_REFCOUNT   () {  1 } #          $total_reference_count,\nsub SH_MODECOUNT  () {  2 } #          [ $read_reference_count,     (MODE_RD)\n                            #            $write_reference_count,    (MODE_WR)\n                            #            $expedite_reference_count, (MODE_EX)\n# --- CEASE SUB STRUCT ---  #          ],\n                            #        ],\n                            #        ...\n                            #      },\n                            #    },\n\nsub _data_handle_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n\n  foreach my $fd_rec (values %kr_filenos) {\n    my $rd_rec = $fd_rec->[FNO_MODE_RD][FMO_SESSIONS];\n    $rd_rec->{$new_id} = delete $rd_rec->{$old_id} if exists $rd_rec->{$old_id};\n\n    my $wr_rec = $fd_rec->[FNO_MODE_WR][FMO_SESSIONS];\n    $wr_rec->{$new_id} = delete $wr_rec->{$old_id} if exists $wr_rec->{$old_id};\n\n    my $ex_rec = $fd_rec->[FNO_MODE_EX][FMO_SESSIONS];\n    $ex_rec->{$new_id} = delete $ex_rec->{$old_id} if exists $ex_rec->{$old_id};\n  }\n\n  $kr_ses_to_handle{$new_id} = delete $kr_ses_to_handle{$old_id}\n    if exists $kr_ses_to_handle{$old_id};\n}\n\n### Begin-run initialization.\n\nsub _data_handle_initialize {\n  my ($self, $queue) = @_;\n  $kr_queue = $queue;\n}\n\n### End-run leak checking.\n\nsub _data_handle_finalize {\n  my $finalized_ok = 1;\n\n  while (my ($fd, $fd_rec) = each(%kr_filenos)) {\n    my ($rd, $wr, $ex, $tot) = @$fd_rec;\n    $finalized_ok = 0;\n\n    _warn \"!!! Leaked fileno: $fd (total refcnt=$tot)\\n\";\n\n    _warn(\n      \"!!!\\tRead:\\n\",\n      \"!!!\\t\\trefcnt  = $rd->[FMO_REFCOUNT]\\n\",\n    );\n    while (my ($sid, $ses_rec) = each(%{$rd->[FMO_SESSIONS]})) {\n      _warn \"!!!\\t\\tsession $sid\\n\";\n      while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {\n        _warn(\n          \"!!!\\t\\t\\thandle  = $hnd_rec->[HSS_HANDLE]\\n\",\n          \"!!!\\t\\t\\tsession = $hnd_rec->[HSS_SESSION]\\n\",\n          \"!!!\\t\\t\\tevent   = $hnd_rec->[HSS_STATE]\\n\",\n          \"!!!\\t\\t\\targs    = (@{$hnd_rec->[HSS_ARGS]})\\n\",\n        );\n      }\n    }\n\n    _warn(\n      \"!!!\\tWrite:\\n\",\n      \"!!!\\t\\trefcnt  = $wr->[FMO_REFCOUNT]\\n\",\n    );\n    while (my ($sid, $ses_rec) = each(%{$wr->[FMO_SESSIONS]})) {\n      _warn \"!!!\\t\\tsession = $sid\\n\";\n      while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {\n        _warn(\n          \"!!!\\t\\t\\thandle  = $hnd_rec->[HSS_HANDLE]\\n\",\n          \"!!!\\t\\t\\tsession = $hnd_rec->[HSS_SESSION]\\n\",\n          \"!!!\\t\\t\\tevent   = $hnd_rec->[HSS_STATE]\\n\",\n          \"!!!\\t\\t\\targs    = (@{$hnd_rec->[HSS_ARGS]})\\n\",\n        );\n      }\n    }\n\n    _warn(\n      \"!!!\\tException:\\n\",\n      \"!!!\\t\\trefcnt  = $ex->[FMO_REFCOUNT]\\n\",\n    );\n    while (my ($sid, $ses_rec) = each(%{$ex->[FMO_SESSIONS]})) {\n      _warn \"!!!\\t\\tsession = $sid\\n\";\n      while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {\n        _warn(\n          \"!!!\\t\\t\\thandle  = $hnd_rec->[HSS_HANDLE]\\n\",\n          \"!!!\\t\\t\\tsession = $hnd_rec->[HSS_SESSION]\\n\",\n          \"!!!\\t\\t\\tevent   = $hnd_rec->[HSS_STATE]\\n\",\n          \"!!!\\t\\t\\targs    = (@{$hnd_rec->[HSS_ARGS]})\\n\",\n        );\n      }\n    }\n  }\n\n  while (my ($ses_id, $hnd_rec) = each(%kr_ses_to_handle)) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked file descriptor in $ses_id\\n\";\n    while (my ($fd, $rc) = each(%$hnd_rec)) {\n      _warn(\n        \"!!!\\tDescriptor: $fd (tot refcnt=$rc->[SH_REFCOUNT])\\n\",\n        \"!!!\\t\\tRead      refcnt: $rc->[SH_MODECOUNT]->[MODE_RD]\\n\",\n        \"!!!\\t\\tWrite     refcnt: $rc->[SH_MODECOUNT]->[MODE_WR]\\n\",\n        \"!!!\\t\\tException refcnt: $rc->[SH_MODECOUNT]->[MODE_EX]\\n\",\n      );\n    }\n  }\n\n  return $finalized_ok;\n}\n\n### Enqueue \"select\" events for a list of file descriptors in a given\n### access mode.\n\nsub _data_handle_enqueue_ready {\n  my ($self, $mode) = splice(@_, 0, 2);\n\n  my $now = monotime();\n  foreach my $fileno (@_) {\n    if (ASSERT_DATA) {\n      _trap \"internal inconsistency: undefined fileno\" unless defined $fileno;\n    }\n\n    # By-pass the event queue for things that come over the pipe:\n    # this reduces signal latency\n    if( USE_SIGNAL_PIPE ) {\n      # _warn \"fileno=$fileno signal_pipe_read=$POE::Kernel::signal_pipe_read_fd\";\n      if( $fileno == $POE::Kernel::signal_pipe_read_fd ) {\n        $self->_data_sig_pipe_read( $fileno, $mode );\n        next;\n      }\n    }\n\n    # Avoid autoviviying an empty $kr_filenos record if the fileno has\n    # been deactivated.  This can happen if a file descriptor is ready\n    # in multiple modes, and an earlier dispatch removes it before a\n    # later dispatch happens.\n    next unless exists $kr_filenos{$fileno};\n\n    # Gather and dispatch all the events for this fileno/mode pair.\n\n    foreach my $select (\n      map { values %$_ }\n      values %{ $kr_filenos{$fileno}[$mode][FMO_SESSIONS] }\n    ) {\n      $self->_dispatch_event(\n        $select->[HSS_SESSION], $select->[HSS_SESSION],\n        $select->[HSS_STATE], ET_SELECT, [\n          $select->[HSS_HANDLE],  # EA_SEL_HANDLE\n          $mode,                  # EA_SEL_MODE\n          @{$select->[HSS_ARGS]}, # EA_SEL_ARGS\n        ],\n        __FILE__, __LINE__, undef, $now, -__LINE__\n      );\n    }\n  }\n\n  $self->_", 8192) = 8192
09:01:57.054090 stat("modules/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054146 stat("modules/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054197 stat("modules/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054245 stat("modules/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054294 stat("/etc/perl/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054363 stat("/etc/perl/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054422 stat("/usr/local/lib/perl/5.14.2/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054483 stat("/usr/local/lib/perl/5.14.2/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054543 stat("/usr/local/share/perl/5.14.2/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054604 stat("/usr/local/share/perl/5.14.2/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054673 stat("/usr/lib/perl5/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054733 stat("/usr/lib/perl5/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054792 stat("/usr/share/perl5/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054852 stat("/usr/share/perl5/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.054911 stat("/usr/lib/perl/5.14/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.054971 stat("/usr/lib/perl/5.14/FileHandle.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.055031 stat("/usr/share/perl/5.14/FileHandle.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.055091 stat("/usr/share/perl/5.14/FileHandle.pm", {st_mode=S_IFREG|0644, st_size=2105, ...}) = 0
09:01:57.055161 open("/usr/share/perl/5.14/FileHandle.pm", O_RDONLY) = 5
09:01:57.055224 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad30) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.055278 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.055354 read(5, "package FileHandle;\n\nuse 5.006;\nuse strict;\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK);\n\n$VERSION = \"2.02\";\n\nrequire IO::File;\n@ISA = qw(IO::File);\n\n@EXPORT = qw(_IOFBF _IOLBF _IONBF);\n\n@EXPORT_OK = qw(\n    pipe\n\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n\n    print\n    printf\n    getline\n    getlines\n);\n\n#\n# Everything we're willing to export, we must first import.\n#\nimport IO::Handle grep { !defined(&$_) } @EXPORT, @EXPORT_OK;\n\n#\n# Some people call \"FileHandle::function\", so all the functions\n# that were in the old FileHandle class must be imported, too.\n#\n{\n    no strict 'refs';\n\n    my %import = (\n\t'IO::Handle' =>\n\t    [qw(DESTROY new_from_fd fdopen close fileno getc ungetc gets\n\t\teof flush error clearerr setbuf setvbuf _open_mode_string)],\n\t'IO::Seekable' =>\n\t    [qw(seek tell getpos setpos)],\n\t'IO::File' =>\n\t    [qw(new new_tmpfile open)]\n    );\n    for my $pkg (keys %import) {\n\tfor my $func (@{$import{$pkg}}) {\n\t    my $c = *{\"${pkg}::$func\"}{CODE}\n\t\tor die \"${pkg}::$func missing\";\n\t    *$func = $c;\n\t}\n    }\n}\n\n#\n# Specialized importer for Fcntl magic.\n#\nsub import {\n    my $pkg = shift;\n    my $callpkg = caller;\n    require Exporter;\n    Exporter::export($pkg, $callpkg, @_);\n\n    #\n    # If the Fcntl extension is available,\n    #  export its constants.\n    #\n    eval {\n\trequire Fcntl;\n\tExporter::export('Fcntl', $callpkg);\n    };\n}\n\n################################################\n# This is the only exported function we define;\n# the rest come from other classes.\n#\n\nsub pipe {\n    my $r = new IO::Handle;\n    my $w = new IO::Handle;\n    CORE::pipe($r, $w) or return undef;\n    ($r, $w);\n}\n\n# Rebless standard file handles\nbless *STDIN{IO},  \"FileHandle\" if ref *STDIN{IO}  eq \"IO::Handle\";\nbless *STDOUT{IO}, \"FileHandle\" if ref *STDOUT{IO} eq \"IO::Handle\";\nbless *STDERR{IO}, \"FileHandle\" if ref *STDERR{IO} eq \"IO::Handle\";\n\n1;\n\n__END__\n\n", 8192) = 2105
09:01:57.055815 lseek(5, 2104, SEEK_SET) = 2104
09:01:57.055883 lseek(5, 0, SEEK_CUR)   = 2104
09:01:57.055927 close(5)                = 0
09:01:57.055993 stat("modules/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056042 stat("modules/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056107 stat("modules/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056164 stat("modules/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056221 stat("/etc/perl/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056279 stat("/etc/perl/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056344 stat("/usr/local/lib/perl/5.14.2/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056404 stat("/usr/local/lib/perl/5.14.2/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056464 stat("/usr/local/share/perl/5.14.2/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056524 stat("/usr/local/share/perl/5.14.2/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056584 stat("/usr/lib/perl5/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056643 stat("/usr/lib/perl5/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056702 stat("/usr/share/perl5/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056761 stat("/usr/share/perl5/IO/File.pm", 0x7ffe1233afa0) = -1 ENOENT (No such file or directory)
09:01:57.056820 stat("/usr/lib/perl/5.14/IO/File.pmc", 0x7ffe1233b050) = -1 ENOENT (No such file or directory)
09:01:57.056881 stat("/usr/lib/perl/5.14/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1682, ...}) = 0
09:01:57.056951 open("/usr/lib/perl/5.14/IO/File.pm", O_RDONLY) = 5
09:01:57.057013 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad30) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.057068 lseek(5, 0, SEEK_CUR)   = 0
09:01:57.057135 brk(0xb4b000)           = 0xb4b000
09:01:57.057200 read(5, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.15\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: $class->new([FILENAME [,MODE [,PERMS]]])\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak 'usage: $fh->open(FILENAME, IOLAYERS)';\n\t} else {\n            return open($fh, IO::Handle::_open_mode_string($mode), $file);\n        }\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 8192) = 1682
09:01:57.057514 stat("modules/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.057581 stat("modules/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.057642 stat("modules/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.057705 stat("modules/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.057764 stat("/etc/perl/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.057822 stat("/etc/perl/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.057881 stat("/usr/local/lib/perl/5.14.2/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.057941 stat("/usr/local/lib/perl/5.14.2/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.058009 stat("/usr/local/share/perl/5.14.2/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.058090 stat("/usr/local/share/perl/5.14.2/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.058142 stat("/usr/lib/perl5/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.058194 stat("/usr/lib/perl5/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.058245 stat("/usr/share/perl5/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.058295 stat("/usr/share/perl5/IO/Seekable.pm", 0x7ffe1233a970) = -1 ENOENT (No such file or directory)
09:01:57.058366 stat("/usr/lib/perl/5.14/IO/Seekable.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.058428 stat("/usr/lib/perl/5.14/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
09:01:57.058499 open("/usr/lib/perl/5.14/IO/Seekable.pm", O_RDONLY) = 6
09:01:57.058563 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a700) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.058619 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.058691 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can't get these from IO::Handle or we'll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak 'usage: $io->tell()';\n    tell($_[0]);\n}\n\n1;\n", 8192) = 686
09:01:57.059013 read(6, "", 8192)       = 0
09:01:57.059072 close(6)                = 0
09:01:57.059463 read(5, "", 8192)       = 0
09:01:57.059521 close(5)                = 0
09:01:57.060600 read(4, "data_ses_gc_sweep();\n}\n\n### Test whether POE is tracking a file handle.\n\nsub _data_handle_is_good {\n  my ($self, $handle, $mode) = @_;\n\n  # Don't bother if the kernel isn't tracking the file.\n  return 0 unless exists $kr_filenos{fileno $handle};\n\n  # Don't bother if the kernel isn't tracking the file mode.\n  return 0 unless $kr_filenos{fileno $handle}->[$mode]->[FMO_REFCOUNT];\n\n  return 1;\n}\n\n### Add a select to the session, and possibly begin a watcher.\n\nsub _data_handle_add {\n  my ($self, $handle, $mode, $session, $event, $args) = @_;\n  my $fd = fileno($handle);\n\n  # First time watching the file descriptor.  Do some heavy setup.\n  #\n  # NB - This means we can't optimize away the delete() calls here and\n  # there, because they probably ensure that the structure exists.\n  unless (exists $kr_filenos{$fd}) {\n\n    $kr_filenos{$fd} =\n      [ [ 0,          # FMO_REFCOUNT    MODE_RD\n          HS_PAUSED,  # FMO_ST_ACTUAL\n          { },        # FMO_SESSIONS\n        ],\n        [ 0,          # FMO_REFCOUNT    MODE_WR\n          HS_PAUSED,  # FMO_ST_ACTUAL\n          { },        # FMO_SESSIONS\n        ],\n        [ 0,          # FMO_REFCOUNT    MODE_EX\n          HS_PAUSED,  # FMO_ST_ACTUAL\n          { },        # FMO_SESSIONS\n        ],\n        0,            # FNO_TOT_REFCOUNT\n      ];\n\n    if (TRACE_FILES) {\n      _warn \"<fh> adding $handle fd ($fd) in mode ($mode)\";\n    }\n\n    $self->_data_handle_condition( $handle );\n  }\n\n  # Cache some high-level lookups.\n  my $kr_fileno  = $kr_filenos{$fd};\n  my $kr_fno_rec = $kr_fileno->[$mode];\n\n  # The session is already watching this fileno in this mode.\n\n  my $sid = $session->ID;\n  if ($kr_fno_rec->[FMO_SESSIONS]->{$sid}) {\n\n    # The session is also watching it by the same handle.  Treat this\n    # as a \"resume\" in this mode.\n\n    if (exists $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd}) {\n      if (TRACE_FILES) {\n        _warn(\"<fh> running $handle fileno($fd) mode($mode)\");\n      }\n      $self->loop_resume_filehandle($handle, $mode);\n      $kr_fno_rec->[FMO_ST_ACTUAL] = HS_RUNNING;\n    }\n\n    # The session is watching it by a different handle.  It can't be\n    # done yet, but maybe later when drivers are added to the mix.\n    #\n    # TODO - This can occur if someone closes a filehandle without\n    # calling select_foo() to deregister it from POE.  In that case,\n    # the operating system reuses the file descriptor, but we still\n    # have something registered for it here.\n\n    else {\n      foreach my $watch_sid (keys %{$kr_fno_rec->[FMO_SESSIONS]}) {\n        foreach my $hdl_rec (\n          values %{$kr_fno_rec->[FMO_SESSIONS]->{$watch_sid}}\n        ) {\n          my $other_handle = $hdl_rec->[HSS_HANDLE];\n\n          my $why;\n          unless (defined(fileno $other_handle)) {\n            $why = \"closed\";\n          }\n          elsif (fileno($handle) == fileno($other_handle)) {\n            $why = \"open\";\n          }\n          else {\n            $why = \"open with different file descriptor\";\n          }\n\n          if ($sid eq $watch_sid) {\n            _die(\n              \"A session was caught watching two different file handles that\\n\",\n              \"reference the same file descriptor in the same mode ($mode).\\n\",\n              \"This error is usually caused by a file descriptor leak.  The\\n\",\n              \"most common cause is explicitly closing a filehandle without\\n\",\n              \"first unregistering it from POE.\\n\",\n              \"\\n\",\n              \"Some possibly helpful information:\\n\",\n              \"  Session    : \",\n              $self->_data_alias_loggable($sid), \"\\n\",\n              \"  Old handle : $other_handle (currently $why)\\n\",\n              \"  New handle : $handle\\n\",\n              \"\\n\",\n              \"Please correct the program and try again.\\n\",\n            );\n          }\n          else {\n            _die(\n              \"Two sessions were caught watching the same file descriptor\\n\",\n              \"in the same mode ($mode).  This error is usually caused by\\n\",\n              \"a file descriptor leak.  The most common cause is explicitly\\n\",\n              \"closing a filehandle without first unregistering it from POE.\\n\",\n              \"\\n\",\n              \"Some possibly helpful information:\\n\",\n              \"  Old session: \",\n              $self->_data_alias_loggable($hdl_rec->[HSS_SESSION]->ID), \"\\n\",\n              \"  Old handle : $other_handle (currently $why)\\n\",\n              \"  New session: \",\n              $self->_data_alias_loggable($sid), \"\\n\",\n              \"  New handle : $handle\\n\",\n              \"\\n\",\n              \"Please correct the program and try again.\\n\",\n            );\n          }\n        }\n      }\n      _trap \"internal inconsistency\";\n    }\n  }\n\n  # The session is not watching this fileno in this mode.  Record\n  # the session/handle pair.\n\n  else {\n    $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd} = [\n      $handle,   # HSS_HANDLE\n      $session,  # HSS_SESSION\n      $event,    # HSS_STATE\n      $args,     # HSS_ARGS\n    ];\n\n    # Fix reference counts.\n    $kr_fileno->[FNO_TOT_REFCOUNT]++;\n    $kr_fno_rec->[FMO_REFCOUNT]++;\n\n    # If this is the first time a file is watched in this mode, then\n    # have the event loop bridge watch it.\n\n    if ($kr_fno_rec->[FMO_REFCOUNT] == 1) {\n      $self->loop_watch_filehandle($handle, $mode);\n      $kr_fno_rec->[FMO_ST_ACTUAL]  = HS_RUNNING;\n    }\n  }\n\n  # If the session hasn't already been watching the filehandle, then\n  # register the filehandle in the session's structure.\n\n  unless (exists $kr_ses_to_handle{$sid}->{$fd}) {\n    $kr_ses_to_handle{$sid}->{$fd} = [\n      $handle,  # SH_HANDLE\n      0,        # SH_REFCOUNT\n      [ 0,      # SH_MODECOUNT / MODE_RD\n        0,      # SH_MODECOUNT / MODE_WR\n        0       # SH_MODECOUNT / MODE_EX\n      ]\n    ];\n    $self->_data_ses_refcount_inc($sid);\n  }\n\n  # Modify the session's handle structure's reference counts, so the\n  # session knows it has a reason to live.\n\n  my $ss_handle = $kr_ses_to_handle{$sid}->{$fd};\n  unless ($ss_handle->[SH_MODECOUNT]->[$mode]) {\n    $ss_handle->[SH_MODECOUNT]->[$mode]++;\n    $ss_handle->[SH_REFCOUNT]++;\n  }\n}\n\n### Condition a file handle so that it is ready for select et al\nsub _data_handle_condition {\n    my( $self, $handle ) = @_;\n\n    # For DOSISH systems like OS/2.  Wrapped in eval{} in case it's a\n    # tied handle that doesn't support binmode.\n    eval { binmode *$handle };\n\n    # Turn off blocking on the handle.  Requires a sufficiently\n    # advanced Perl as not to be broken.  Otherwise we must skip tied\n    # filehandles or plain files.\n    #\n    # Perl-5.6.2 and older seem to hate tied FHs or plain files, so we\n    # be careful!\n    #\n    # ok 115 - regular file: handle removed fully\n    # Bad filehandle: GEN11\n    #   at /home/cpan/poe/blib/lib/POE/Resource/FileHandles.pm line 442.\n    # Compilation failed in require\n    #   at t/20_resources/10_perl/filehandles.t line 9.\n\n    IO::Handle::blocking($handle, 0) if (\n      $] >= 5.008001 or not (tied *$handle or -f $handle)\n    );\n\n    # Turn off buffering.\n    # you may be tempted to use $handle->autoflush(1) BUT DON'T DO THAT! ( things blow up )\n    CORE::select((CORE::select($handle), $| = 1)[0]);\n}\n\n### Remove a select from the kernel, and possibly trigger the\n### session's destruction.\n\nsub _data_handle_remove {\n  my ($self, $handle, $mode, $sid) = @_;\n  my $fd = fileno($handle);\n\n  # Make sure the handle is deregistered with the kernel.\n\n  if (defined($fd) and exists($kr_filenos{$fd})) {\n    my $kr_fileno  = $kr_filenos{$fd};\n    my $kr_fno_rec = $kr_fileno->[$mode];\n\n    # Make sure the handle was registered to the requested session.\n\n    if (\n      exists($kr_fno_rec->[FMO_SESSIONS]->{$sid}) and\n      exists($kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd})\n    ) {\n\n      TRACE_FILES and\n        _warn(\n          \"<fh> removing handle ($handle) fileno ($fd) mode ($mode) from \" .\n          $self->_data_alias_loggable($sid) . Carp::shortmess()\n        );\n\n      # Remove the handle from the kernel's session record.\n\n      my $handle_rec = delete $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd};\n\n      my $kill_session = $handle_rec->[HSS_SESSION];\n      my $kill_event   = $handle_rec->[HSS_STATE];\n\n      # Remo", 8192) = 8192
09:01:57.061302 brk(0xb6c000)           = 0xb6c000
09:01:57.061748 read(4, "ve any events destined for that handle.\n      my $my_select = sub {\n        return 0 unless $_[0]->[EV_TYPE]    &  ET_SELECT;\n        return 0 unless $_[0]->[EV_SESSION] == $kill_session;\n        return 0 unless $_[0]->[EV_NAME]    eq $kill_event;\n        return 0 unless $_[0]->[EV_ARGS]->[EA_SEL_HANDLE] == $handle;\n        return 0 unless $_[0]->[EV_ARGS]->[EA_SEL_MODE]   == $mode;\n        return 1;\n      };\n\n      foreach ($kr_queue->remove_items($my_select)) {\n        my ($time, $id, $event) = @$_;\n        $self->_data_ev_refcount_dec(\n          $event->[EV_SOURCE]->ID(),\n          $event->[EV_SESSION]->ID(),\n        );\n\n        TRACE_EVENTS and _warn(\n          \"<ev> removing select event $id ``$event->[EV_NAME]''\" .\n          Carp::shortmess\n        );\n      }\n\n      # Decrement the handle's reference count.\n\n      $kr_fno_rec->[FMO_REFCOUNT]--;\n\n      if (ASSERT_DATA) {\n        _trap \"<dt> fileno mode refcount went below zero\"\n          if $kr_fno_rec->[FMO_REFCOUNT] < 0;\n      }\n\n      # If the \"mode\" count drops to zero, then stop selecting the\n      # handle.\n\n      unless ($kr_fno_rec->[FMO_REFCOUNT]) {\n        $self->loop_ignore_filehandle($handle, $mode);\n        $kr_fno_rec->[FMO_ST_ACTUAL]  = HS_STOPPED;\n\n        # The session is not watching handles anymore.  Remove the\n        # session entirely the fileno structure.\n        delete $kr_fno_rec->[FMO_SESSIONS]->{$sid}\n          unless keys %{$kr_fno_rec->[FMO_SESSIONS]->{$sid}};\n      }\n\n      # Decrement the kernel record's handle reference count.  If the\n      # handle is done being used, then delete it from the kernel's\n      # record structure.  This initiates Perl's garbage collection on\n      # it, as soon as whatever else in \"user space\" frees it.\n\n      $kr_fileno->[FNO_TOT_REFCOUNT]--;\n\n      if (ASSERT_DATA) {\n        _trap \"<dt> fileno refcount went below zero\"\n          if $kr_fileno->[FNO_TOT_REFCOUNT] < 0;\n      }\n\n      unless ($kr_fileno->[FNO_TOT_REFCOUNT]) {\n        if (TRACE_FILES) {\n          _warn \"<fh> deleting handle ($handle) fileno ($fd) entirely\";\n        }\n        delete $kr_filenos{$fd};\n      }\n    }\n    elsif (TRACE_FILES) {\n      _warn(\n        \"<fh> session doesn't own handle ($handle) fileno ($fd) mode ($mode)\"\n      );\n    }\n  }\n  elsif (TRACE_FILES) {\n    _warn(\n      \"<fh> handle ($handle) fileno ($fd) is not registered with POE::Kernel\" .\n      Carp::shortmess()\n\n    );\n  }\n\n  # SS_HANDLES - Remove the select from the session, assuming there is\n  # a session to remove it from.  TODO Key it on fileno?\n\n  if (\n    exists($kr_ses_to_handle{$sid}) and\n    exists($kr_ses_to_handle{$sid}->{$fd})\n  ) {\n\n    # Remove it from the session's read, write or expedite mode.\n\n    my $ss_handle = $kr_ses_to_handle{$sid}->{$fd};\n    if ($ss_handle->[SH_MODECOUNT]->[$mode]) {\n\n      # Hmm... what is this?  Was POE going to support multiple selects?\n\n      $ss_handle->[SH_MODECOUNT]->[$mode] = 0;\n\n      # Decrement the reference count, and delete the handle if it's done.\n\n      $ss_handle->[SH_REFCOUNT]--;\n\n      if (ASSERT_DATA) {\n        _trap \"<dt> refcount went below zero\"\n          if $ss_handle->[SH_REFCOUNT] < 0;\n      }\n\n      unless ($ss_handle->[SH_REFCOUNT]) {\n        delete $kr_ses_to_handle{$sid}->{$fd};\n        $self->_data_ses_refcount_dec($sid);\n        delete $kr_ses_to_handle{$sid}\n          unless keys %{$kr_ses_to_handle{$sid}};\n      }\n    }\n    elsif (TRACE_FILES) {\n      _warn(\n        \"<fh> handle ($handle) fileno ($fd) is not registered with\",\n        $self->_data_alias_loggable($sid)\n      );\n    }\n  }\n}\n\n### Resume a filehandle.  If there are no events in the queue for this\n### handle/mode pair, then we go ahead and set the actual state now.\n### Otherwise it must wait until the queue empties.\n\nsub _data_handle_resume {\n  my ($self, $handle, $mode) = @_;\n\n  my $kr_fileno = $kr_filenos{fileno($handle)};\n  my $kr_fno_rec = $kr_fileno->[$mode];\n\n  if (TRACE_FILES) {\n    _warn(\n      \"<fh> resume test: $handle fileno(\" . fileno($handle) . \") mode($mode)\"\n    );\n  }\n\n  $self->loop_resume_filehandle($handle, $mode);\n  $kr_fno_rec->[FMO_ST_ACTUAL] = HS_RUNNING;\n}\n\n### Pause a filehandle.  If there are no events in the queue for this\n### handle/mode pair, then we go ahead and set the actual state now.\n### Otherwise it must wait until the queue empties.\n\nsub _data_handle_pause {\n  my ($self, $handle, $mode) = @_;\n\n  my $kr_fileno = $kr_filenos{fileno($handle)};\n  my $kr_fno_rec = $kr_fileno->[$mode];\n\n  if (TRACE_FILES) {\n    _warn(\n      \"<fh> pause test: $handle fileno(\" . fileno($handle) . \") mode($mode)\"\n    );\n  }\n\n  $self->loop_pause_filehandle($handle, $mode);\n  $kr_fno_rec->[FMO_ST_ACTUAL] = HS_PAUSED;\n}\n\n### Return the number of active filehandles in the entire system.\n\nsub _data_handle_count {\n  return scalar keys %kr_filenos;\n}\n\n### Return the number of active handles for a single session.\n\nsub _data_handle_count_ses {\n  my ($self, $sid) = @_;\n  return 0 unless exists $kr_ses_to_handle{$sid};\n  return scalar keys %{$kr_ses_to_handle{$sid}};\n}\n\n### Clear all the handles owned by a session.\n\nsub _data_handle_clear_session {\n  my ($self, $sid) = @_;\n\n  return unless exists $kr_ses_to_handle{$sid}; # avoid autoviv\n  foreach (values %{$kr_ses_to_handle{$sid}}) {\n    my $handle = $_->[SH_HANDLE];\n    my $refcount = $_->[SH_MODECOUNT];\n\n    $self->_data_handle_remove($handle, MODE_RD, $sid) if $refcount->[MODE_RD];\n    $self->_data_handle_remove($handle, MODE_WR, $sid) if $refcount->[MODE_WR];\n    $self->_data_handle_remove($handle, MODE_EX, $sid) if $refcount->[MODE_EX];\n  }\n}\n\n# TODO Testing accessors.  Maybe useful for introspection.  May need\n# modification before that.\n\nsub _data_handle_fno_refcounts {\n  my ($self, $fd) = @_;\n  return(\n    $kr_filenos{$fd}->[FNO_TOT_REFCOUNT],\n    $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_REFCOUNT],\n    $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_REFCOUNT],\n    $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_REFCOUNT],\n  )\n}\n\nsub _data_handle_fno_states {\n  my ($self, $fd) = @_;\n  return(\n    $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_ST_ACTUAL],\n    $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_ST_ACTUAL],\n    $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_ST_ACTUAL],\n  );\n}\n\nsub _data_handle_fno_sessions {\n  my ($self, $fd) = @_;\n\n  return(\n    $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_SESSIONS],\n    $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_SESSIONS],\n    $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_SESSIONS],\n  );\n}\n\nsub _data_handle_handles {\n  my $self = shift;\n  return %kr_ses_to_handle;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::FileHandles - internal filehandle manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::FileHandles is a mix-in class for POE::Kernel.  It\nprovides the low-level features to manage filehandles.  It is used\ninternally by POE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/I/O Watchers (Selects)> for the public file watcher\nAPI.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nPOE watches I/O based on filehandles rather than file descriptors,\nwhich means there can be clashes between its API and an underlying\ndescriptor-based event loop.  This is usually not a problem, but it\nmay require a work-around in certain edge cases.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 7545
09:01:57.063248 lseek(4, 22902, SEEK_SET) = 22902
09:01:57.063330 lseek(4, 0, SEEK_CUR)   = 22902
09:01:57.063384 close(4)                = 0
09:01:57.063488 stat("modules/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.063550 stat("modules/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.063610 stat("modules/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.063669 stat("modules/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.063728 stat("/etc/perl/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.063787 stat("/etc/perl/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.063863 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.063915 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.063966 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064017 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064067 stat("/usr/lib/perl5/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064138 stat("/usr/lib/perl5/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064197 stat("/usr/share/perl5/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064257 stat("/usr/share/perl5/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064324 stat("/usr/lib/perl/5.14/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064387 stat("/usr/lib/perl/5.14/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064448 stat("/usr/share/perl/5.14/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064508 stat("/usr/share/perl/5.14/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064602 stat("/usr/local/lib/site_perl/POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064662 stat("/usr/local/lib/site_perl/POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064723 stat("./POE/XS/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064781 stat("./POE/XS/Resource/SIDs.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.064889 stat("modules/POE/Resource/SIDs.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.064950 stat("modules/POE/Resource/SIDs.pm", {st_mode=S_IFREG|0600, st_size=2518, ...}) = 0
09:01:57.065020 open("modules/POE/Resource/SIDs.pm", O_RDONLY) = 4
09:01:57.065082 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.065140 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.065208 read(4, "# Session IDs: The data to maintain them, and accessors to get at them\n# sanely from other files.\n\npackage POE::Resource::SIDs;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\n### Map session IDs to sessions.  Map sessions to session IDs.\n### Maintain a sequence number for determining the next session ID.\n\nmy %kr_session_ids;\n#  ( $session_id => $session_reference,\n#    ...,\n#  );\n\nmy $kr_sid_seq = 0;\n\nsub _data_sid_initialize {\n  $poe_kernel->[KR_SESSION_IDS] = \\%kr_session_ids;\n  $poe_kernel->[KR_SID_SEQ] = \\$kr_sid_seq;\n}\n\nsub _data_sid_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n  $kr_session_ids{$new_id} = delete $kr_session_ids{$old_id}\n    if exists $kr_session_ids{$old_id};\n}\n\n### End-run leak checking.\n\nsub _data_sid_finalize {\n  my $finalized_ok = 1;\n  while (my ($sid, $ses) = each(%kr_session_ids)) {\n    _warn \"!!! Leaked session ID: $sid = $ses\\n\";\n    $finalized_ok = 0;\n  }\n  return $finalized_ok;\n}\n\n### Allocate a new session ID.\n\nsub _data_sid_allocate {\n  my $self = shift;\n  1 while exists $kr_session_ids{++$kr_sid_seq};\n  return $kr_sid_seq;\n}\n\n### Set a session ID.\n\nsub _data_sid_set {\n  my ($self, $sid, $session) = @_;\n  $kr_session_ids{$sid} = $session;\n}\n\n### Clear a session ID.\n\nsub _data_sid_clear {\n  my ($self, $sid) = @_;\n\n  return delete $kr_session_ids{$sid} unless ASSERT_DATA;\n\n  my $removed = delete $kr_session_ids{$sid};\n  _trap(\"unknown SID '$sid'\") unless defined $removed;\n  $removed;\n}\n\n### Resolve a session ID into its session.\n\nsub _data_sid_resolve {\n  my ($self, $sid) = @_;\n  return $kr_session_ids{$sid};\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::SIDs - internal session ID manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::SIDs is a mix-in class for POE::Kernel.  It provides\nthe features necessary to manage session IDs.  It is used internally\nby POE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Session Identifiers (IDs and Aliases)> for more\ninformation about session IDs.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 2518
09:01:57.065637 lseek(4, 1722, SEEK_SET) = 1722
09:01:57.065711 lseek(4, 0, SEEK_CUR)   = 1722
09:01:57.065762 close(4)                = 0
09:01:57.065859 stat("modules/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.065919 stat("modules/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.065977 stat("modules/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066043 stat("modules/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066115 stat("/etc/perl/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066165 stat("/etc/perl/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066216 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066267 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066335 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066394 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066453 stat("/usr/lib/perl5/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066511 stat("/usr/lib/perl5/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066569 stat("/usr/share/perl5/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066626 stat("/usr/share/perl5/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066684 stat("/usr/lib/perl/5.14/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066743 stat("/usr/lib/perl/5.14/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066802 stat("/usr/share/perl/5.14/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066861 stat("/usr/share/perl/5.14/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.066920 stat("/usr/local/lib/site_perl/POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.066977 stat("/usr/local/lib/site_perl/POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.067036 stat("./POE/XS/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.067093 stat("./POE/XS/Resource/Sessions.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.067194 stat("modules/POE/Resource/Sessions.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.067253 stat("modules/POE/Resource/Sessions.pm", {st_mode=S_IFREG|0600, st_size=17462, ...}) = 0
09:01:57.067321 open("modules/POE/Resource/Sessions.pm", O_RDONLY) = 4
09:01:57.067382 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.067435 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.067496 brk(0xb8e000)           = 0xb8e000
09:01:57.067559 read(4, "# Manage session data structures on behalf of POE::Kernel.\n\npackage POE::Resource::Sessions;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\n# Map stringy sessions to their references for _data_ses_resolve.\nmy %kr_session_refs;\n# { $session_ref => $blessed, ... }\n\n### Session structure.\nmy %kr_sessions;\n#  { $session_id =>\n#    [ $blessed_session,         SS_SESSION\n#      $total_reference_count,   SS_REFCOUNT\n#      $parent_session,          SS_PARENT\n#      { $child_session_id => $blessed_ref,  SS_CHILDREN\n#        ...,\n#      },\n#      { $process_id => $placeholder_value,  SS_PROCESSES\n#        ...,\n#      },\n#    ],\n#    ...,\n#  };\n\nsub SS_SESSION    () { 0 }\nsub SS_REFCOUNT   () { 1 }\nsub SS_PARENT     () { 2 }\nsub SS_CHILDREN   () { 3 }\nsub SS_PROCESSES  () { 4 }\n\nBEGIN { $POE::Kernel::poe_kernel->[KR_SESSIONS] = \\%kr_sessions; }\n\nsub _data_ses_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n\n  while (my ($sid, $ses_rec) = each %kr_sessions) {\n    my $children = $ses_rec->[SS_CHILDREN];\n    $children->{$new_id} = delete $children->{$old_id}\n      if exists $children->{$old_id};\n  }\n\n  $kr_sessions{$new_id} = delete $kr_sessions{$old_id}\n    if exists $kr_sessions{$old_id};\n}\n\n### End-run leak checking.\n\nsub _data_ses_clone {\n  %kr_session_refs = ();\n  foreach my $ses_ref (map { $_->[SS_SESSION] } values %kr_sessions) {\n    $kr_session_refs{$ses_ref} = $ses_ref;\n  }\n}\n\nsub _data_ses_finalize {\n  my $finalized_ok = 1;\n\n  while (my ($sid, $ses_rec) = each %kr_sessions) {\n    $finalized_ok = 0;\n    _warn(\n      \"!!! Leaked session: $sid\\n\",\n      \"!!!\\trefcnt = $ses_rec->[SS_REFCOUNT]\\n\",\n      \"!!!\\tparent = $ses_rec->[SS_PARENT]\\n\",\n      \"!!!\\tchilds = \", join(\"; \", keys(%{$ses_rec->[SS_CHILDREN]})), \"\\n\",\n      \"!!!\\tprocs  = \", join(\"; \", keys(%{$ses_rec->[SS_PROCESSES]})),\"\\n\",\n    );\n  }\n\n  while (my ($stringy, $blessed) = each %kr_session_refs) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked stringy session $stringy = $blessed\\n\";\n    _warn \"!!!\\tBad clone detected, while we're at it.\\n\" if (\n      $stringy ne \"$blessed\"\n    );\n  }\n\n  return $finalized_ok;\n}\n\n### Enter a new session into the back-end stuff.\n\nmy %kr_marked_for_gc;\nmy @kr_marked_for_gc;\n\nsub _data_ses_allocate {\n  my ($self, $session, $sid, $parent_id) = @_;\n\n  my $parent;\n  if (defined $parent_id) {\n    _trap \"parent session $parent_id does not exist\" unless (\n      exists $kr_sessions{$parent_id}\n    );\n\n    $parent = $kr_sessions{$parent_id}[SS_SESSION];\n\n    _trap \"session $session is already allocated\" if exists $kr_sessions{$sid};\n  }\n\n  TRACE_REFCNT and _warn \"<rc> allocating $session\";\n\n  $kr_sessions{$sid} =\n    [ $session,   # SS_SESSION\n      0,          # SS_REFCOUNT\n      $parent,    # SS_PARENT\n      { },        # SS_CHILDREN\n      { },        # SS_PROCESSES\n    ];\n\n  # For the ID to session reference lookup.\n  $self->_data_sid_set($sid, $session);\n\n  # For the stringy to blessed session reference lookup.\n  $kr_session_refs{$session} = $session;\n\n  # Manage parent/child relationship.\n  if (defined $parent_id) {\n    if (TRACE_SESSIONS) {\n      _warn(\n        \"<ss> \",\n        $self->_data_alias_loggable($sid), \" has parent \",\n        $self->_data_alias_loggable($parent_id)\n      );\n    }\n\n    $kr_sessions{$parent_id}->[SS_CHILDREN]->{$sid} = $session;\n    $self->_data_ses_refcount_inc($parent_id);\n  }\n\n  TRACE_REFCNT and _warn \"<rc> $session marked for gc\";\n  unless ($sid eq $self->ID) {\n    push @kr_marked_for_gc, $sid;\n    $kr_marked_for_gc{$sid} = $sid;\n  }\n}\n\n# Release a session's resources, and remove it.  This doesn't do\n# garbage collection for the session itself because that should\n# already have happened.\n#\n# TODO This is yet another place where resources will need to register\n# a function.  Every resource's _data_???_clear_session is called\n# here.\n\nsub _data_ses_free {\n  my ($self, $sid) = @_;\n\n  TRACE_REFCNT and do {\n    _warn \"<rc> freeing session $sid\";\n    _trap(\"!!! free defunct session $sid?!\\n\") unless (\n      $self->_data_ses_exists($sid)\n    );\n  };\n\n  if (TRACE_SESSIONS) {\n    _warn \"<ss> freeing \", $self->_data_alias_loggable($sid);\n  }\n\n  # Manage parent/child relationships.\n\n  my $parent   = $kr_sessions{$sid}->[SS_PARENT];\n  my @children = $self->_data_ses_get_children($sid);\n\n  if (defined $parent) {\n    my $parent_id = $parent->ID;\n\n    if (ASSERT_DATA) {\n      _trap \"session is its own parent\" if $parent_id eq $sid;\n      _trap \"session's parent ($parent_id) doesn't exist\"\n        unless exists $kr_sessions{$parent_id};\n\n      unless ($self->_data_ses_is_child($parent_id, $sid)) {\n        _trap(\n          $self->_data_alias_loggable($sid), \" isn't a child of \",\n          $self->_data_alias_loggable($parent_id), \" (it's a child of \",\n          $self->_data_alias_loggable($self->_data_ses_get_parent($sid)->ID),\n          \")\"\n        );\n      }\n    }\n\n    # Remove the departing session from its parent.\n\n    _trap \"internal inconsistency ($parent_id/$sid)\"\n      unless delete $kr_sessions{$parent_id}->[SS_CHILDREN]->{$sid};\n\n    $kr_sessions{$sid}->[SS_PARENT] = undef;\n\n    if (TRACE_SESSIONS) {\n      _cluck(\n        \"<ss> removed \",\n        $self->_data_alias_loggable($sid), \" from \",\n        $self->_data_alias_loggable($parent_id)\n      );\n    }\n\n    $self->_data_ses_refcount_dec($parent_id);\n\n    # Move the departing session's children to its parent.\n\n    foreach (@children) {\n      $self->_data_ses_move_child($_->ID, $parent_id)\n    }\n  }\n  elsif (ASSERT_DATA) {\n    _trap \"no parent to give children to\" if @children;\n  }\n\n  my $session = $kr_sessions{$sid}[SS_SESSION];\n\n  # Things which do not hold reference counts.\n\n  $self->_data_sid_clear($sid);                # Remove from SID tables.\n  $self->_data_sig_clear_session($sid);        # Remove all leftover signals.\n\n  # Things which do hold reference counts.\n\n  $self->_data_alias_clear_session($sid);      # Remove all leftover aliases.\n  $self->_data_extref_clear_session($sid);     # Remove all leftover extrefs.\n  $self->_data_handle_clear_session($sid);     # Remove all leftover handles.\n\n  $self->_data_ev_clear_session($sid);         # Remove all leftover events.\n\n  # Remove the session itself.\n\n  delete $kr_marked_for_gc{$sid};\n  delete $kr_sessions{$sid};\n  delete $kr_session_refs{$session};\n}\n\n### Move a session to a new parent.\n\nsub _data_ses_move_child {\n  my ($self, $sid, $new_parent_id) = @_;\n\n  if (ASSERT_DATA) {\n    _trap(\"moving nonexistent child to another parent\")\n      unless exists $kr_sessions{$sid};\n    _trap(\"moving child to a nonexistent parent\")\n      unless exists $kr_sessions{$new_parent_id};\n  }\n\n  if (TRACE_SESSIONS) {\n    _warn(\n      \"<ss> moving \",\n      $self->_data_alias_loggable($sid), \" to \",\n      $self->_data_alias_loggable($new_parent_id)\n    );\n  }\n\n  my $old_parent_id = $self->_data_ses_get_parent($sid)->ID;\n\n  if (ASSERT_DATA) {\n    _trap(\"moving child from a nonexistent parent\")\n      unless exists $kr_sessions{$old_parent_id};\n  }\n\n  # Remove the session from its old parent.\n  delete $kr_sessions{$old_parent_id}->[SS_CHILDREN]->{$sid};\n\n  if (TRACE_SESSIONS) {\n    _warn(\n      \"<ss> removed \",\n      $self->_data_alias_loggable($sid), \" from \",\n      $self->_data_alias_loggable($old_parent_id)\n    );\n  }\n\n  $self->_data_ses_refcount_dec($old_parent_id);\n\n  # Change the session's parent.\n  $kr_sessions{$sid}->[SS_PARENT] = $kr_sessions{$new_parent_id}[SS_SESSION];\n\n  if (TRACE_SESSIONS) {\n    _warn(\n      \"<ss> changed parent of \",\n      $self->_data_alias_loggable($sid), \" to \",\n      $self->_data_alias_loggable($new_parent_id)\n    );\n  }\n\n  # Add the current session to the new parent's children.\n  $kr_sessions{$new_parent_id}->[SS_CHILDREN]->{$sid} = (\n    $kr_sessions{$sid}[SS_SESSION]\n  );\n\n  if (TRACE_SESSIONS) {\n    _warn(\n      \"<ss> added \",\n      $self->_data_alias_loggable($sid), \" as child of \",\n      $self->_data_alias_loggable($new_parent_id)\n    );\n  }\n\n  $self->_data_ses_refcount_inc($new_parent_id);\n\n  # We do not call _data_ses_collect_garbage() here.  This function is\n  # called in batc", 8192) = 8192
09:01:57.068768 read(4, "h for a departing session, to move its children to\n  # its parent.  The GC test would be superfluous here.  Rather, it's\n  # up to the caller to do the proper GC test after moving things\n  # around.\n}\n\n### Get a session's parent.\n\nsub _data_ses_get_parent {\n  my ($self, $sid) = @_;\n  if (ASSERT_DATA || ASSERT_USAGE) {\n    _trap(\"undefined session ID\") unless defined $sid;\n    _trap(\"retrieving parent of a nonexistent session\")\n      unless exists $kr_sessions{$sid};\n  }\n  return $kr_sessions{$sid}->[SS_PARENT];\n}\n\n### Get a session's children.\n\nsub _data_ses_get_children {\n  my ($self, $sid) = @_;\n  if (ASSERT_DATA) {\n    _trap(\"retrieving children of a nonexistent session\")\n      unless exists $kr_sessions{$sid};\n  }\n  return values %{$kr_sessions{$sid}->[SS_CHILDREN]};\n}\n\n### Is a session a child of another?\n\nsub _data_ses_is_child {\n  my ($self, $parent_id, $child_id) = @_;\n  if (ASSERT_DATA) {\n    _trap(\"testing is-child of a nonexistent parent session\")\n      unless exists $kr_sessions{$parent_id};\n  }\n  return(\n    exists $kr_sessions{$parent_id} &&\n    exists $kr_sessions{$parent_id}->[SS_CHILDREN]->{$child_id}\n  );\n}\n\n### Determine whether a session exists.  We should only need to verify\n### this for sessions provided by the outside.  Internally, our code\n### should be so clean it's not necessary.\n\nsub _data_ses_exists {\n  my ($self, $sid) = @_;\n  return exists $kr_sessions{$sid};\n}\n\n### Resolve a session into its reference.\n\nsub _data_ses_resolve {\n  my ($self, $session) = @_;\n  return undef unless exists $kr_session_refs{$session}; # Prevents autoviv.\n  return $kr_session_refs{$session};\n}\n\n### Resolve a session ID into its reference.\n\nsub _data_ses_resolve_to_id {\n  my ($self, $session) = @_;\n  $session = $self->_data_ses_resolve($session);\n  return undef unless defined $session;\n  return $session->ID;\n}\n\n### Sweep the GC marks.\n\nsub _data_ses_gc_sweep {\n  my $self = shift;\n\n  TRACE_REFCNT and _warn \"<rc> trying sweep\";\n  while (@kr_marked_for_gc) {\n    my %temp_marked = %kr_marked_for_gc;\n    %kr_marked_for_gc = ();\n\n    my @todo = reverse @kr_marked_for_gc;\n    @kr_marked_for_gc = ();\n\n    # Never GC the POE::Kernel singleton.\n    delete $temp_marked{$self->ID};\n\n    foreach my $sid (@todo) {\n      next unless delete $temp_marked{$sid};\n      $self->_data_ses_stop($sid);\n    }\n  }\n}\n\n### Decrement a session's main reference count.  This is called by\n### each watcher when the last thing it watches for the session goes\n### away.  In other words, a session's reference count should only\n### enumerate the different types of things being watched; not the\n### number of each.\n\nsub _data_ses_refcount_dec {\n  my ($self, $sid) = @_;\n\n  if (ASSERT_DATA) {\n    _trap(\"decrementing refcount of a nonexistent session\")\n      unless exists $kr_sessions{$sid};\n  }\n\n  if (TRACE_REFCNT) {\n    _cluck(\n      \"<rc> decrementing refcount for \",\n      $self->_data_alias_loggable($sid)\n    );\n  }\n\n  if (--$kr_sessions{$sid}->[SS_REFCOUNT] < 1) {\n    TRACE_REFCNT and _warn \"<rc> session $sid marked for gc\";\n    unless ($sid eq $self->ID) {\n      push @kr_marked_for_gc, $sid;\n      $kr_marked_for_gc{$sid} = $sid;\n    }\n  }\n\n  $self->_data_ses_dump_refcounts($sid) if TRACE_REFCNT;\n\n  if (ASSERT_DATA and $kr_sessions{$sid}->[SS_REFCOUNT] < 0) {\n    _trap(\n      $self->_data_alias_loggable($sid),\n     \" reference count went below zero\"\n   );\n  }\n}\n\n### Increment a session's main reference count.\n\nsub _data_ses_refcount_inc {\n  my ($self, $sid) = @_;\n\n  if (ASSERT_DATA) {\n    _trap(\"incrementing refcount for nonexistent session\")\n      unless exists $kr_sessions{$sid};\n  }\n\n  if (TRACE_REFCNT) {\n    _cluck(\n      \"<rc> incrementing refcount for \",\n      $self->_data_alias_loggable($sid)\n    );\n  }\n\n  if (++$kr_sessions{$sid}->[SS_REFCOUNT] > 0) {\n    TRACE_REFCNT and _warn \"<rc> session $sid unmarked for gc\";\n    delete $kr_marked_for_gc{$sid};\n  }\n  elsif (TRACE_REFCNT) {\n    _warn(\n      \"??? session $sid refcount = $kr_sessions{$sid}->[SS_REFCOUNT]\"\n    );\n  }\n\n  $self->_data_ses_dump_refcounts($sid) if TRACE_REFCNT;\n}\n\nsub _data_ses_dump_refcounts {\n  my ($self, $sid) = @_;\n\n  my $ss = $kr_sessions{$sid};\n\n  _warn(\n    \"<rc> +----- GC test for \", $self->_data_alias_loggable($sid), \"-----\\n\",\n    \"<rc> | total refcnt  : \", $ss->[SS_REFCOUNT], \"\\n\",\n    \"<rc> | event count   : \", $self->_data_ev_get_count_to($sid), \"\\n\",\n    \"<rc> | post count    : \", $self->_data_ev_get_count_from($sid), \"\\n\",\n    \"<rc> | child sessions: \", scalar(keys(%{$ss->[SS_CHILDREN]})), \"\\n\",\n    \"<rc> | handles in use: \", $self->_data_handle_count_ses($sid), \"\\n\",\n    \"<rc> | aliases in use: \", $self->_data_alias_count_ses($sid), \"\\n\",\n    \"<rc> | extra refs    : \", $self->_data_extref_count_ses($sid), \"\\n\",\n    \"<rc> | pid count     : \", $self->_data_sig_session_awaits_pids($sid), \"\\n\",\n    \"<rc> +---------------------------------------------------\\n\",\n  );\n\n  unless ($ss->[SS_REFCOUNT] and $self->_data_sig_session_awaits_pids($sid)) {\n    _warn(\n      \"<rc> | \", $self->_data_alias_loggable($sid),\n      \" is eligible for garbage collection.\\n\",\n      \"<rc> +---------------------------------------------------\\n\",\n    );\n  }\n\n  _carp \"<rc> | called\";\n}\n\n# Query a session's reference count.  Added for testing purposes.\n\nsub _data_ses_refcount {\n  my ($self, $sid) = @_;\n  return $kr_sessions{$sid}->[SS_REFCOUNT];\n}\n\n### Compatibility function to do a GC sweep on attempted garbage\n### collection.  The tests still try to call this.\n\nsub _data_ses_collect_garbage {\n  my ($self, $sid) = @_;\n  # TODO - Deprecation warning.\n  $self->_data_ses_gc_sweep();\n}\n\n### Return the number of sessions we know about.\n\nsub _data_ses_count {\n  return scalar keys %kr_sessions;\n}\n\n### Close down a session by force.\n\n# Stop a session, dispatching _stop, _parent, and _child as necessary.\n#\n# Dispatch _stop to a session, removing it from the kernel's data\n# structures as a side effect.\n\nmy %already_stopping;\n\nsub _data_ses_stop {\n  my ($self, $sid) = @_;\n\n  # Don't stop a session that's already in the throes of stopping.\n  # This can happen with exceptions, during die() in _stop.  It can\n  # probably be removed if exceptions are.\n\n  return if exists $already_stopping{$sid};\n  $already_stopping{$sid} = 1;\n\n  TRACE_REFCNT and _warn \"<rc> stopping session $sid\";\n\n  if (ASSERT_DATA) {\n    _trap(\"stopping a nonexistent session\") unless exists $kr_sessions{$sid};\n  }\n\n  if (TRACE_SESSIONS) {\n    _warn(\"<ss> stopping \", $self->_data_alias_loggable($sid));\n  }\n\n  # Maintain referential integrity between parents and children.\n  # First move the children of the stopping session up to its parent.\n  my $parent = $self->_data_ses_get_parent($sid);\n\n  foreach my $child ($self->_data_ses_get_children($sid)) {\n    $self->_dispatch_event(\n      $parent, $self,\n      EN_CHILD, ET_CHILD, [ CHILD_GAIN, $child ],\n      __FILE__, __LINE__, undef, monotime(), -__LINE__\n    );\n    $self->_dispatch_event(\n      $child, $self,\n      EN_PARENT, ET_PARENT,\n      [ $self->_data_ses_get_parent($child->ID), $parent, ],\n      __FILE__, __LINE__, undef, monotime(), -__LINE__\n    );\n  }\n\n  # Referential integrity has been dealt with.  Now notify the session\n  # that it has been stopped.\n\n  my $session = $kr_sessions{$sid}[SS_SESSION];\n  my $stop_return = $self->_dispatch_event(\n    $session, $self->get_active_session(),\n    EN_STOP, ET_STOP, [],\n    __FILE__, __LINE__, undef, monotime(), -__LINE__\n  );\n\n  # If the departing session has a parent, notify it that the session\n  # is being lost.\n\n  if (defined $parent) {\n    $self->_dispatch_event(\n      $parent, $self,\n      EN_CHILD, ET_CHILD, [ CHILD_LOSE, $session, $stop_return ],\n      __FILE__, __LINE__, undef, monotime(), -__LINE__\n    );\n  }\n\n  # Deallocate the session.\n\n  $self->_data_ses_free($sid);\n\n  # Stop the main loop if everything is gone.\n  # XXX - Under Tk this is called twice.  Why?  WHY is it called twice?\n  unless (keys %kr_sessions) {\n    $self->loop_halt();\n  }\n\n  delete $already_stopping{$sid};\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Sessions - internal session manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::Sessi", 8192) = 8192
09:01:57.069745 brk(0xbaf000)           = 0xbaf000
09:01:57.070081 lseek(4, 16220, SEEK_SET) = 16220
09:01:57.070130 lseek(4, 0, SEEK_CUR)   = 16220
09:01:57.070175 close(4)                = 0
09:01:57.070265 stat("modules/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070332 stat("modules/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070391 stat("modules/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070447 stat("modules/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070505 stat("/etc/perl/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070563 stat("/etc/perl/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070621 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070680 stat("/usr/local/lib/perl/5.14.2/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070739 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070798 stat("/usr/local/share/perl/5.14.2/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070857 stat("/usr/lib/perl5/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.070915 stat("/usr/lib/perl5/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.070973 stat("/usr/share/perl5/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071031 stat("/usr/share/perl5/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.071089 stat("/usr/lib/perl/5.14/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071148 stat("/usr/lib/perl/5.14/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.071207 stat("/usr/share/perl/5.14/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071267 stat("/usr/share/perl/5.14/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.071326 stat("/usr/local/lib/site_perl/POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071383 stat("/usr/local/lib/site_perl/POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.071442 stat("./POE/XS/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071498 stat("./POE/XS/Resource/Signals.pm", 0x7ffe1233b5d0) = -1 ENOENT (No such file or directory)
09:01:57.071596 stat("modules/POE/Resource/Signals.pmc", 0x7ffe1233b680) = -1 ENOENT (No such file or directory)
09:01:57.071656 stat("modules/POE/Resource/Signals.pm", {st_mode=S_IFREG|0600, st_size=29206, ...}) = 0
09:01:57.071724 open("modules/POE/Resource/Signals.pm", O_RDONLY) = 4
09:01:57.071784 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b360) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.071840 lseek(4, 0, SEEK_CUR)   = 0
09:01:57.071910 read(4, "# The data necessary to manage signals, and the accessors to get at\n# that data in a sane fashion.\n\npackage POE::Resource::Signals;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\n# These methods are folded into POE::Kernel;\npackage POE::Kernel;\n\nuse strict;\n\nuse POE::Pipe::OneWay;\nuse POE::Resource::FileHandles;\nuse POSIX qw(:sys_wait_h sigprocmask SIG_SETMASK);\n\n### Map watched signal names to the sessions that are watching them\n### and the events that must be delivered when they occur.\n\nsub SEV_EVENT   () { 0 }\nsub SEV_ARGS    () { 1 }\nsub SEV_SESSION () { 2 }\n\nmy %kr_signals;\n#  ( $signal_name =>\n#    { $session_id =>\n#     [ $event_name,    SEV_EVENT\n#       $event_args,    SEV_ARGS\n#       $session_ref,   SEV_SESSION\n#     ],\n#      ...,\n#    },\n#    ...,\n#  );\n\nmy %kr_sessions_to_signals;\n#  ( $session_id =>\n#    { $signal_name =>\n#      [ $event_name,   SEV_EVENT\n#        $event_args,   SEV_ARGS\n#        $session_ref,  SEV_SESSION\n#      ],\n#      ...,\n#    },\n#    ...,\n#  );\n\nmy %kr_pids_to_events;\n# { $pid =>\n#   { $session_id =>\n#     [ $blessed_session,   # PID_SESSION\n#       $event_name,        # PID_EVENT\n#       $args,              # PID_ARGS\n#     ]\n#   }\n# }\n\nmy %kr_sessions_to_pids;\n# { $session_id => { $pid => 1 } }\n\nsub PID_SESSION () { 0 }\nsub PID_EVENT   () { 1 }\nsub PID_ARGS    () { 2 }\n\nsub _data_sig_relocate_kernel_id {\n  my ($self, $old_id, $new_id) = @_;\n\n  while (my ($signal, $sig_rec) = each %kr_signals) {\n    next unless exists $sig_rec->{$old_id};\n    $sig_rec->{$new_id} = delete $sig_rec->{$old_id};\n  }\n\n  $kr_sessions_to_signals{$new_id} = delete $kr_sessions_to_signals{$old_id}\n    if exists $kr_sessions_to_signals{$old_id};\n\n  while (my ($pid, $pid_rec) = each %kr_pids_to_events) {\n    next unless exists $pid_rec->{$old_id};\n    $pid_rec->{$new_id} = delete $pid_rec->{$old_id};\n  }\n\n  $kr_sessions_to_pids{$new_id} = delete $kr_sessions_to_pids{$old_id}\n    if exists $kr_sessions_to_pids{$old_id};\n}\n\n# Bookkeeping per dispatched signal.\n\n# TODO - Why not lexicals?\nuse vars (\n '@kr_signaled_sessions',            # The sessions touched by a signal.\n '$kr_signal_total_handled',         # How many sessions handled a signal.\n '$kr_signal_type',                  # The type of signal being dispatched.\n);\n\n#my @kr_signaled_sessions;           # The sessions touched by a signal.\n#my $kr_signal_total_handled;        # How many sessions handled a signal.\n#my $kr_signal_type;                 # The type of signal being dispatched.\n\n# A flag to tell whether we're currently polling for signals.\n# Under USE_SIGCHLD, determines whether a SIGCHLD polling event has\n# already been queued.\nmy $polling_for_signals = 0;\n\n# There may be latent subprocesses in some environments.\n# Or we may need to \"always loop once\" if we're polling for SIGCHLD.\n# This constant lets us define those exceptional cases.\n# We had some in the past, but as of 2013-10-06 we seem to have\n# eliminated those special cases.\nuse constant BASE_SIGCHLD_COUNT => 0;\n\nmy $kr_has_child_procs = BASE_SIGCHLD_COUNT;\n\n# A list of special signal types.  Signals that aren't listed here are\n# benign (they do not kill sessions at all).  \"Terminal\" signals are\n# the ones that UNIX defaults to killing processes with.  Thus STOP is\n# not terminal.\n\nsub SIGTYPE_BENIGN      () { 0x00 }\nsub SIGTYPE_TERMINAL    () { 0x01 }\nsub SIGTYPE_NONMASKABLE () { 0x02 }\n\nmy %_signal_types = (\n  QUIT => SIGTYPE_TERMINAL,\n  INT  => SIGTYPE_TERMINAL,\n  KILL => SIGTYPE_TERMINAL,\n  TERM => SIGTYPE_TERMINAL,\n  HUP  => SIGTYPE_TERMINAL,\n  IDLE => SIGTYPE_TERMINAL,\n  DIE  => SIGTYPE_TERMINAL,\n  ZOMBIE    => SIGTYPE_NONMASKABLE,\n  UIDESTROY => SIGTYPE_NONMASKABLE,\n);\n\n# Build a list of useful, real signals.  Nonexistent signals, and ones\n# which are globally unhandled, usually cause segmentation faults if\n# perl was poorly configured.  Some signals aren't available in some\n# environments.\n\nmy %_safe_signals;\n\nsub _data_sig_initialize {\n  my $self = shift;\n\n  $self->_data_sig_reset_procs;\n\n  $poe_kernel->[KR_SIGNALS] = \\%kr_signals;\n  $poe_kernel->[KR_PIDS]    = \\%kr_pids_to_events;\n\n  # In case we're called multiple times.\n  unless (keys %_safe_signals) {\n    foreach my $signal (keys %SIG) {\n\n      # Nonexistent signals, and ones which are globally unhandled.\n      next if (\n        $signal =~ /^\n          ( NUM\\d+\n          |__[A-Z0-9]+__\n          |ALL|CATCHALL|DEFER|HOLD|IGNORE|MAX|PAUSE\n          |RTMIN|RTMAX|SETS\n          |SEGV\n          |\n          )\n        $/x\n      );\n\n      # Windows doesn't have a SIGBUS, but the debugger causes SIGBUS\n      # to be entered into %SIG.  It's fatal to register its handler.\n      next if $signal eq 'BUS' and RUNNING_IN_HELL;\n\n      # Apache uses SIGCHLD and/or SIGCLD itself, so we can't.\n      next if $signal =~ /^CH?LD$/ and exists $INC{'Apache.pm'};\n\n      $_safe_signals{$signal} = 1;\n    }\n\n    # Reset some important signal handlers.  The rest remain\n    # untouched.\n\n    $self->loop_ignore_signal(\"CHLD\") if exists $SIG{CHLD};\n    $self->loop_ignore_signal(\"CLD\")  if exists $SIG{CLD};\n    $self->loop_ignore_signal(\"PIPE\") if exists $SIG{PIPE};\n\n    $self->_data_sig_pipe_build if USE_SIGNAL_PIPE;\n  }\n}\n\nsub _data_sig_has_forked {\n  my( $self ) = @_;\n  $self->_data_sig_reset_procs;\n  if( USE_SIGNAL_PIPE ) {\n    $self->_data_sig_mask_all;\n    $self->_data_sig_pipe_finalize;\n    $self->_data_sig_pipe_build;\n    $self->_data_sig_unmask_all;\n  }\n}\n\nsub _data_sig_reset_procs {\n  my $self = shift;\n  # Initialize this to a true value so our waitpid() loop can run at\n  # least once.  Starts false when running in an Apache handler so our\n  # SIGCHLD hijinks don't interfere with the web server.\n  $self->_data_sig_cease_polling();\n  $kr_has_child_procs = BASE_SIGCHLD_COUNT;\n}\n\n\n### Return signals that are safe to manipulate.\n\nsub _data_sig_get_safe_signals {\n  return keys %_safe_signals;\n}\n\n### End-run leak checking.\nour $finalizing;\n\nsub _data_sig_finalize {\n  my( $self ) = @_;\n  my $finalized_ok = 1;\n  # tell _data_sig_pipe_send to ignore CHLD that waitpid might provoke\n  local $finalizing = 1;\n\n  $self->_data_sig_pipe_finalize;\n\n  while (my ($sig, $sig_rec) = each(%kr_signals)) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked signal $sig\\n\";\n    while (my ($sid, $ses_rec) = each(%{$kr_signals{$sig}})) {\n      my ($event, $args, $session) = @$ses_rec;\n      _warn \"!!!\\t$sid = $session -> $event (@$args)\\n\";\n    }\n  }\n\n  while (my ($sid, $ses_rec) = each(%kr_sessions_to_signals)) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked signal cross-reference: $sid\\n\";\n    while (my ($sig, $sig_rec) = each(%{$kr_signals{$sid}})) {\n      my ($event, $args) = @$sig_rec;\n      _warn \"!!!\\t$sig = $event (@$args)\\n\";\n    }\n  }\n\n  while (my ($sid, $pid_rec) = each(%kr_sessions_to_pids)) {\n    $finalized_ok = 0;\n    my @pids = keys %$pid_rec;\n    _warn \"!!! Leaked session to PID map: $sid -> (@pids)\\n\";\n  }\n\n  while (my ($pid, $ses_rec) = each(%kr_pids_to_events)) {\n    $finalized_ok = 0;\n    _warn \"!!! Leaked PID to event map: $pid\\n\";\n    while (my ($sid, $ev_rec, $ses) = each %$ses_rec) {\n      _warn \"!!!\\t$ses -> $ev_rec->[PID_EVENT] (@{$ev_rec->[PID_ARGS]})\\n\";\n    }\n  }\n\n  if ($kr_has_child_procs) {\n    _warn \"!!! Kernel has $kr_has_child_procs child process(es).\\n\";\n  }\n\n  if ($polling_for_signals) {\n    _warn \"!!! Finalizing signals while polling is active.\\n\";\n  }\n\n  if (USE_SIGNAL_PIPE and $self->_data_sig_pipe_has_signals()) {\n    _warn \"!!! Finalizing signals while signal pipe contains messages.\\n\";\n  }\n\n  if (exists $kr_signals{CHLD}) {\n    _warn \"!!! Finalizing signals while a blanket _child signal is watched.\\n\";\n  }\n\n  %_safe_signals = ();\n\n  unless (RUNNING_IN_HELL) {\n    local $!;\n    local $?;\n\n    my $leaked_children = 0;\n\n    PROCESS: until ((my $pid = waitpid( -1, WNOHANG )) == -1) {\n      $finalized_ok = 0;\n      $leaked_children++;\n\n      if ($pid == 0) {\n        _warn(\n          \"!!! At least one child process is still running \" .\n          \"when POE::Kernel->run() is ready to return.\\n\"\n        );\n        last PROCESS;\n      }\n\n      _warn(\n        \"!!! Stopped child process (PID $pid) reaped \" .\n          \"when", 8192) = 8192
09:01:57.073317 read(4, " POE::Kernel->run() is ready to return.\\n\"\n      );\n    }\n\n    if ($leaked_children) {\n      _warn(\"!!! Be sure to use sig_child() to reap child processes.\\n\");\n      _warn(\"!!! In extreme cases, failure to reap child processes has\\n\");\n      _warn(\"!!! resulted in a slow 'fork bomb' that has halted systems.\\n\");\n    }\n  }\n\n  return $finalized_ok;\n}\n\n### Add a signal to a session.\n\nsub _data_sig_add {\n  my ($self, $session, $signal, $event, $args) = @_;\n\n  my $sid = $session->ID;\n  $kr_sessions_to_signals{$sid}->{$signal} = [ $event, $args || [], $session ];\n  $self->_data_sig_signal_watch($sid, $signal);\n  $kr_signals{$signal}->{$sid} = [ $event, $args || [], $session ];\n}\n\nsub _data_sig_signal_watch {\n  my ($self, $sid, $signal) = @_;\n\n  # TODO - $sid not used?\n\n  # First session to watch the signal.\n  # Ask the event loop to watch the signal.\n  if (\n    !exists($kr_signals{$signal}) and\n    exists($_safe_signals{$signal}) and\n    ($signal ne \"CHLD\" or !scalar(keys %kr_sessions_to_pids))\n  ) {\n    $self->loop_watch_signal($signal);\n  }\n}\n\nsub _data_sig_signal_ignore {\n  my ($self, $sid, $signal) = @_;\n\n  # TODO - $sid not used?\n\n  if (\n    !exists($kr_signals{$signal}) and\n    exists($_safe_signals{$signal}) and\n    ($signal ne \"CHLD\" or !scalar(keys %kr_sessions_to_pids))\n  ) {\n    $self->loop_ignore_signal($signal);\n  }\n}\n\n### Remove a signal from a session.\n\nsub _data_sig_remove {\n  my ($self, $sid, $signal) = @_;\n\n  delete $kr_sessions_to_signals{$sid}->{$signal};\n  delete $kr_sessions_to_signals{$sid}\n    unless keys(%{$kr_sessions_to_signals{$sid}});\n\n  delete $kr_signals{$signal}->{$sid};\n\n  # Last watcher for that signal.  Stop watching it internally.\n  unless (keys %{$kr_signals{$signal}}) {\n    delete $kr_signals{$signal};\n    $self->_data_sig_signal_ignore($sid, $signal);\n  }\n}\n\n### Clear all the signals from a session.\n\n# XXX - It's ok to clear signals from a session that doesn't exist.\n# Usually it means that the signals are being cleared, but it might\n# mean that the session really doesn't exist.  Should we care?\n\nsub _data_sig_clear_session {\n  my ($self, $sid) = @_;\n\n  if (exists $kr_sessions_to_signals{$sid}) { # avoid autoviv\n    foreach (keys %{$kr_sessions_to_signals{$sid}}) {\n      $self->_data_sig_remove($sid, $_);\n    }\n  }\n\n  if (exists $kr_sessions_to_pids{$sid}) { # avoid autoviv\n    foreach (keys %{$kr_sessions_to_pids{$sid}}) {\n      $self->_data_sig_pid_ignore($sid, $_);\n    }\n  }\n}\n\n### Watch and ignore PIDs.\n\nsub _data_sig_pid_watch {\n  my ($self, $session, $pid, $event, $args) = @_;\n\n  my $sid = $session->ID;\n\n  $kr_pids_to_events{$pid}{$sid} = [\n    $session, # PID_SESSION\n    $event,   # PID_EVENT\n    $args,    # PID_ARGS\n  ];\n\n  $self->_data_sig_signal_watch($sid, \"CHLD\");\n\n  $kr_sessions_to_pids{$sid}{$pid} = 1;\n  $self->_data_ses_refcount_inc($sid);\n\n  # Assume there's a child process.  This will be corrected on the\n  # next polling interval.\n  $kr_has_child_procs++ unless USE_SIGCHLD;\n}\n\nsub _data_sig_pid_ignore {\n  my ($self, $sid, $pid) = @_;\n\n  # Remove PID to event mapping.\n\n  delete $kr_pids_to_events{$pid}{$sid};\n  delete $kr_pids_to_events{$pid} unless (\n    keys %{$kr_pids_to_events{$pid}}\n  );\n\n  # Remove session to PID mapping.\n\n  delete $kr_sessions_to_pids{$sid}{$pid};\n  unless (keys %{$kr_sessions_to_pids{$sid}}) {\n    delete $kr_sessions_to_pids{$sid};\n    $self->_data_sig_signal_ignore($sid, \"CHLD\");\n  }\n\n  $self->_data_ses_refcount_dec($sid);\n}\n\nsub _data_sig_session_awaits_pids {\n  my ($self, $sid) = @_;\n\n  # There must be child processes or pending signals.\n  # Watching PIDs doesn't matter if there are none to be reaped.\n  return 0 unless $kr_has_child_procs or $self->_data_sig_pipe_has_signals();\n\n  # This session is watching at least one PID with sig_child().\n  # TODO - Watching a non-existent PID is legal but ill-advised.\n  return 1 if exists $kr_sessions_to_pids{$sid};\n\n  # Is the session waiting for a blanket sig(CHLD)?\n  return(\n    (exists $kr_sessions_to_signals{$sid}) &&\n    (exists $kr_sessions_to_signals{$sid}{CHLD})\n  );\n}\n\nsub _data_sig_pids_is_ses_watching {\n  my ($self, $sid, $pid) = @_;\n  return(\n    exists($kr_sessions_to_pids{$sid}) &&\n    exists($kr_sessions_to_pids{$sid}{$pid})\n  );\n}\n\n### Return a signal's type, or SIGTYPE_BENIGN if it's not special.\n\nsub _data_sig_type {\n  my ($self, $signal) = @_;\n  return $_signal_types{$signal} || SIGTYPE_BENIGN;\n}\n\n### Flag a signal as being handled by some session.\n\nsub _data_sig_handled {\n  my $self = shift;\n  $kr_signal_total_handled++;\n}\n\n### Clear the structures associated with a signal's \"handled\" status.\n\nsub _data_sig_reset_handled {\n  my ($self, $signal) = @_;\n  undef $kr_signal_total_handled;\n  $kr_signal_type = $self->_data_sig_type($signal);\n  undef @kr_signaled_sessions;\n}\n\n### Is the signal explicitly watched?\n\nsub _data_sig_explicitly_watched {\n  my ($self, $signal) = @_;\n  return exists $kr_signals{$signal};\n}\n\n### Return the signals watched by a session and the events they\n### generate.  TODO Used mainly for testing, but may also be useful\n### for introspection.\n\nsub _data_sig_watched_by_session {\n  my ($self, $sid) = @_;\n  return unless exists $kr_sessions_to_signals{$sid};\n  return %{$kr_sessions_to_signals{$sid}};\n}\n\n### Which sessions are watching a signal?\n\nsub _data_sig_watchers {\n  my ($self, $signal) = @_;\n  return %{$kr_signals{$signal}};\n}\n\n### Return the current signal's handled status.\n### TODO Used for testing.\n\nsub _data_sig_handled_status {\n  return(\n    $kr_signal_total_handled,\n    $kr_signal_type,\n    \\@kr_signaled_sessions,\n  );\n}\n\n### Determine if a given session is watching a signal.  This uses a\n### two-step exists so that the longer one does not autovivify keys in\n### the shorter one.\n\nsub _data_sig_is_watched_by_session {\n  my ($self, $signal, $sid) = @_;\n  return(\n    exists($kr_signals{$signal}) &&\n    exists($kr_signals{$signal}->{$sid})\n  );\n}\n\n### Destroy sessions touched by a nonmaskable signal or by an\n### unhandled terminal signal.  Check for garbage-collection on\n### sessions which aren't to be terminated.\n\nsub _data_sig_free_terminated_sessions {\n  my $self = shift;\n\n  if (\n    ($kr_signal_type & SIGTYPE_NONMASKABLE) or\n    ($kr_signal_type & SIGTYPE_TERMINAL and !$kr_signal_total_handled)\n  ) {\n    foreach my $dead_session (@kr_signaled_sessions) {\n      next unless $self->_data_ses_exists($dead_session->ID);\n\n      if (TRACE_SIGNALS) {\n        _warn(\n          \"<sg> stopping signaled session \",\n          $self->_data_alias_loggable($dead_session->ID)\n        );\n      }\n\n      $self->_data_ses_stop($dead_session->ID);\n    }\n  }\n\n  # Erase @kr_signaled_sessions, or they will leak until the next\n  # signal.\n  @kr_signaled_sessions = ();\n}\n\n### A signal has touched a session.  Record this fact for later\n### destruction tests.\n\nsub _data_sig_touched_session {\n  my ($self, $session) = @_;\n  push @kr_signaled_sessions, $session;\n}\n\n# only used under !USE_SIGCHLD\nsub _data_sig_begin_polling {\n  my ($self, $signal) = @_;\n\n  return if $polling_for_signals;\n  $polling_for_signals = 1;\n\n  $self->_data_sig_enqueue_poll_event($signal);\n  $self->_idle_queue_grow();\n}\n\n# only used under !USE_SIGCHLD\nsub _data_sig_cease_polling {\n  $polling_for_signals = 0;\n}\n\nsub _data_sig_enqueue_poll_event {\n  my ($self, $signal) = @_;\n\n  if ( USE_SIGCHLD ) {\n    return if $polling_for_signals;\n    $polling_for_signals = 1;\n\n    $self->_data_ev_enqueue(\n      $self, $self, EN_SCPOLL, ET_SCPOLL, [ $signal ],\n      __FILE__, __LINE__, undef\n    );\n  } else {\n    return if $self->_data_ses_count() < 1;\n    return unless $polling_for_signals;\n\n    $self->_data_ev_enqueue(\n      $self, $self, EN_SCPOLL, ET_SCPOLL, [ $signal ],\n      __FILE__, __LINE__, undef, walltime(), POE::Kernel::CHILD_POLLING_INTERVAL(),\n    );\n  }\n}\n\nsub _data_sig_handle_poll_event {\n  my ($self, $signal) = @_;\n\n  if ( USE_SIGCHLD ) {\n    $polling_for_signals = undef;\n  }\n\n  if (TRACE_SIGNALS) {\n    _warn(\n      \"<sg> POE::Kernel is polling for signals at \" . monotime() .\n      (USE_SIGCHLD ? \" due to SIGCHLD\" : \"\")\n    );\n  }\n\n  $self->_data_sig_reap_pids();\n\n  # The poll loop is over.  Resume slowly polling for signals.\n\n  if (US", 8192) = 8192
09:01:57.073784 brk(0xbd0000)           = 0xbd0000
09:01:57.074608 read(4, "E_SIGCHLD) {\n    if (TRACE_SIGNALS) {\n      _warn(\"<sg> POE::Kernel has reset the SIG$signal handler\");\n    }\n    # Per https://rt.cpan.org/Ticket/Display.html?id=45109 setting the\n    # signal handler must be done after reaping the outstanding child\n    # processes, at least on SysV systems like HP-UX.\n    $SIG{$signal} = \\&_loop_signal_handler_chld;\n  }\n  else {\n    # The poll loop is over.  Resume slowly polling for signals.\n\n    if ($polling_for_signals) {\n      if (TRACE_SIGNALS) {\n        _warn(\"<sg> POE::Kernel will poll again after a delay\");\n      }\n      $self->_data_sig_enqueue_poll_event($signal);\n    }\n    else {\n      if (TRACE_SIGNALS) {\n        _warn(\"<sg> POE::Kernel SIGCHLD poll loop paused\");\n      }\n      $self->_idle_queue_shrink();\n    }\n  }\n}\n\nsub _data_sig_reap_pids {\n  my $self = shift();\n\n  # Reap children for as long as waitpid(2) says something\n  # interesting has happened.\n  # TODO This has a possibility of an infinite loop, but so far it\n  # hasn't hasn't happened.\n\n  my $pid;\n  while ($pid = waitpid(-1, WNOHANG)) {\n    # waitpid(2) returned a process ID.  Emit an appropriate SIGCHLD\n    # event and loop around again.\n\n    if (($pid > 0) or (RUNNING_IN_HELL and $pid < -1)) {\n      if (RUNNING_IN_HELL or WIFEXITED($?) or WIFSIGNALED($?)) {\n\n        if (TRACE_SIGNALS) {\n          _warn(\"<sg> POE::Kernel detected SIGCHLD (pid=$pid; exit=$?)\");\n        }\n\n        # Check for explicit SIGCHLD watchers, and enqueue explicit\n        # events for them.\n\n        if (exists $kr_pids_to_events{$pid}) {\n          my @sessions_to_clear;\n          while (my ($sid, $ses_rec) = each %{$kr_pids_to_events{$pid}}) {\n            $self->_data_ev_enqueue(\n              $ses_rec->[PID_SESSION], $self, $ses_rec->[PID_EVENT], ET_SIGCLD,\n              [ 'CHLD', $pid, $?, @{$ses_rec->[PID_ARGS]} ],\n              __FILE__, __LINE__, undef\n            );\n            push @sessions_to_clear, $sid;\n          }\n          $self->_data_sig_pid_ignore($_, $pid) foreach @sessions_to_clear;\n        }\n\n        # Kick off a SIGCHLD cascade.\n        $self->_data_ev_enqueue(\n          $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'CHLD', $pid, $? ],\n          __FILE__, __LINE__, undef\n        );\n      }\n      elsif (TRACE_SIGNALS) {\n        _warn(\"<sg> POE::Kernel detected strange exit (pid=$pid; exit=$?\");\n      }\n\n      if (TRACE_SIGNALS) {\n        _warn(\"<sg> POE::Kernel will poll again immediately\");\n      }\n\n      next;\n    }\n\n    # The only other negative value waitpid(2) should return is -1.\n    # This is highly unlikely, but it's necessary to catch\n    # portability problems.\n    #\n    # TODO - Find a way to test this.\n\n    _trap \"internal consistency error: waitpid returned $pid\" if $pid != -1;\n\n    # If the error is an interrupted syscall, poll again right away.\n\n    if ($! == EINTR) {\n      if (TRACE_SIGNALS) {\n        _warn(\n          \"<sg> POE::Kernel's waitpid(2) was interrupted.\\n\",\n          \"POE::Kernel will poll again immediately.\\n\"\n        );\n      }\n      next;\n    }\n\n    # No child processes exist.  TODO This is different than\n    # children being present but running.  Maybe this condition\n    # could halt polling entirely, and some UNIVERSAL::fork wrapper\n    # could restart polling when processes are forked.\n\n    if ($! == ECHILD) {\n      if (TRACE_SIGNALS) {\n        _warn(\"<sg> POE::Kernel has no child processes\");\n      }\n      last;\n    }\n\n    # Some other error occurred.\n\n    if (TRACE_SIGNALS) {\n      _warn(\"<sg> POE::Kernel's waitpid(2) got error: $!\");\n    }\n    last;\n  }\n\n  # Remember whether there are more processes to reap.\n\n  $kr_has_child_procs = !$pid;\n}\n\n# Are there child processes worth waiting for?\n# We don't really care if we're not polling for signals.\n\nsub _data_sig_kernel_awaits_pids {\n  my $self = shift();\n\n  return 0 if !USE_SIGCHLD and !$polling_for_signals;\n\n  # There must be child processes or pending signals.\n  return 0 unless $kr_has_child_procs or $self->_data_sig_pipe_has_signals();\n\n  # At least one session is watching an explicit PID.\n  # TODO - Watching a non-existent PID is legal but ill-advised.\n  return 1 if scalar keys %kr_pids_to_events;\n\n  # Is the session waiting for a blanket sig(CHLD)?\n  return exists $kr_signals{CHLD};\n}\n\n######################\n## Safe signals, the final solution:\n## Semantically, signal handlers and the main loop are in different threads.\n## To avoid all possible deadlock and race conditions once and for all we\n## implement them as shared-nothing threads.\n##\n## The signal handlers are split in 2 :\n##  - a top handler, which sends the signal number over a one-way pipe.\n##  - a bottom handler, which is called when this number is received in the\n##  main loop.\n## The top handler will send a packet of PID and number.  We need the PID\n## because of the race condition with signals in perl; signals meant for the\n## parent end up in both the parent and child.  So we check the PID to make\n## sure it was intended for the child.  We use 'ii' (2 ints, aka 8 bytes)\n## and not 'iC' (int+byte, aka 5 bytes) because we want a small factor of\n## the buffer size in the hopes of never getting a short read.  Ever.\n\nuse vars qw( $signal_pipe_read_fd );\nmy(\n  $signal_pipe_write,\n  $signal_pipe_read,\n  $signal_pipe_pid,\n  $signal_mask_none,\n  $signal_mask_all,\n\n  @pending_signals,\n);\n\nsub SIGINFO_NAME    () { 0 }\nsub SIGINFO_SRC_PID () { 1 }\n\n\nsub _data_sig_pipe_has_signals {\n  my $self = shift();\n  return unless $signal_pipe_read;\n  my $vec = '';\n  vec($vec, fileno($signal_pipe_read), 1) = 1;\n\n  # Ambiguous call resolved as CORE::select(), qualify as such or use &\n  return(CORE::select($vec, undef, undef, 0) > 0);\n}\n\n\nsub _data_sig_pipe_build {\n  my( $self ) = @_;\n  return unless USE_SIGNAL_PIPE;\n  my $fake = 128;\n\n  # Associate the pipe with this PID\n  $signal_pipe_pid = $$;\n\n  # Mess with the signal mask\n  $self->_data_sig_mask_all;\n\n  # Open the signal pipe.\n  # TODO - Normally POE::Pipe::OneWay will do the right thing.  Why\n  # are we overriding its per-platform autodetection?\n  if (RUNNING_IN_HELL) {\n    ( $signal_pipe_read, $signal_pipe_write ) = POE::Pipe::OneWay->new('inet');\n  }\n  else {\n    ( $signal_pipe_read, $signal_pipe_write ) = POE::Pipe::OneWay->new('pipe');\n  }\n\n  unless ($signal_pipe_write) {\n    _trap \"<sg> Error \" . ($!+0) . \" trying to create the signal pipe: $!\";\n  }\n\n  # Allows Resource::FileHandles to by-pass the queue\n  $signal_pipe_read_fd = fileno $signal_pipe_read;\n  if( TRACE_SIGNALS ) {\n    _warn \"<sg> signal_pipe_write=$signal_pipe_write\";\n    _warn \"<sg> signal_pipe_read=$signal_pipe_read\";\n    _warn \"<sg> signal_pipe_read_fd=$signal_pipe_read_fd\";\n  }\n\n  # Add to the select list\n  $self->_data_handle_condition( $signal_pipe_read );\n  $self->loop_watch_filehandle( $signal_pipe_read, MODE_RD );\n  $self->_data_sig_unmask_all;\n}\n\nsub _data_sig_mask_build {\n  return if RUNNING_IN_HELL;\n  $signal_mask_none  = POSIX::SigSet->new();\n  $signal_mask_none->emptyset();\n  $signal_mask_all  = POSIX::SigSet->new();\n  $signal_mask_all->fillset();\n}\n\n### Mask all signals\nsub _data_sig_mask_all {\n  return if RUNNING_IN_HELL;\n  my $self = $poe_kernel;\n  unless( $signal_mask_all ) {\n    $self->_data_sig_mask_build;\n  }\n  my $mask_temp = POSIX::SigSet->new();\n  sigprocmask( SIG_SETMASK, $signal_mask_all, $mask_temp )\n            or _trap \"<sg> Unable to mask all signals: $!\";\n}\n\n### Unmask all signals\nsub _data_sig_unmask_all {\n  return if RUNNING_IN_HELL;\n  my $self = $poe_kernel;\n  unless( $signal_mask_none ) {\n    $self->_data_sig_mask_build;\n  }\n  my $mask_temp = POSIX::SigSet->new();\n  sigprocmask( SIG_SETMASK, $signal_mask_none, $mask_temp )\n        or _trap \"<sg> Unable to unmask all signals: $!\";\n}\n\n\n\nsub _data_sig_pipe_finalize {\n  my( $self ) = @_;\n  if( $signal_pipe_read ) {\n    $self->loop_ignore_filehandle( $signal_pipe_read, MODE_RD );\n    close $signal_pipe_read; undef $signal_pipe_read;\n  }\n  if( $signal_pipe_write ) {\n    close $signal_pipe_write; undef $signal_pipe_write;\n  }\n  # Don't send anything more!\n  undef( $signal_pipe_pid );\n}\n\n### Send a signal \"message\" to the main thread\n### Called from the top signal handlers\nsub _data_sig_pipe_send {\n  local $!;\n\n  my", 8192) = 8192
09:01:57.075917 brk(0xbf1000)           = 0xbf1000
09:01:57.076362 read(4, " $signal_name = $_[1];\n\n  if( TRACE_SIGNALS ) {\n    _warn \"<sg> Caught SIG$signal_name\";\n  }\n\n  return if $finalizing;\n\n  if( not defined $signal_pipe_pid ) {\n    _trap \"<sg> _data_sig_pipe_send called before signal pipe was initialized.\";\n  }\n\n  # ugh- has_forked() can't be called fast enough.  This warning might\n  # show up before it is called.  Should we just detect forking and do it\n  # for the user?  Probably not...\n\n  if( $$ != $signal_pipe_pid ) {\n    _warn(\n      \"<sg> Signal caught in different process than POE::Kernel initialized \" .\n      \"(newPID=$$ oldPID=$signal_pipe_pid sig=$signal_name).\\n\"\n    );\n    _warn(\n      \"Call POE::Kernel->has_forked() in the child process \" .\n      \"to relocate the signal handler.\\n\"\n    );\n  }\n\n  # We're registering signals in a list.  Pipes have more finite\n  # capacity, so we'll just write a single-byte semaphore-like token.\n  # It's up to the reader to process the list.  Duplicates are\n  # permitted, and their ordering may be significant.  Precedent:\n  # http://search.cpan.org/perldoc?IPC%3A%3AMorseSignals\n\n  push @pending_signals, [\n    $signal_name, # SIGINFO_NAME\n    $$,           # SIGINFO_SRC_PID\n  ];\n\n  if (TRACE_SIGNALS) {\n    _warn \"<sg> Attempting signal pipe write\";\n  }\n\n  my $count = syswrite( $signal_pipe_write, '!' );\n\n  # TODO - We need to crash gracefully if the write fails, but not if\n  # it's due to the pipe being full.  We might solve this by only\n  # writing on the edge of @pending_signals == 1 after the push().\n  # We assume @pending_signals > 1 means there's a byte in the pipe,\n  # so the reader will wake up to catch 'em all.\n\n  if ( ASSERT_DATA ) {\n    unless (defined $count and $count == 1) {\n      _trap \"<sg> Signal pipe write failed: $!\";\n    }\n  }\n}\n\n### Read all signal numbers.\n### Call the related bottom handler.  That is, inside the kernel loop.\nsub _data_sig_pipe_read {\n  my( $self, $fileno, $mode ) = @_;\n\n  if( ASSERT_DATA ) {\n    _trap \"Illegal mode=$mode on fileno=$fileno\" unless\n                                    $fileno == $signal_pipe_read_fd\n                                and $mode eq MODE_RD;\n  }\n\n  # Read all data from the signal pipe.\n  # The data itself doesn't matter.\n  # TODO - If writes can happen on the edge of @pending_signals (from\n  # 0 to 1 element), then we oughtn't need to loop here.\n\n  while (1) {\n    my $octets_count = sysread( $signal_pipe_read, (my $data), 65536 );\n\n    next if $octets_count;\n    last if defined $octets_count;\n\n    last if $! == EAGAIN or $! == EWOULDBLOCK;\n\n    if (ASSERT_DATA) {\n      _trap \"<sg> Error \" . ($!+0) . \" reading from signal pipe: $!\";\n    }\n    elsif(TRACE_SIGNALS) {\n      _warn \"<sg> Error \" . ($!+0) . \" reading from signal pipe: $!\";\n    }\n\n    last;\n  }\n\n  # Double buffer signals.\n  # The intent is to avoid a race condition by processing the same\n  # buffer that new signals go into.\n\n  return unless @pending_signals;\n  my @signals = @pending_signals;\n  @pending_signals = ();\n\n  if (TRACE_SIGNALS) {\n    _warn \"<sg> Read \" . scalar(@signals) . \" signals from the list\";\n  }\n\n  foreach my $signal (@signals) {\n    my $signal_name    = $signal->[SIGINFO_NAME];\n    my $signal_src_pid = $signal->[SIGINFO_SRC_PID];\n\n    # Ignore signals from other processes.\n    # This can happen if we've fork()ed without calling has_forked()\n    # to reset the signals subsystem.\n    #\n    # TODO - We might be able to get rid of has_forked() if PID\n    # mismatches are detected.\n\n    next if $signal_src_pid != $$;\n\n    if( $signal_name eq 'CHLD' ) {\n      _loop_signal_handler_chld_bottom( $signal_name );\n    }\n    elsif( $signal_name eq 'PIPE' ) {\n      _loop_signal_handler_pipe_bottom( $signal_name );\n    }\n    else {\n      _loop_signal_handler_generic_bottom( $signal_name );\n    }\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Resource::Signals - internal signal manager for POE::Kernel\n\n=head1 SYNOPSIS\n\nThere is no public API.\n\n=head1 DESCRIPTION\n\nPOE::Resource::Signals is a mix-in class for POE::Kernel.  It provides\nthe features needed to manage signals.  It is used internally by\nPOE::Kernel, so it has no public interface.\n\n=head1 SEE ALSO\n\nSee L<POE::Kernel/Signals> for a deeper discussion about POE's signal\nhandling.\n\nSee L<POE::Kernel/Signal Watcher Methods> for POE's public signals\nAPI.\n\nSee L<POE::Kernel/Resources> for public information about POE\nresources.\n\nSee L<POE::Resource> for general discussion about resources and the\nclasses that manage them.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 4630
09:01:57.077179 lseek(4, 28359, SEEK_SET) = 28359
09:01:57.077236 lseek(4, 0, SEEK_CUR)   = 28359
09:01:57.077289 close(4)                = 0
09:01:57.077394 uname({sys="Linux", node="river.fysh.org", ...}) = 0
09:01:57.077590 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:01:57.077661 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.077738 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:01:57.077802 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:01:57.077858 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.077920 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:01:57.077978 rt_sigprocmask(SIG_BLOCK, [PIPE], [], 8) = 0
09:01:57.078044 rt_sigaction(SIGPIPE, {SIG_IGN, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], 0}, 8) = 0
09:01:57.078118 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:01:57.078196 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.078299 pipe([4, 5])            = 0
09:01:57.078367 ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bb60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.078421 lseek(4, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.078474 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bb60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.078526 lseek(5, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.078577 fcntl(4, F_SETFD, FD_CLOEXEC) = 0
09:01:57.078628 fcntl(5, F_SETFD, FD_CLOEXEC) = 0
09:01:57.078703 fcntl(4, F_GETFL)       = 0 (flags O_RDONLY)
09:01:57.078755 fcntl(4, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.078823 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.078928 stat("modules/POE/Session.pmc", 0x7ffe1233bca0) = -1 ENOENT (No such file or directory)
09:01:57.078987 stat("modules/POE/Session.pm", {st_mode=S_IFREG|0600, st_size=56038, ...}) = 0
09:01:57.079052 open("modules/POE/Session.pm", O_RDONLY) = 6
09:01:57.079110 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b980) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.079162 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.079224 read(6, "package POE::Session;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw(carp croak);\nuse Errno;\n\nsub SE_NAMESPACE    () { 0 }\nsub SE_OPTIONS      () { 1 }\nsub SE_STATES       () { 2 }\nsub SE_ID           () { 3 }\n\nsub CREATE_ARGS     () { 'args' }\nsub CREATE_OPTIONS  () { 'options' }\nsub CREATE_INLINES  () { 'inline_states' }\nsub CREATE_PACKAGES () { 'package_states' }\nsub CREATE_OBJECTS  () { 'object_states' }\nsub CREATE_HEAP     () { 'heap' }\n\nsub OPT_TRACE       () { 'trace' }\nsub OPT_DEBUG       () { 'debug' }\nsub OPT_DEFAULT     () { 'default' }\n\nsub EN_START        () { '_start' }\nsub EN_DEFAULT      () { '_default' }\nsub EN_SIGNAL       () { '_signal' }\n\n#------------------------------------------------------------------------------\n# Debugging flags for subsystems.  They're done as double evals here\n# so that someone may define them before using POE::Session (or POE),\n# and the pre-defined value will take precedence over the defaults\n# here.\n\n# Shorthand for defining an assert constant.\n\nsub _define_assert {\n  no strict 'refs';\n  foreach my $name (@_) {\n\n    local $^W = 0;\n\n    next if defined *{\"ASSERT_$name\"}{CODE};\n    if (defined *{\"POE::Kernel::ASSERT_$name\"}{CODE}) {\n      eval(\n        \"sub ASSERT_$name () { \" .\n        *{\"POE::Kernel::ASSERT_$name\"}{CODE}->() .\n        \"}\"\n      );\n      die if $@;\n    }\n    else {\n      eval \"sub ASSERT_$name () { ASSERT_DEFAULT }\";\n      die if $@;\n    }\n  }\n}\n\n# Shorthand for defining a trace constant.\nsub _define_trace {\n  no strict 'refs';\n\n  local $^W = 0;\n\n  foreach my $name (@_) {\n    next if defined *{\"TRACE_$name\"}{CODE};\n    if (defined *{\"POE::Kernel::TRACE_$name\"}{CODE}) {\n      eval(\n        \"sub TRACE_$name () { \" .\n        *{\"POE::Kernel::TRACE_$name\"}{CODE}->() .\n        \"}\"\n      );\n      die if $@;\n    }\n    else {\n      eval \"sub TRACE_$name () { TRACE_DEFAULT }\";\n      die if $@;\n    }\n  }\n}\n\nBEGIN {\n\n  # ASSERT_DEFAULT changes the default value for other ASSERT_*\n  # constants.  It inherits POE::Kernel's ASSERT_DEFAULT value, if\n  # it's present.\n\n  unless (defined &ASSERT_DEFAULT) {\n    if (defined &POE::Kernel::ASSERT_DEFAULT) {\n      eval( \"sub ASSERT_DEFAULT () { \" . &POE::Kernel::ASSERT_DEFAULT . \" }\" );\n    }\n    else {\n      eval 'sub ASSERT_DEFAULT () { 0 }';\n    }\n  };\n\n  # TRACE_DEFAULT changes the default value for other TRACE_*\n  # constants.  It inherits POE::Kernel's TRACE_DEFAULT value, if\n  # it's present.\n\n  unless (defined &TRACE_DEFAULT) {\n    if (defined &POE::Kernel::TRACE_DEFAULT) {\n      eval( \"sub TRACE_DEFAULT () { \" . &POE::Kernel::TRACE_DEFAULT . \" }\" );\n    }\n    else {\n      eval 'sub TRACE_DEFAULT () { 0 }';\n    }\n  };\n\n  _define_assert(\"STATES\");\n  _define_trace(\"DESTROY\");\n}\n\n#------------------------------------------------------------------------------\n# Export constants into calling packages.  This is evil; perhaps\n# EXPORT_OK instead?  The parameters NFA has in common with SESSION\n# (and other sessions) must be kept at the same offsets as each-other.\n\nsub OBJECT  () {  0 } # TODO - deprecate and replace with SELF\nsub SESSION () {  1 }\nsub KERNEL  () {  2 }\nsub HEAP    () {  3 }\nsub STATE   () {  4 } # TODO - deprecate and replace with EVENT\nsub SENDER  () {  5 }\n# NFA keeps its state in 6.  unused in session so that args match up.\nsub CALLER_FILE () { 7 }\nsub CALLER_LINE () { 8 }\nsub CALLER_STATE () { 9 } # TODO - deprecate and replace with CALLER_EVENT\nsub ARG0    () { 10 }\nsub ARG1    () { 11 }\nsub ARG2    () { 12 }\nsub ARG3    () { 13 }\nsub ARG4    () { 14 }\nsub ARG5    () { 15 }\nsub ARG6    () { 16 }\nsub ARG7    () { 17 }\nsub ARG8    () { 18 }\nsub ARG9    () { 19 }\n\nsub import {\n  my $package = caller();\n  no strict 'refs';\n  *{ $package . '::OBJECT'  } = \\&OBJECT;\n  *{ $package . '::SESSION' } = \\&SESSION;\n  *{ $package . '::KERNEL'  } = \\&KERNEL;\n  *{ $package . '::HEAP'    } = \\&HEAP;\n  *{ $package . '::STATE'   } = \\&STATE;\n  *{ $package . '::SENDER'  } = \\&SENDER;\n  *{ $package . '::ARG0'    } = \\&ARG0;\n  *{ $package . '::ARG1'    } = \\&ARG1;\n  *{ $package . '::ARG2'    } = \\&ARG2;\n  *{ $package . '::ARG3'    } = \\&ARG3;\n  *{ $package . '::ARG4'    } = \\&ARG4;\n  *{ $package . '::ARG5'    } = \\&ARG5;\n  *{ $package . '::ARG6'    } = \\&ARG6;\n  *{ $package . '::ARG7'    } = \\&ARG7;\n  *{ $package . '::ARG8'    } = \\&ARG8;\n  *{ $package . '::ARG9'    } = \\&ARG9;\n  *{ $package . '::CALLER_FILE' } = \\&CALLER_FILE;\n  *{ $package . '::CALLER_LINE' } = \\&CALLER_LINE;\n  *{ $package . '::CALLER_STATE' } = \\&CALLER_STATE;\n}\n\nsub instantiate {\n  my $type = shift;\n\n  croak \"$type requires a working Kernel\"\n    unless defined $POE::Kernel::poe_kernel;\n\n  my $self =\n    bless [ { }, # SE_NAMESPACE\n            { }, # SE_OPTIONS\n            { }, # SE_STATES\n          ], $type;\n\n  if (ASSERT_STATES) {\n    $self->[SE_OPTIONS]->{+OPT_DEFAULT} = 1;\n  }\n\n  return $self;\n}\n\nsub try_alloc {\n  my ($self, @args) = @_;\n  # Verify that the session has a special start state, otherwise how\n  # do we know what to do?  Don't even bother registering the session\n  # if the start state doesn't exist.\n\n  if (exists $self->[SE_STATES]->{+EN_START}) {\n    $POE::Kernel::poe_kernel->session_alloc($self, @args);\n  }\n  else {\n    carp( \"discarding session \",\n          $POE::Kernel::poe_kernel->ID_session_to_id($self),\n          \" - no '_start' state\"\n        );\n    $self = undef;\n  }\n\n  $self;\n}\n\n#------------------------------------------------------------------------------\n# New style constructor.  This uses less DWIM and more DWIS, and it's\n# more comfortable for some folks; especially the ones who don't quite\n# know WTM.\n\nsub create {\n  my ($type, @params) = @_;\n  my @args;\n\n  # We treat the parameter list strictly as a hash.  Rather than dying\n  # here with a Perl error, we'll catch it and blame it on the user.\n\n  if (@params & 1) {\n    croak \"odd number of events/handlers (missing one or the other?)\";\n  }\n  my %params = @params;\n\n  my $self = $type->instantiate(\\%params);\n\n  # Process _start arguments.  We try to do the right things with what\n  # we're given.  If the arguments are a list reference, map its items\n  # to ARG0..ARGn; otherwise make whatever the heck it is be ARG0.\n\n  if (exists $params{+CREATE_ARGS}) {\n    if (ref($params{+CREATE_ARGS}) eq 'ARRAY') {\n      push @args, @{$params{+CREATE_ARGS}};\n    }\n    else {\n      push @args, $params{+CREATE_ARGS};\n    }\n    delete $params{+CREATE_ARGS};\n  }\n\n  # Process session options here.  Several options may be set.\n\n  if (exists $params{+CREATE_OPTIONS}) {\n    if (ref($params{+CREATE_OPTIONS}) eq 'HASH') {\n      $self->[SE_OPTIONS] = $params{+CREATE_OPTIONS};\n    }\n    else {\n      croak \"options for $type constructor is expected to be a HASH reference\";\n    }\n    delete $params{+CREATE_OPTIONS};\n  }\n\n  # Get down to the business of defining states.\n\n  while (my ($param_name, $param_value) = each %params) {\n\n    # Inline states are expected to be state-name/coderef pairs.\n\n    if ($param_name eq CREATE_INLINES) {\n      croak \"$param_name does not refer to a hash\"\n        unless (ref($param_value) eq 'HASH');\n\n      while (my ($state, $handler) = each(%$param_value)) {\n        croak \"inline state for '$state' needs a CODE reference\"\n          unless (ref($handler) eq 'CODE');\n        $self->_register_state($state, $handler);\n      }\n    }\n\n    # Package states are expected to be package-name/list-or-hashref\n    # pairs.  If the second part of the pair is a arrayref, then the\n    # package methods are expected to be named after the states\n    # they'll handle.  If it's a hashref, then the keys are state\n    # names and the values are package methods that implement them.\n\n    elsif ($param_name eq CREATE_PACKAGES) {\n      croak \"$param_name does not refer to an array\"\n        unless (ref($param_value) eq 'ARRAY');\n      croak \"the array for $param_name has an odd number of elements\"\n        if (@$param_value & 1);\n\n      # Copy the parameters so they aren't destroyed.\n      my @param_value = @$param_value;\n      while (my ($package, $handlers) = splice(@param_value, 0, 2)) {\n\n        # TODO What do we do if the package name has some sort of\n", 8192) = 8192
09:01:57.080576 brk(0xc12000)           = 0xc12000
09:01:57.080757 read(6, "        # blessing?  Do we use the blessed thingy's package, or do we\n        # maybe complain because the user might have wanted to make\n        # object states instead?\n\n        # An array of handlers.  The array's items are passed through\n        # as both state names and package method names.\n\n        if (ref($handlers) eq 'ARRAY') {\n          foreach my $method (@$handlers) {\n            $self->_register_state($method, $package, $method);\n          }\n        }\n\n        # A hash of handlers.  Hash keys are state names; values are\n        # package methods to implement them.\n\n        elsif (ref($handlers) eq 'HASH') {\n          while (my ($state, $method) = each %$handlers) {\n            $self->_register_state($state, $package, $method);\n          }\n        }\n\n        else {\n          croak( \"states for package '$package' \" .\n                 \"need to be a hash or array ref\"\n               );\n        }\n      }\n    }\n\n    # Object states are expected to be object-reference/\n    # list-or-hashref pairs.  They must be passed to &create in a list\n    # reference instead of a hash reference because making object\n    # references into hash keys loses their blessings.\n\n    elsif ($param_name eq CREATE_OBJECTS) {\n      croak \"$param_name does not refer to an array\"\n        unless (ref($param_value) eq 'ARRAY');\n      croak \"the array for $param_name has an odd number of elements\"\n        if (@$param_value & 1);\n\n      # Copy the parameters so they aren't destroyed.\n      my @param_value = @$param_value;\n      while (@param_value) {\n        my ($object, $handlers) = splice(@param_value, 0, 2);\n\n        # Verify that the object is an object.  This may catch simple\n        # mistakes; or it may be overkill since it already checks that\n        # $param_value is a arrayref.\n\n        carp \"'$object' is not an object\" unless ref($object);\n\n        # An array of handlers.  The array's items are passed through\n        # as both state names and object method names.\n\n        if (ref($handlers) eq 'ARRAY') {\n          foreach my $method (@$handlers) {\n            $self->_register_state($method, $object, $method);\n          }\n        }\n\n        # A hash of handlers.  Hash keys are state names; values are\n        # package methods to implement them.\n\n        elsif (ref($handlers) eq 'HASH') {\n          while (my ($state, $method) = each %$handlers) {\n            $self->_register_state($state, $object, $method);\n          }\n        }\n\n        else {\n          croak \"states for object '$object' need to be a hash or array ref\";\n        }\n\n      }\n    }\n\n    # Import an external heap.  This is a convenience, since it\n    # eliminates the need to connect _start options to heap values.\n\n    elsif ($param_name eq CREATE_HEAP) {\n      $self->[SE_NAMESPACE] = $param_value;\n    }\n\n    else {\n      croak \"unknown $type parameter: $param_name\";\n    }\n  }\n\n  return $self->try_alloc(@args);\n}\n\n#------------------------------------------------------------------------------\n\nsub DESTROY {\n  my $self = shift;\n\n  # Session's data structures are destroyed through Perl's usual\n  # garbage collection.  TRACE_DESTROY here just shows what's in the\n  # session before the destruction finishes.\n\n  TRACE_DESTROY and do {\n    require Data::Dumper;\n    POE::Kernel::_warn(\n      \"----- Session $self Leak Check -----\\n\",\n      \"-- Namespace (HEAP):\\n\",\n      Data::Dumper::Dumper($self->[SE_NAMESPACE]),\n      \"-- Options:\\n\",\n    );\n    foreach (sort keys (%{$self->[SE_OPTIONS]})) {\n      POE::Kernel::_warn(\"   $_ = \", $self->[SE_OPTIONS]->{$_}, \"\\n\");\n    }\n    POE::Kernel::_warn(\"-- States:\\n\");\n    foreach (sort keys (%{$self->[SE_STATES]})) {\n      POE::Kernel::_warn(\"   $_ = \", $self->[SE_STATES]->{$_}, \"\\n\");\n    }\n  };\n}\n\n#------------------------------------------------------------------------------\n\nsub _invoke_state {\n  my ($self, $source_session, $state, $etc, $file, $line, $fromstate) = @_;\n\n  # Trace the state invocation if tracing is enabled.\n\n  if ($self->[SE_OPTIONS]->{+OPT_TRACE}) {\n    POE::Kernel::_warn(\n      $POE::Kernel::poe_kernel->ID_session_to_id($self),\n      \" -> $state (from $file at $line)\\n\"\n    );\n  }\n\n  # The desired destination state doesn't exist in this session.\n  # Attempt to redirect the state transition to _default.\n\n  unless (exists $self->[SE_STATES]->{$state}) {\n\n    # There's no _default either; redirection's not happening today.\n    # Drop the state transition event on the floor, and optionally\n    # make some noise about it.\n\n    unless (exists $self->[SE_STATES]->{+EN_DEFAULT}) {\n      $! = exists &Errno::ENOSYS ? &Errno::ENOSYS : &Errno::EIO;\n      if ($self->[SE_OPTIONS]->{+OPT_DEFAULT} and $state ne EN_SIGNAL) {\n        my $loggable_self =\n          $POE::Kernel::poe_kernel->_data_alias_loggable($self->ID);\n        POE::Kernel::_warn(\n          \"a '$state' event was sent from $file at $line to $loggable_self \",\n          \"but $loggable_self has neither a handler for it \",\n          \"nor one for _default\\n\"\n        );\n      }\n      return undef;\n    }\n\n    # If we get this far, then there's a _default state to redirect\n    # the transition to.  Trace the redirection.\n\n    if ($self->[SE_OPTIONS]->{+OPT_TRACE}) {\n      POE::Kernel::_warn(\n        $POE::Kernel::poe_kernel->ID_session_to_id($self),\n        \" -> $state redirected to _default\\n\"\n      );\n    }\n\n    # Transmogrify the original state transition into a corresponding\n    # _default invocation.  ARG1 is copied from $etc so it can't be\n    # altered from a distance.\n\n    $etc   = [ $state, [@$etc] ];\n    $state = EN_DEFAULT;\n  }\n\n  # If we get this far, then the state can be invoked.  So invoke it\n  # already!\n\n  # Inline states are invoked this way.\n\n  if (ref($self->[SE_STATES]->{$state}) eq 'CODE') {\n    return $self->[SE_STATES]->{$state}->\n      ( undef,                          # object\n        $self,                          # session\n        $POE::Kernel::poe_kernel,       # kernel\n        $self->[SE_NAMESPACE],          # heap\n        $state,                         # state\n        $source_session,                # sender\n        undef,                          # unused #6\n        $file,                          # caller file name\n        $line,                          # caller file line\n        $fromstate,                     # caller state\n        @$etc                           # args\n      );\n  }\n\n  # Package and object states are invoked this way.\n\n  my ($object, $method) = @{$self->[SE_STATES]->{$state}};\n  return\n    $object->$method                    # package/object (implied)\n      ( $self,                          # session\n        $POE::Kernel::poe_kernel,       # kernel\n        $self->[SE_NAMESPACE],          # heap\n        $state,                         # state\n        $source_session,                # sender\n        undef,                          # unused #6\n        $file,                          # caller file name\n        $line,                          # caller file line\n    $fromstate,            # caller state\n        @$etc                           # args\n      );\n}\n\n#------------------------------------------------------------------------------\n# Add, remove or replace states in the session.\n\nsub _register_state {\n  my ($self, $name, $handler, $method) = @_;\n  $method = $name unless defined $method;\n\n  # Deprecate _signal.\n  # RC 2004-09-07 - Decided to leave this in because it blames\n  # problems with _signal on the user for using it.  It should\n  # probably go away after a little while, but not during the other\n  # deprecations.\n\n  if ($name eq EN_SIGNAL) {\n\n    # Report the problem outside POE.\n    my $caller_level = 0;\n    local $Carp::CarpLevel = 1;\n    while ( (caller $caller_level)[0] =~ /^POE::/ ) {\n      $caller_level++;\n      $Carp::CarpLevel++;\n    }\n\n    croak(\n      \",----- DEPRECATION ERROR -----\\n\",\n      \"| The _signal event is deprecated.  Please use sig() to register\\n\",\n      \"| an explicit signal handler instead.\\n\",\n      \"`-----------------------------\\n\",\n   );\n  }\n\n  # There is a handler, so try to define the state.  This replaces an\n  # existing state.\n\n  if ($handler) {\n\n    # Coderef handlers are inline states.\n\n    if (ref(", 8192) = 8192
09:01:57.081775 read(6, "$handler) eq 'CODE') {\n      carp( \"redefining handler for event($name) for session(\",\n            $POE::Kernel::poe_kernel->ID_session_to_id($self), \")\"\n          )\n        if ( $self->[SE_OPTIONS]->{+OPT_DEBUG} &&\n             (exists $self->[SE_STATES]->{$name})\n           );\n      $self->[SE_STATES]->{$name} = $handler;\n    }\n\n    # Non-coderef handlers may be package or object states.  See if\n    # the method belongs to the handler.\n\n    elsif ($handler->can($method)) {\n      carp( \"redefining handler for event($name) for session(\",\n            $POE::Kernel::poe_kernel->ID_session_to_id($self), \")\"\n          )\n        if ( $self->[SE_OPTIONS]->{+OPT_DEBUG} &&\n             (exists $self->[SE_STATES]->{$name})\n           );\n      $self->[SE_STATES]->{$name} = [ $handler, $method ];\n    }\n\n    # Something's wrong.  This code also seems wrong, since\n    # ref($handler) can't be 'CODE'.\n\n    else {\n      if ( (ref($handler) eq 'CODE') and\n           $self->[SE_OPTIONS]->{+OPT_TRACE}\n         ) {\n        carp( $POE::Kernel::poe_kernel->ID_session_to_id($self),\n              \" : handler for event($name) is not a proper ref - not registered\"\n            )\n      }\n      else {\n        unless ($handler->can($method)) {\n          if (length ref($handler)) {\n            croak \"object $handler does not have a '$method' method\"\n          }\n          else {\n            croak \"package $handler does not have a '$method' method\";\n          }\n        }\n      }\n    }\n  }\n\n  # No handler.  Delete the state!\n\n  else {\n    delete $self->[SE_STATES]->{$name};\n  }\n}\n\n#------------------------------------------------------------------------------\n# Return the session's ID.  This is a thunk into POE::Kernel, where\n# the session ID really lies.\n\nsub _set_id {\n  my ($self, $id) = @_;\n  $self->[SE_ID] = $id;\n}\n\nsub ID {\n  return shift()->[SE_ID];\n}\n\n#------------------------------------------------------------------------------\n# Set or fetch session options.\n\nsub option {\n  my $self = shift;\n  my %return_values;\n\n  # Options are set in pairs.\n\n  while (@_ >= 2) {\n    my ($flag, $value) = splice(@_, 0, 2);\n    $flag = lc($flag);\n\n    # If the value is defined, then set the option.\n\n    if (defined $value) {\n\n      # Change some handy values into boolean representations.  This\n      # clobbers the user's original values for the sake of DWIM-ism.\n\n      ($value = 1) if ($value =~ /^(on|yes|true)$/i);\n      ($value = 0) if ($value =~ /^(no|off|false)$/i);\n\n      $return_values{$flag} = $self->[SE_OPTIONS]->{$flag};\n      $self->[SE_OPTIONS]->{$flag} = $value;\n    }\n\n    # Remove the option if the value is undefined.\n\n    else {\n      $return_values{$flag} = delete $self->[SE_OPTIONS]->{$flag};\n    }\n  }\n\n  # If only one option is left, then there's no value to set, so we\n  # fetch its value.\n\n  if (@_) {\n    my $flag = lc(shift);\n    $return_values{$flag} =\n      ( exists($self->[SE_OPTIONS]->{$flag})\n        ? $self->[SE_OPTIONS]->{$flag}\n        : undef\n      );\n  }\n\n  # If only one option was set or fetched, then return it as a scalar.\n  # Otherwise return it as a hash of option names and values.\n\n  my @return_keys = keys(%return_values);\n  if (@return_keys == 1) {\n    return $return_values{$return_keys[0]};\n  }\n  else {\n    return \\%return_values;\n  }\n}\n\n# Fetch the session's heap.  In rare cases, libraries may need to\n# break encapsulation this way, probably also using\n# $kernel->get_current_session as an accessory to the crime.\n\nsub get_heap {\n  my $self = shift;\n  return $self->[SE_NAMESPACE];\n}\n\n#------------------------------------------------------------------------------\n# Create an anonymous sub that, when called, posts an event back to a\n# session.  This maps postback references (stringified; blessing, and\n# thus refcount, removed) to parent session IDs.  Members are set when\n# postbacks are created, and postbacks' DESTROY methods use it to\n# perform the necessary cleanup when they go away.  Thanks to njt for\n# steering me right on this one.\n\nmy %anonevent_parent_id;\nmy %anonevent_weakened;\n\n# I assume that when the postback owner loses all reference to it,\n# they are done posting things back to us.  That's when the postback's\n# DESTROY is triggered, and referential integrity is maintained.\n\nsub POE::Session::AnonEvent::DESTROY {\n  my $self = shift;\n  my $parent_id = delete $anonevent_parent_id{$self};\n  unless (delete $anonevent_weakened{$self}) {\n    $POE::Kernel::poe_kernel->refcount_decrement( $parent_id, 'anon_event' );\n  }\n}\n\nsub POE::Session::AnonEvent::weaken {\n  my $self = shift;\n  unless ($anonevent_weakened{$self}) {\n    my $parent_id = $anonevent_parent_id{$self};\n    $POE::Kernel::poe_kernel->refcount_decrement( $parent_id, 'anon_event' );\n    $anonevent_weakened{$self} = 1;\n  }\n  return $self;\n}\n\n# Tune postbacks depending on variations in toolkit behavior.\n\nBEGIN {\n  # Tk blesses its callbacks internally, so we need to wrap our\n  # blessed callbacks in unblessed ones.  Otherwise our postback's\n  # DESTROY method probably won't be called.\n  if (exists $INC{'Tk.pm'}) {\n    eval 'sub USING_TK () { 1 }';\n  }\n  else {\n    eval 'sub USING_TK () { 0 }';\n  }\n};\n\n# Create a postback closure, maintaining referential integrity in the\n# process.  The next step is to give it to something that expects to\n# be handed a callback.\n\nsub postback {\n  my ($self, $event, @etc) = @_;\n  my $id = $POE::Kernel::poe_kernel->ID_session_to_id($self);\n\n  my $postback = bless sub {\n    $POE::Kernel::poe_kernel->post( $id, $event, [ @etc ], [ @_ ] );\n    return 0;\n  }, 'POE::Session::AnonEvent';\n\n  $anonevent_parent_id{$postback} = $id;\n  $POE::Kernel::poe_kernel->refcount_increment( $id, 'anon_event' );\n\n  # Tk blesses its callbacks, so we must present one that isn't\n  # blessed.  Otherwise Tk's blessing would divert our DESTROY call to\n  # its own, and that's not right.\n\n  return sub { $postback->(@_) } if USING_TK;\n  return $postback;\n}\n\n# Create a synchronous callback closure.  The return value will be\n# passed to whatever is handed the callback.\n\nsub callback {\n  my ($self, $event, @etc) = @_;\n  my $id = $POE::Kernel::poe_kernel->ID_session_to_id($self);\n\n  my $callback = bless sub {\n    $POE::Kernel::poe_kernel->call( $id, $event, [ @etc ], [ @_ ] );\n  }, 'POE::Session::AnonEvent';\n\n  $anonevent_parent_id{$callback} = $id;\n  $POE::Kernel::poe_kernel->refcount_increment( $id, 'anon_event' );\n\n  # Tk blesses its callbacks, so we must present one that isn't\n  # blessed.  Otherwise Tk's blessing would divert our DESTROY call to\n  # its own, and that's not right.\n\n  return sub { $callback->(@_) } if USING_TK;\n  return $callback;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Session - a generic event-driven task\n\n=head1 SYNOPSIS\n\n  use POE; # auto-includes POE::Kernel and POE::Session\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub { $_[KERNEL]->yield(\"next\") },\n      next   => sub {\n        print \"tick...\\n\";\n        $_[KERNEL]->delay(next => 1);\n      },\n    },\n  );\n\n  POE::Kernel->run();\n  exit;\n\nPOE::Session can also dispatch to object and class methods through\nL</object_states> and L</package_states> callbacks.\n\n=head1 DESCRIPTION\n\nPOE::Session and its subclasses translate events from POE::Kernel's\ngeneric dispatcher into the particular calling conventions suitable for\napplication code.  In design pattern parlance, POE::Session classes\nare adapters between L<POE::Kernel> and application code.\n\nThe L<sessions|POE::Kernel/Sessions> that POE::Kernel manages are more\nlike generic task structures.  Unfortunately these two disparate\nconcepts have virtually identical names.\n\n=head2 A note on nomenclature\n\nThis documentation will refer to event handlers as \"states\" in certain\nunavoidable situations.  Sessions were originally meant to be\nevent-driven state machines, but their purposes evolved over time.\nSome of the legacy vocabulary lives on in the API for backward\ncompatibility, however.\n\nConfusingly, L<POE::NFA> is a class for implementing actual\nevent-driven state machines.  Its documentation uses \"state\" in the\nproper sense.\n\n=head1 USING POE::Session\n\nPOE::Session has two main purposes.  First, it maps event names to the\ncode that will handle them.  Second, ", 8192) = 8192
09:01:57.082550 brk(0xc33000)           = 0xc33000
09:01:57.082896 lseek(6, 23024, SEEK_SET) = 23024
09:01:57.082949 lseek(6, 0, SEEK_CUR)   = 23024
09:01:57.083012 close(6)                = 0
09:01:57.083135 stat("modules/POE/Component/IRC.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:57.083196 stat("modules/POE/Component/IRC.pm", {st_mode=S_IFREG|0600, st_size=98882, ...}) = 0
09:01:57.083262 open("modules/POE/Component/IRC.pm", O_RDONLY) = 6
09:01:57.083320 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bfa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.083372 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.083434 read(6, "package POE::Component::IRC;\nBEGIN {\n  $POE::Component::IRC::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\nuse Carp;\nuse POE qw(Wheel::SocketFactory Wheel::ReadWrite Driver::SysRW\n           Filter::Line Filter::Stream Filter::Stackable);\nuse POE::Filter::IRCD;\nuse POE::Filter::IRC::Compat;\nuse POE::Component::IRC::Constants qw(:ALL);\nuse POE::Component::IRC::Plugin qw(:ALL);\nuse POE::Component::IRC::Plugin::DCC;\nuse POE::Component::IRC::Plugin::ISupport;\nuse POE::Component::IRC::Plugin::Whois;\nuse Socket qw(AF_INET SOCK_STREAM unpack_sockaddr_in inet_ntoa inet_aton);\nuse base qw(POE::Component::Syndicator);\n\nour ($GOT_SSL, $GOT_CLIENT_DNS, $GOT_SOCKET6, $GOT_ZLIB);\n\nBEGIN {\n    eval {\n        require POE::Component::SSLify;\n        import POE::Component::SSLify qw( Client_SSLify SSLify_ContextCreate );\n        $GOT_SSL = 1;\n    };\n    eval {\n        require POE::Component::Client::DNS;\n        $GOT_CLIENT_DNS = 1 if $POE::Component::Client::DNS::VERSION >= 0.99;\n    };\n    eval {\n        require POE::Filter::Zlib::Stream;\n        $GOT_ZLIB = 1 if $POE::Filter::Zlib::Stream::VERSION >= 1.96;\n    };\n    # Socket6 provides AF_INET6 where earlier Perls' Socket don't.\n    eval {\n        Socket->import(qw(AF_INET6 unpack_sockaddr_in6 inet_ntop));\n        $GOT_SOCKET6 = 1;\n    };\n    if (!$GOT_SOCKET6) {\n        eval {\n            require Socket6;\n            Socket6->import(qw(AF_INET6 unpack_sockaddr_in6 inet_ntop));\n            $GOT_SOCKET6 = 1;\n        };\n        if (!$GOT_SOCKET6) {\n            # provide a dummy sub so code compiles\n            *AF_INET6 = sub { ~0 };\n        }\n    }\n}\n\n# BINGOS: I have bundled up all the stuff that needs changing\n# for inherited classes into _create. This gets called from 'spawn'.\n# $self->{OBJECT_STATES_ARRAYREF} contains event mappings to methods that have\n# the same name, gets passed to POE::Session->create as $self => [ ];\n# $self->{OBJECT_STATES_HASHREF} contains event mappings to methods, where the\n# event and the method have diferent names.\n# $self->{IRC_CMDS} contains the traditional %irc_commands, mapping commands\n# to events and the priority that the command has.\nsub _create {\n    my ($self) = @_;\n\n    $self->{IRC_CMDS} = {\n        rehash    => [ PRI_HIGH,     'noargs',        ],\n        die       => [ PRI_HIGH,     'noargs',        ],\n        restart   => [ PRI_HIGH,     'noargs',        ],\n        quit      => [ PRI_NORMAL,   'oneoptarg',     ],\n        version   => [ PRI_HIGH,     'oneoptarg',     ],\n        time      => [ PRI_HIGH,     'oneoptarg',     ],\n        trace     => [ PRI_HIGH,     'oneoptarg',     ],\n        admin     => [ PRI_HIGH,     'oneoptarg',     ],\n        info      => [ PRI_HIGH,     'oneoptarg',     ],\n        away      => [ PRI_HIGH,     'oneoptarg',     ],\n        users     => [ PRI_HIGH,     'oneoptarg',     ],\n        lusers    => [ PRI_HIGH,     'oneoptarg',     ],\n        locops    => [ PRI_HIGH,     'oneoptarg',     ],\n        operwall  => [ PRI_HIGH,     'oneoptarg',     ],\n        wallops   => [ PRI_HIGH,     'oneoptarg',     ],\n        motd      => [ PRI_HIGH,     'oneoptarg',     ],\n        who       => [ PRI_HIGH,     'oneoptarg',     ],\n        nick      => [ PRI_HIGH,     'onlyonearg',    ],\n        oper      => [ PRI_HIGH,     'onlytwoargs',   ],\n        invite    => [ PRI_HIGH,     'onlytwoargs',   ],\n        squit     => [ PRI_HIGH,     'onlytwoargs',   ],\n        kill      => [ PRI_HIGH,     'onlytwoargs',   ],\n        privmsg   => [ PRI_NORMAL,   'privandnotice', ],\n        privmsglo => [ PRI_NORMAL+1, 'privandnotice', ],\n        privmsghi => [ PRI_NORMAL-1, 'privandnotice', ],\n        notice    => [ PRI_NORMAL,   'privandnotice', ],\n        noticelo  => [ PRI_NORMAL+1, 'privandnotice', ],\n        noticehi  => [ PRI_NORMAL-1, 'privandnotice', ],\n        squery    => [ PRI_NORMAL,   'privandnotice', ],\n        join      => [ PRI_HIGH,     'oneortwo',      ],\n        summon    => [ PRI_HIGH,     'oneortwo',      ],\n        sconnect  => [ PRI_HIGH,     'oneandtwoopt',  ],\n        whowas    => [ PRI_HIGH,     'oneandtwoopt',  ],\n        stats     => [ PRI_HIGH,     'spacesep',      ],\n        links     => [ PRI_HIGH,     'spacesep',      ],\n        mode      => [ PRI_HIGH,     'spacesep',      ],\n        servlist  => [ PRI_HIGH,     'spacesep',      ],\n        cap       => [ PRI_HIGH,     'spacesep',      ],\n        part      => [ PRI_HIGH,     'commasep',      ],\n        names     => [ PRI_HIGH,     'commasep',      ],\n        list      => [ PRI_HIGH,     'commasep',      ],\n        whois     => [ PRI_HIGH,     'commasep',      ],\n        ctcp      => [ PRI_HIGH,     'ctcp',          ],\n        ctcpreply => [ PRI_HIGH,     'ctcp',          ],\n        ping      => [ PRI_HIGH,     'oneortwo',      ],\n        pong      => [ PRI_HIGH,     'oneortwo',      ],\n    };\n\n    my %event_map = map {($_ => $self->{IRC_CMDS}->{$_}->[CMD_SUB])}\n        keys %{ $self->{IRC_CMDS} };\n\n    $self->{OBJECT_STATES_HASHREF} = {\n        %event_map,\n        quote => 'sl',\n    };\n\n    $self->{OBJECT_STATES_ARRAYREF} = [qw(\n        syndicator_started\n        _parseline\n        _sock_down\n        _sock_failed\n        _sock_up\n        _socks_proxy_connect\n        _socks_proxy_response\n        debug\n        connect\n        _resolve_addresses\n        _do_connect\n        _quit_timeout\n        _send_login\n        _got_dns_response\n        ison\n        kick\n        remove\n        nickserv\n        shutdown\n        sl\n        sl_login\n        sl_high\n        sl_delayed\n        sl_prioritized\n        topic\n        userhost\n    )];\n\n    return;\n}\n\n# BINGOS: the component can now configure itself via _configure() from\n# either spawn() or connect()\n## no critic (Subroutines::ProhibitExcessComplexity)\nsub _configure {\n    my ($self, $args) = @_;\n    my $spawned = 0;\n\n    if (ref $args eq 'HASH' && keys %{ $args }) {\n        $spawned = delete $args->{spawned};\n        $self->{use_localaddr} = delete $args->{localaddr};\n        @{ $self }{ keys %{ $args } } = values %{ $args };\n    }\n\n    if ($ENV{POCOIRC_DEBUG}) {\n        $self->{debug} = 1;\n        $self->{plugin_debug} = 1;\n    }\n\n    if ($self->{debug}) {\n        $self->{ircd_filter}->debug(1);\n        $self->{ircd_compat}->debug(1);\n    }\n\n    if ($self->{useipv6} && !$GOT_SOCKET6) {\n        warn \"'useipv6' option specified, but Socket6 was not found\\n\";\n    }\n\n    if ($self->{usessl} && !$GOT_SSL) {\n        warn \"'usessl' option specified, but POE::Component::SSLify was not found\\n\";\n    }\n\n    $self->{dcc}->nataddr($self->{nataddr}) if exists $self->{nataddr};\n    $self->{dcc}->dccports($self->{dccports}) if exists $self->{dccports};\n\n    $self->{port} = 6667 if !$self->{port};\n    $self->{msg_length} = 450 if !defined $self->{msg_length};\n\n    if ($self->{use_localaddr}) {\n        $self->{localaddr} = $self->{use_localaddr}\n            . ($self->{localport} ? (':'.$self->{localport}) : '');\n    }\n\n    # Make sure that we have reasonable defaults for all the attributes.\n    # The \"IRC*\" variables are ircII environment variables.\n    if (!defined $self->{nick}) {\n        $self->{nick} = $ENV{IRCNICK} || eval { scalar getpwuid($>) }\n            || $ENV{USER} || $ENV{LOGNAME} || 'WankerBot';\n    }\n\n    if (!defined $self->{username}) {\n        $self->{username} = eval { scalar getpwuid($>) } || $ENV{USER}\n            || $ENV{LOGNAME} || 'foolio';\n    }\n\n    if (!defined $self->{ircname}) {\n        $self->{ircname} = $ENV{IRCNAME} || eval { (getpwuid $>)[6] }\n            || 'Just Another Perl Hacker';\n    }\n\n    if (!defined $self->{server} && !$spawned) {\n        die \"No IRC server specified\\n\" if !$ENV{IRCSERVER};\n        $self->{server} = $ENV{IRCSERVER};\n    }\n\n    return;\n}\n\nsub debug {\n    my ($self, $switch) = @_[OBJECT, ARG0];\n\n    $self->{debug} = $switch;\n    $self->{ircd_filter}->debug( $switch );\n    $self->{ircd_compat}->debug( $switch );\n    return;\n}\n\n# Parse a message from the IRC server and generate the appropriate\n# event(s) for listening sessions.\nsub _parseline {\n    my ($session, $self, $ev) = @_[SESSION, OBJECT, ARG0];\n\n    return if !$ev->{name};\n    $self-", 8192) = 8192
09:01:57.084127 stat("modules/POE/Wheel/SocketFactory.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.084190 stat("modules/POE/Wheel/SocketFactory.pm", {st_mode=S_IFREG|0600, st_size=50239, ...}) = 0
09:01:57.084256 open("modules/POE/Wheel/SocketFactory.pm", O_RDONLY) = 7
09:01:57.084316 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.084368 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.084434 read(7, "package POE::Wheel::SocketFactory;\n\nuse strict;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw( carp croak );\nuse Symbol qw( gensym );\n\nuse Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);\nuse Errno qw(\n  EWOULDBLOCK EADDRNOTAVAIL EINPROGRESS EADDRINUSE ECONNABORTED\n  ESPIPE\n);\n\nuse Socket qw(\n  AF_INET SOCK_STREAM SOL_SOCKET AF_UNIX PF_UNIX \n  PF_INET SOCK_DGRAM SO_ERROR unpack_sockaddr_in \n  unpack_sockaddr_un PF_UNSPEC SO_REUSEADDR INADDR_ANY \n  pack_sockaddr_in pack_sockaddr_un inet_aton SOMAXCONN\n);\n\nuse IO::Handle ();\nuse FileHandle ();\nuse POE qw( Wheel );\npush @ISA, qw(POE::Wheel);\n\nsub CRIMSON_SCOPE_HACK ($) { 0 }\nsub DEBUG () { 0 }\n\nsub MY_SOCKET_HANDLE   () {  0 }\nsub MY_UNIQUE_ID       () {  1 }\nsub MY_EVENT_SUCCESS   () {  2 }\nsub MY_EVENT_FAILURE   () {  3 }\nsub MY_SOCKET_DOMAIN   () {  4 }\nsub MY_STATE_ACCEPT    () {  5 }\nsub MY_STATE_CONNECT   () {  6 }\nsub MY_MINE_SUCCESS    () {  7 }\nsub MY_MINE_FAILURE    () {  8 }\nsub MY_SOCKET_PROTOCOL () {  9 }\nsub MY_SOCKET_TYPE     () { 10 }\nsub MY_STATE_ERROR     () { 11 }\nsub MY_SOCKET_SELECTED () { 12 }\n\n# Fletch has subclassed SSLSocketFactory from SocketFactory.\n# He's added new members after MY_SOCKET_SELECTED.  Be sure, if you\n# extend this, to extend add stuff BEFORE MY_SOCKET_SELECTED or let\n# Fletch know you've broken his module.\n\n# If IPv6 support can't be loaded, then provide dummies so the code at\n# least compiles.  Suggested in rt.cpan.org 27250.\nBEGIN {\n\n  eval { Socket->import( qw(getaddrinfo unpack_sockaddr_in6) ) };\n  if ($@) {\n    *getaddrinfo = sub { Carp::confess(\"Unable to use IPv6: Socket doesn't provide getaddrinfo()\") };\n    *unpack_sockaddr_in6 = sub { Carp::confess(\"Unable to use IPv6: Socket doesn't provide unpack_sockaddr_in6()\") };\n  }\n\n  # Socket6 provides AF_INET6 and PF_INET6 where earlier Perls' Socket don't.\n  eval { Socket->import( qw(AF_INET6 PF_INET6) ) };\n  if ($@) {\n    eval { require Socket6; Socket6->import( qw(AF_INET6 PF_INET6) ) };\n    if ($@) {\n      *AF_INET6 = sub { -1 };\n      *PF_INET6 = sub { -1 };\n    }\n  }\n\n  eval { Socket->import( 'IPPROTO_TCP' ) };\n  if ($@) {\n    *IPPROTO_TCP = (getprotobyname 'tcp')[2];\n  }\n\n  eval { Socket->import( 'IPPROTO_UDP' ) };\n  if ($@) {\n    *IPPROTO_UDP = (getprotobyname 'udp')[2];\n  }\n}\n\n# Common protocols to help support systems that don't have\n# getprotobyname().\nmy %proto_by_name = (\n    tcp => IPPROTO_TCP,\n    udp => IPPROTO_UDP,\n);\n\nmy %proto_by_number = reverse %proto_by_name;\n\n#------------------------------------------------------------------------------\n# These tables customize the socketfactory.  Many protocols share the\n# same operations, it seems, and this is a way to add new ones with a\n# minimum of additional code.\n\nsub DOM_UNIX  () { 'unix'  }  # UNIX domain socket\nsub DOM_INET  () { 'inet'  }  # INET domain socket\nsub DOM_INET6 () { 'inet6' }  # INET v6 domain socket\n\n# AF_XYZ and PF_XYZ may be different.\nmy %map_family_to_domain = (\n  AF_UNIX,  DOM_UNIX,  PF_UNIX,  DOM_UNIX,\n  AF_INET,  DOM_INET,  PF_INET,  DOM_INET,\n  AF_INET6, DOM_INET6,\n  PF_INET6, DOM_INET6,\n);\n\nsub SVROP_LISTENS () { 'listens' }  # connect/listen sockets\nsub SVROP_NOTHING () { 'nothing' }  # connectionless sockets\n\n# Map family/protocol pairs to connection or connectionless\n# operations.\nmy %supported_protocol = (\n  DOM_UNIX, {\n    none => SVROP_LISTENS\n  },\n  DOM_INET, {\n    tcp  => SVROP_LISTENS,\n    udp  => SVROP_NOTHING,\n  },\n  DOM_INET6, {\n    tcp  => SVROP_LISTENS,\n    udp  => SVROP_NOTHING,\n  },\n);\n\n# Sane default socket types for each supported protocol.  TODO Maybe\n# this structure can be combined with %supported_protocol?\nmy %default_socket_type = (\n  DOM_UNIX, {\n    none => SOCK_STREAM\n  },\n  DOM_INET, {\n    tcp  => SOCK_STREAM,\n    udp  => SOCK_DGRAM,\n  },\n  DOM_INET6, {\n    tcp  => SOCK_STREAM,\n    udp  => SOCK_DGRAM,\n  },\n);\n\n#------------------------------------------------------------------------------\n# Perform system-dependent translations on Unix addresses, if\n# necessary.\n\nsub _condition_unix_address {\n  my ($address) = @_;\n\n  # OS/2 would like sockets to use backwhacks, and please place them\n  # in the virtual \\socket\\ directory.  Thank you.\n  if ($^O eq 'os2') {\n    $address =~ tr[\\\\][/];\n    if ($address !~ m{^/socket/}) {\n      $address =~ s{^/?}{/socket/};\n    }\n    $address =~ tr[/][\\\\];\n  }\n\n  $address;\n}\n\n#------------------------------------------------------------------------------\n# Define the select handler that will accept connections.\n\nsub _define_accept_state {\n  my $self = shift;\n\n  # We do these stupid closure tricks to avoid putting $self in it\n  # directly.  If you include $self in one of the state() closures,\n  # the component will fail to shut down properly: there will be a\n  # circular definition in the closure holding $self alive.\n\n  my $domain = $map_family_to_domain{ $self->[MY_SOCKET_DOMAIN] };\n  $domain = '(undef)' unless defined $domain;\n  my $event_success = \\$self->[MY_EVENT_SUCCESS];\n  my $event_failure = \\$self->[MY_EVENT_FAILURE];\n  my $unique_id     =  $self->[MY_UNIQUE_ID];\n\n  $poe_kernel->state(\n    $self->[MY_STATE_ACCEPT] = ref($self) . \"($unique_id) -> select accept\",\n    sub {\n      # prevents SEGV\n      0 && CRIMSON_SCOPE_HACK('<');\n\n      # subroutine starts here\n      my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n\n      my $new_socket = gensym;\n      my $peer = accept($new_socket, $handle);\n\n      if ($peer) {\n        my ($peer_addr, $peer_port);\n        if ( $domain eq DOM_UNIX ) {\n          $peer_port = undef;\n          eval { $peer_addr = unpack_sockaddr_un($peer) };\n          $peer_addr = undef if length $@;\n        }\n        elsif ( $domain eq DOM_INET ) {\n          ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);\n        }\n        elsif ( $domain eq DOM_INET6 ) {\n          ($peer_port, $peer_addr) = unpack_sockaddr_in6($peer);\n        }\n        else {\n          die \"sanity failure: socket domain == $domain\";\n        }\n        $k->call(\n          $me, $$event_success,\n          $new_socket, $peer_addr, $peer_port,\n          $unique_id\n        );\n      }\n      elsif ($! != EWOULDBLOCK and $! != ECONNABORTED and $! != ESPIPE) {\n        # OSX reports ESPIPE, which isn't documented anywhere.\n        $$event_failure && $k->call(\n          $me, $$event_failure,\n          'accept', ($!+0), $!, $unique_id\n        );\n      }\n    }\n  );\n\n  $self->[MY_SOCKET_SELECTED] = 'yes';\n  $poe_kernel->select_read(\n    $self->[MY_SOCKET_HANDLE],\n    $self->[MY_STATE_ACCEPT]\n  );\n}\n\n#------------------------------------------------------------------------------\n# Define the select handler that will finalize an established\n# connection.\n\nsub _define_connect_state {\n  my $self = shift;\n\n  # We do these stupid closure tricks to avoid putting $self in it\n  # directly.  If you include $self in one of the state() closures,\n  # the component will fail to shut down properly: there will be a\n  # circular definition in the closure holding $self alive.\n\n  my $domain = $map_family_to_domain{ $self->[MY_SOCKET_DOMAIN] };\n  $domain = '(undef)' unless defined $domain;\n  my $event_success   = \\$self->[MY_EVENT_SUCCESS];\n  my $event_failure   = \\$self->[MY_EVENT_FAILURE];\n  my $unique_id       =  $self->[MY_UNIQUE_ID];\n  my $socket_selected = \\$self->[MY_SOCKET_SELECTED];\n\n  my $socket_handle   = \\$self->[MY_SOCKET_HANDLE];\n  my $state_accept    = \\$self->[MY_STATE_ACCEPT];\n  my $state_connect   = \\$self->[MY_STATE_CONNECT];\n  my $mine_success    = \\$self->[MY_MINE_SUCCESS];\n  my $mine_failure    = \\$self->[MY_MINE_FAILURE];\n\n  $poe_kernel->state(\n    $self->[MY_STATE_CONNECT] = (\n      ref($self) .  \"($unique_id) -> select connect\"\n    ),\n    sub {\n      # This prevents SEGV in older versions of Perl.\n      0 && CRIMSON_SCOPE_HACK('<');\n\n      # Grab some values and stop watching the socket.\n      my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n\n      _shutdown(\n        $socket_selected, $socket_handle,\n        $state_accept, $state_connect,\n        $mine_success, $event_success,\n        $mine_failure, $event_failure,\n      );\n\n      # Throw a failure if the connection failed.\n      $! = unpack('i', getsockopt($hand", 8192) = 8192
09:01:57.085240 stat("modules/POE/Wheel.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.085300 stat("modules/POE/Wheel.pm", {st_mode=S_IFREG|0600, st_size=11024, ...}) = 0
09:01:57.085365 open("modules/POE/Wheel.pm", O_RDONLY) = 8
09:01:57.085424 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a700) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.085476 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.085543 read(8, "package POE::Wheel;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw(croak);\n\n# Used to generate unique IDs for wheels.  This is static data, shared\n# by all.\nmy $current_id = 0;\nmy %active_wheel_ids;\n\nsub new {\n  my $type = shift;\n  croak \"$type is not meant to be used directly\";\n}\n\nsub allocate_wheel_id {\n  while (1) {\n    last unless exists $active_wheel_ids{ ++$current_id };\n  }\n  return $active_wheel_ids{$current_id} = $current_id;\n}\n\nsub free_wheel_id {\n  my $id = shift;\n  delete $active_wheel_ids{$id};\n}\n\nsub _test_set_wheel_id {\n  $current_id = shift;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Wheel - event-driven mixins for POE::Session\n\n=head1 SYNOPSIS\n\nThis base class has no synopsis.\nPlease consult one of the subclasses instead.\n\n=head1 DESCRIPTION\n\nA POE::Wheel object encapsulates a bundle of event handlers that\nperform a specific task.  It also manages the event watchers that\ntrigger those handlers.\n\nObject lifetime is very important for POE wheels.  At creation time,\nmost wheels will add anonymous event handlers to the currently active\nsession.  In other words, the session that created the wheel is\nmodified to handle new events.  Event watchers may also be initialized\nas necessary to trigger the new handlers.  These event watchers are\nalso owned by the session that created the wheel.\n\nSessions must not expose their wheels to other sessions.  Doing so\nwill likely cause problems because wheels are tightly integrated with\nthe sessions that created them.  For example, calling put() on a\nPOE::Wheel::ReadWrite instance may enable a write-okay watcher.  The\nhandler for this watcher is already defined in the wheel's owner.\nCalling put() outside that session will enable the write-okay watcher\nin the wrong session, and the event will never be handled.\n\nLikewise, wheels must be destroyed from within their creator sessions.\nOtherwise breakage will occur when the wheels' DESTROY methods try to\nunregister event handlers and watchers from the wrong sessions.  To\nsimplify things, it's recommended to store POE::Wheel instances in\nheaps of the sessions that created them.\n\nFor example, creating a POE::Wheel::FollowTail object will register an\nevent handler that periodically polls a file for new information.  It\nwill also start the timer that triggers the periodic polling.\n\n  use POE;\n  use POE::Wheel::FollowTail;\n\n  my @files_to_tail = qw( messages maillog security );\n\n  foreach my $filename (@files_to_tail) {\n    POE::Session->create(\n      inline_states => {\n        _start => sub {\n          push @{$_[HEAP]{messages}}, POE::Wheel::FollowTail->new(\n            Filename   => \"/var/log/$filename\",\n            InputEvent => \"got_input\",\n          );\n        },\n        got_input => sub {\n          print \"$filename: $_[ARG0]\\n\";\n        },\n      }\n    );\n  }\n\n  POE::Kernel->run();\n  exit;\n\nAs illustrated in the previous example it is possible---sometimes\nrecommended---to create more than one POE::Wheel of a particular type\nin the same session.  A session with multiple wheels may scale better\nthan separate sessions with one wheel apiece.  When in doubt,\nbenchmark.\n\nUnlike components (or cheese), wheels do not stand alone.  Each wheel\nmust be created by a session in order to register event watchers and\nhandlers within that session.  Wheels are thusly tightly coupled to\ntheir creator sessions and cannot be passed to other sessions.\n\n=head1 FILTERS, AND DRIVERS\n\nMany wheels perform data transfer operations on filehandles (which, as\nyou probably know, includes sockets, pipes, and just about anything\nelse that can store or transfer data).\n\nTo avoid subclass hell, POE::Wheel objects may be customized at\ncreation time by including other objects from the POE::Filter and\nPOE::Driver namespaces.\n\n=head2 Filters\n\nPOE \"filters\" implement data parsers and serializers.  For example,\nPOE::Filter::Line parses streams into records separated by some string\n(the traditional network newline by default).  The Line filter also\nadds record separators to data being output.\n\nPOE::Filter::HTTPD is a more complex example.  It implements a subset\nof the server-side of the HTTP protocol.  Input streams are parsed\ninto HTTP requests and wrapped in HTTP::Request objects.  Server code\nsends HTTP::Response objects back to the client, which are serialized\nso they may be sent to a socket.\n\nMost wheels use POE::Filter::Line by default.\n\n=head2 Drivers\n\nPOE \"drivers\" implement strategies for sending data to a filehandle\nand receiving input from it.  A single POE::Wheel class may interact\nwith files, pipes, sockets, or devices by using the appropriate\ndriver.\n\nPOE::Driver::SysRW is the only driver that comes with POE.  sysread()\nand syswrite() can handle nearly every kind of stream interaction, so\nthere hasn't been much call for another type of driver.\n\n=head1 METHODS\n\nPOE::Wheel defines a common interface that most subclasses use.\nSubclasses may implement other methods, especially to help perform\ntheir unique tasks.  If something useful isn't documented here, see\nthe subclass before implementing a feature.\n\n=head2 Required Methods\n\nThese methods are required by all subclasses.\n\n=head3 new LOTS_OF_STUFF\n\nnew() instantiates and initializes a new wheel object and returns it.\nThe new wheel will continue to function for as long as it exists,\nalthough other methods may alter the way it functions.\n\nPart of any wheel's construction is the registration of anonymous\nevent handlers to perform wheel-specific tasks.  Event watchers are\nalso started to trigger the handlers when relevant activity occurs.\n\nEvery wheel has a different purpose and requires different constructor\nparameters, so LOTS_OF_STUFF is documented in each particular\nsubclass.\n\n=head3 DESTROY\n\nDESTROY is Ye Olde Perl Object Destructor.  When the wheel's last\nstrong reference is relinquished, DESTROY triggers the wheel's\ncleanup.  The object removes itself from the session that created it:\nActive event watchers are stopped, and anonymous event handlers are\nunregistered.\n\n=head3 event EVENT_TYPE, EVENT_NAME [, EVENT_TYPE, EVENT_NAME, ....]\n\nevent() changes the events that a wheel will emit.  Its parameters are\none or more pairs of EVENT_TYPEs and the EVENT_NAMEs to emit when each\ntype of event occurs.  If an EVENT_NAME is undefined, then the wheel\nwill stop emitting that type of event.  Or the wheel may throw an\nerror if the event type is required.\n\nEVENT_TYPEs differ for each wheel and correspond to the constructor\nparameters that match /.*Event$/.  For example, POE::Wheel::ReadWrite\nmay emit up to five different kinds of event: InputEvent, ErrorEvent,\nFlushedEvent, HighEvent, LowEvent.  The name of each emitted event may\nbe changed at run time.\n\nThis example changes the events to emit on new input and when output\nis flushed.  It stops the wheel from emitting events when errors\noccur.\n\n  $wheel->event(\n    InputEvent   => 'new_input_event',\n    ErrorEvent   => undef,\n    FlushedEvent => 'new_flushed_event',\n  );\n\n=head2 I/O Methods\n\nWheels that perform input and output may implement some or all of\nthese methods.  The put() method is a common omission.  Wheels that\ndon't perform output do not have put() methods.\n\n=head3 put RECORD [, RECORD [, ....]]\n\nput() sends one or more RECORDs to the wheel for transmitting.  Each\nRECORD is serialized by the wheel's associated POE::Filter so that it\nwill be ready to transmit.  The serialized stream may be transmitted\nimmediately by the wheel's POE::Driver object, or it may be buffered\nin the POE::Driver until it can be flushed to the output filehandle.\n\nMost wheels use POE::Filter::Line and POE::Driver::SysRW by default,\nso it's not necessary to specify them in most cases.\n\n=head2 Class Static Functions\n\nThese functions expose information that is common to all wheels.  They\nare not methods, so they should B<not> be called as methods.\n\n  my $new_wheel_id = POE::Wheel::allocate_wheel_id();\n  POE::Wheel::free_wheel_id($new_wheel_id);\n\n=head3 allocate_wheel_id\n\nB<This is not a class method.>\n\nEvery wheel has a unique ID.  allocate_wheel_id() returns the next\navailable unique wheel ID.  Wheel constructors use it to set their IDs\ninternal", 8192) = 8192
09:01:57.086162 lseek(8, 650, SEEK_SET) = 650
09:01:57.086213 lseek(8, 0, SEEK_CUR)   = 650
09:01:57.086258 close(8)                = 0
09:01:57.086815 brk(0xc54000)           = 0xc54000
09:01:57.087157 read(7, "le, SOL_SOCKET, SO_ERROR));\n      if ($!) {\n        (defined $$event_failure) and $k->call(\n          $me, $$event_failure,\n          'connect', ($!+0), $!, $unique_id\n        );\n        return;\n      }\n\n      # Get the remote address, or throw an error if that fails.\n      my $peer = getpeername($handle);\n      if ($!) {\n        (defined $$event_failure) and $k->call(\n          $me, $$event_failure,\n          'getpeername', ($!+0), $!, $unique_id\n        );\n        return;\n      }\n\n      # Parse the remote address according to the socket's domain.\n      my ($peer_addr, $peer_port);\n\n      # UNIX sockets have some trouble with peer addresses.\n      if ($domain eq DOM_UNIX) {\n        if (defined $peer) {\n          eval { $peer_addr = unpack_sockaddr_un($peer) };\n          $peer_addr = undef if length $@;\n        }\n      }\n\n      # INET socket stacks tend not to.\n      elsif ($domain eq DOM_INET) {\n        if (defined $peer) {\n          eval {\n            ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);\n          };\n          if (length $@) {\n            $peer_port = $peer_addr = undef;\n          }\n        }\n      }\n\n      # INET6 socket stacks tend not to.\n      elsif ($domain eq DOM_INET6) {\n        if (defined $peer) {\n          eval {\n            ($peer_port, $peer_addr) = unpack_sockaddr_in6($peer);\n          };\n          if (length $@) {\n            $peer_port = $peer_addr = undef;\n          }\n        }\n      }\n\n      # What are we doing here?\n      else {\n        die \"sanity failure: socket domain == $domain\";\n      }\n\n      # Tell the session it went okay.  Also let go of the socket.\n      $k->call(\n        $me, $$event_success,\n        $handle, $peer_addr, $peer_port, $unique_id\n      );\n    }\n  );\n\n  # Cygwin and Windows expect an error state registered to expedite.\n  # This code is nearly identical the stuff above.\n  if ($^O eq \"cygwin\" or $^O eq \"MSWin32\") {\n    $poe_kernel->state(\n      $self->[MY_STATE_ERROR] = (\n        ref($self) .  \"($unique_id) -> connect error\"\n      ),\n      sub {\n        # This prevents SEGV in older versions of Perl.\n        0 && CRIMSON_SCOPE_HACK('<');\n\n        # Grab some values and stop watching the socket.\n        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n\n        _shutdown(\n          $socket_selected, $socket_handle,\n          $state_accept, $state_connect,\n          $mine_success, $event_success,\n          $mine_failure, $event_failure,\n        );\n\n        # Throw a failure if the connection failed.\n        $! = unpack('i', getsockopt($handle, SOL_SOCKET, SO_ERROR));\n        if ($!) {\n          (defined $$event_failure) and $k->call(\n            $me, $$event_failure, 'connect', ($!+0), $!, $unique_id\n          );\n          return;\n        }\n      }\n    );\n    $poe_kernel->select_expedite(\n      $self->[MY_SOCKET_HANDLE],\n      $self->[MY_STATE_ERROR]\n    );\n  }\n\n  $self->[MY_SOCKET_SELECTED] = 'yes';\n  $poe_kernel->select_write(\n    $self->[MY_SOCKET_HANDLE],\n    $self->[MY_STATE_CONNECT]\n  );\n}\n\n#------------------------------------------------------------------------------\n\nsub event {\n  my $self = shift;\n  push(@_, undef) if (scalar(@_) & 1);\n\n  while (@_) {\n    my ($name, $event) = splice(@_, 0, 2);\n\n    if ($name eq 'SuccessEvent') {\n      if (defined $event) {\n        if (ref($event)) {\n          carp \"reference for SuccessEvent will be treated as an event name\"\n        }\n        $self->[MY_EVENT_SUCCESS] = $event;\n        undef $self->[MY_MINE_SUCCESS];\n      }\n      else {\n        carp \"SuccessEvent requires an event name.  ignoring undef\";\n      }\n    }\n    elsif ($name eq 'FailureEvent') {\n      if (defined $event) {\n        if (ref($event)) {\n          carp \"reference for FailureEvent will be treated as an event name\";\n        }\n        $self->[MY_EVENT_FAILURE] = $event;\n        undef $self->[MY_MINE_FAILURE];\n      }\n      else {\n        carp \"FailureEvent requires an event name.  ignoring undef\";\n      }\n    }\n    else {\n      carp \"ignoring unknown SocketFactory parameter '$name'\";\n    }\n  }\n\n  $self->[MY_SOCKET_SELECTED] = 'yes';\n  if (defined $self->[MY_STATE_ACCEPT]) {\n    $poe_kernel->select_read(\n      $self->[MY_SOCKET_HANDLE],\n      $self->[MY_STATE_ACCEPT]\n     );\n  }\n  elsif (defined $self->[MY_STATE_CONNECT]) {\n    $poe_kernel->select_write(\n      $self->[MY_SOCKET_HANDLE],\n      $self->[MY_STATE_CONNECT]\n    );\n    if ($^O eq \"cygwin\" or $^O eq \"MSWin32\") {\n      $poe_kernel->select_expedite(\n        $self->[MY_SOCKET_HANDLE],\n        $self->[MY_STATE_ERROR]\n      );\n    }\n  }\n  else {\n    die \"POE developer error - no state defined\";\n  }\n}\n\n#------------------------------------------------------------------------------\n\nsub getsockname {\n  my $self = shift;\n  return undef unless (\n    defined $self->[MY_SOCKET_HANDLE] and\n    fileno($self->[MY_SOCKET_HANDLE])\n  );\n  return getsockname($self->[MY_SOCKET_HANDLE]);\n}\n\nsub ID {\n  return $_[0]->[MY_UNIQUE_ID];\n}\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n\n  # Don't take responsibility for a bad parameter count.\n  croak \"$type requires an even number of parameters\" if @_ & 1;\n\n  my %params = @_;\n\n  # The calling convention experienced a hard deprecation.\n  croak \"wheels no longer require a kernel reference as their first parameter\"\n    if (@_ && (ref($_[0]) eq 'POE::Kernel'));\n\n  # Ensure some of the basic things are present.\n  croak \"$type requires a working Kernel\" unless (defined $poe_kernel);\n  croak 'SuccessEvent required' unless (defined $params{SuccessEvent});\n  croak 'FailureEvent required' unless (defined $params{FailureEvent});\n  my $event_success = $params{SuccessEvent};\n  my $event_failure = $params{FailureEvent};\n\n  # Create the SocketServer.  Cache a copy of the socket handle.\n  my $socket_handle = gensym();\n  my $self = bless(\n    [\n      $socket_handle,                   # MY_SOCKET_HANDLE\n      &POE::Wheel::allocate_wheel_id(), # MY_UNIQUE_ID\n      $event_success,                   # MY_EVENT_SUCCESS\n      $event_failure,                   # MY_EVENT_FAILURE\n      undef,                            # MY_SOCKET_DOMAIN\n      undef,                            # MY_STATE_ACCEPT\n      undef,                            # MY_STATE_CONNECT\n      undef,                            # MY_MINE_SUCCESS\n      undef,                            # MY_MINE_FAILURE\n      undef,                            # MY_SOCKET_PROTOCOL\n      undef,                            # MY_SOCKET_TYPE\n      undef,                            # MY_STATE_ERROR\n      undef,                            # MY_SOCKET_SELECTED\n    ],\n    $type\n  );\n\n  # Default to Internet sockets.\n  my $domain = delete $params{SocketDomain};\n  if (defined $domain) {\n    # [rt.cpan.org 76314] Untaint the domain.\n    ($domain) = ($domain =~ /\\A(.*)\\z/s);\n  }\n  else {\n    $domain = AF_INET;\n  }\n  $self->[MY_SOCKET_DOMAIN] = $domain;\n\n  # Abstract the socket domain into something we don't have to keep\n  # testing duplicates of.\n  my $abstract_domain = $map_family_to_domain{$self->[MY_SOCKET_DOMAIN]};\n  unless (defined $abstract_domain) {\n    $poe_kernel->yield(\n      $event_failure,\n      'domain',\n      0,\n      \"SocketDomain $domain is currently unsupported on this platform\",\n      $self->[MY_UNIQUE_ID]\n    );\n    return $self;\n  }\n\n  #---------------#\n  # Create Socket #\n  #---------------#\n\n  # Declare the protocol name out here; it'll be needed by\n  # getservbyname later.\n  my $protocol_name;\n\n  # Unix sockets don't use protocols; warn the programmer, and force\n  # PF_UNSPEC.\n  if ($abstract_domain eq DOM_UNIX) {\n    carp 'SocketProtocol ignored for Unix socket'\n      if defined $params{SocketProtocol};\n    $self->[MY_SOCKET_PROTOCOL] = PF_UNSPEC;\n    $protocol_name = 'none';\n  }\n\n  # Internet sockets use protocols.  Default the INET protocol to tcp,\n  # and try to resolve it.\n  elsif (\n    $abstract_domain eq DOM_INET or\n    $abstract_domain eq DOM_INET6\n  ) {\n    my $socket_protocol = (\n      (defined $params{SocketProtocol})\n      ? $params{SocketProtocol}\n      : 'tcp'\n    );\n\n\n    if ($socket_protocol !~ /^\\d+$/) {\n      unless ($socket_protocol = $proto_by_name{$socket_protocol} || ev", 8192) = 8192
09:01:57.088292 read(7, "al { getprotobyname($socket_protocol) }) {\n        $poe_kernel->yield(\n          $event_failure, 'getprotobyname', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n\n    # Get the protocol's name regardless of what was provided.  If the\n    # protocol isn't supported, croak now instead of making the\n    # programmer wonder why things fail later.\n    $protocol_name = $proto_by_number{$socket_protocol} || eval { lc(getprotobynumber($socket_protocol)) };\n    unless ($protocol_name) {\n      $poe_kernel->yield(\n        $event_failure, 'getprotobynumber', $!+0, $!, $self->[MY_UNIQUE_ID]\n      );\n      return $self;\n    }\n\n    unless (defined $supported_protocol{$abstract_domain}->{$protocol_name}) {\n      croak \"SocketFactory does not support Internet $protocol_name sockets\";\n    }\n\n    $self->[MY_SOCKET_PROTOCOL] = $socket_protocol;\n  }\n  else {\n    die \"Mail this error to the author of POE: Internal consistency error\";\n  }\n\n  # If no SocketType, default it to something appropriate.\n  if (defined $params{SocketType}) {\n    $self->[MY_SOCKET_TYPE] = $params{SocketType};\n  }\n  else {\n    unless (defined $default_socket_type{$abstract_domain}->{$protocol_name}) {\n      croak \"SocketFactory does not support $abstract_domain $protocol_name\";\n    }\n    $self->[MY_SOCKET_TYPE] =\n      $default_socket_type{$abstract_domain}->{$protocol_name};\n  }\n\n  # o  create a dummy socket\n  # o  cache the value of SO_OPENTYPE in $win32_socket_opt\n  # o  set the overlapped io attribute\n  # o  close dummy socket\n  my $win32_socket_opt;\n  if ( POE::Kernel::RUNNING_IN_HELL) {\n\n    # Constants are evaluated first so they exist when the code uses\n    # them.\n    eval {\n      *SO_OPENTYPE     = sub () { 0x7008 };\n      *SO_SYNCHRONOUS_ALERT    = sub () { 0x10 };\n      *SO_SYNCHRONOUS_NONALERT = sub () { 0x20 };\n    };\n    die \"Could not install SO constants [$@]\" if $@;\n\n    # Turn on socket overlapped IO attribute per MSKB: Q181611. \n\n    eval {\n      socket(POE, AF_INET, SOCK_STREAM, IPPROTO_TCP)\n        or die \"socket failed: $!\";\n      my $opt = unpack(\"I\", getsockopt(POE, SOL_SOCKET, SO_OPENTYPE()));\n      $win32_socket_opt = $opt;\n      $opt &= ~(SO_SYNCHRONOUS_ALERT()|SO_SYNCHRONOUS_NONALERT());\n      setsockopt(POE, SOL_SOCKET, SO_OPENTYPE(), $opt);\n      close POE;\n    };\n\n    die if $@;\n  }\n\n  # Create the socket.\n  unless (\n    socket( $socket_handle, $self->[MY_SOCKET_DOMAIN],\n      $self->[MY_SOCKET_TYPE], $self->[MY_SOCKET_PROTOCOL]\n    )\n  ) {\n    $poe_kernel->yield(\n      $event_failure, 'socket', $!+0, $!, $self->[MY_UNIQUE_ID]\n    );\n    return $self;\n  }\n\n  # o  create a dummy socket\n  # o  restore previous value of SO_OPENTYPE\n  # o  close dummy socket\n  #\n  # This way we'd only be turning on the overlap attribute for\n  # the socket we created... and not all subsequent sockets.\n  if ( POE::Kernel::RUNNING_IN_HELL) {\n    eval {\n      socket(POE, AF_INET, SOCK_STREAM, IPPROTO_TCP)\n        or die \"socket failed: $!\";\n      setsockopt(POE, SOL_SOCKET, SO_OPENTYPE(), $win32_socket_opt);\n      close POE;\n    };\n\n    die if $@;\n  }\n  DEBUG && warn \"socket\";\n\n  #------------------#\n  # Configure Socket #\n  #------------------#\n\n  # Make the socket binary.  It's wrapped in eval{} because tied\n  # filehandle classes may actually die in their binmode methods.\n  eval { binmode($socket_handle) };\n\n  # Don't block on socket operations, because the socket will be\n  # driven by a select loop.\n  $socket_handle->blocking(0);\n\n  # Make the socket reusable, if requested.\n  if (\n    (defined $params{Reuse})\n       and ( (lc($params{Reuse}) eq 'yes')\n             or (lc($params{Reuse}) eq 'on')\n             or ( ($params{Reuse} =~ /\\d+/)\n                  and $params{Reuse}\n                )\n           )\n     )\n  {\n    setsockopt($socket_handle, SOL_SOCKET, SO_REUSEADDR, 1) or do {\n      $poe_kernel->yield(\n        $event_failure,\n        'setsockopt', $!+0, $!, $self->[MY_UNIQUE_ID]\n      );\n      return $self;\n    };\n  }\n\n  #-------------#\n  # Bind Socket #\n  #-------------#\n\n  my $bind_address;\n\n  # Check SocketFactory /Bind.*/ parameters in an Internet socket\n  # context, and translate them into parameters that bind()\n  # understands.\n  if ($abstract_domain eq DOM_INET) {\n    # Don't bind if the creator doesn't specify a related parameter.\n    if ((defined $params{BindAddress}) or (defined $params{BindPort})) {\n\n      # Set the bind address, or default to INADDR_ANY.\n      $bind_address = (\n        (defined $params{BindAddress})\n        ? $params{BindAddress}\n        : INADDR_ANY\n      );\n\n      # Need to check lengths in octets, not characters.\n      BEGIN { eval { require bytes } and bytes->import; }\n\n      # Resolve the bind address if it's not already packed.\n      unless (length($bind_address) == 4) {\n        $bind_address = inet_aton($bind_address);\n      }\n\n      unless (defined $bind_address) {\n        $! = EADDRNOTAVAIL;\n        $poe_kernel->yield(\n          $event_failure,\n          \"inet_aton\", $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n\n      # Set the bind port, or default to 0 (any) if none specified.\n      # Resolve it to a number, if at all possible.\n      my $bind_port = (defined $params{BindPort}) ? $params{BindPort} : 0;\n      if ($bind_port =~ /[^0-9]/) {\n        $bind_port = getservbyname($bind_port, $protocol_name);\n        unless (defined $bind_port) {\n          $! = EADDRNOTAVAIL;\n          $poe_kernel->yield(\n            $event_failure,\n            'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]\n          );\n          return $self;\n        }\n      }\n\n      $bind_address = pack_sockaddr_in($bind_port, $bind_address);\n      unless (defined $bind_address) {\n        $poe_kernel->yield(\n          $event_failure,\n          \"pack_sockaddr_in\", $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n  }\n\n  # Check SocketFactory /Bind.*/ parameters in an Internet socket\n  # context, and translate them into parameters that bind()\n  # understands.\n  elsif ($abstract_domain eq DOM_INET6) {\n\n    # Don't bind if the creator doesn't specify a related parameter.\n    if ((defined $params{BindAddress}) or (defined $params{BindPort})) {\n\n      # Set the bind address, or default to INADDR_ANY.\n      $bind_address = (\n        (defined $params{BindAddress})\n        ? $params{BindAddress}\n        : \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"  # XXX - Only Socket6 has?\n      );\n\n      # Set the bind port, or default to 0 (any) if none specified.\n      # Resolve it to a number, if at all possible.\n      my $bind_port = (defined $params{BindPort}) ? $params{BindPort} : 0;\n      if ($bind_port =~ /[^0-9]/) {\n        $bind_port = getservbyname($bind_port, $protocol_name);\n        unless (defined $bind_port) {\n          $! = EADDRNOTAVAIL;\n          $poe_kernel->yield(\n            $event_failure,\n            'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]\n          );\n          return $self;\n        }\n      }\n\n      # Need to check lengths in octets, not characters.\n      BEGIN { eval { require bytes } and bytes->import; }\n\n      # Undef $bind_address if IN6ADDR_ANY and handle with AI_PASSIVE\n      if ( $bind_address eq '::' || $bind_address eq \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ) {\n        $bind_address = undef;\n      }\n\n      # Resolve the bind address.\n      my ($error, @addresses) = getaddrinfo(\n        $bind_address, $bind_port, {\n          family   => $self->[MY_SOCKET_DOMAIN],\n          socktype => $self->[MY_SOCKET_TYPE],\n          ( defined $bind_address ? () : ( flags => 1 ) ),\n        }\n      );\n\n      unless (@addresses) {\n        warn $error if $error;\n\n        $! = EADDRNOTAVAIL;\n        $poe_kernel->yield(\n          $event_failure,\n          \"getaddrinfo\", $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n\n      $bind_address = $addresses[0]->{addr};\n    }\n  }\n\n  # Check SocketFactory /Bind.*/ parameters in a Unix context, and\n  # translate them into parameters bind() understands.\n  elsif ($abstract_domain eq DOM_UNIX) {\n    carp 'BindPort ignored for Unix socket' if defined $params{BindPort};\n\n    if (defined $params{BindAddress}) {\n      # Is this necessary,", 8192) = 8192
09:01:57.088744 brk(0xc75000)           = 0xc75000
09:01:57.089217 stat("modules/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089282 stat("modules/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089339 stat("modules/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089394 stat("modules/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089449 stat("/etc/perl/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089505 stat("/etc/perl/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089560 stat("/usr/local/lib/perl/5.14.2/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089618 stat("/usr/local/lib/perl/5.14.2/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089680 stat("/usr/local/share/perl/5.14.2/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089737 stat("/usr/local/share/perl/5.14.2/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089794 stat("/usr/lib/perl5/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089849 stat("/usr/lib/perl5/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.089903 stat("/usr/share/perl5/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.089959 stat("/usr/share/perl5/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.090014 stat("/usr/lib/perl/5.14/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.090091 stat("/usr/lib/perl/5.14/bytes.pm", 0x7ffe1233afe0) = -1 ENOENT (No such file or directory)
09:01:57.090143 stat("/usr/share/perl/5.14/bytes.pmc", 0x7ffe1233b090) = -1 ENOENT (No such file or directory)
09:01:57.090195 stat("/usr/share/perl/5.14/bytes.pm", {st_mode=S_IFREG|0644, st_size=447, ...}) = 0
09:01:57.090253 open("/usr/share/perl/5.14/bytes.pm", O_RDONLY) = 8
09:01:57.090321 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad70) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.090373 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.090442 read(8, "package bytes;\n\nour $VERSION = '1.04';\n\n$bytes::hint_bits = 0x00000008;\n\nsub import {\n    $^H |= $bytes::hint_bits;\n}\n\nsub unimport {\n    $^H &= ~$bytes::hint_bits;\n}\n\nsub AUTOLOAD {\n    require \"bytes_heavy.pl\";\n    goto &$AUTOLOAD if defined &$AUTOLOAD;\n    require Carp;\n    Carp::croak(\"Undefined subroutine $AUTOLOAD called\");\n}\n\nsub length (_);\nsub chr (_);\nsub ord (_);\nsub substr ($$;$$);\nsub index ($$;$);\nsub rindex ($$;$);\n\n1;\n__END__\n\n", 8192) = 447
09:01:57.090617 lseek(8, 446, SEEK_SET) = 446
09:01:57.090669 lseek(8, 0, SEEK_CUR)   = 446
09:01:57.090719 close(8)                = 0
09:01:57.091074 read(7, " or will bind() return EADDRINUSE?\n      if (defined $params{RemotePort}) {\n        $! = EADDRINUSE;\n        $poe_kernel->yield(\n          $event_failure,\n          'bind', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n\n      $bind_address = &_condition_unix_address($params{BindAddress});\n      $bind_address = pack_sockaddr_un($bind_address);\n      unless ($bind_address) {\n        $poe_kernel->yield(\n          $event_failure,\n          'pack_sockaddr_un', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n  }\n\n  # This is an internal consistency error, and it should be hard\n  # trapped right away.\n  else {\n    die \"Mail this error to the author of POE: Internal consistency error\";\n  }\n\n  # Perform the actual bind, if there's a bind address to bind to.\n  if (defined $bind_address) {\n    unless (bind($socket_handle, $bind_address)) {\n      $poe_kernel->yield(\n        $event_failure,\n        'bind', $!+0, $!, $self->[MY_UNIQUE_ID]\n      );\n      return $self;\n    }\n\n    DEBUG && warn \"bind\";\n  }\n\n  #---------#\n  # Connect #\n  #---------#\n\n  my $connect_address;\n\n  if (defined $params{RemoteAddress}) {\n\n    # Check SocketFactory /Remote.*/ parameters in an Internet socket\n    # context, and translate them into parameters that connect()\n    # understands.\n    if (\n      $abstract_domain eq DOM_INET or\n      $abstract_domain eq DOM_INET6\n    ) {\n      # connecting if RemoteAddress\n      croak 'RemotePort required' unless (defined $params{RemotePort});\n      carp 'ListenQueue ignored' if (defined $params{ListenQueue});\n\n      my $remote_port = $params{RemotePort};\n      if ($remote_port =~ /[^0-9]/) {\n        unless ($remote_port = getservbyname($remote_port, $protocol_name)) {\n          $! = EADDRNOTAVAIL;\n          $poe_kernel->yield(\n            $event_failure,\n            'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]\n          );\n          return $self;\n        }\n      }\n\n      my $error_tag;\n      if ($abstract_domain eq DOM_INET) {\n        $connect_address = inet_aton($params{RemoteAddress});\n        $error_tag = \"inet_aton\";\n      }\n      elsif ($abstract_domain eq DOM_INET6) {\n        my ($error, @addresses) = getaddrinfo(\n          $params{RemoteAddress}, $remote_port, {\n            family   => $self->[MY_SOCKET_DOMAIN],\n            socktype => $self->[MY_SOCKET_TYPE],\n          },\n        );\n\n        unless (@addresses) {\n          warn $error if $error;\n          $connect_address = undef;\n        }\n        else {\n          $connect_address = $addresses[0]->{addr};\n        }\n\n        $error_tag = \"getaddrinfo\";\n      }\n      else {\n        die \"unknown domain $abstract_domain\";\n      }\n\n      # TODO - If the gethostbyname2() code is removed, then we can\n      # combine the previous code with the following code, and perhaps\n      # remove one of these redundant $connect_address checks.  The\n      # 0.29 release should tell us pretty quickly whether it's\n      # needed.  If we reach 0.30 without incident, it's probably safe\n      # to remove the old gethostbyname2() code and clean this up.\n      unless (defined $connect_address) {\n        $! = EADDRNOTAVAIL;\n        $poe_kernel->yield(\n          $event_failure,\n          $error_tag, $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n\n      if ($abstract_domain eq DOM_INET) {\n        $connect_address = pack_sockaddr_in($remote_port, $connect_address);\n        $error_tag = \"pack_sockaddr_in\";\n      }\n      elsif ($abstract_domain eq DOM_INET6) {\n        $error_tag = \"pack_sockaddr_in6\";\n      }\n      else {\n        die \"unknown domain $abstract_domain\";\n      }\n\n      unless ($connect_address) {\n        $! = EADDRNOTAVAIL;\n        $poe_kernel->yield(\n          $event_failure,\n          $error_tag, $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n\n    # Check SocketFactory /Remote.*/ parameters in a Unix socket\n    # context, and translate them into parameters connect()\n    # understands.\n    elsif ($abstract_domain eq DOM_UNIX) {\n\n      $connect_address = _condition_unix_address($params{RemoteAddress});\n      $connect_address = pack_sockaddr_un($connect_address);\n      unless (defined $connect_address) {\n        $poe_kernel->yield(\n          $event_failure,\n          'pack_sockaddr_un', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n\n    # This is an internal consistency error, and it should be trapped\n    # right away.\n    else {\n      die \"Mail this error to the author of POE: Internal consistency error\";\n    }\n  }\n\n  else {\n    carp \"RemotePort ignored without RemoteAddress\"\n      if defined $params{RemotePort};\n  }\n\n  # Perform the actual connection, if a connection was requested.  If\n  # the connection can be established, then return the SocketFactory\n  # handle.\n  if (defined $connect_address) {\n    unless (connect($socket_handle, $connect_address)) {\n      if ($! and ($! != EINPROGRESS) and ($! != EWOULDBLOCK)) {\n        $poe_kernel->yield(\n          $event_failure,\n          'connect', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n    }\n\n    DEBUG && warn \"connect\";\n\n    $self->[MY_SOCKET_HANDLE] = $socket_handle;\n    $self->_define_connect_state();\n    $self->event(\n      SuccessEvent => $params{SuccessEvent},\n      FailureEvent => $params{FailureEvent},\n    );\n    return $self;\n  }\n\n  #---------------------#\n  # Listen, or Whatever #\n  #---------------------#\n\n  # A connection wasn't requested, so this must be a server socket.\n  # Do whatever it is that needs to be done for whatever type of\n  # server socket this is.\n  if (exists $supported_protocol{$abstract_domain}->{$protocol_name}) {\n    my $protocol_op = $supported_protocol{$abstract_domain}->{$protocol_name};\n\n    DEBUG && warn \"$abstract_domain + $protocol_name = $protocol_op\";\n\n    if ($protocol_op eq SVROP_LISTENS) {\n      my $listen_queue = $params{ListenQueue} || SOMAXCONN;\n      # <rmah> In SocketFactory, you limit the ListenQueue parameter\n      #        to SOMAXCON (or is it SOCONNMAX?)...why?\n      # <rmah> ah, here's czth, he'll have more to say on this issue\n      # <czth> not really.  just that SOMAXCONN can lie, notably on\n      #        Solaris and reportedly on BSDs too\n      # \n      # ($listen_queue > SOMAXCONN) && ($listen_queue = SOMAXCONN);\n      unless (listen($socket_handle, $listen_queue)) {\n        $poe_kernel->yield(\n          $event_failure,\n          'listen', $!+0, $!, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n\n      DEBUG && warn \"listen\";\n\n      $self->[MY_SOCKET_HANDLE] = $socket_handle;\n      $self->_define_accept_state();\n      $self->event(\n        SuccessEvent => $params{SuccessEvent},\n        FailureEvent => $params{FailureEvent},\n      );\n      return $self;\n    }\n    else {\n      carp \"Ignoring ListenQueue parameter for non-listening socket\"\n        if defined $params{ListenQueue};\n      if ($protocol_op eq SVROP_NOTHING) {\n        # Do nothing.  Duh.  Fire off a success event immediately, and\n        # return.\n        $poe_kernel->yield(\n          $event_success,\n          $socket_handle, undef, undef, $self->[MY_UNIQUE_ID]\n        );\n        return $self;\n      }\n      else {\n        die \"Mail this error to the author of POE: Internal consistency error\";\n      }\n    }\n  }\n  else {\n    die \"SocketFactory doesn't support $abstract_domain $protocol_name socket\";\n  }\n\n  die \"Mail this error to the author of POE: Internal consistency error\";\n}\n\n# Pause and resume accept.\nsub pause_accept {\n  my $self = shift;\n  if (\n    defined $self->[MY_SOCKET_HANDLE] and\n    defined $self->[MY_STATE_ACCEPT] and\n    defined $self->[MY_SOCKET_SELECTED]\n  ) {\n    $poe_kernel->select_pause_read($self->[MY_SOCKET_HANDLE]);\n  }\n}\n\nsub resume_accept {\n  my $self = shift;\n  if (\n    defined $self->[MY_SOCKET_HANDLE] and\n    defined $self->[MY_STATE_ACCEPT] and\n    defined $self->[MY_SOCKET_SELECTED]\n  ) {\n    $poe_kernel->select_resume_read($self->[MY_SOCKET_HANDLE]);\n  }\n}\n\n#------------------------------------------------------------------------------\n# DESTROY and _shutdown pass things by reference because _shutdown is\n", 8192) = 8192
09:01:57.091888 brk(0xc96000)           = 0xc96000
09:01:57.092346 read(7, "# called from the state() closures above.  As a result, we can't\n# mention $self explicitly, or the wheel won't shut itself down\n# properly.  Rather, it will form a circular reference on $self.\n\nsub DESTROY {\n  my $self = shift;\n  _shutdown(\n    \\$self->[MY_SOCKET_SELECTED],\n    \\$self->[MY_SOCKET_HANDLE],\n    \\$self->[MY_STATE_ACCEPT],\n    \\$self->[MY_STATE_CONNECT],\n    \\$self->[MY_MINE_SUCCESS],\n    \\$self->[MY_EVENT_SUCCESS],\n    \\$self->[MY_MINE_FAILURE],\n    \\$self->[MY_EVENT_FAILURE],\n  );\n  &POE::Wheel::free_wheel_id($self->[MY_UNIQUE_ID]);\n}\n\nsub _shutdown {\n  my (\n    $socket_selected, $socket_handle,\n    $state_accept, $state_connect,\n    $mine_success, $event_success,\n    $mine_failure, $event_failure,\n  ) = @_;\n\n  if (defined $$socket_selected) {\n    $poe_kernel->select($$socket_handle);\n    $$socket_selected = undef;\n  }\n\n  if (defined $$state_accept) {\n    $poe_kernel->state($$state_accept);\n    $$state_accept = undef;\n  }\n\n  if (defined $$state_connect) {\n    $poe_kernel->state($$state_connect);\n    $$state_connect = undef;\n  }\n\n  if (defined $$mine_success) {\n    $poe_kernel->state($$event_success);\n    $$mine_success = $$event_success = undef;\n  }\n\n  if (defined $$mine_failure) {\n    $poe_kernel->state($$event_failure);\n    $$mine_failure = $$event_failure = undef;\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Wheel::SocketFactory - non-blocking socket creation\n\n=head1 SYNOPSIS\n\nSee L<POE::Component::Server::TCP/SYNOPSIS> for a much simpler version\nof this program.\n\n  #!perl\n\n  use warnings;\n  use strict;\n\n  use IO::Socket;\n  use POE qw(Wheel::SocketFactory Wheel::ReadWrite);\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub {\n        # Start the server.\n        $_[HEAP]{server} = POE::Wheel::SocketFactory->new(\n          BindPort => 12345,\n          SuccessEvent => \"on_client_accept\",\n          FailureEvent => \"on_server_error\",\n        );\n      },\n      on_client_accept => sub {\n        # Begin interacting with the client.\n        my $client_socket = $_[ARG0];\n        my $io_wheel = POE::Wheel::ReadWrite->new(\n          Handle => $client_socket,\n          InputEvent => \"on_client_input\",\n          ErrorEvent => \"on_client_error\",\n        );\n        $_[HEAP]{client}{ $io_wheel->ID() } = $io_wheel;\n      },\n      on_server_error => sub {\n        # Shut down server.\n        my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];\n        warn \"Server $operation error $errnum: $errstr\\n\";\n        delete $_[HEAP]{server};\n      },\n      on_client_input => sub {\n        # Handle client input.\n        my ($input, $wheel_id) = @_[ARG0, ARG1];\n        $input =~ tr[a-zA-Z][n-za-mN-ZA-M]; # ASCII rot13\n        $_[HEAP]{client}{$wheel_id}->put($input);\n      },\n      on_client_error => sub {\n        # Handle client error, including disconnect.\n        my $wheel_id = $_[ARG3];\n        delete $_[HEAP]{client}{$wheel_id};\n      },\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\n=head1 DESCRIPTION\n\nPOE::Wheel::SocketFactory creates sockets upon demand.  It can create\nconnectionless UDP sockets, but it really shines for client/server\nwork where establishing connections normally would block.\n\n=head1 PUBLIC METHODS\n\n=head2 new\n\nnew() creates a new POE::Wheel::SocketFactory object.  For sockets\nwhich listen() for and accept() connections, the wheel will generate\nnew sockets for each accepted client.  Socket factories for one-shot\nsockets, such as UDP peers or clients established by connect() only\nemit a single socket and can be destroyed afterwards without ill\neffects.\n\nnew() always returns a POE::Wheel::SocketFactory object even if it\nfails to establish the socket.  This allows the object to be queried\nafter it has sent its session a C<FailureEvent>.\n\nnew() accepts a healthy number of named parameters, each governing\nsome aspect of socket creation.\n\n=head3 Creating the Socket\n\nSocket creation is done with Perl's built-in socket() function.  The\nnew() parameters beginning with C<Socket> determine how socket() will\nbe called.\n\n=head4 SocketDomain\n\nC<SocketDomain> instructs the wheel to create a socket within a\nparticular domain.  Supported domains are C<AF_UNIX>, C<AF_INET>,\nC<AF_INET6>, C<PF_UNIX>, C<PF_INET>, and C<PF_INET6>.  If omitted, the\nsocket will be created in the C<AF_INET> domain.\n\nPOE::Wheel::SocketFactory contains a table of supported domains and\nthe instructions needed to create them.  Please send patches to\nsupport additional domains, as needed.\n\nNote: C<AF_INET6> and C<PF_INET6> are supplied by the L<Socket>\nmodule included in Perl 5.8.0 or later.  Perl versions before 5.8.0\nshould not attempt to use IPv6 until someone contributes a workaround.\n\nIPv6 support requires a Socket module that implements getaddrinfo()\nand unpack_sockaddr_in6().  There may be other modules that perform\nthese functions, but most if not all of them have been deprecated with\nthe advent of proper core Socket support for IPv6.\n\n=for comment\nTODO - Example.\n\n=head4 SocketType\n\nC<SocketType> supplies the socket() call with a particular socket\ntype, which may be C<SOCK_STREAM> or C<SOCK_DGRAM>.  C<SOCK_STREAM> is\nthe default if C<SocketType> is not supplied.\n\n=for comment\nTODO - Example.\n\n=head4 SocketProtocol\n\nC<SocketProtocol> sets the socket() call's protocol.  Protocols may be\nspecified by number or name.  C<SocketProtocol> is ignored for UNIX\ndomain sockets.\n\nThe protocol defaults to \"tcp\" for INET domain sockets.  There is no\ndefault for other socket domains.\n\n=for comment\nTODO - Example.\n\n=head3 Setting Socket Options\n\nPOE::Wheel::SocketFactory uses ioctl(), fcntl() and setsockopt() to\nset socket options after the socket is created.  All sockets are set\nnon-blocking, and bound sockets may be made reusable.\n\n=head4 Reuse\n\nWhen set, the C<Reuse> parameter allows a bound port to be reused\nimmediately.  C<Reuse> is considered enabled if it contains \"yes\",\n\"on\", or a true numeric value.  All other values disable port reuse,\nas does omitting C<Reuse> entirely.\n\nFor security purposes, a port cannot be reused for a minute or more\nafter a server has released it.  This gives clients time to realize\nthe port has been abandoned.  Otherwise a malicious service may snatch\nup the port and spoof the legitimate service.\n\nIt's also terribly annoying to wait a minute or more between server\ninvocations, especially during development.\n\n=head3 Bind the Socket to an Address and Port\n\nA socket may optionally be bound to a specific interface and port.\nThe C<INADDR_ANY> address may be used to bind to a specific port\nacross all interfaces.\n\nSockets are bound using bind().  POE::Wheel::SocketFactory parameters\nbeginning with C<Bind> control how bind() is called.\n\n=head4 BindAddress\n\nC<BindAddress> sets an address to bind the socket's local endpoint to.\nC<INADDR_ANY> will be used if C<BindAddress> is not specified.\n\nC<BindAddress> may contain either a string or a packed Internet\naddress (for \"INET\" domain sockets).  The string parameter should be a\ndotted numeric address or a resolvable host name.  Note that the host\nname will be resolved with a blocking call.  If this is not desired,\nuse POE::Component::Client::DNS to perform a non-blocking name\nresolution.\n\nWhen used to bind a \"UNIX\" domain socket, C<BindAddress> should\ncontain a path describing the socket's filename.  This is required for\nserver sockets and datagram client sockets.  C<BindAddress> has no\ndefault value for UNIX sockets.\n\n=for comment\nTODO - Example.\n\n=head4 BindPort\n\nC<BindPort> is only meaningful for \"INET\" domain sockets.  It contains\na port on the C<BindAddress> interface where the socket will be bound.\nIt defaults to 0 if omitted, which will cause the bind() call to\nchoose an indeterminate unallocated port.\n\nC<BindPort> may be a port number or a name that can be looked up in\nthe system's services (or equivalent) database.\n\n=for comment\nTODO - Example.\n\n=head3 Connectionless Sockets\n\nConnectionless sockets may interact with remote endpoints without\nneeding to listen() for connections or connect() to remote addresses.\n\nThis class of sockets is complete after the bind() call.\n\n=for comment\nTODO - Example.\n\n=head3 Connecting the Socket to a Remote Endpoint\n\nA socket may either listen for connections", 8192) = 8192
09:01:57.092921 lseek(7, 34091, SEEK_SET) = 34091
09:01:57.092973 lseek(7, 0, SEEK_CUR)   = 34091
09:01:57.093024 close(7)                = 0
09:01:57.093152 stat("modules/POE/Wheel/ReadWrite.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.093211 stat("modules/POE/Wheel/ReadWrite.pm", {st_mode=S_IFREG|0600, st_size=37692, ...}) = 0
09:01:57.093277 open("modules/POE/Wheel/ReadWrite.pm", O_RDONLY) = 7
09:01:57.093335 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.093387 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.093454 read(7, "package POE::Wheel::ReadWrite;\n\nuse strict;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw( croak carp );\nuse POE qw(Wheel Driver::SysRW Filter::Line);\npush @ISA, qw(POE::Wheel);\n\n# Offsets into $self.\nsub HANDLE_INPUT               () {  0 }\nsub HANDLE_OUTPUT              () {  1 }\nsub FILTER_INPUT               () {  2 }\nsub FILTER_OUTPUT              () {  3 }\nsub DRIVER_BOTH                () {  4 }\nsub EVENT_INPUT                () {  5 }\nsub EVENT_ERROR                () {  6 }\nsub EVENT_FLUSHED              () {  7 }\nsub WATERMARK_WRITE_MARK_HIGH  () {  8 }\nsub WATERMARK_WRITE_MARK_LOW   () {  9 }\nsub WATERMARK_WRITE_EVENT_HIGH () { 10 }\nsub WATERMARK_WRITE_EVENT_LOW  () { 11 }\nsub WATERMARK_WRITE_STATE      () { 12 }\nsub DRIVER_BUFFERED_OUT_OCTETS () { 13 }\nsub STATE_WRITE                () { 14 }\nsub STATE_READ                 () { 15 }\nsub UNIQUE_ID                  () { 16 }\nsub AUTOFLUSH                  () { 17 }\n\nsub CRIMSON_SCOPE_HACK ($) { 0 }\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  my %params = @_;\n\n  croak \"wheels no longer require a kernel reference as their first parameter\"\n    if (@_ && (ref($_[0]) eq 'POE::Kernel'));\n\n  croak \"$type requires a working Kernel\" unless defined $poe_kernel;\n\n  my ($in_handle, $out_handle);\n  if (defined $params{Handle}) {\n    carp \"Ignoring InputHandle parameter (Handle parameter takes precedence)\"\n      if defined $params{InputHandle};\n    carp \"Ignoring OutputHandle parameter (Handle parameter takes precedence)\"\n      if defined $params{OutputHandle};\n    $in_handle = $out_handle = delete $params{Handle};\n  }\n  else {\n    croak \"Handle or InputHandle required\"\n      unless defined $params{InputHandle};\n    croak \"Handle or OutputHandle required\"\n      unless defined $params{OutputHandle};\n    $in_handle  = delete $params{InputHandle};\n    $out_handle = delete $params{OutputHandle};\n  }\n\n  my ($in_filter, $out_filter);\n  if (defined $params{Filter}) {\n    carp \"Ignoring InputFilter parameter (Filter parameter takes precedence)\"\n      if (defined $params{InputFilter});\n    carp \"Ignoring OutputFilter parameter (Filter parameter takes precedence)\"\n      if (defined $params{OutputFilter});\n    $in_filter = $out_filter = delete $params{Filter};\n  }\n  else {\n    $in_filter = delete $params{InputFilter};\n    $out_filter = delete $params{OutputFilter};\n\n    # If neither Filter, InputFilter or OutputFilter is defined, then\n    # they default to POE::Filter::Line.\n    unless (defined $in_filter and defined $out_filter) {\n      my $new_filter = POE::Filter::Line->new();\n      $in_filter = $new_filter unless defined $in_filter;\n      $out_filter = $new_filter unless defined $out_filter;\n    }\n  }\n\n  my $driver = delete $params{Driver};\n  $driver = POE::Driver::SysRW->new() unless defined $driver;\n\n  { my $mark_errors = 0;\n    if (defined($params{HighMark}) xor defined($params{LowMark})) {\n      carp \"HighMark and LowMark parameters require each-other\";\n      $mark_errors++;\n    }\n    # Then they both exist, and they must be checked.\n    elsif (defined $params{HighMark}) {\n      unless (defined($params{HighMark}) and defined($params{LowMark})) {\n        carp \"HighMark and LowMark parameters must both be defined\";\n        $mark_errors++;\n      }\n      unless (($params{HighMark} > 0) and ($params{LowMark} > 0)) {\n        carp \"HighMark and LowMark parameters must be above 0\";\n        $mark_errors++;\n      }\n    }\n    if (defined $params{HighEvent} and not defined $params{HighMark}) {\n      carp \"HighEvent requires a corresponding HighMark\";\n      $mark_errors++;\n    }\n    if (defined($params{LowMark}) xor defined($params{LowEvent})) {\n      carp \"LowMark and LowEvent parameters require each-other\";\n      $mark_errors++;\n    }\n    croak \"Water mark errors\" if $mark_errors;\n  }\n\n  my $self = bless [\n    $in_handle,                       # HANDLE_INPUT\n    $out_handle,                      # HANDLE_OUTPUT\n    $in_filter,                       # FILTER_INPUT\n    $out_filter,                      # FILTER_OUTPUT\n    $driver,                          # DRIVER_BOTH\n    delete $params{InputEvent},       # EVENT_INPUT\n    delete $params{ErrorEvent},       # EVENT_ERROR\n    delete $params{FlushedEvent},     # EVENT_FLUSHED\n    # Water marks.\n    delete $params{HighMark},         # WATERMARK_WRITE_MARK_HIGH\n    delete $params{LowMark},          # WATERMARK_WRITE_MARK_LOW\n    delete $params{HighEvent},        # WATERMARK_WRITE_EVENT_HIGH\n    delete $params{LowEvent},         # WATERMARK_WRITE_EVENT_LOW\n    0,                                # WATERMARK_WRITE_STATE\n    # Driver statistics.\n    0,                                # DRIVER_BUFFERED_OUT_OCTETS\n    # Dynamic state names.\n    undef,                            # STATE_WRITE\n    undef,                            # STATE_READ\n    # Unique ID.\n    &POE::Wheel::allocate_wheel_id(), # UNIQUE_ID\n    delete $params{AutoFlush},         # AUTOFLUSH\n  ], $type;\n\n  if (scalar keys %params) {\n    carp(\n      \"unknown parameters in $type constructor call: \",\n      join(', ', keys %params)\n    );\n  }\n\n  $self->_define_read_state();\n  $self->_define_write_state();\n\n  return $self;\n}\n\n#------------------------------------------------------------------------------\n# Redefine the select-write handler.  This uses stupid closure tricks\n# to prevent keeping extra references to $self around.\n\nsub _define_write_state {\n  my $self = shift;\n\n  # Read-only members.  If any of these change, then the write state\n  # is invalidated and needs to be redefined.\n  my $driver        = $self->[DRIVER_BOTH];\n  my $high_mark     = $self->[WATERMARK_WRITE_MARK_HIGH];\n  my $low_mark      = $self->[WATERMARK_WRITE_MARK_LOW];\n  my $event_error   = \\$self->[EVENT_ERROR];\n  my $event_flushed = \\$self->[EVENT_FLUSHED];\n  my $event_high    = \\$self->[WATERMARK_WRITE_EVENT_HIGH];\n  my $event_low     = \\$self->[WATERMARK_WRITE_EVENT_LOW];\n  my $unique_id     = $self->[UNIQUE_ID];\n\n  # Read/write members.  These are done by reference, to avoid pushing\n  # $self into the anonymous sub.  Extra copies of $self are bad and\n  # can prevent wheels from destructing properly.\n  my $is_in_high_water_state     = \\$self->[WATERMARK_WRITE_STATE];\n  my $driver_buffered_out_octets = \\$self->[DRIVER_BUFFERED_OUT_OCTETS];\n\n  # Register the select-write handler.\n\n  $poe_kernel->state(\n    $self->[STATE_WRITE] = ref($self) . \"($unique_id) -> select write\",\n    sub {                             # prevents SEGV\n      0 && CRIMSON_SCOPE_HACK('<');\n                                      # subroutine starts here\n      my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n\n      $$driver_buffered_out_octets = $driver->flush($handle);\n\n      # When you can't write, nothing else matters.\n      if ($!) {\n        $$event_error && $k->call(\n          $me, $$event_error, 'write', ($!+0), $!, $unique_id\n        );\n        $k->select_write($handle);\n      }\n\n      # Could write, or perhaps couldn't but only because the\n      # filehandle's buffer is choked.\n      else {\n\n        # In high water state?  Check for low water.  High water\n        # state will never be set if $event_low is undef, so don't\n        # bother checking its definedness here.\n        if ($$is_in_high_water_state) {\n          if ( $$driver_buffered_out_octets <= $low_mark ) {\n            $$is_in_high_water_state = 0;\n            $k->call( $me, $$event_low, $unique_id ) if defined $$event_low;\n          }\n        }\n\n        # Not in high water state.  Check for high water.  Needs to\n        # also check definedness of $$driver_buffered_out_octets.\n        # Although we know this ahead of time and could probably\n        # optimize it away with a second state definition, it would\n        # be best to wait until ReadWrite stabilizes.  That way\n        # there will be only half as much code to maintain.\n        elsif (\n          $high_mark and\n          ( $$driver_buffered_out_octets >= $high_mark )\n        ) {\n          $$is_in_high_water_state = 1;\n          $k->call( $me, $$event_high, $unique_id ) if defined $$event_high;\n        }", 8192) = 8192
09:01:57.094145 stat("modules/POE/Driver/SysRW.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.094202 stat("modules/POE/Driver/SysRW.pm", {st_mode=S_IFREG|0600, st_size=6774, ...}) = 0
09:01:57.094261 open("modules/POE/Driver/SysRW.pm", O_RDONLY) = 8
09:01:57.094328 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a700) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.094380 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.094448 read(8, "# Copyright 1998-2013 Rocco Caputo <rcaputo@cpan.org>.  All rights\n# reserved.  This program is free software; you can redistribute it\n# and/or modify it under the same terms as Perl itself.\n\npackage POE::Driver::SysRW;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Errno qw(EAGAIN EWOULDBLOCK);\nuse Carp qw(croak);\n\nsub OUTPUT_QUEUE        () { 0 }\nsub CURRENT_OCTETS_DONE () { 1 }\nsub CURRENT_OCTETS_LEFT () { 2 }\nsub BLOCK_SIZE          () { 3 }\nsub TOTAL_OCTETS_LEFT   () { 4 }\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  my $self = bless [\n    [ ],   # OUTPUT_QUEUE\n    0,     # CURRENT_OCTETS_DONE\n    0,     # CURRENT_OCTETS_LEFT\n    65536, # BLOCK_SIZE\n    0,     # TOTAL_OCTETS_LEFT\n  ], $type;\n\n  if (@_) {\n    if (@_ % 2) {\n      croak \"$type requires an even number of parameters, if any\";\n    }\n    my %args = @_;\n    if (defined $args{BlockSize}) {\n      $self->[BLOCK_SIZE] = delete $args{BlockSize};\n      croak \"$type BlockSize must be greater than 0\"\n        if ($self->[BLOCK_SIZE] <= 0);\n    }\n    if (keys %args) {\n      my @bad_args = sort keys %args;\n      croak \"$type has unknown parameter(s): @bad_args\";\n    }\n  }\n\n  $self;\n}\n\n#------------------------------------------------------------------------------\n\nsub put {\n  my ($self, $chunks) = @_;\n  my $old_queue_octets = $self->[TOTAL_OCTETS_LEFT];\n\n  # Need to check lengths in octets, not characters.\n  BEGIN { eval { require bytes } and bytes->import; }\n\n  foreach (grep { length } @$chunks) {\n    $self->[TOTAL_OCTETS_LEFT] += length;\n    push @{$self->[OUTPUT_QUEUE]}, $_;\n  }\n\n  if ($self->[TOTAL_OCTETS_LEFT] && (!$old_queue_octets)) {\n    $self->[CURRENT_OCTETS_LEFT] = length($self->[OUTPUT_QUEUE]->[0]);\n    $self->[CURRENT_OCTETS_DONE] = 0;\n  }\n\n  $self->[TOTAL_OCTETS_LEFT];\n}\n\n#------------------------------------------------------------------------------\n\nsub get {\n  my ($self, $handle) = @_;\n\n  my $result = sysread($handle, my $buffer = '', $self->[BLOCK_SIZE]);\n\n  # sysread() returned a positive number of octets.  Return whatever\n  # was read.\n  return [ $buffer ] if $result;\n\n  # 18:01 <dngor> sysread() clears $! when it returns 0 for eof?\n  # 18:01 <merlyn> nobody clears $!\n  # 18:01 <merlyn> returning 0 is not an error\n  # 18:01 <merlyn> returning -1 is an error, and sets $!\n  # 18:01 <merlyn> eof is not an error. :)\n\n  # 18:21 <dngor> perl -wle '$!=1; warn \"\\$!=\",$!+0; \\\n  #               warn \"sysread=\",sysread(STDIN,my $x=\"\",100); \\\n  #               die \"\\$!=\",$!+0' < /dev/null\n  # 18:23 <lathos> $!=1 at foo line 1.\n  # 18:23 <lathos> sysread=0 at foo line 1.\n  # 18:23 <lathos> $!=0 at foo line 1.\n  # 18:23 <lathos> 5.6.0 on Darwin.\n  # 18:23 <dngor> Same, 5.6.1 on fbsd 4.4-stable.\n  #               read(2) must be clearing errno or something.\n\n  # sysread() returned 0, signifying EOF.  Although $! is magically\n  # set to 0 on EOF, it may not be portable to rely on this.\n  if (defined $result) {\n    $! = 0;\n    return undef;\n  }\n\n  # Nonfatal sysread() error.  Return an empty list.\n  return [ ] if $! == EAGAIN or $! == EWOULDBLOCK;\n\n  # fatal sysread error\n  undef;\n}\n\n#------------------------------------------------------------------------------\n\nsub flush {\n  my ($self, $handle) = @_;\n\n  # Need to check lengths in octets, not characters.\n  BEGIN { eval { require bytes } and bytes->import; }\n\n  # Reset errno in case there is nothing to write.\n  # https://rt.cpan.org/Public/Bug/Display.html?id=87721\n  $! = 0;\n\n  # syswrite() it, like we're supposed to\n  while (@{$self->[OUTPUT_QUEUE]}) {\n    my $wrote_count = syswrite(\n      $handle,\n      $self->[OUTPUT_QUEUE]->[0],\n      $self->[CURRENT_OCTETS_LEFT],\n      $self->[CURRENT_OCTETS_DONE],\n    );\n\n    # Errors only count if syswrite() failed.\n    $! = 0 if defined $wrote_count;\n\n    unless ($wrote_count) {\n      $! = 0 if $! == EAGAIN or $! == EWOULDBLOCK;\n      last;\n    }\n\n    $self->[CURRENT_OCTETS_DONE] += $wrote_count;\n    $self->[TOTAL_OCTETS_LEFT] -= $wrote_count;\n    unless ($self->[CURRENT_OCTETS_LEFT] -= $wrote_count) {\n      shift(@{$self->[OUTPUT_QUEUE]});\n      if (@{$self->[OUTPUT_QUEUE]}) {\n        $self->[CURRENT_OCTETS_DONE] = 0;\n        $self->[CURRENT_OCTETS_LEFT] = length($self->[OUTPUT_QUEUE]->[0]);\n      }\n      else {\n        $self->[CURRENT_OCTETS_DONE] = $self->[CURRENT_OCTETS_LEFT] = 0;\n      }\n    }\n  }\n\n  $self->[TOTAL_OCTETS_LEFT];\n}\n\n#------------------------------------------------------------------------------\n\nsub get_out_messages_buffered {\n  scalar(@{$_[0]->[OUTPUT_QUEUE]});\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Driver::SysRW - buffered, non-blocking I/O using sysread and syswrite\n\n=head1 SYNOPSIS\n\nL<POE::Driver/SYNOPSIS> illustrates how the interface works.  This\nmodule is merely one implementation.\n\n=head1 DESCRIPTION\n\nThis driver implements L<POE::Driver> using sysread and syswrite.\n\n=head1 PUBLIC METHODS\n\nPOE::Driver::SysRW introduces some additional features not covered in\nthe base interface.\n\n=head2 new [BlockSize => OCTETS]\n\nnew() creates a new buffered I/O driver that uses sysread() to read\ndata from a handle and syswrite() to flush data to that handle.  The\nconstructor accepts one optional named parameter, C<BlockSize>, which\nindicates the maximum number of OCTETS that will be read at one time.\n\nC<BlockSize> is 64 kilobytes (65536 octets) by default.  Higher values\nmay improve performance in streaming applications, but the trade-off\nis a lower event granularity and increased resident memory usage.\n\nLower C<BlockSize> values reduce memory consumption somewhat with\ncorresponding throughput penalties.\n\n  my $driver = POE::Driver::SysRW->new;\n\n  my $driver = POE::Driver::SysRW->new( BlockSize => $block_size );\n\nDrivers are commonly instantiated within POE::Wheel constructor calls:\n\n  $_[HEAP]{wheel} = POE::Wheel::ReadWrite->new(\n    InputHandle => \\*STDIN,\n    OutputHandle => \\*STDOUT,\n    Driver => POE::Driver::SysRW->new(),\n    Filter => POE::Filter::Line->new(),\n  );\n\nApplications almost always use POE::Driver::SysRW, so POE::Wheel\nobjects almost always will create their own if no Driver is specified.\n\n=head2 All Other Methods\n\nPOE::Driver::SysRW documents the abstract interface documented in\nPOE::Driver.  Please see L<POE::Driver> for more details about the\nfollowing methods:\n\n=over 4\n\n=item flush\n\n=item get\n\n=item get_out_messages_buffered\n\n=item put\n\n=back\n\n=head1 SEE ALSO\n\nL<POE::Driver>, L<POE::Wheel>.\n\nAlso see the SEE ALSO section of L<POE>, which contains a brief\nroadmap of POE's documentation.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 6774
09:01:57.095259 brk(0xcb7000)           = 0xcb7000
09:01:57.095417 lseek(8, 4660, SEEK_SET) = 4660
09:01:57.095469 lseek(8, 0, SEEK_CUR)   = 4660
09:01:57.095519 close(8)                = 0
09:01:57.095611 stat("modules/POE/Filter/Line.pmc", 0x7ffe1233aa20) = -1 ENOENT (No such file or directory)
09:01:57.095670 stat("modules/POE/Filter/Line.pm", {st_mode=S_IFREG|0600, st_size=12682, ...}) = 0
09:01:57.095742 open("modules/POE/Filter/Line.pm", O_RDONLY) = 8
09:01:57.095801 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a700) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.095867 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.095922 read(8, "package POE::Filter::Line;\n\nuse strict;\nuse POE::Filter;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n@ISA = qw(POE::Filter);\n\nuse Carp qw(carp croak);\n\nsub DEBUG () { 0 }\n\nsub FRAMING_BUFFER   () { 0 }\nsub INPUT_REGEXP     () { 1 }\nsub OUTPUT_LITERAL   () { 2 }\nsub AUTODETECT_STATE () { 3 }\nsub MAX_LENGTH       () { 4 }\nsub MAX_BUFFER       () { 5 }\nsub FIRST_UNUSED     () { 6 }  # First unused $self offset.\n\nsub AUTO_STATE_DONE   () { 0x00 }\nsub AUTO_STATE_FIRST  () { 0x01 }\nsub AUTO_STATE_SECOND () { 0x02 }\n\nuse base 'Exporter';\nour @EXPORT_OK = qw( FIRST_UNUSED );\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n\n  croak \"$type requires an even number of parameters\" if @_ and @_ & 1;\n  my %params = @_;\n\n  croak \"$type cannot have both Regexp and Literal line endings\" if (\n    defined $params{Regexp} and defined $params{Literal}\n  );\n\n  my ($input_regexp, $output_literal);\n  my $autodetect = AUTO_STATE_DONE;\n\n  # Literal newline for both incoming and outgoing.  Every other known\n  # parameter conflicts with this one.\n  if (defined $params{Literal}) {\n    croak \"A defined Literal must have a nonzero length\"\n      unless defined($params{Literal}) and length($params{Literal});\n    $input_regexp   = quotemeta $params{Literal};\n    $output_literal = $params{Literal};\n    if (\n      exists $params{InputLiteral} or # undef means something\n      defined $params{InputRegexp} or\n      defined $params{OutputLiteral}\n    ) {\n      croak \"$type cannot have Literal with any other parameter\";\n    }\n  }\n\n  # Input and output are specified separately, then.\n  else {\n\n    # Input can be either a literal or a regexp.  The regexp may be\n    # compiled or not; we don't rightly care at this point.\n    if (exists $params{InputLiteral}) {\n      $input_regexp = $params{InputLiteral};\n\n      # InputLiteral is defined.  Turn it into a regexp and be done.\n      # Otherwise we will autodetect it.\n      if (defined($input_regexp) and length($input_regexp)) {\n        $input_regexp = quotemeta $input_regexp;\n      }\n      else {\n        $autodetect   = AUTO_STATE_FIRST;\n        $input_regexp = '';\n      }\n\n      croak \"$type cannot have both InputLiteral and InputRegexp\"\n        if defined $params{InputRegexp};\n    }\n    elsif (defined $params{InputRegexp}) {\n      $input_regexp = $params{InputRegexp};\n      croak \"$type cannot have both InputLiteral and InputRegexp\"\n        if defined $params{InputLiteral};\n    }\n    else {\n      $input_regexp = \"(\\\\x0D\\\\x0A?|\\\\x0A\\\\x0D?)\";\n    }\n\n    if (defined $params{OutputLiteral}) {\n      $output_literal = $params{OutputLiteral};\n    }\n    else {\n      $output_literal = \"\\x0D\\x0A\";\n    }\n  }\n\n  my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \\%params );\n  my $max_length = $type->__param_max( MaxLength => 64*1024*1024, \\%params );\n  croak \"MaxBuffer is not large enough for MaxLength blocks\"\n        unless $max_buffer >= $max_length;\n\n  delete @params{qw(Literal InputLiteral OutputLiteral InputRegexp MaxLength MaxBuffer)};\n  carp(\"$type ignores unknown parameters: \", join(', ', sort keys %params))\n    if scalar keys %params;\n\n  my $self = bless [\n    '',              # FRAMING_BUFFER\n    $input_regexp,   # INPUT_REGEXP\n    $output_literal, # OUTPUT_LITERAL\n    $autodetect,     # AUTODETECT_STATE\n    $max_length,     # MAX_LENGTH\n    $max_buffer      # MAX_BUFFER\n  ], $type;\n\n  DEBUG and warn join ':', @$self;\n\n  $self;\n}\n\n\n#------------------------------------------------------------------------------\n# get() is inherited from POE::Filter.\n\n#------------------------------------------------------------------------------\n# 2001-07-27 RCC: Add get_one_start() and get_one() to correct filter\n# changing and make input flow control possible.\n\nsub get_one_start {\n  my ($self, $stream) = @_;\n\n  DEBUG and do {\n    my $temp = join '', @$stream;\n    $temp = unpack 'H*', $temp;\n    warn \"got some raw data: $temp\\n\";\n  };\n\n  $self->[FRAMING_BUFFER] .= join '', @$stream;\n  die \"Framing buffer exceeds the limit\"\n    if $self->[MAX_BUFFER] < length( $self->[FRAMING_BUFFER] );\n}\n\n# TODO There is a lot of code duplicated here.  What can be done?\n\nsub get_one {\n  my $self = shift;\n\n  # Process as many newlines an we can find.\n  LINE: while (1) {\n\n    # Autodetect is done, or it never started.  Parse some buffer!\n    unless ($self->[AUTODETECT_STATE]) {\n      DEBUG and warn unpack 'H*', $self->[INPUT_REGEXP];\n      last LINE\n        unless $self->[FRAMING_BUFFER] =~ s/^(.*?)$self->[INPUT_REGEXP]//s;\n      DEBUG and warn \"got line: <<\", unpack('H*', $1), \">>\\n\";\n      my $line = $1;\n      die \"Next line exceeds maximum line length\"\n            if length( $line ) > $self->[MAX_LENGTH];\n\n      return [ $line ];\n    }\n\n    # Waiting for the first line ending.  Look for a generic newline.\n    if ($self->[AUTODETECT_STATE] & AUTO_STATE_FIRST) {\n      last LINE\n        unless $self->[FRAMING_BUFFER] =~ s/^(.*?)(\\x0D\\x0A?|\\x0A\\x0D?)//;\n\n      my $line = $1;\n\n      # The newline can be complete under two conditions.  First: If\n      # it's two characters.  Second: If there's more data in the\n      # framing buffer.  Loop around in case there are more lines.\n      if ( (length($2) == 2) or\n           (length $self->[FRAMING_BUFFER])\n         ) {\n        DEBUG and warn \"detected complete newline after line: <<$1>>\\n\";\n        $self->[INPUT_REGEXP] = $2;\n        $self->[AUTODETECT_STATE] = AUTO_STATE_DONE;\n      }\n\n      # The regexp has matched a potential partial newline.  Save it,\n      # and move to the next state.  There is no more data in the\n      # framing buffer, so we're done.\n      else {\n        DEBUG and warn \"detected suspicious newline after line: <<$1>>\\n\";\n        $self->[INPUT_REGEXP] = $2;\n        $self->[AUTODETECT_STATE] = AUTO_STATE_SECOND;\n      }\n      die \"Next line exceeds maximum line length\"\n            if length( $line ) > $self->[MAX_LENGTH];\n\n      return [ $line ];\n    }\n\n    # Waiting for the second line beginning.  Bail out if we don't\n    # have anything in the framing buffer.\n    if ($self->[AUTODETECT_STATE] & AUTO_STATE_SECOND) {\n      return [ ] unless length $self->[FRAMING_BUFFER];\n\n      # Test the first character to see if it completes the previous\n      # potentially partial newline.\n      if (\n        substr($self->[FRAMING_BUFFER], 0, 1) eq\n        ( $self->[INPUT_REGEXP] eq \"\\x0D\" ? \"\\x0A\" : \"\\x0D\" )\n      ) {\n\n        # Combine the first character with the previous newline, and\n        # discard the newline from the buffer.  This is two statements\n        # for backward compatibility.\n        DEBUG and warn \"completed newline after line: <<$1>>\\n\";\n        $self->[INPUT_REGEXP] .= substr($self->[FRAMING_BUFFER], 0, 1);\n        substr($self->[FRAMING_BUFFER], 0, 1) = '';\n      }\n      elsif (DEBUG) {\n        warn \"decided prior suspicious newline is okay\\n\";\n      }\n\n      # Regardless, whatever is in INPUT_REGEXP is now a complete\n      # newline.  End autodetection, post-process the found newline,\n      # and loop to see if there are other lines in the buffer.\n      $self->[INPUT_REGEXP] = $self->[INPUT_REGEXP];\n      $self->[AUTODETECT_STATE] = AUTO_STATE_DONE;\n      next LINE;\n    }\n\n    die \"consistency error: AUTODETECT_STATE = $self->[AUTODETECT_STATE]\";\n  }\n\n  return [ ];\n}\n\n#------------------------------------------------------------------------------\n# New behavior.  First translate system newlines (\"\\n\") into whichever\n# newlines are supposed to be sent.  Second, add a trailing newline if\n# one doesn't already exist.  Since the referenced output list is\n# supposed to contain one line per element, we also do a split and\n# join.  Bleah. ... why isn't the code doing what the comment says?\n\nsub put {\n  my ($self, $lines) = @_;\n\n  my @raw;\n  foreach (@$lines) {\n    push @raw, $_ . $self->[OUTPUT_LITERAL];\n  }\n\n  \\@raw;\n}\n\n#------------------------------------------------------------------------------\n\nsub get_pending {\n  my $self = shift;\n  return [ $self->[FRAMING_BUFFER] ] if length $self->[FRAMING_BUFFER];\n  return undef;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Filter::Line - se", 8192) = 8192
09:01:57.096408 stat("modules/POE/Filter.pmc", 0x7ffe1233a3f0) = -1 ENOENT (No such file or directory)
09:01:57.096467 stat("modules/POE/Filter.pm", {st_mode=S_IFREG|0600, st_size=10887, ...}) = 0
09:01:57.096532 open("modules/POE/Filter.pm", O_RDONLY) = 9
09:01:57.096590 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0d0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.096642 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.096709 read(9, "package POE::Filter;\n\nuse strict;\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw(croak);\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  croak \"$type is not meant to be used directly\";\n}\n\n# Return all the messages possible to parse in the current input\n# buffer.  This uses the newer get_one_start() and get_one(), which is\n# implementation dependent.\n\nsub get {\n  my ($self, $stream) = @_;\n  my @return;\n\n  $self->get_one_start($stream);\n  while (1) {\n    my $next = $self->get_one();\n    last unless @$next;\n    push @return, @$next;\n  }\n\n  return \\@return;\n}\n\nsub clone {\n  my $self = shift;\n  my $buf = (ref($self->[0]) eq 'ARRAY') ? [ ] : '';\n  my $nself = bless [\n    $buf,                     # BUFFER\n    @$self[1..$#$self],  # everything else\n  ], ref $self;\n  return $nself;\n}\n\n\nsub __param_max\n\n{\n    my( $type, $name, $default, $params ) = @_;\n    return $default    # 512 MB\n        unless defined $params->{$name};\n\n    my $ret = $params->{$name};\n    croak \"$name must be a number\"\n            unless $ret =~ /^\\d+$/;\n    croak \"$name must greater then 0\"\n            unless $ret > 0;\n    return $ret;\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Filter - protocol abstractions for POE::Wheel and standalone use\n\n=head1 SYNOPSIS\n\nTo use with POE::Wheel classes, pass a POE::Filter object to one of\nthe \"...Filter\" constructor parameters:\n\n  #!perl\n\n  use POE qw(Filter::Line Wheel::FollowTail);\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub {\n        $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(\n          Filename => \"/var/log/system.log\",\n          InputEvent => \"got_log_line\",\n          Filter => POE::Filter::Line->new(),\n        );\n      },\n      got_log_line => sub {\n        print \"Log: $_[ARG0]\\n\";\n      }\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\nStandalone use without POE:\n\n  #!perl\n\n  use warnings;\n  use strict;\n  use POE::Filter::Line;\n\n  my $filter = POE::Filter::Line->new( Literal => \"\\n\" );\n\n  # Prints three lines: one, two three.\n\n  $filter->get_one_start([\"one\\ntwo\\nthr\", \"ee\\nfour\"]);\n  while (1) {\n    my $line = $filter->get_one();\n    last unless @$line;\n    print $line->[0], \"\\n\";\n  }\n\n  # Prints two lines: four, five.\n\n  $filter->get_one_start([\"\\nfive\\n\"]);\n  while (1) {\n    my $line = $filter->get_one();\n    last unless @$line;\n    print $line->[0], \"\\n\";\n  }\n\n=head1 DESCRIPTION\n\nPOE::Filter objects plug into the wheels and define how the data will\nbe serialized for writing and parsed after reading.  POE::Wheel\nobjects are responsible for moving data, and POE::Filter objects\ndefine how the data should look.\n\nPOE::Filter objects are simple by design.  They do not use POE\ninternally, so they are limited to serialization and parsing.  This\nmay complicate implementation of certain protocols (like HTTP 1.x),\nbut it allows filters to be used in stand-alone programs.\n\nStand-alone use is very important.  It allows application developers\nto create lightweight blocking libraries that may be used as simple\nclients for POE servers.  POE::Component::IKC::ClientLite is a notable\nexample.  This lightweight, blocking event-passing client supports\nthin clients for gridded POE applications.  The canonical use case is\nto inject events into an IKC application or grid from CGI interfaces,\nwhich require lightweight resource use.\n\nPOE filters and drivers pass data in array references.  This is\nslightly awkward, but it minimizes the amount of data that must be\ncopied on Perl's stack.\n\n=head1 PUBLIC INTERFACE\n\nAll POE::Filter classes must support the minimal interface, defined\nhere.  Specific filters may implement and document additional methods.\n\n=head2 new PARAMETERS\n\nnew() creates and initializes a new filter.  Constructor parameters\nvary from one POE::Filter subclass to the next, so please consult the\ndocumentation for your desired filter.\n\n=head2 clone\n\nclone() creates and initializes a new filter based on the constructor\nparameters of the existing one.  The new filter is a near-identical\ncopy, except that its buffers are empty.\n\nCertain components, such as POE::Component::Server::TCP, use clone().\nThese components accept a master or template filter at creation time,\nthen clone() that filter for each new connection.\n\n  my $new_filter = $old_filter->clone();\n\n=head2 get_one_start ARRAYREF\n\nget_one_start() accepts an array reference containing unprocessed\nstream chunks.  The chunks are added to the filter's internal buffer\nfor parsing by get_one().\n\nThe L</SYNOPSIS> shows get_one_start() in use.\n\n=head2 get_one\n\nget_one() parses zero or one complete item from the filter's internal\nbuffer.  The data is returned as an ARRAYREF suitable for passing to\nanother filter or a POE::Wheel object.  Filters will return empty\nARRAYREFs if they don't have enough raw data to build a complete item.\n\nget_one() is the lazy form of get().  It only parses only one item at\na time from the filter's buffer.  This is vital for applications that\nmay switch filters in mid-stream, as it ensures that the right filter\nis in use at any given time.\n\nThe L</SYNOPSIS> shows get_one() in use.  Note how it assumes the\nreturn is always an ARRAYREF, and it implicitly handles empty ones.\n\n=head2 get ARRAYREF\n\nget() is the greedy form of get_one().  It accepts an array reference\ncontaining unprocessed stream chunks, and it adds that data to the\nfilter's internal buffer.  It then parses as many full items as\npossible from the buffer and returns them in another array reference.\nAny unprocessed data remains in the filter's buffer for the next call.\n\nAs with get_one(), get() will return an empty array reference if the\nfilter doesn't contain enough raw data to build a complete item.\n\nIn fact, get() is implemented in POE::Filter in terms of\nget_one_start() and get_one().\n\nHere's the get() form of the SYNOPSIS stand-alone example:\n\n  #!perl\n\n  use warnings;\n  use strict;\n  use POE::Filter::Line;\n\n  my $filter = POE::Filter::Line->new( Literal => \"\\n\" );\n\n  # Prints three lines: one, two three.\n\n  my $lines = $filter->get([\"one\\ntwo\\nthr\", \"ee\\nfour\"]);\n  foreach my $line (@$lines) {\n    print \"$line\\n\";\n  }\n\n  # Prints two lines: four, five.\n\n  $lines = $filter->get([\"\\nfive\\n\"]);\n  foreach my $line (@$lines) {\n    print \"$line\\n\";\n  }\n\nget() should not be used with wheels that support filter switching.\nIts greedy nature means that it often parses streams well in advance\nof a wheel's events.  By the time an application changes the wheel's\nfilter, it's too late: The old filter has already parsed the rest of\nthe received data.\n\nConsider a stream of letters, numbers, and periods.  The periods\nsignal when to switch filters from one that parses letters to one that\nparses numbers.\n\nIn our hypothetical application, letters must be handled one at a\ntime, but numbers may be handled in chunks.  We'll use\nPOE::Filter::Block with a BlockSize of 1 to parse letters, and\nPOE::FIlter::Line with a Literal terminator of \".\" to handle numbers.\n\nHere's the sample stream:\n\n  abcdefg.1234567.hijklmnop.890.q\n\nWe'll start with a ReadWrite wheel configured to parse characters.\n\n  $_[HEAP]{wheel} = POE::Wheel::ReadWrite->new(\n    Filter => POE::Filter::Block->new( BlockSize => 1 ),\n    Handle => $socket,\n    InputEvent => \"got_letter\",\n  );\n\nThe \"got_letter\" handler will be called 8 times.  One for each letter\nfrom a through g, and once for the period following g.  Upon receiving\nthe period, it will switch the wheel into number mode.\n\n  sub handle_letter {\n    my $letter = $_[ARG0];\n    if ($letter eq \".\") {\n      $_[HEAP]{wheel}->set_filter(\n        POE::Filter::Line->new( Literal => \".\" )\n      );\n      $_[HEAP]{wheel}->event( InputEvent => \"got_number\" );\n    }\n    else {\n      print \"Got letter: $letter\\n\";\n    }\n  }\n\nIf the greedy get() were used, the entire input stream would have been\nparsed as characters in advance of the first handle_letter() call.\nThe set_filter() call would have been moot, since there would be no\ndata left to be parsed.\n\nThe \"got_number\" handler receives contiguous runs of digits as\nperiod-terminated lines.  The greedy get() would cause a similar\nproble", 8192) = 8192
09:01:57.097394 lseek(9, 1257, SEEK_SET) = 1257
09:01:57.097448 lseek(9, 0, SEEK_CUR)   = 1257
09:01:57.097499 close(9)                = 0
09:01:57.098358 lseek(8, 8156, SEEK_SET) = 8156
09:01:57.098413 lseek(8, 0, SEEK_CUR)   = 8156
09:01:57.098462 close(8)                = 0
09:01:57.098836 brk(0xcd8000)           = 0xcd8000
09:01:57.099129 read(7, "\n      }\n\n      # All chunks written; fire off a \"flushed\" event.  This\n      # occurs independently, so it's possible to get a low-water\n      # call and a flushed call at the same time (if the low mark\n      # is 1).\n      unless ($$driver_buffered_out_octets) {\n        $k->select_pause_write($handle);\n        $$event_flushed && $k->call($me, $$event_flushed, $unique_id);\n      }\n    }\n  );\n\n  $poe_kernel->select_write($self->[HANDLE_OUTPUT], $self->[STATE_WRITE]);\n\n  # Pause the write select immediately, unless output is pending.\n  $poe_kernel->select_pause_write($self->[HANDLE_OUTPUT])\n    unless ($self->[DRIVER_BUFFERED_OUT_OCTETS]);\n}\n\n#------------------------------------------------------------------------------\n# Redefine the select-read handler.  This uses stupid closure tricks\n# to prevent keeping extra references to $self around.\n\nsub _define_read_state {\n  my $self = shift;\n\n  # Register the select-read handler.\n\n  if (defined $self->[EVENT_INPUT]) {\n\n    # If any of these change, then the read state is invalidated and\n    # needs to be redefined.\n\n    my $driver       = $self->[DRIVER_BOTH];\n    my $input_filter = \\$self->[FILTER_INPUT];\n    my $event_input  = \\$self->[EVENT_INPUT];\n    my $event_error  = \\$self->[EVENT_ERROR];\n    my $unique_id    = $self->[UNIQUE_ID];\n\n    # If the filter can get_one, then define the input state in terms\n    # of get_one_start() and get_one().\n\n    if (\n      $$input_filter->can('get_one') and\n      $$input_filter->can('get_one_start')\n    ) {\n      $poe_kernel->state(\n        $self->[STATE_READ] = ref($self) . \"($unique_id) -> select read\",\n        sub {\n\n          # Protects against coredump on older perls.\n          0 && CRIMSON_SCOPE_HACK('<');\n\n          # The actual code starts here.\n          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n          if (defined(my $raw_input = $driver->get($handle))) {\n            $$input_filter->get_one_start($raw_input);\n            while (1) {\n              my $next_rec = $$input_filter->get_one();\n              last unless @$next_rec;\n              foreach my $cooked_input (@$next_rec) {\n                $k->call($me, $$event_input, $cooked_input, $unique_id);\n              }\n            }\n          }\n          else {\n            $$event_error and $k->call(\n              $me, $$event_error, 'read', ($!+0), $!, $unique_id\n            );\n            $k->select_read($handle);\n          }\n        }\n      );\n    }\n\n    # Otherwise define the input state in terms of the older, less\n    # robust, yet faster get().\n\n    else {\n      $poe_kernel->state(\n        $self->[STATE_READ] = ref($self) . \"($unique_id) -> select read\",\n        sub {\n\n          # Protects against coredump on older perls.\n          0 && CRIMSON_SCOPE_HACK('<');\n\n          # The actual code starts here.\n          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n          if (defined(my $raw_input = $driver->get($handle))) {\n            foreach my $cooked_input (@{$$input_filter->get($raw_input)}) {\n              $k->call($me, $$event_input, $cooked_input, $unique_id);\n            }\n          }\n          else {\n            $$event_error and $k->call(\n              $me, $$event_error, 'read', ($!+0), $!, $unique_id\n            );\n            $k->select_read($handle);\n          }\n        }\n      );\n    }\n                                        # register the state's select\n    $poe_kernel->select_read($self->[HANDLE_INPUT], $self->[STATE_READ]);\n  }\n                                        # undefine the select, just in case\n  else {\n    $poe_kernel->select_read($self->[HANDLE_INPUT])\n  }\n}\n\n#------------------------------------------------------------------------------\n# Redefine events.\n\nsub event {\n  my $self = shift;\n  push(@_, undef) if (scalar(@_) & 1);\n\n  my ($redefine_read, $redefine_write) = (0, 0);\n\n  while (@_) {\n    my ($name, $event) = splice(@_, 0, 2);\n\n    if ($name eq 'InputEvent') {\n      $self->[EVENT_INPUT] = $event;\n      $redefine_read = 1;\n    }\n    elsif ($name eq 'ErrorEvent') {\n      $self->[EVENT_ERROR] = $event;\n      $redefine_read = $redefine_write = 1;\n    }\n    elsif ($name eq 'FlushedEvent') {\n      $self->[EVENT_FLUSHED] = $event;\n      $redefine_write = 1;\n    }\n    elsif ($name eq 'HighEvent') {\n      if (defined $self->[WATERMARK_WRITE_MARK_HIGH]) {\n        $self->[WATERMARK_WRITE_EVENT_HIGH] = $event;\n        $redefine_write = 1;\n      }\n      else {\n        carp \"Ignoring HighEvent (there is no high watermark set)\";\n      }\n    }\n    elsif ($name eq 'LowEvent') {\n      if (defined $self->[WATERMARK_WRITE_MARK_LOW]) {\n        $self->[WATERMARK_WRITE_EVENT_LOW] = $event;\n        $redefine_write = 1;\n      }\n      else {\n        carp \"Ignoring LowEvent (there is no high watermark set)\";\n      }\n    }\n    else {\n      carp \"ignoring unknown ReadWrite parameter '$name'\";\n    }\n  }\n\n  $self->_define_read_state()  if $redefine_read;\n  $self->_define_write_state() if $redefine_write;\n}\n\n#------------------------------------------------------------------------------\n\nsub DESTROY {\n  my $self = shift;\n\n  # Turn off the select.  This is a problem if a wheel is being\n  # swapped, since it will turn off selects for the other wheel.\n  if ($self->[HANDLE_INPUT]) {\n    $poe_kernel->select_read($self->[HANDLE_INPUT]);\n    $self->[HANDLE_INPUT] = undef;\n  }\n\n  if ($self->[HANDLE_OUTPUT]) {\n    $poe_kernel->select_write($self->[HANDLE_OUTPUT]);\n    $self->[HANDLE_OUTPUT] = undef;\n  }\n\n  if ($self->[STATE_READ]) {\n    $poe_kernel->state($self->[STATE_READ]);\n    $self->[STATE_READ] = undef;\n  }\n\n  if ($self->[STATE_WRITE]) {\n    $poe_kernel->state($self->[STATE_WRITE]);\n    $self->[STATE_WRITE] = undef;\n  }\n\n  &POE::Wheel::free_wheel_id($self->[UNIQUE_ID]);\n}\n\n#------------------------------------------------------------------------------\n# TODO - We set the high/low watermark state here, but we don't fire\n# events for it.  My assumption is that the return value tells us\n# all we want to know.\n\nsub put {\n  my ($self, @chunks) = @_;\n\n  my $old_buffered_out_octets = $self->[DRIVER_BUFFERED_OUT_OCTETS];\n  my $new_buffered_out_octets =\n    $self->[DRIVER_BUFFERED_OUT_OCTETS] =\n    $self->[DRIVER_BOTH]->put($self->[FILTER_OUTPUT]->put(\\@chunks));\n\n  if (\n    $self->[AUTOFLUSH] &&\n    $new_buffered_out_octets and !$old_buffered_out_octets\n  ) {\n    $old_buffered_out_octets = $new_buffered_out_octets;\n    $self->flush();\n    $new_buffered_out_octets = $self->[DRIVER_BUFFERED_OUT_OCTETS];\n  }\n\n  # Resume write-ok if the output buffer gets data.  This avoids\n  # redundant calls to select_resume_write(), which is probably a good\n  # thing.\n  if ($new_buffered_out_octets and !$old_buffered_out_octets) {\n    $poe_kernel->select_resume_write($self->[HANDLE_OUTPUT]);\n  }\n\n  # If the high watermark has been reached, return true.\n  if (\n    $self->[WATERMARK_WRITE_MARK_HIGH] and\n    $new_buffered_out_octets >= $self->[WATERMARK_WRITE_MARK_HIGH]\n  ) {\n    return $self->[WATERMARK_WRITE_STATE] = 1;\n  }\n\n  return $self->[WATERMARK_WRITE_STATE] = 0;\n}\n\n#------------------------------------------------------------------------------\n# Redefine filter. -PG / Now that there are two filters internally,\n# one input and one output, make this set both of them at the same\n# time. -RCC\n\nsub _transfer_input_buffer {\n  my ($self, $buf) = @_;\n\n  my $old_input_filter = $self->[FILTER_INPUT];\n\n  # If the new filter implements \"get_one\", use that.\n  if (\n    $old_input_filter->can('get_one') and\n    $old_input_filter->can('get_one_start')\n  ) {\n    if (defined $buf) {\n      $self->[FILTER_INPUT]->get_one_start($buf);\n      while ($self->[FILTER_INPUT] == $old_input_filter) {\n        my $next_rec = $self->[FILTER_INPUT]->get_one();\n        last unless @$next_rec;\n        foreach my $cooked_input (@$next_rec) {\n          $poe_kernel->call(\n            $poe_kernel->get_active_session(),\n            $self->[EVENT_INPUT],\n            $cooked_input, $self->[UNIQUE_ID]\n          );\n        }\n      }\n    }\n  }\n\n  # Otherwise use the old behavior.\n  else {\n    if (defined $buf) {\n      foreach my $cooked_input (@{$self->[FILTER_INPUT]->get($buf)}) {\n        $poe_kernel->call(\n          $poe_kernel->get_activ", 8192) = 8192
09:01:57.100217 brk(0xcf9000)           = 0xcf9000
09:01:57.100323 read(7, "e_session(),\n          $self->[EVENT_INPUT],\n          $cooked_input, $self->[UNIQUE_ID]\n        );\n      }\n    }\n  }\n}\n\n# Set input and output filters.\n\nsub set_filter {\n  my ($self, $new_filter) = @_;\n  my $buf = $self->[FILTER_INPUT]->get_pending();\n  $self->[FILTER_INPUT] = $self->[FILTER_OUTPUT] = $new_filter;\n\n  $self->_transfer_input_buffer($buf);\n}\n\n# Redefine input and/or output filters separately.\nsub set_input_filter {\n  my ($self, $new_filter) = @_;\n  my $buf = $self->[FILTER_INPUT]->get_pending();\n  $self->[FILTER_INPUT] = $new_filter;\n\n  $self->_transfer_input_buffer($buf);\n}\n\n# No closures need to be redefined or anything.  All the previously\n# put stuff has been serialized already.\nsub set_output_filter {\n  my ($self, $new_filter) = @_;\n  $self->[FILTER_OUTPUT] = $new_filter;\n}\n\n# Get the current input filter; used for accessing the filter's custom\n# methods, as in: $wheel->get_input_filter()->filter_method();\nsub get_input_filter {\n  my $self = shift;\n  return $self->[FILTER_INPUT];\n}\n\n# Get the current input filter; used for accessing the filter's custom\n# methods, as in: $wheel->get_input_filter()->filter_method();\nsub get_output_filter {\n  my $self = shift;\n  return $self->[FILTER_OUTPUT];\n}\n\n# Set the high water mark.\n\nsub set_high_mark {\n  my ($self, $new_high_mark) = @_;\n\n  unless (defined $self->[WATERMARK_WRITE_MARK_HIGH]) {\n    carp \"Ignoring high mark (must be initialized in constructor first)\";\n    return;\n  }\n\n  unless (defined $new_high_mark) {\n    carp \"New high mark is undefined.  Ignored\";\n    return;\n  }\n\n  unless ($new_high_mark > $self->[WATERMARK_WRITE_MARK_LOW]) {\n    carp \"New high mark would not be greater than low mark.  Ignored\";\n    return;\n  }\n\n  $self->[WATERMARK_WRITE_MARK_HIGH] = $new_high_mark;\n  $self->_define_write_state();\n}\n\nsub set_low_mark {\n  my ($self, $new_low_mark) = @_;\n\n  unless (defined $self->[WATERMARK_WRITE_MARK_LOW]) {\n    carp \"Ignoring low mark (must be initialized in constructor first)\";\n    return;\n  }\n\n  unless (defined $new_low_mark) {\n    carp \"New low mark is undefined.  Ignored\";\n    return;\n  }\n\n  unless ($new_low_mark > 0) {\n    carp \"New low mark would be less than one.  Ignored\";\n    return;\n  }\n\n  unless ($new_low_mark < $self->[WATERMARK_WRITE_MARK_HIGH]) {\n    carp \"New low mark would not be less than high high mark.  Ignored\";\n    return;\n  }\n\n  $self->[WATERMARK_WRITE_MARK_LOW] = $new_low_mark;\n  $self->_define_write_state();\n}\n\n# Return driver statistics.\nsub get_driver_out_octets {\n  $_[0]->[DRIVER_BUFFERED_OUT_OCTETS];\n}\n\nsub get_driver_out_messages {\n  $_[0]->[DRIVER_BOTH]->get_out_messages_buffered();\n}\n\n# Get the wheel's ID.\nsub ID {\n  return $_[0]->[UNIQUE_ID];\n}\n\n# Pause the wheel's input watcher.\nsub pause_input {\n  my $self = shift;\n  return unless defined $self->[HANDLE_INPUT];\n  $poe_kernel->select_pause_read( $self->[HANDLE_INPUT] );\n}\n\n# Resume the wheel's input watcher.\nsub resume_input {\n  my $self = shift;\n  return unless  defined $self->[HANDLE_INPUT];\n  $poe_kernel->select_resume_read( $self->[HANDLE_INPUT] );\n}\n\n# Return the wheel's input handle\nsub get_input_handle {\n  my $self = shift;\n  return $self->[HANDLE_INPUT];\n}\n\n# Return the wheel's output handle\nsub get_output_handle {\n  my $self = shift;\n  return $self->[HANDLE_OUTPUT];\n}\n\n# Shutdown the socket for reading.\nsub shutdown_input {\n  my $self = shift;\n  return unless defined $self->[HANDLE_INPUT];\n  eval { local $^W = 0; shutdown($self->[HANDLE_INPUT], 0) };\n  $poe_kernel->select_read($self->[HANDLE_INPUT], undef);\n}\n\n# Shutdown the socket for writing.\nsub shutdown_output {\n  my $self = shift;\n  return unless defined $self->[HANDLE_OUTPUT];\n  eval { local $^W=0; shutdown($self->[HANDLE_OUTPUT], 1) };\n  $poe_kernel->select_write($self->[HANDLE_OUTPUT], undef);\n}\n\n# Flush the output handle\nsub flush {\n  my $self = shift;\n  return unless defined $self->[HANDLE_OUTPUT];\n  $poe_kernel->call($poe_kernel->get_active_session(),\n        $self->[STATE_WRITE], $self->[HANDLE_OUTPUT]);\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Wheel::ReadWrite - non-blocking buffered I/O mix-in for POE::Session\n\n=head1 SYNOPSIS\n\n  #!perl\n\n  use warnings;\n  use strict;\n\n  use IO::Socket::INET;\n  use POE qw(Wheel::ReadWrite);\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub {\n        # Note: IO::Socket::INET will block.  We recommend\n        # POE::Wheel::SocketFactory or POE::Component::Client::TCP if\n        # blocking is contraindicated.\n        $_[HEAP]{client} = POE::Wheel::ReadWrite->new(\n          Handle => IO::Socket::INET->new(\n            PeerHost => 'www.yahoo.com',\n            PeerPort => 80,\n          ),\n          InputEvent => 'on_remote_data',\n          ErrorEvent => 'on_remote_fail',\n        );\n\n        print \"Connected.  Sending request...\\n\";\n        $_[HEAP]{client}->put(\n          \"GET / HTTP/0.9\",\n          \"Host: www.yahoo.com\",\n          \"\",\n        );\n      },\n      on_remote_data => sub {\n        print \"Received: $_[ARG0]\\n\";\n      },\n      on_remote_fail => sub {\n        print \"Connection failed or ended.  Shutting down...\\n\";\n        delete $_[HEAP]{client};\n      },\n    },\n  );\n\n  POE::Kernel->run();\n  exit;\n\n=head1 DESCRIPTION\n\nPOE::Wheel::ReadWrite encapsulates a common design pattern: dealing\nwith buffered I/O in a non-blocking, event driven fashion.\n\nThe pattern goes something like this:\n\nGiven a filehandle, watch it for incoming data.  When notified of\nincoming data, read it, buffer it, and parse it according to some\nlow-level protocol (such as line-by-line).  Generate higher-level\n\"here be lines\" events, one per parsed line.\n\nIn the other direction, accept whole chunks of data (such as lines)\nfor output.  Reformat them according to some low-level protocol (such\nas by adding newlines), and buffer them for output.  Flush the\nbuffered data when the filehandle is ready to transmit it.\n\n=head1 PUBLIC METHODS\n\n=head2 Constructor\n\nPOE::Wheel subclasses tend to perform a lot of setup so that they run\nlighter and faster.  POE::Wheel::ReadWrite's constructor is no\nexception.\n\n=head3 new\n\nnew() creates and returns a new POE:Wheel::ReadWrite instance.  Under\nmost circumstances, the wheel will continue to read/write to one or\nmore filehandles until it's destroyed.\n\n=head4 Handle\n\nHandle defines the filehandle that a POE::Wheel::ReadWrite object will\nread from and write to.  The L</SYNOPSIS> includes an example using\nHandle.\n\nA single POE::Wheel::ReadWrite object can read from and write to different\nfilehandles.  See L</InputHandle> for more information and an example.\n\n=head4 InputHandle\n\nInputHandle and OutputHandle may be used to specify different handles\nfor input and output.  For example, input may be from STDIN and output\nmay go to STDOUT:\n\n  $_[HEAP]{console} = POE::Wheel::ReadWrite->new(\n    InputHandle => \\*STDIN,\n    OutputHandle => \\*STDOUT,\n    InputEvent => \"console_input\",\n  );\n\nInputHandle and OutputHandle may not be used with Handle.\n\n=head4 OutputHandle\n\nInputHandle and OutputHandle may be used to specify different handles\nfor input and output.  Please see L</InputHandle> for more information\nand an example.\n\n=head4 Driver\n\nDriver specifies how POE::Wheel::ReadWrite will actually read from and\nwrite to its filehandle or filehandles.  Driver must be an object that\ninherits from L<POE::Driver>.\n\nL<POE::Driver::SysRW>, which implements sysread() and syswrite(), is the\ndefault.  It's used in nearly all cases, so there's no point in\nspecifying it.\n\n=for comment\nTODO - Example.\n\n=head4 Filter\n\nFilter is the parser that POE::Wheel::ReadWrite will used to recognize\ninput data and the serializer it uses to prepare data for writing.  It\ndefaults to a new L<POE::Filter::Line> instance since many network\nprotocols are line based.\n\n=for comment\nTODO - Example.\n\n=head4 InputFilter\n\nInputFilter and OutputFilter may be used to specify different filters\nfor input and output.\n\n=for comment\nTODO - Example.\n\n=head4 OutputFilter\n\nInputFilter and OutputFilter may be used to specify different filters\nfor input and output. Please see L</InputFilter> for more information\nand an example.\n\n=head4 InputEvent\n\nInputEvent specifies the name of the event that will be sent for every\ncomplete ", 8192) = 8192
09:01:57.101187 lseek(7, 20406, SEEK_SET) = 20406
09:01:57.101239 lseek(7, 0, SEEK_CUR)   = 20406
09:01:57.101288 close(7)                = 0
09:01:57.101412 stat("modules/POE/Filter/Stream.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.101469 stat("modules/POE/Filter/Stream.pm", {st_mode=S_IFREG|0600, st_size=2886, ...}) = 0
09:01:57.101533 open("modules/POE/Filter/Stream.pm", O_RDONLY) = 7
09:01:57.101591 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.101642 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.101707 read(7, "package POE::Filter::Stream;\n\nuse strict;\nuse POE::Filter;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n@ISA = qw(POE::Filter);\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  my $buffer = '';\n  my $self = bless \\$buffer, $type;\n  $self;\n}\n\nsub clone {\n  my $self = shift;\n  my $buffer = '';\n  my $clone = bless \\$buffer, ref $self;\n}\n\n#------------------------------------------------------------------------------\n# get() is inherited from POE::Filter.\n\n#------------------------------------------------------------------------------\n# 2001-07-27 RCC: The get_one() variant of get() allows Wheel::Xyz to\n# retrieve one filtered block at a time.  This is necessary for filter\n# changing and proper input flow control.  Although it's kind of\n# pointless for Stream, but it has to follow the proper interface.\n\nsub get_one_start {\n  my ($self, $stream) = @_;\n  $$self .= join '', @$stream;\n}\n\nsub get_one {\n  my $self = shift;\n  return [ ] unless length $$self;\n  my $chunk = $$self;\n  $$self = '';\n  return [ $chunk ];\n}\n\n#------------------------------------------------------------------------------\n\nsub put {\n  my ($self, $chunks) = @_;\n  [ @$chunks ];\n}\n\n#------------------------------------------------------------------------------\n\nsub get_pending {\n  my $self = shift;\n  return [ $$self ] if length $$self;\n  return undef;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Filter::Stream - a no-op filter that passes data through unchanged\n\n=head1 SYNOPSIS\n\n  #!perl\n\n  use Term::ReadKey;\n  use POE qw(Wheel::ReadWrite Filter::Stream);\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub {\n        ReadMode \"ultra-raw\";\n        $_[HEAP]{io} = POE::Wheel::ReadWrite->new(\n          InputHandle => \\*STDIN,\n          OutputHandle => \\*STDOUT,\n          InputEvent => \"got_some_data\",\n          Filter => POE::Filter::Stream->new(),\n        );\n      },\n      got_some_data => sub {\n        $_[HEAP]{io}->put(\"<$_[ARG0]>\");\n        delete $_[HEAP]{io} if $_[ARG0] eq \"\\cC\";\n      },\n      _stop => sub {\n        ReadMode \"restore\";\n        print \"\\n\";\n      },\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\n=head1 DESCRIPTION\n\nPOE::Filter::Stream passes data through without changing it.  It\nfollows POE::Filter's API and implements no new functionality.\n\nIn the L</SYNOPSIS>, POE::Filter::Stream is used to collect keystrokes\nwithout any interpretation and display output without any\nembellishments.\n\n=head1 SEE ALSO\n\nL<POE::Filter> for more information about filters in general.\n\nThe SEE ALSO section in L<POE> contains a table of contents covering\nthe entire POE distribution.\n\n=head1 BUGS\n\nNone known.\n\n=head1 AUTHORS & COPYRIGHTS\n\nPlease see L<POE> for more information about authors and contributors.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 2886
09:01:57.102101 lseek(7, 1466, SEEK_SET) = 1466
09:01:57.102151 lseek(7, 0, SEEK_CUR)   = 1466
09:01:57.102196 close(7)                = 0
09:01:57.102281 stat("modules/POE/Filter/Stackable.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.102350 stat("modules/POE/Filter/Stackable.pm", {st_mode=S_IFREG|0600, st_size=9865, ...}) = 0
09:01:57.102414 open("modules/POE/Filter/Stackable.pm", O_RDONLY) = 7
09:01:57.102470 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.102521 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.102579 read(7, "# 2001/01/25 shizukesa@pobox.com\n\n# This implements a filter stack, which turns ReadWrite into something\n# very, very interesting.\n\n# 2001-07-26 RCC: I have no idea how to make this support get_one, so\n# I'm not going to right now.\n\npackage POE::Filter::Stackable;\n\nuse strict;\nuse POE::Filter;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n@ISA = qw(POE::Filter);\n\nuse Carp qw(croak);\n\nsub FILTERS () { 0 }\n\nsub FIRST_UNUSED () { 1 }  # First unused $self offset.\n\nuse base 'Exporter';\nour @EXPORT_OK = qw( FIRST_UNUSED );\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  croak \"$type must be given an even number of parameters\" if @_ & 1;\n  my %params = @_;\n\n  $params{Filters} = [ ] unless defined $params{Filters};\n  # Sanity check the filters\n  if ( ref $params{Filters} eq 'ARRAY') {\n\n    my $self = bless [\n      $params{Filters}, # FILTERS\n    ], $type;\n\n    return $self;\n  } else {\n    croak \"Filters is not an ARRAY reference!\";\n  }\n}\n\nsub clone {\n  my $self = shift;\n  my $clone = bless [\n    [ ],    # FILTERS\n  ], ref $self;\n  foreach my $filter (@{$self->[FILTERS]}) {\n    push (@{$clone->[FILTERS]}, $filter->clone());\n  }\n  $clone;\n}\n\n#------------------------------------------------------------------------------\n\nsub get_one_start {\n  my ($self, $data) = @_;\n  $self->[FILTERS]->[0]->get_one_start($data);\n}\n\n# RCC 2005-06-28: get_one() needs to strobe through all the filters\n# regardless whether there's data to input to each.  This is because a\n# later filter in the chain may produce multiple things from one piece\n# of input.  If we stop even though there's no subsequent input, we\n# may lose something.\n#\n# Keep looping through the filters we manage until get_one() returns a\n# record, or until none of the filters exchange data.\n\nsub get_one {\n  my ($self) = @_;\n\n  my $return = [ ];\n\n  while (!@$return) {\n    my $exchanged = 0;\n\n    foreach my $filter (@{$self->[FILTERS]}) {\n\n      # If we have something to input to the next filter, do that.\n      if (@$return) {\n        $filter->get_one_start($return);\n        $exchanged++;\n      }\n\n      # Get what we can from the current filter.\n      $return = $filter->get_one();\n    }\n\n    last unless $exchanged;\n  }\n\n  return $return;\n}\n\n# get() is inherited from POE::Filter.\n\n#------------------------------------------------------------------------------\n\nsub put {\n  my ($self, $data) = @_;\n  foreach my $filter (reverse @{$self->[FILTERS]}) {\n    $data = $filter->put($data);\n    last unless @$data;\n  }\n  $data;\n}\n\n#------------------------------------------------------------------------------\n\nsub get_pending {\n  my ($self) = @_;\n  my $data;\n  for (@{$self->[FILTERS]}) {\n    $_->put($data) if $data && @{$data};\n    $data = $_->get_pending;\n  }\n  $data || [];\n}\n\n#------------------------------------------------------------------------------\n\nsub filter_types {\n   map { ref($_) } @{$_[0]->[FILTERS]};\n}\n\n#------------------------------------------------------------------------------\n\nsub filters {\n  @{$_[0]->[FILTERS]};\n}\n\n#------------------------------------------------------------------------------\n\nsub shift {\n  my ($self) = @_;\n  my $filter = shift @{$self->[FILTERS]};\n  my $pending = $filter->get_pending;\n  $self->[FILTERS]->[0]->put( $pending ) if $pending;\n  $filter;\n}\n\n#------------------------------------------------------------------------------\n\nsub unshift {\n  my ($self, @filters) = @_;\n\n  # Sanity check\n  foreach my $elem ( @filters ) {\n    if ( ! defined $elem or ! UNIVERSAL::isa( $elem, 'POE::Filter' ) ) {\n      croak \"Filter element is not a POE::Filter instance!\";\n    }\n  }\n\n  unshift(@{$self->[FILTERS]}, @filters);\n}\n\n#------------------------------------------------------------------------------\n\nsub push {\n  my ($self, @filters) = @_;\n\n  # Sanity check\n  foreach my $elem ( @filters ) {\n    if ( ! defined $elem or ! UNIVERSAL::isa( $elem, 'POE::Filter' ) ) {\n      croak \"Filter element is not a POE::Filter instance!\";\n    }\n  }\n\n  push(@{$self->[FILTERS]}, @filters);\n}\n\n#------------------------------------------------------------------------------\n\nsub pop {\n  my ($self) = @_;\n  my $filter = pop @{$self->[FILTERS]};\n  my $pending = $filter->get_pending;\n  $self->[FILTERS]->[-1]->put( $pending ) if $pending;\n  $filter;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Filter::Stackable - combine multiple POE::Filter objects\n\n=head1 SYNOPSIS\n\n  #!perl\n\n  use POE qw(\n    Wheel::FollowTail\n    Filter::Line Filter::Grep Filter::Stackable\n  );\n\n  POE::Session->create(\n    inline_states => {\n      _start => sub {\n        my $parse_input_as_lines = POE::Filter::Line->new();\n\n        my $select_sudo_log_lines = POE::Filter::Grep->new(\n          Put => sub { 1 },\n          Get => sub {\n            my $input = shift;\n            return $input =~ /sudo\\[\\d+\\]/i;\n          },\n        );\n\n        my $filter_stack = POE::Filter::Stackable->new(\n          Filters => [\n            $parse_input_as_lines, # first on get, last on put\n            $select_sudo_log_lines, # first on put, last on get\n          ]\n        );\n\n        $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(\n          Filename => \"/var/log/system.log\",\n          InputEvent => \"got_log_line\",\n          Filter => $filter_stack,\n        );\n      },\n      got_log_line => sub {\n        print \"Log: $_[ARG0]\\n\";\n      }\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\n=head1 DESCRIPTION\n\nPOE::Filter::Stackable combines multiple filters together in such a\nway that they appear to be a single filter.  All the usual POE::Filter\nmethods work, but data is secretly passed through the stacked filters\nbefore it is returned.  POE::Wheel objects and stand-alone programs\nneed no modifications to work with a filter stack.\n\nIn the L</SYNOPSIS>, POE::Filter::Line and POE::Filter::Grep are\ncombined into one filter that only returns a particular kind of line.\nThis can be more efficient than filtering lines in application space,\nas fewer events may need to be dispatched and handled.\n\nInternally, filters are stored in an array.\n\nData added by get_one_start() will flow through the filter array in\nincreasing index order.  Filter #0 will have first crack at it,\nfollowed by filter #1 and so.  The get_one() call will return an item\nafter it has passed through the last filter.\n\nput() passes data through the filters in descending index order.  Data\nwill go through the filter with the highest index first, and put()\nwill return the results after data has passed through filter #0.\n\n=head1 PUBLIC FILTER METHODS\n\nIn addition to the usual POE::Filter methods, POE::Filter::Stackable\nalso supports the following.\n\n=head2 new\n\nBy default, new() creates an empty filter stack that behaves like\nPOE::Filter::Stream.  It may be given optional parameters to\ninitialize the stack with an array of filters.\n\n  my $sudo_lines = POE::Filter::Stackable->new(\n    Filters => [\n      POE::Filter::Line->new(),\n      POE::Filter::Grep->new(\n        Put => sub { 1 }, # put all items\n        Get => sub { shift() =~ /sudo\\[\\d+\\]/i },\n      ),\n    ]\n  );\n\n=head2 pop\n\nBehaves like Perl's built-in pop() for the filter stack.  The\nhighest-indexed filter is removed from the stack and returned.  Any\ndata remaining in the filter's input buffer is lost, but an\napplication may always call L<POE::Filter/get_pending> on the returned\nfilter.\n\n  my $last_filter = $stackable->pop();\n  my $last_buffer = $last_filter->get_pending();\n\n=head2 shift\n\nBehaves like Perl's built-in shift() for the filter stack.  The 0th\nfilter is removed from the stack and returned.  Any data remaining in\nthe filter's input buffer is passed to the new head of the stack, or\nit is lost if the stack becomes empty.  An application may also call\nL<POE::Filter/get_pending> on the returned filter to examine the\nfilter's input buffer.\n\n  my $first_filter = $stackable->shift();\n  my $first_buffer = $first_filter->get_pending();\n\n=head2 push FILTER[, FILTER]\n\npush() adds one or more new FILTERs to the end of the stack.  The\nnewly pushed FILTERs will process input last, and they will handle\noutput first.\n\n  # Reverse data read through the stack.\n  # rot1", 8192) = 8192
09:01:57.103350 brk(0xd1a000)           = 0xd1a000
09:01:57.103643 lseek(7, 4383, SEEK_SET) = 4383
09:01:57.103693 lseek(7, 0, SEEK_CUR)   = 4383
09:01:57.103742 close(7)                = 0
09:01:57.103836 stat("modules/POE/Filter/IRCD.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.103903 stat("modules/POE/Filter/IRCD.pm", {st_mode=S_IFREG|0600, st_size=9146, ...}) = 0
09:01:57.103962 open("modules/POE/Filter/IRCD.pm", O_RDONLY) = 7
09:01:57.104014 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.104060 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.104135 read(7, "package POE::Filter::IRCD;\n{\n  $POE::Filter::IRCD::VERSION = '2.44';\n}\n\n#ABSTRACT: A POE-based parser for the IRC protocol\n\nuse strict;\nuse warnings;\nuse Carp;\nuse base qw[POE::Filter];\n\nsub _PUT_LITERAL () { 1 }\n\n# Probably some other stuff should go here.\n\nmy $g = {\n  space\t\t\t=> qr/\\x20+/o,\n  trailing_space\t=> qr/\\x20*/o,\n};\n\nmy $irc_regex = qr/^\n  (?:\n    \\x40                # '@'-prefixed IRCv3.2 messsage tags.\n    (\\S+)               # [tags] Semi-colon delimited key=value list\n    $g->{space}\n  )?\n  (?:\n    \\x3a                #  : comes before hand\n    (\\S+)               #  [prefix]\n    $g->{'space'}       #  Followed by a space\n  )?                    # but is optional.\n  (\n    \\d{3}|[a-zA-Z]+     #  [command]\n  )                     # required.\n  (?:\n    $g->{'space'}       # Strip leading space off [middle]s\n    (                   # [middle]s\n      (?:\n        [^\\x00\\x0a\\x0d\\x20\\x3a]\n        [^\\x00\\x0a\\x0d\\x20]*\n      )                 # Match on 1 of these,\n      (?:\n        $g->{'space'}\n        [^\\x00\\x0a\\x0d\\x20\\x3a]\n        [^\\x00\\x0a\\x0d\\x20]*\n      )*                # then match as many of these as possible\n    )\n  )?                    # otherwise dont match at all.\n  (?:\n    $g->{'space'}\\x3a   # Strip off leading spacecolon for [trailing]\n    ([^\\x00\\x0a\\x0d]*)\t# [trailing]\n  )?                    # [trailing] is not necessary.\n  $g->{'trailing_space'}\n$/x;\n\nsub new {\n  my $type = shift;\n  croak \"$type requires an even number of parameters\" if @_ % 2;\n  my $buffer = { @_ };\n  $buffer->{uc $_} = delete $buffer->{$_} for keys %{ $buffer };\n  $buffer->{BUFFER} = [];\n  return bless $buffer, $type;\n}\n\nsub debug {\n  my $self = shift;\n  my $value = shift;\n\n  if ( defined $value ) {\n\t$self->{DEBUG} = $value;\n\treturn $self->{DEBUG};\n  }\n  $self->{DEBUG} = $value;\n}\n\nsub get {\n  my ($self, $raw_lines) = @_;\n  my $events = [];\n\n  foreach my $raw_line (@$raw_lines) {\n    warn \"->$raw_line \\n\" if $self->{DEBUG};\n    if ( my($tags, $prefix, $command, $middles, $trailing) = $raw_line =~ m/$irc_regex/ ) {\n      my $event = { raw_line => $raw_line };\n      if ($tags) {\n        for my $tag_pair (split /;/, $tags) {\n          my ($thistag, $thisval) = split /=/, $tag_pair;\n          $event->{tags}->{$thistag} = $thisval\n        }\n      }\n      $event->{'prefix'} = $prefix if $prefix;\n      $event->{'command'} = uc $command;\n      $event->{'params'} = [] if defined ( $middles ) || defined ( $trailing );\n      push @{$event->{'params'}}, (split /$g->{'space'}/, $middles) if defined $middles;\n      push @{$event->{'params'}}, $trailing if defined $trailing;\n      push @$events, $event;\n    }\n    else {\n      warn \"Received line $raw_line that is not IRC protocol\\n\";\n    }\n  }\n  return $events;\n}\n\nsub get_one_start {\n  my ($self, $raw_lines) = @_;\n  push @{ $self->{BUFFER} }, $_ for @$raw_lines;\n}\n\nsub get_one {\n  my $self = shift;\n  my $events = [];\n\n  if ( my $raw_line = shift ( @{ $self->{BUFFER} } ) ) {\n    warn \"->$raw_line \\n\" if $self->{DEBUG};\n    if ( my($tags, $prefix, $command, $middles, $trailing) = $raw_line =~ m/$irc_regex/ ) {\n      my $event = { raw_line => $raw_line };\n      if ($tags) {\n        for my $tag_pair (split /;/, $tags) {\n          my ($thistag, $thisval) = split /=/, $tag_pair;\n          $event->{tags}->{$thistag} = $thisval\n        }\n      }\n      $event->{'prefix'} = $prefix if $prefix;\n      $event->{'command'} = uc $command;\n      $event->{'params'} = [] if defined ( $middles ) || defined ( $trailing );\n      push @{$event->{'params'}}, (split /$g->{'space'}/, $middles) if defined $middles;\n      push @{$event->{'params'}}, $trailing if defined $trailing;\n      push @$events, $event;\n    }\n    else {\n      warn \"Received line $raw_line that is not IRC protocol\\n\";\n    }\n  }\n  return $events;\n}\n\nsub get_pending {\n  return;\n}\n\nsub put {\n  my ($self, $events) = @_;\n  my $raw_lines = [];\n\n  foreach my $event (@$events) {\n    if (ref $event eq 'HASH') {\n      my $colonify = ( defined $event->{colonify} ? $event->{colonify} : $self->{COLONIFY} );\n      if ( _PUT_LITERAL || _checkargs($event) ) {\n        my $raw_line = '';\n        if ( ref $event->{tags} eq 'HASH' && keys %{ $event->{tags} } ) {\n          $raw_line .= '@';\n          my @tags = %{ $event->{tags} };\n          while (my ($thistag, $thisval) = splice @tags, 0, 2) {\n            $raw_line .= $thistag . ( defined $thisval ? '='.$thisval : '' );\n            $raw_line .= ';' if @tags;\n          }\n          $raw_line .= ' ';\n        }\n        $raw_line .= (':' . $event->{'prefix'} . ' ') if exists $event->{'prefix'};\n        $raw_line .= $event->{'command'};\n\tif ( $event->{'params'} and ref $event->{'params'} eq 'ARRAY' ) {\n\t\tmy $params = [ @{ $event->{'params'} } ];\n\t\t$raw_line .= ' ';\n\t\tmy $param = shift @$params;\n\t\twhile (@$params) {\n\t\t\t$raw_line .= $param . ' ';\n\t\t\t$param = shift @$params;\n\t\t}\n\t\t$raw_line .= ':' if $param =~ m/\\x20/ or $colonify;\n\t\t$raw_line .= $param;\n\t}\n        push @$raw_lines, $raw_line;\n        warn \"<-$raw_line \\n\" if $self->{DEBUG};\n      }\n      else {\n        next;\n      }\n    }\n    else {\n      warn __PACKAGE__ . \" non hashref passed to put(): \\\"$event\\\"\\n\";\n      push @$raw_lines, $event if ref $event eq 'SCALAR';\n    }\n  }\n  return $raw_lines;\n}\n\nsub clone {\n  my $self = shift;\n  my $nself = { };\n  $nself->{$_} = $self->{$_} for keys %{ $self };\n  $nself->{BUFFER} = [ ];\n  return bless $nself, ref $self;\n}\n\n# This thing is far from correct, dont use it.\nsub _checkargs {\n  my $event = shift || return;\n  warn(\"Invalid characters in prefix: \" . $event->{'prefix'} . \"\\n\")\n    if ($event->{'prefix'} =~ m/[\\x00\\x0a\\x0d\\x20]/);\n  warn(\"Undefined command passed.\\n\")\n    unless ($event->{'command'} =~ m/\\S/o);\n  warn(\"Invalid command: \" . $event->{'command'} . \"\\n\")\n    unless ($event->{'command'} =~ m/^(?:[a-zA-Z]+|\\d{3})$/o);\n  foreach my $middle (@{$event->{'middles'}}) {\n    warn(\"Invalid middle: $middle\\n\")\n      unless ($middle =~ m/^[^\\x00\\x0a\\x0d\\x20\\x3a][^\\x00\\x0a\\x0d\\x20]*$/);\n  }\n  warn(\"Invalid trailing: \" . $event->{'trailing'} . \"\\n\")\n    unless ($event->{'trailing'} =~ m/^[\\x00\\x0a\\x0d]*$/);\n}\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nPOE::Filter::IRCD - A POE-based parser for the IRC protocol\n\n=head1 VERSION\n\nversion 2.44\n\n=head1 SYNOPSIS\n\n    use POE::Filter::IRCD;\n\n    my $filter = POE::Filter::IRCD->new( debug => 1, colonify => 0 );\n    my $arrayref = $filter->get( [ $hashref ] );\n    my $arrayref2 = $filter->put( $arrayref );\n\n    use POE qw(Filter::Stackable Filter::Line Filter::IRCD);\n\n    my ($filter) = POE::Filter::Stackable->new();\n    $filter->push( POE::Filter::Line->new( InputRegexp => '\\015?\\012', OutputLiteral => \"\\015\\012\" ),\n\t\t   POE::Filter::IRCD->new(), );\n\n=head1 DESCRIPTION\n\nPOE::Filter::IRCD provides a convenient way of parsing and creating IRC protocol\nlines. It provides the parsing engine for L<POE::Component::Server::IRC> and L<POE::Component::IRC>.\nA standalone version exists as L<Parse::IRC>.\n\n=head1 CONSTRUCTOR\n\n=over\n\n=item C<new>\n\nCreates a new POE::Filter::IRCD object. Takes two optional arguments:\n\n  'debug', which will print all lines received to STDERR;\n  'colonify', set to 1 to force the filter to always colonify the last param passed in a put(),\n              default is 0. See below for more detail.\n\n=back\n\n=head1 METHODS\n\n=over\n\n=item C<get_one_start>\n\n=item C<get_one>\n\n=item C<get_pending>\n\n=item C<get>\n\nTakes an arrayref which is contains lines of IRC formatted input. Returns an arrayref of hashrefs\nwhich represents the lines. The hashref contains the following fields:\n\n  prefix\n  command\n  params ( this is an arrayref )\n  raw_line\n\nFor example, if the filter receives the following line, the following hashref is produced:\n\n  LINE: ':moo.server.net 001 lamebot :Welcome to the IRC network lamebot'\n\n  HASHREF: {\n\t\tprefix   => ':moo.server.net',\n\t\tcommand  => '001',\n\t\tparams   => [ 'lamebot', 'Welcome to the IRC network lamebot' ],\n\t\traw_line => ':moo.server.net 001 lamebot :Welcome to the IRC network lamebot',\n\t   }\n\n=item C<put>\n\nTakes an arrayref containing hashrefs of IRC data and returns an arrayref containing IRC formatted lines.\nOptionally, one can specify 'colonify' to override the g", 8192) = 8192
09:01:57.105413 brk(0xd3b000)           = 0xd3b000
09:01:57.105507 lseek(7, 6142, SEEK_SET) = 6142
09:01:57.105558 lseek(7, 0, SEEK_CUR)   = 6142
09:01:57.105607 close(7)                = 0
09:01:57.105731 stat("modules/POE/Filter/IRC/Compat.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.105789 stat("modules/POE/Filter/IRC/Compat.pm", {st_mode=S_IFREG|0600, st_size=15440, ...}) = 0
09:01:57.105853 open("modules/POE/Filter/IRC/Compat.pm", O_RDONLY) = 7
09:01:57.105910 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.105959 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.106023 read(7, "package POE::Filter::IRC::Compat;\nBEGIN {\n  $POE::Filter::IRC::Compat::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Filter::IRC::Compat::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\nuse Carp;\nuse POE::Filter::IRCD;\nuse File::Basename qw(fileparse);\nuse base qw(POE::Filter);\n\nmy %irc_cmds = (\n    qr/^\\d{3}$/ => sub {\n        my ($self, $event, $line) = @_;\n        $event->{args}->[0] = _decolon( $line->{prefix} );\n        shift @{ $line->{params} };\n        if ( $line->{params}->[0] && $line->{params}->[0] =~ /\\x20/ ) {\n            $event->{args}->[1] = $line->{params}->[0];\n        }\n        else {\n            $event->{args}->[1] = join(' ', ( map { /\\x20/ ? \":$_\" : $_ } @{ $line->{params} } ) );\n        }\n        $event->{args}->[2] = $line->{params};\n    },\n    qr/^cap$/ => sub {\n        my ($self, $event, $line) = @_;\n\n        for (my $i = 0; ; $i++) {\n            last if !defined $line->{params}[$i+1];\n            $event->{args}[$i] = $line->{params}[$i+1];\n        }\n    },\n    qr/^notice$/ => sub {\n        my ($self, $event, $line) = @_;\n\n        if (defined $line->{prefix} && $line->{prefix} =~ /!/) {\n            $event->{args} = [\n                _decolon( $line->{prefix} ),\n                [split /,/, $line->{params}->[0]],\n                ($self->{identifymsg}\n                    ? _split_idmsg($line->{params}->[1])\n                    : $line->{params}->[1]\n                ),\n            ];\n        }\n        else {\n            $event->{name} = 'snotice';\n            $event->{args} = [\n                $line->{params}->[1],\n                $line->{params}->[0],\n                (defined $line->{prefix} ? _decolon($line->{prefix}) : ()),\n            ];\n        }\n    },\n    qr/^privmsg$/ => sub {\n        my ($self, $event, $line) = @_;\n        if ( grep { index( $line->{params}->[0], $_ ) >= 0 } @{ $self->{chantypes} } ) {\n            $event->{args} = [\n                _decolon( $line->{prefix} ),\n                [split /,/, $line->{params}->[0]],\n                ($self->{identifymsg}\n                    ? _split_idmsg($line->{params}->[1])\n                    : $line->{params}->[1]\n                ),\n            ];\n            $event->{name} = 'public';\n        }\n        else {\n            $event->{args} = [\n                _decolon( $line->{prefix} ),\n                [split /,/, $line->{params}->[0]],\n                ($self->{identifymsg}\n                    ? _split_idmsg($line->{params}->[1])\n                    : $line->{params}->[1]\n                ),\n            ];\n            $event->{name} = 'msg';\n        }\n    },\n    qr/^invite$/ => sub {\n        my ($self, $event, $line) = @_;\n        shift( @{ $line->{params} } );\n        unshift( @{ $line->{params} }, _decolon( $line->{prefix} || '' ) ) if $line->{prefix};\n        $event->{args} = $line->{params};\n    },\n);\n\n# the magic cookie jar\nmy %dcc_types = (\n    qr/^(?:CHAT|SEND)$/ => sub {\n        my ($nick, $type, $args) = @_;\n        my ($file, $addr, $port, $size);\n        return if !(($file, $addr, $port, $size) = $args =~ /^(\".+\"|[^ ]+) +(\\d+) +(\\d+)(?: +(\\d+))?/);\n\n        if ($file =~ s/^\"//) {\n            $file =~ s/\"$//;\n            $file =~ s/\\\\\"/\"/g;\n        }\n        $file = fileparse($file);\n\n        return (\n            $port,\n            {\n                nick => $nick,\n                type => $type,\n                file => $file,\n                size => $size,\n                addr => $addr,\n                port => $port,\n            },\n            $file,\n            $size,\n            $addr,\n        );\n    },\n    qr/^(?:ACCEPT|RESUME)$/ => sub {\n        my ($nick, $type, $args) = @_;\n        my ($file, $port, $position);\n        return if !(($file, $port, $position) = $args =~ /^(\".+\"|[^ ]+) +(\\d+) +(\\d+)/);\n\n        $file =~ s/^\"|\"$//g;\n        $file = fileparse($file);\n\n        return (\n            $port,\n            {\n                nick => $nick,\n                type => $type,\n                file => $file,\n                size => $position,\n                port => $port,\n            },\n            $file,\n            $position,\n        );\n    },\n);\n\nsub new {\n    my ($package, %self) = @_;\n\n    $self{lc $_} = delete $self{$_} for keys %self;\n    $self{BUFFER} = [ ];\n    $self{_ircd} = POE::Filter::IRCD->new();\n    $self{chantypes} = [ '#', '&' ] if ref $self{chantypes} ne 'ARRAY';\n\n    return bless \\%self, $package;\n}\n\nsub clone {\n    my $self = shift;\n    my $nself = { };\n    $nself->{$_} = $self->{$_} for keys %{ $self };\n    $nself->{BUFFER} = [ ];\n    return bless $nself, ref $self;\n}\n\n# Set/clear the 'debug' flag.\nsub debug {\n    my ($self, $flag) = @_;\n    if (defined $flag) {\n        $self->{debug} = $flag;\n        $self->{_ircd}->debug($flag);\n    }\n    return $self->{debug};\n}\n\nsub chantypes {\n    my ($self, $ref) = @_;\n    return if ref $ref ne 'ARRAY' || !@{ $ref };\n    $self->{chantypes} = $ref;\n    return 1;\n}\n\nsub identifymsg {\n    my ($self, $switch) = @_;\n    $self->{identifymsg} = $switch;\n    return;\n}\n\nsub _split_idmsg {\n    my ($line) = @_;\n    my ($identified, $msg) = split //, $line, 2;\n    $identified = $identified eq '+' ? 1 : 0;\n    return $msg, $identified;\n}\n\nsub get_one {\n    my ($self) = @_;\n    my $line = shift @{ $self->{BUFFER} } or return [ ];\n\n    if (ref $line ne 'HASH' || !$line->{command} || !$line->{params}) {\n        warn \"Received line '$line' that is not IRC protocol\\n\" if $self->{debug};\n        return [ ];\n    }\n\n    if ($line->{command} =~ /^PRIVMSG|NOTICE$/ && $line->{params}->[1] =~ tr/\\001//) {\n        return $self->_get_ctcp($line);\n    }\n\n    my $event = {\n        name     => lc $line->{command},\n        raw_line => $line->{raw_line},\n    };\n\n    for my $cmd (keys %irc_cmds) {\n        if ($event->{name} =~ $cmd) {\n            $irc_cmds{$cmd}->($self, $event, $line);\n            return [ $event ];\n        }\n    }\n\n    # default\n    unshift( @{ $line->{params} }, _decolon( $line->{prefix} || '' ) ) if $line->{prefix};\n    $event->{args} = $line->{params};\n    return [ $event ];\n}\n\nsub get_one_start {\n    my ($self, $lines) = @_;\n    push @{ $self->{BUFFER} }, @$lines;\n    return;\n}\n\nsub put {\n    my ($self, $lineref) = @_;\n    my $quoted = [ ];\n    push @$quoted, _ctcp_quote($_) for @$lineref;\n    return $quoted;\n}\n\n# Properly CTCP-quotes a message. Whoop.\nsub _ctcp_quote {\n    my ($line) = @_;\n\n    $line = _low_quote( $line );\n    #$line =~ s/\\\\/\\\\\\\\/g;\n    $line =~ s/\\001/\\\\a/g;\n\n    return \"\\001$line\\001\";\n}\n\n# Splits a message into CTCP and text chunks. This is gross. Most of\n# this is also stolen from Net::IRC, but I (fimm) wrote that too, so it's\n# used with permission. ;-)\nsub _ctcp_dequote {\n    my ($msg) = @_;\n    my (@chunks, $ctcp, $text);\n\n    # CHUNG! CHUNG! CHUNG!\n\n    if (!defined $msg) {\n        croak 'Not enough arguments to POE::Filter::IRC::Compat::_ctcp_dequote';\n    }\n\n    # Strip out any low-level quoting in the text.\n    $msg = _low_dequote( $msg );\n\n    # Filter misplaced \\001s before processing... (Thanks, tchrist!)\n    substr($msg, rindex($msg, \"\\001\"), 1, '\\\\a')\n        if ($msg =~ tr/\\001//) % 2 != 0;\n\n    return if $msg !~ tr/\\001//;\n\n    @chunks = split /\\001/, $msg;\n    shift @chunks if !length $chunks[0]; # FIXME: Is this safe?\n\n    for (@chunks) {\n        # Dequote unnecessarily quoted chars, and convert escaped \\'s and ^A's.\n        s/\\\\([^\\\\a])/$1/g;\n        s/\\\\\\\\/\\\\/g;\n        s/\\\\a/\\001/g;\n    }\n\n    # If the line begins with a control-A, the first chunk is a CTCP\n    # message. Otherwise, it starts with text and alternates with CTCP\n    # messages. Really stupid protocol.\n    if ($msg =~ /^\\001/) {\n        push @$ctcp, shift @chunks;\n    }\n\n    while (@chunks) {\n        push @$text, shift @chunks;\n        push @$ctcp, shift @chunks if @chunks;\n    }\n\n    return ($ctcp, $text);\n}\n\nsub _decolon {\n    my ($line) = @_;\n\n    $line =~ s/^://;\n    return $line;\n}\n\n## no critic (Subroutines::ProhibitExcessComplexity)\nsub _get_ctcp {\n    my ($self, $line) = @_;\n\n    # Is this a CTCP request or reply?\n    my $ctcp_type = $line->{command} eq 'PRIVMSG' ? 'ctcp' : 'ctcpreply';\n\n    # CAPAP IDENTIFY-MSG is only applied to ACTIONs\n    my ($msg, $identified) = ($line->{params}->[1], ", 8192) = 8192
09:01:57.106590 stat("modules/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.106648 stat("modules/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.106702 stat("modules/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.106755 stat("modules/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.106808 stat("/etc/perl/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.106861 stat("/etc/perl/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.106915 stat("/usr/local/lib/perl/5.14.2/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.106972 stat("/usr/local/lib/perl/5.14.2/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.107027 stat("/usr/local/share/perl/5.14.2/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.107084 stat("/usr/local/share/perl/5.14.2/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.107139 stat("/usr/lib/perl5/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.107193 stat("/usr/lib/perl5/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.107248 stat("/usr/share/perl5/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.107303 stat("/usr/share/perl5/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.107378 stat("/usr/lib/perl/5.14/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.107437 stat("/usr/lib/perl/5.14/File/Basename.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.107493 stat("/usr/share/perl/5.14/File/Basename.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.107550 stat("/usr/share/perl/5.14/File/Basename.pm", {st_mode=S_IFREG|0644, st_size=11251, ...}) = 0
09:01:57.107615 open("/usr/share/perl/5.14/File/Basename.pm", O_RDONLY) = 8
09:01:57.107674 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.107727 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.107794 read(8, "=head1 NAME\n\nFile::Basename - Parse file paths into directory, filename and suffix.\n\n=head1 SYNOPSIS\n\n    use File::Basename;\n\n    ($name,$path,$suffix) = fileparse($fullname,@suffixlist);\n    $name = fileparse($fullname,@suffixlist);\n\n    $basename = basename($fullname,@suffixlist);\n    $dirname  = dirname($fullname);\n\n\n=head1 DESCRIPTION\n\nThese routines allow you to parse file paths into their directory, filename\nand suffix.\n\nB<NOTE>: C<dirname()> and C<basename()> emulate the behaviours, and\nquirks, of the shell and C functions of the same name.  See each\nfunction's documentation for details.  If your concern is just parsing\npaths it is safer to use L<File::Spec>'s C<splitpath()> and\nC<splitdir()> methods.\n\nIt is guaranteed that\n\n    # Where $path_separator is / for Unix, \\ for Windows, etc...\n    dirname($path) . $path_separator . basename($path);\n\nis equivalent to the original path for all systems but VMS.\n\n\n=cut\n\n\npackage File::Basename;\n\n# File::Basename is used during the Perl build, when the re extension may\n# not be available, but we only actually need it if running under tainting.\nBEGIN {\n  if (${^TAINT}) {\n    require re;\n    re->import('taint');\n  }\n}\n\n\nuse strict;\nuse 5.006;\nuse warnings;\nour(@ISA, @EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(fileparse fileparse_set_fstype basename dirname);\n$VERSION = \"2.82\";\n\nfileparse_set_fstype($^O);\n\n\n=over 4\n\n=item C<fileparse>\nX<fileparse>\n\n    my($filename, $directories, $suffix) = fileparse($path);\n    my($filename, $directories, $suffix) = fileparse($path, @suffixes);\n    my $filename                         = fileparse($path, @suffixes);\n\nThe C<fileparse()> routine divides a file path into its $directories, $filename\nand (optionally) the filename $suffix.\n\n$directories contains everything up to and including the last\ndirectory separator in the $path including the volume (if applicable).\nThe remainder of the $path is the $filename.\n\n     # On Unix returns (\"baz\", \"/foo/bar/\", \"\")\n     fileparse(\"/foo/bar/baz\");\n\n     # On Windows returns (\"baz\", 'C:\\foo\\bar\\', \"\")\n     fileparse('C:\\foo\\bar\\baz');\n\n     # On Unix returns (\"\", \"/foo/bar/baz/\", \"\")\n     fileparse(\"/foo/bar/baz/\");\n\nIf @suffixes are given each element is a pattern (either a string or a\nC<qr//>) matched against the end of the $filename.  The matching\nportion is removed and becomes the $suffix.\n\n     # On Unix returns (\"baz\", \"/foo/bar/\", \".txt\")\n     fileparse(\"/foo/bar/baz.txt\", qr/\\.[^.]*/);\n\nIf type is non-Unix (see C<fileparse_set_fstype()>) then the pattern\nmatching for suffix removal is performed case-insensitively, since\nthose systems are not case-sensitive when opening existing files.\n\nYou are guaranteed that C<$directories . $filename . $suffix> will\ndenote the same location as the original $path.\n\n=cut\n\n\nsub fileparse {\n  my($fullname,@suffices) = @_;\n\n  unless (defined $fullname) {\n      require Carp;\n      Carp::croak(\"fileparse(): need a valid pathname\");\n  }\n\n  my $orig_type = '';\n  my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);\n\n  my($taint) = substr($fullname,0,0);  # Is $fullname tainted?\n\n  if ($type eq \"VMS\" and $fullname =~ m{/} ) {\n    # We're doing Unix emulation\n    $orig_type = $type;\n    $type = 'Unix';\n  }\n\n  my($dirpath, $basename);\n\n  if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {\n    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\\\\/])?)(.*)/s);\n    $dirpath .= '.\\\\' unless $dirpath =~ /[\\\\\\/]\\z/;\n  }\n  elsif ($type eq \"OS2\") {\n    ($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\\\/])?)(.*)#s);\n    $dirpath = './' unless $dirpath;\t# Can't be 0\n    $dirpath .= '/' unless $dirpath =~ m#[\\\\/]\\z#;\n  }\n  elsif ($type eq \"MacOS\") {\n    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);\n    $dirpath = ':' unless $dirpath;\n  }\n  elsif ($type eq \"AmigaOS\") {\n    ($dirpath,$basename) = ($fullname =~ /(.*[:\\/])?(.*)/s);\n    $dirpath = './' unless $dirpath;\n  }\n  elsif ($type eq 'VMS' ) {\n    ($dirpath,$basename) = ($fullname =~ /^(.*[:>\\]])?(.*)/s);\n    $dirpath ||= '';  # should always be defined\n  }\n  else { # Default to Unix semantics.\n    ($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);\n    if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {\n      # dev:[000000] is top of VMS tree, similar to Unix '/'\n      # so strip it off and treat the rest as \"normal\"\n      my $devspec  = $1;\n      my $remainder = $3;\n      ($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);\n      $dirpath ||= '';  # should always be defined\n      $dirpath = $devspec.$dirpath;\n    }\n    $dirpath = './' unless $dirpath;\n  }\n      \n\n  my $tail   = '';\n  my $suffix = '';\n  if (@suffices) {\n    foreach $suffix (@suffices) {\n      my $pat = ($igncase ? '(?i)' : '') . \"($suffix)\\$\";\n      if ($basename =~ s/$pat//s) {\n        $taint .= substr($suffix,0,0);\n        $tail = $1 . $tail;\n      }\n    }\n  }\n\n  # Ensure taint is propagated from the path to its pieces.\n  $tail .= $taint;\n  wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)\n            : ($basename .= $taint);\n}\n\n\n\n=item C<basename>\nX<basename> X<filename>\n\n    my $filename = basename($path);\n    my $filename = basename($path, @suffixes);\n\nThis function is provided for compatibility with the Unix shell command\nC<basename(1)>.  It does B<NOT> always return the file name portion of a\npath as you might expect.  To be safe, if you want the file name portion of\na path use C<fileparse()>.\n\nC<basename()> returns the last level of a filepath even if the last\nlevel is clearly directory.  In effect, it is acting like C<pop()> for\npaths.  This differs from C<fileparse()>'s behaviour.\n\n    # Both return \"bar\"\n    basename(\"/foo/bar\");\n    basename(\"/foo/bar/\");\n\n@suffixes work as in C<fileparse()> except all regex metacharacters are\nquoted.\n\n    # These two function calls are equivalent.\n    my $filename = basename(\"/foo/bar/baz.txt\",  \".txt\");\n    my $filename = fileparse(\"/foo/bar/baz.txt\", qr/\\Q.txt\\E/);\n\nAlso note that in order to be compatible with the shell command,\nC<basename()> does not strip off a suffix if it is identical to the\nremaining characters in the filename.\n\n=cut\n\n\nsub basename {\n  my($path) = shift;\n\n  # From BSD basename(1)\n  # The basename utility deletes any prefix ending with the last slash `/'\n  # character present in string (after first stripping trailing slashes)\n  _strip_trailing_sep($path);\n\n  my($basename, $dirname, $suffix) = fileparse( $path, map(\"\\Q$_\\E\",@_) );\n\n  # From BSD basename(1)\n  # The suffix is not stripped if it is identical to the remaining \n  # characters in string.\n  if( length $suffix and !length $basename ) {\n      $basename = $suffix;\n  }\n  \n  # Ensure that basename '/' == '/'\n  if( !length $basename ) {\n      $basename = $dirname;\n  }\n\n  return $basename;\n}\n\n\n\n=item C<dirname>\nX<dirname>\n\nThis function is provided for compatibility with the Unix shell\ncommand C<dirname(1)> and has inherited some of its quirks.  In spite of\nits name it does B<NOT> always return the directory name as you might\nexpect.  To be safe, if you want the directory name of a path use\nC<fileparse()>.\n\nOnly on VMS (where there is no ambiguity between the file and directory\nportions of a path) and AmigaOS (possibly due to an implementation quirk in\nthis module) does C<dirname()> work like C<fileparse($path)>, returning just the\n$directories.\n\n    # On VMS and AmigaOS\n    my $directories = dirname($path);\n\nWhen using Unix or MSDOS syntax this emulates the C<dirname(1)> shell function\nwhich is subtly different from how C<fileparse()> works.  It returns all but\nthe last level of a file path even if the last level is clearly a directory.\nIn effect, it is not returning the directory portion but simply the path one\nlevel up acting like C<chop()> for file paths.\n\nAlso unlike C<fileparse()>, C<dirname()> does not include a trailing slash on\nits returned path.\n\n    # returns /foo/bar.  fileparse() would return /foo/bar/\n    dirname(\"/foo/bar/baz\");\n\n    # also returns /foo/bar despite the fact that baz is clearly a \n    # directory.  fileparse() would return /foo/bar/baz/\n    dirname(\"/foo/bar/baz/\");\n\n    # returns '.'.  fileparse() would re", 8192) = 8192
09:01:57.108726 read(8, "turn 'foo/'\n    dirname(\"foo/\");\n\nUnder VMS, if there is no directory information in the $path, then the\ncurrent default device and directory is used.\n\n=cut\n\n\nsub dirname {\n    my $path = shift;\n\n    my($type) = $Fileparse_fstype;\n\n    if( $type eq 'VMS' and $path =~ m{/} ) {\n        # Parse as Unix\n        local($File::Basename::Fileparse_fstype) = '';\n        return dirname($path);\n    }\n\n    my($basename, $dirname) = fileparse($path);\n\n    if ($type eq 'VMS') { \n        $dirname ||= $ENV{DEFAULT};\n    }\n    elsif ($type eq 'MacOS') {\n\tif( !length($basename) && $dirname !~ /^[^:]+:\\z/) {\n            _strip_trailing_sep($dirname);\n\t    ($basename,$dirname) = fileparse $dirname;\n\t}\n\t$dirname .= \":\" unless $dirname =~ /:\\z/;\n    }\n    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { \n        _strip_trailing_sep($dirname);\n        unless( length($basename) ) {\n\t    ($basename,$dirname) = fileparse $dirname;\n\t    _strip_trailing_sep($dirname);\n\t}\n    }\n    elsif ($type eq 'AmigaOS') {\n        if ( $dirname =~ /:\\z/) { return $dirname }\n        chop $dirname;\n        $dirname =~ s{[^:/]+\\z}{} unless length($basename);\n    }\n    else {\n        _strip_trailing_sep($dirname);\n        unless( length($basename) ) {\n\t    ($basename,$dirname) = fileparse $dirname;\n\t    _strip_trailing_sep($dirname);\n\t}\n    }\n\n    $dirname;\n}\n\n\n# Strip the trailing path separator.\nsub _strip_trailing_sep  {\n    my $type = $Fileparse_fstype;\n\n    if ($type eq 'MacOS') {\n        $_[0] =~ s/([^:]):\\z/$1/s;\n    }\n    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { \n        $_[0] =~ s/([^:])[\\\\\\/]*\\z/$1/;\n    }\n    else {\n        $_[0] =~ s{(.)/*\\z}{$1}s;\n    }\n}\n\n\n=item C<fileparse_set_fstype>\nX<filesystem>\n\n  my $type = fileparse_set_fstype();\n  my $previous_type = fileparse_set_fstype($type);\n\nNormally File::Basename will assume a file path type native to your current\noperating system (ie. /foo/bar style on Unix, \\foo\\bar on Windows, etc...).\nWith this function you can override that assumption.\n\nValid $types are \"MacOS\", \"VMS\", \"AmigaOS\", \"OS2\", \"RISCOS\",\n\"MSWin32\", \"DOS\" (also \"MSDOS\" for backwards bug compatibility),\n\"Epoc\" and \"Unix\" (all case-insensitive).  If an unrecognized $type is\ngiven \"Unix\" will be assumed.\n\nIf you've selected VMS syntax, and the file specification you pass to\none of these routines contains a \"/\", they assume you are using Unix\nemulation and apply the Unix syntax rules instead, for that function\ncall only.\n\n=back\n\n=cut\n\n\nBEGIN {\n\nmy @Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);\nmy @Types = (@Ignore_Case, qw(Unix));\n\nsub fileparse_set_fstype {\n    my $old = $Fileparse_fstype;\n\n    if (@_) {\n        my $new_type = shift;\n\n        $Fileparse_fstype = 'Unix';  # default\n        foreach my $type (@Types) {\n            $Fileparse_fstype = $type if $new_type =~ /^$type/i;\n        }\n\n        $Fileparse_igncase = \n          (grep $Fileparse_fstype eq $_, @Ignore_Case) ? 1 : 0;\n    }\n\n    return $old;\n}\n\n}\n\n\n1;\n\n\n=head1 SEE ALSO\n\nL<dirname(1)>, L<basename(1)>, L<File::Spec>\n", 8192) = 3059
09:01:57.109219 brk(0xd5c000)           = 0xd5c000
09:01:57.109339 read(8, "", 8192)       = 0
09:01:57.109392 close(8)                = 0
09:01:57.110535 brk(0xd7d000)           = 0xd7d000
09:01:57.110760 read(7, "undef);\n    ($msg, $identified) = _split_idmsg($msg) if $self->{identifymsg} && $msg =~ /^.ACTION/;\n\n    my $events = [ ];\n    my ($ctcp, $text) = _ctcp_dequote($msg);\n\n    if (!defined $ctcp) {\n        warn \"Received malformed CTCP message: $msg\\n\" if $self->{debug};\n        return $events;\n    }\n\n    my $nick = defined $line->{prefix} ? (split /!/, $line->{prefix})[0] : undef;\n\n    # We only process the first CTCP. The only people who send multiple ones\n    # are those who are trying to flood our outgoing queue anyway (e.g. by\n    # having us reply to 20 VERSION requests at a time).\n    my ($name, $args);\n    CTCP: for my $string ($ctcp->[0]) {\n        if (!(($name, $args) = $string =~ /^(\\w+)(?: +(.*))?/)) {\n            defined $nick\n                ? do { warn \"Received malformed CTCP message from $nick: $string\\n\" if $self->{debug} }\n                : do { warn \"Trying to send malformed CTCP message: $string\\n\" if $self->{debug} }\n            ;\n            last CTCP;\n        }\n\n        if (lc $name eq 'dcc') {\n            my ($dcc_type, $rest);\n\n            if (!(($dcc_type, $rest) = $args =~ /^(\\w+) +(.+)/)) {\n                defined $nick\n                    ? do { warn \"Received malformed DCC request from $nick: $args\\n\" if $self->{debug} }\n                    : do { warn \"Trying to send malformed DCC request: $args\\n\" if $self->{debug} }\n                ;\n                last CTCP;\n\n            }\n            $dcc_type = uc $dcc_type;\n\n            my ($handler) = grep { $dcc_type =~ /$_/ } keys %dcc_types;\n            if (!$handler) {\n                warn \"Unhandled DCC $dcc_type request: $rest\\n\" if $self->{debug};\n                last CTCP;\n            }\n\n            my @dcc_args = $dcc_types{$handler}->($nick, $dcc_type, $rest);\n            if (!@dcc_args) {\n                defined $nick\n                    ? do { warn \"Received malformed DCC $dcc_type request from $nick: $rest\\n\" if $self->{debug} }\n                    : do { warn \"Trying to send malformed DCC $dcc_type request: $rest\\n\" if $self->{debug} }\n                ;\n                last CTCP;\n            }\n\n            push @$events, {\n                name => 'dcc_request',\n                args => [\n                    $line->{prefix},\n                    $dcc_type,\n                    @dcc_args,\n                ],\n                raw_line => $line->{raw_line},\n            };\n        }\n        else {\n            push @$events, {\n                name => $ctcp_type . '_' . lc $name,\n                args => [\n                    $line->{prefix},\n                    [split /,/, $line->{params}->[0]],\n                    (defined $args ? $args : ''),\n                    (defined $identified ? $identified : () ),\n                ],\n                raw_line => $line->{raw_line},\n            };\n        }\n    }\n\n    # XXX: I'm not quite sure what this is for, but on FreeNode it adds an\n    # extra bogus event and displays a debug message, so I have disabled it.\n    # FreeNode precedes PRIVMSG and CTCP ACTION messages with '+' or '-'.\n    #if ($text && @$text) {\n    #    my $what;\n    #    ($what) = $line->{raw_line} =~ /^(:[^ ]+ +\\w+ +[^ ]+ +)/\n    #        or warn \"What the heck? '\".$line->{raw_line}.\"'\\n\" if $self->{debug};\n    #    $text = (defined $what ? $what : '') . ':' . join '', @$text;\n    #    $text =~ s/\\cP/^P/g;\n    #    warn \"CTCP: $text\\n\" if $self->{debug};\n    #    push @$events, @{ $self->{_ircd}->get([$text]) };\n    #}\n\n    return $events;\n}\n\n# Quotes a string in a low-level, protocol-safe, utterly brain-dead\n# fashion. Returns the quoted string.\nsub _low_quote {\n    my ($line) = @_;\n    my %enquote = (\"\\012\" => 'n', \"\\015\" => 'r', \"\\0\" => '0', \"\\cP\" => \"\\cP\");\n\n    if (!defined $line) {\n        croak 'Not enough arguments to POE::Filter::IRC::Compat->_low_quote';\n    }\n\n    if ($line =~ tr/[\\012\\015\\0\\cP]//) { # quote \\n, \\r, ^P, and \\0.\n        $line =~ s/([\\012\\015\\0\\cP])/\\cP$enquote{$1}/g;\n    }\n\n    return $line;\n}\n\n# Does low-level dequoting on CTCP messages. I hate this protocol.\n# Yes, I copied this whole section out of Net::IRC.\nsub _low_dequote {\n    my ($line) = @_;\n    my %dequote = (n => \"\\012\", r => \"\\015\", 0 => \"\\0\", \"\\cP\" => \"\\cP\");\n\n    if (!defined $line) {\n        croak 'Not enough arguments to POE::Filter::IRC::Compat->_low_dequote';\n    }\n\n    # dequote \\n, \\r, ^P, and \\0.\n    # Thanks to Abigail (abigail@foad.org) for this clever bit.\n    if ($line =~ tr/\\cP//) {\n        $line =~ s/\\cP([nr0\\cP])/$dequote{$1}/g;\n    }\n\n    return $line;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Filter::IRC::Compat - A filter which converts L<POE::Filter::IRCD|POE::Filter::IRCD>\noutput into L<POE::Component::IRC|POE::Component::IRC> events\n\n=head1 SYNOPSIS\n\n my $filter = POE::Filter::IRC::Compat->new();\n my @events = @{ $filter->get( [ @lines ] ) };\n my @msgs = @{ $filter->put( [ @messages ] ) };\n\n=head1 DESCRIPTION\n\nPOE::Filter::IRC::Compat is a L<POE::Filter|POE::Filter> that converts\nL<POE::Filter::IRCD|POE::Filter::IRCD> output into the L<POE::Component::IRC|POE::Component::IRC>\ncompatible event references. Basically a hack, so I could replace\nL<POE::Filter::IRC|POE::Filter::IRC> with something that was more\ngeneric.\n\nAmong other things, it converts normal text into thoroughly CTCP-quoted\nmessages, and transmogrifies CTCP-quoted messages into their normal,\nsane components. Rather what you'd expect a filter to do.\n\nA note: the CTCP protocol sucks bollocks. If I ever meet the fellow who\ncame up with it, I'll shave their head and tattoo obscenities on it.\nJust read the \"specification\" (F<docs/ctcpspec.html> in this distribution)\nand you'll hopefully see what I mean. Quote this, quote that, quote this\nagain, all in different and weird ways... and who the hell needs to send\nmixed CTCP and text messages? WTF? It looks like it's practically complexity\nfor complexity's sake -- and don't even get me started on the design of the\nDCC protocol! Anyhow, enough ranting. Onto the rest of the docs...\n\n=head1 METHODS\n\n=head2 C<new>\n\nReturns a POE::Filter::IRC::Compat object. Takes no arguments.\n\n=head2 C<clone>\n\nMakes a copy of the filter, and clears the copy's buffer.\n\n=head2 C<get>\n\nTakes an arrayref of L<POE::Filter::IRCD> hashrefs and produces an arrayref of\nL<POE::Component::IRC|POE::Component::IRC> compatible event hashrefs. Yay.\n\n=head2 C<get_one_start>, C<get_one>\n\nThese perform a similar function as C<get> but enable the filter to work with\nL<POE::Filter::Stackable|POE::Filter::Stackable>.\n\n=head2 C<put>\n\nTakes an array reference of CTCP messages to be properly quoted. This\ndoesn't support CTCPs embedded in normal messages, which is a\nbrain-dead hack in the protocol, so do it yourself if you really need\nit. Returns an array reference of the quoted lines for sending.\n\n=head2 C<debug>\n\nTakes an optinal true/false value which enables/disables debugging\naccordingly. Returns the debug status.\n\n=head2 C<chantypes>\n\nTakes an arrayref of possible channel prefix indicators.\n\n=head2 C<identifymsg>\n\nTakes a boolean to turn on/off the support for CAPAB IDENTIFY-MSG.\n\n=head1 AUTHOR\n\nChris 'BinGOs' Williams\n\n=head1 SEE ALSO\n\nL<POE::Filter::IRCD|POE::Filter::IRCD>\n\nL<POE::Filter|POE::Filter>\n\nL<POE::Filter::Stackable|POE::Filter::Stackable>\n\n=cut\n", 8192) = 7248
09:01:57.111570 read(7, "", 8192)       = 0
09:01:57.111621 close(7)                = 0
09:01:57.111725 stat("modules/POE/Component/IRC/Constants.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.111782 stat("modules/POE/Component/IRC/Constants.pm", {st_mode=S_IFREG|0600, st_size=1650, ...}) = 0
09:01:57.111861 open("modules/POE/Component/IRC/Constants.pm", O_RDONLY) = 7
09:01:57.111915 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.111962 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.112025 read(7, "package POE::Component::IRC::Constants;\nBEGIN {\n  $POE::Component::IRC::Constants::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::Constants::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\n\nrequire Exporter;\nuse base qw(Exporter);\nour @EXPORT_OK = qw(\n    PCI_REFCOUNT_TAG PRI_LOGIN PRI_HIGH PRI_NORMAL MSG_PRI MSG_TEXT\n    CMD_PRI CMD_SUB\n);\nour %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );\n\nuse constant {\n    # The name of the reference count P::C::I keeps in client sessions.\n    PCI_REFCOUNT_TAG => 'P::C::I registered',\n\n    # Message priorities.\n    PRI_LOGIN  => 10, # PASS/NICK/USER messages must go first.\n    PRI_HIGH   => 20, # KICK/MODE etc. is more important than chatter.\n    PRI_NORMAL => 30, # Random chatter.\n\n    MSG_PRI  => 0, # Queued message priority.\n    MSG_TEXT => 1, # Queued message text.\n\n    # RCC: Since most of the commands are data driven, I have moved their\n    # event/handler maps here and added priorities for each data driven\n    # command.  The priorities determine message importance when messages\n    # are queued up.  Lower ones get sent first.\n    CMD_PRI => 0, # Command priority.\n    CMD_SUB => 1, # Command handler.\n};\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC::Constants - Defines constants required by\nL<POE::Component::IRC|POE::Component::IRC>\n\n=head1 SYNOPSIS\n\n use POE::Component::IRC::Constants qw(:ALL);\n\n=head1 DESCRIPTION\n\nPOE::Component::IRC::Constants defines constants required by\nL<POE::Component::IRC|POE::Component::IRC> and derived sub-classes.\n\n=head1 AUTHOR\n\nChris Williams <chris@bingosnet.co.uk>\n\n=head1 SEE ALSO\n\nL<POE::Component::IRC|POE::Component::IRC>\n\n=cut\n", 8192) = 1650
09:01:57.112361 read(7, "", 8192)       = 0
09:01:57.112414 close(7)                = 0
09:01:57.112568 stat("modules/POE/Component/IRC/Plugin.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.112624 stat("modules/POE/Component/IRC/Plugin.pm", {st_mode=S_IFREG|0600, st_size=11449, ...}) = 0
09:01:57.112687 open("modules/POE/Component/IRC/Plugin.pm", O_RDONLY) = 7
09:01:57.112744 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.112794 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.112859 read(7, "package POE::Component::IRC::Plugin;\nBEGIN {\n  $POE::Component::IRC::Plugin::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::Plugin::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\n\nrequire Exporter;\nuse base qw(Exporter);\nour @EXPORT_OK = qw(PCI_EAT_NONE PCI_EAT_CLIENT PCI_EAT_PLUGIN PCI_EAT_ALL);\nour %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );\n\nuse constant {\n    PCI_EAT_NONE   => 1,\n    PCI_EAT_CLIENT => 2,\n    PCI_EAT_PLUGIN => 3,\n    PCI_EAT_ALL    => 4,\n};\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC::Plugin - Provides plugin constants and documentation for\nL<POE::Component::IRC|POE::Component::IRC>\n\n=head1 SYNOPSIS\n\n # A simple ROT13 'encryption' plugin\n\n package Rot13;\n\n use strict;\n use warnings;\n use POE::Component::IRC::Plugin qw( :ALL );\n\n # Plugin object constructor\n sub new {\n     my $package = shift;\n     return bless {}, $package;\n }\n\n sub PCI_register {\n     my ($self, $irc) = splice @_, 0, 2;\n\n     $irc->plugin_register( $self, 'SERVER', qw(public) );\n     return 1;\n }\n\n # This is method is mandatory but we don't actually have anything to do.\n sub PCI_unregister {\n     return 1;\n }\n\n sub S_public {\n     my ($self, $irc) = splice @_, 0, 2;\n\n     # Parameters are passed as scalar-refs including arrayrefs.\n     my $nick    = ( split /!/, ${ $_[0] } )[0];\n     my $channel = ${ $_[1] }->[0];\n     my $msg     = ${ $_[2] };\n\n     if (my ($rot13) = $msg =~ /^rot13 (.+)/) {\n         $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];\n\n         # Send a response back to the server.\n         $irc->yield( privmsg => $channel => $rot13 );\n         # We don't want other plugins to process this\n         return PCI_EAT_PLUGIN;\n     }\n\n     # Default action is to allow other plugins to process it.\n     return PCI_EAT_NONE;\n }\n\n=head1 DESCRIPTION\n\nPOE::Component::IRC's plugin system has been released separately as\nL<Object::Pluggable|Object::Pluggable>. Gleaning at its documentation is\nadvised. The rest of this document mostly describes aspects that are\nspecific to POE::Component::IRC's use of Object::Pluggable.\n\n=head1 HISTORY\n\nCertain individuals in #PoE on MAGNet said we didn't need to bloat the\nPoCo-IRC code...\n\nBinGOs, the current maintainer of the module, and I heartily agreed that this\nis a wise choice.\n\nOne example:\n\nLook at the magnificent new feature in 3.4 -> irc_whois replies! Yes, that is\na feature I bet most of us have been coveting for a while, as it definitely\nmakes our life easier. It was implemented in 30 minutes or so after a request,\nthe maintainer said. I replied by saying that it's a wonderful idea, but what\nwould happen if somebody else asked for a new feature? Maybe thatfeature is\nsomething we all would love to have, so should it be put in the core? Plugins\nallow the core to stay lean and mean, while delegating additional functionality\nto outside modules. BinGOs' work with making PoCo-IRC inheritable is wonderful,\nbut what if there were 2 modules which have features that you would love to\nhave in your bot? Inherit from both? Imagine the mess...\n\nHere comes plugins to the rescue :)\n\nYou could say Bot::Pluggable does the job, and so on, but if this feature were\nput into the core, it would allow PoCo-IRC to be extended beyond our wildest\ndreams, and allow the code to be shared amongst us all, giving us superior bug\nsmashing abilities.\n\nYes, there are changes that most of us will moan when we go update our bots to\nuse the new C<$irc> object system, but what if we also used this opportunity to\nimprove PoCo-IRC even more and give it a lifespan until Perl8 or whatever comes\nalong? :)\n\n=head1 DESCRIPTION\n\nThe plugin system works by letting coders hook into the two aspects of PoCo-IRC:\n\n=over\n\n=item *\n\nData received from the server\n\n=item *\n\nUser commands about to be sent to the server\n\n=back\n\nThe goal of this system is to make PoCo-IRC so easy to extend, enabling it to\nTake Over The World! *Just Kidding*\n\nThe general architecture of using the plugins should be:\n\n # Import the stuff...\n use POE;\n use POE::Component::IRC;\n use POE::Component::IRC::Plugin::ExamplePlugin;\n\n # Create our session here\n POE::Session->create( ... );\n\n # Create the IRC session here\n my $irc = POE::Component::IRC->spawn() or die \"Oh noooo! $!\";\n\n # Create the plugin\n # Of course it could be something like $plugin = MyPlugin->new();\n my $plugin = POE::Component::IRC::Plugin::ExamplePlugin->new( ... );\n\n # Hook it up!\n $irc->plugin_add( 'ExamplePlugin', $plugin );\n\n # OOPS, we lost the plugin object!\n my $pluginobj = $irc->plugin_get( 'ExamplePlugin' );\n\n # We want a list of plugins and objects\n my $hashref = $irc->plugin_list();\n\n # Oh! We want a list of plugin aliases.\n my @aliases = keys %{ $irc->plugin_list() };\n\n # Ah, we want to remove the plugin\n $plugin = $irc->plugin_del( 'ExamplePlugin' );\n\nThe plugins themselves will conform to the standard API described here. What\nthey can do is limited only by imagination and the IRC RFC's ;)\n\n # Import the constants\n use POE::Component::IRC::Plugin qw( :ALL );\n\n # Our constructor\n sub new {\n     ...\n }\n\n # Required entry point for PoCo-IRC\n sub PCI_register {\n     my ($self, $irc) = @_;\n     # Register events we are interested in\n     $irc->plugin_register( $self, 'SERVER', qw( 355 kick whatever) );\n\n     # Return success\n     return 1;\n }\n\n # Required exit point for PoCo-IRC\n sub PCI_unregister {\n     my ($self, $irc) = @_;\n\n     # PCI will automatically unregister events for the plugin\n\n     # Do some cleanup...\n\n     # Return success\n     return 1;\n }\n\n # Registered events will be sent to methods starting with IRC_\n # If the plugin registered for SERVER - irc_355\n sub S_355 {\n     my($self, $irc, $line) = @_;\n\n     # Remember, we receive pointers to scalars, so we can modify them\n     $$line = 'frobnicate!';\n\n     # Return an exit code\n     return PCI_EAT_NONE;\n }\n\n # Default handler for events that do not have a corresponding plugin\n # method defined.\n sub _default {\n     my ($self, $irc, $event) = splice @_, 0, 3;\n\n     print \"Default called for $event\\n\";\n\n     # Return an exit code\n     return PCI_EAT_NONE;\n }\n\nPlugins can even embed their own POE sessions if they need to do fancy stuff.\nBelow is a template for a plugin which does just that.\n\n package POE::Plugin::Template;\n\n use POE;\n use POE::Component::IRC::Plugin qw( :ALL );\n\n sub new {\n     my $package = shift;\n     my $self = bless {@_}, $package;\n     return $self;\n }\n\n sub PCI_register {\n     my ($self, $irc) = splice @_, 0, 2;\n\n     # We store a ref to the $irc object so we can use it in our\n     # session handlers.\n     $self->{irc} = $irc;\n\n     $irc->plugin_register( $self, 'SERVER', qw(blah blah blah) );\n\n     POE::Session->create(\n         object_states => [\n             $self => [qw(_start _shutdown)],\n         ],\n     );\n\n     return 1;\n }\n\n sub PCI_unregister {\n     my ($self, $irc) = splice @_, 0, 2;\n     # Plugin is dying make sure our POE session does as well.\n     $poe_kernel->call( $self->{SESSION_ID} => '_shutdown' );\n     delete $self->{irc};\n     return 1;\n }\n\n sub _start {\n     my ($kernel, $self) = @_[KERNEL, OBJECT];\n     $self->{SESSION_ID} = $_[SESSION]->ID();\n     # Make sure our POE session stays around. Could use aliases but that is so messy :)\n     $kernel->refcount_increment( $self->{SESSION_ID}, __PACKAGE__ );\n     return;\n }\n\n sub _shutdown {\n     my ($kernel, $self) = @_[KERNEL, OBJECT];\n     $kernel->alarm_remove_all();\n     $kernel->refcount_decrement( $self->{SESSION_ID}, __PACKAGE__ );\n     return;\n }\n\n=head1 EVENT TYPES\n\n=head2 SERVER hooks\n\nHooks that are targeted toward data received from the server will get the exact\nsame arguments as if it was a normal event, look at the PoCo-IRC docs for more\ninformation.\n\nNOTE: Server methods are identified in the plugin namespace by the subroutine\nprefix of S_*. I.e. an irc_kick event handler would be:\n\n sub S_kick {}\n\nThe only difference is instead of getting scalars, the hook will get a\nreference to the scalar, to allow it to mangle the data. This allows the plugin\nto modify data *before* they are sent out to registered sessions.\n\nThey are required to return one of the L<exit codes|/EXIT CODES> so PoCo-IRC\nwill know what to do.\n\n=head3 Names of potential hoo", 8192) = 8192
09:01:57.113469 read(7, "ks\n\n 001\n socketerr\n connected\n plugin_del\n ...\n\nKeep in mind that they are always lowercased. Check out the\nL<OUTPUT EVENTS|POE::Component::IRC/OUTPUT EVENTS> section of\nPOE::Component::IRC's documentation for the complete list of events.\n\n=head2 USER hooks\n\nThese type of hooks have two different argument formats. They are split between\ndata sent to the server, and data sent through DCC connections.\n\nNOTE: User methods are identified in the plugin namespace by the subroutine\nprefix of U_*. I.e. an irc_kick event handler would be:\n\n sub U_kick {}\n\nHooks that are targeted to user data have it a little harder. They will receive\na reference to the raw line about to be sent out. That means they will have to\nparse it in order to extract data out of it.\n\nThe reasoning behind this is that it is not possible to insert hooks in every\nmethod in the C<$irc> object, as it will become unwieldy and not allow inheritance\nto work.\n\nThe DCC hooks have it easier, as they do not interact with the server, and will\nreceive references to the arguments specified in the DCC plugin\nL<documentation|POE::Component::IRC::Plugin::DCC/COMMANDS> regarding dcc commands.\n\n=head3 Names of potential hooks\n\n kick\n dcc_chat\n ison\n privmsg\n ...\n\nKeep in mind that they are always lowercased, and are extracted from the raw\nline about to be sent to the irc server. To be able to parse the raw line, some\nRFC reading is in order. These are the DCC events that are not given a raw\nline, they are:\n\n dcc        - $nick, $type, $file, $blocksize, $timeout\n dcc_accept - $cookie, $myfile\n dcc_resume - $cookie\n dcc_chat   - $cookie, @lines\n dcc_close  - $cookie\n\n=head2 _default\n\nIf a plugin has registered for an event but doesn't have a hook method\ndefined for ir, component will attempt to call a plugin's C<_default> method.\nThe first parameter after the plugin and irc objects will be the handler name.\n\n sub _default {\n     my ($self, $irc, $event) = splice @_, 0, 3;\n\n     # $event will be something like S_public or U_dcc, etc.\n     return PCI_EAT_NONE;\n }\n\nThe C<_default> handler is expected to return one of the exit codes so PoCo-IRC\nwill know what to do.\n\n=head1 EXIT CODES\n\n=head2 PCI_EAT_NONE\n\nThis means the event will continue to be processed by remaining plugins and\nfinally, sent to interested sessions that registered for it.\n\n=head2 PCI_EAT_CLIENT\n\nThis means the event will continue to be processed by remaining plugins but\nit will not be sent to any sessions that registered for it. This means nothing\nwill be sent out on the wire if it was an USER event, beware!\n\n=head2 PCI_EAT_PLUGIN\n\nThis means the event will not be processed by remaining plugins, it will go\nstraight to interested sessions.\n\n=head2 PCI_EAT_ALL\n\nThis means the event will be completely discarded, no plugin or session will\nsee it. This means nothing will be sent out on the wire if it was an USER\nevent, beware!\n\n=head1 EXPORTS\n\nExports the return constants for plugins to use in @EXPORT_OK\nAlso, the ':ALL' tag can be used to get all of them.\n\n=head1 SEE ALSO\n\nL<POE::Component::IRC|POE::Component::IRC>\n\nL<Object::Pluggable|Object::Pluggable>\n\nL<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>\n\nL<POE::Session|POE::Session>\n\n=head1 AUTHOR\n\nApocalypse <apocal@cpan.org>\n\n=cut\n", 8192) = 3257
09:01:57.113690 read(7, "", 8192)       = 0
09:01:57.113741 close(7)                = 0
09:01:57.113875 stat("modules/POE/Component/IRC/Plugin/DCC.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.113932 stat("modules/POE/Component/IRC/Plugin/DCC.pm", {st_mode=S_IFREG|0600, st_size=25429, ...}) = 0
09:01:57.113992 open("modules/POE/Component/IRC/Plugin/DCC.pm", O_RDONLY) = 7
09:01:57.114077 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.114126 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.114183 read(7, "package POE::Component::IRC::Plugin::DCC;\nBEGIN {\n  $POE::Component::IRC::Plugin::DCC::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::Plugin::DCC::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\nuse Carp;\nuse File::Basename qw(fileparse);\nuse File::Glob ':glob';\nuse File::Spec::Functions 'rel2abs';\nuse POE qw(Driver::SysRW Filter::Line Filter::Stream\n           Wheel::ReadWrite Wheel::SocketFactory);\nuse POE::Component::IRC::Plugin qw(:ALL);\nuse Socket qw(INADDR_ANY unpack_sockaddr_in inet_aton inet_ntoa);\n\nuse constant {\n    OUT_BLOCKSIZE  => 1024,   # Send DCC data in 1k chunks\n    IN_BLOCKSIZE   => 10_240, # 10k per DCC socket read\n    LISTEN_TIMEOUT => 300,    # Five minutes for listening DCCs\n};\n\nsub new {\n    my ($package) = shift;\n    croak \"$package requires an even number of arguments\" if @_ & 1;\n    my %self = @_;\n    return bless \\%self, $package;\n}\n\nsub PCI_register {\n    my ($self, $irc) = @_;\n\n    $self->{irc} = $irc;\n\n    POE::Session->create(\n        object_states => [\n            $self => [qw(\n                _start\n                _dcc_read\n                _dcc_failed\n                _dcc_timeout\n                _dcc_up\n                _U_dcc\n                _U_dcc_accept\n                _U_dcc_chat\n                _U_dcc_close\n                _U_dcc_resume\n                _cancel_timeout\n            )],\n        ],\n    );\n\n    $irc->plugin_register($self, 'SERVER', qw(disconnected dcc_request));\n    $irc->plugin_register($self, 'USER', qw(dcc dcc_accept dcc_chat dcc_close dcc_resume));\n\n    return 1;\n}\n\nsub PCI_unregister {\n    my ($self) = @_;\n    delete $self->{irc};\n    delete $self->{$_} for qw(wheelmap dcc);\n    $poe_kernel->refcount_decrement($self->{session_id}, __PACKAGE__);\n    return 1;\n}\n\nsub _start {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    $self->{session_id} = $_[SESSION]->ID();\n    $kernel->refcount_increment($self->{session_id}, __PACKAGE__);\n    return;\n}\n\n# set the dcc ports\nsub dccports {\n    my ($self, $value) = @_;\n    $self->{dccports} = $value;\n    return;\n}\n\n# set the NAT address\nsub nataddr {\n    my ($self, $value) = @_;\n    $self->{nataddr} = $value;\n    return;\n}\n\n# returns information about a connection\nsub dcc_info {\n    my ($self, $id) = @_;\n\n    if (!$self->{dcc}->{$id}) {\n        warn \"dcc_info: Unknown wheel ID: $id\\n\";\n        return;\n    }\n\n    my %info;\n    @info{qw(nick type port file size done peeraddr)}\n        = @{ $self->{dcc}->{$id} }{qw(\n            nick type port file size done peeraddr\n        )};\n    return \\%info;\n}\n\nsub _quote_file {\n    my ($file) = @_;\n\n    if ($file =~ /[\\s\"]/) {\n        $file =~ s|\"|\\\\\"|g;\n        $file = qq{\"$file\"};\n    }\n    return $file;\n}\n\nsub S_disconnected {\n    my ($self) = $_;\n    # clean up old cookies for any ignored RESUME requests\n    delete $self->{resuming};\n    return PCI_EAT_NONE;\n}\n\nsub S_dcc_request {\n    my ($self, $irc) = splice @_, 0, 2;\n    my ($user, $type, $port, $cookie, $file, $size) = map { ref =~ /REF|SCALAR/ && ${ $_ } } @_;\n    my $nick = (split /!/, $user)[0];\n\n    if ($type eq 'ACCEPT' && $self->{resuming}->{\"$port+$nick\"}) {\n        # the old cookie has the peer's address\n        my $old_cookie = delete $self->{resuming}->{\"$port+$nick\"};\n        $irc->yield(dcc_accept => $old_cookie);\n    }\n    elsif ($type eq 'RESUME') {\n        for my $cookie (values %{ $self->{dcc} }) {\n            next if $cookie->{nick} ne $nick;\n            next if $cookie->{port} ne $port;\n            $file = _quote_file($file);\n            $cookie->{done} = $size;\n            $irc->yield(ctcp => $nick => \"DCC ACCEPT $file $port $size\");\n            last;\n        }\n    }\n\n    return PCI_EAT_NONE;\n}\n\n# this is a stub handler for all U_dcc* events which redispatches them as\n# events to our own POE session so that we can do stuff related to it,\n# namely create wheels and set alarms/delays\nsub _default {\n    my ($self, $irc, $event) = splice @_, 0, 3;\n    return PCI_EAT_NONE if $event !~ /^U_dcc(?:_accept|_chat|_close|_resume)?$/;\n    $event =~ s/^U_/_U_/;\n    pop @_;\n    my @args = map { $$_ } @_;\n    $poe_kernel->call($self->{session_id}, $event, @args);\n    return PCI_EAT_NONE;\n}\n\n# Attempt to initiate a DCC SEND or CHAT connection with another person.\nsub _U_dcc {\n    my ($kernel, $self, $nick, $type, $file, $blocksize, $timeout)\n        = @_[KERNEL, OBJECT, ARG0..$#_];\n\n    if (!defined $type) {\n        warn \"The 'dcc' command requires at least two arguments\\n\";\n        return;\n    }\n\n    my $irc = $self->{irc};\n    my ($bindport, $bindaddr, $factory, $port, $addr, $size);\n\n    $type = uc $type;\n    if ($type eq 'CHAT') {\n        $file = 'chat';   # As per the semi-specification\n    }\n    elsif ($type eq 'SEND') {\n        if (!defined $file) {\n            warn \"The 'dcc' command requires three arguments for a SEND\\n\";\n            return;\n        }\n        $file = rel2abs(bsd_glob($file));\n        $size = (stat $file)[7];\n        if (!defined $size) {\n            $irc->send_event(\n                'irc_dcc_error',\n                undef,\n                \"Couldn't get ${file}'s size: $!\",\n                $nick,\n                $type,\n                undef,\n                $file,\n            );\n            return;\n        }\n    }\n\n    $bindaddr = $irc->localaddr();\n\n    if ($self->{dccports}) {\n        $bindport = shift @{ $self->{dccports} };\n        if (!defined $bindport) {\n          warn \"dcc: Can't allocate listen port for DCC $type\\n\";\n          return;\n        }\n    }\n\n    $factory = POE::Wheel::SocketFactory->new(\n        BindAddress  => $bindaddr || INADDR_ANY,\n        BindPort     => $bindport,\n        SuccessEvent => '_dcc_up',\n        FailureEvent => '_dcc_failed',\n        Reuse        => 'yes',\n    );\n\n    ($port, $addr) = unpack_sockaddr_in($factory->getsockname());\n    $addr = inet_aton($self->{nataddr}) if $self->{nataddr};\n\n    if (!defined $addr) {\n        warn \"dcc: Can't determine our IP address! ($!)\\n\";\n        return;\n    }\n    $addr = unpack 'N', $addr;\n\n    my $basename = fileparse($file);\n    $basename = _quote_file($basename);\n\n    # Tell the other end that we're waiting for them to connect.\n    $irc->yield(ctcp => $nick => \"DCC $type $basename $addr $port\" . ($size ? \" $size\" : ''));\n\n    my $alarm_id = $kernel->delay_set(\n        '_dcc_timeout', ($timeout || LISTEN_TIMEOUT), $factory->ID,\n    );\n\n    # Store the state for this connection.\n    $self->{dcc}->{ $factory->ID } = {\n        open      => 0,\n        nick      => $nick,\n        type      => $type,\n        file      => $file,\n        size      => $size,\n        port      => $port,\n        addr      => $addr,\n        done      => 0,\n        blocksize => ($blocksize || OUT_BLOCKSIZE),\n        listener  => 1,\n        factory   => $factory,\n        alarm_id  => $alarm_id,\n    };\n\n    return;\n}\n\n# Accepts a proposed DCC connection to another client. See '_dcc_up' for\n# the rest of the logic for this.\nsub _U_dcc_accept {\n    my ($self, $cookie, $myfile) = @_[OBJECT, ARG0, ARG1];\n\n    if (!defined $cookie) {\n        warn \"The 'dcc_accept' command requires at least one argument\\n\";\n        return;\n    }\n\n    if ($cookie->{type} eq 'SEND') {\n        $cookie->{type} = 'GET';\n        $cookie->{file} = $myfile if defined $myfile;   # filename override\n    }\n\n    my $factory = POE::Wheel::SocketFactory->new(\n        RemoteAddress => $cookie->{addr},\n        RemotePort    => $cookie->{port},\n        SuccessEvent  => '_dcc_up',\n        FailureEvent  => '_dcc_failed',\n    );\n\n    $self->{dcc}->{$factory->ID} = $cookie;\n    $self->{dcc}->{$factory->ID}->{factory} = $factory;\n\n    return;\n}\n\n# Send data over a DCC CHAT connection.\nsub _U_dcc_chat {\n    my ($self, $id, @data) = @_[OBJECT, ARG0..$#_];\n\n    if (!defined $id || !@data) {\n        warn \"The 'dcc_chat' command requires at least two arguments\\n\";\n        return;\n    }\n\n    if (!exists $self->{dcc}->{$id}) {\n        warn \"dcc_chat: Unknown wheel ID: $id\\n\";\n        return;\n    }\n\n    if (!exists $self->{dcc}->{$id}->{wheel}) {\n        warn \"dcc_chat: No DCC wheel for id $id!\\n\";\n        return;\n    }\n\n    if ($self->{dcc}->{$id}->{type} ne 'CHAT') {\n        warn \"dcc_chat: id $id isn't associated w", 8192) = 8192
09:01:57.114728 stat("modules/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.114783 stat("modules/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.114834 stat("modules/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.114885 stat("modules/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.114936 stat("/etc/perl/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.114987 stat("/etc/perl/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.115038 stat("/usr/local/lib/perl/5.14.2/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.115092 stat("/usr/local/lib/perl/5.14.2/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.115147 stat("/usr/local/share/perl/5.14.2/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.115200 stat("/usr/local/share/perl/5.14.2/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.115253 stat("/usr/lib/perl5/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.115305 stat("/usr/lib/perl5/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.115357 stat("/usr/share/perl5/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.115409 stat("/usr/share/perl5/File/Glob.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.115461 stat("/usr/lib/perl/5.14/File/Glob.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.115515 stat("/usr/lib/perl/5.14/File/Glob.pm", {st_mode=S_IFREG|0644, st_size=3008, ...}) = 0
09:01:57.115577 open("/usr/lib/perl/5.14/File/Glob.pm", O_RDONLY) = 8
09:01:57.115633 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.115681 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.115744 read(8, "package File::Glob;\n\nuse strict;\nour($VERSION, @ISA, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, $DEFAULT_FLAGS);\n\nrequire XSLoader;\nuse feature 'switch';\n\n@ISA = qw(Exporter);\n\n# NOTE: The glob() export is only here for compatibility with 5.6.0.\n# csh_glob() should not be used directly, unless you know what you're doing.\n\n%EXPORT_TAGS = (\n    'glob' => [ qw(\n        GLOB_ABEND\n\tGLOB_ALPHASORT\n        GLOB_ALTDIRFUNC\n        GLOB_BRACE\n        GLOB_CSH\n        GLOB_ERR\n        GLOB_ERROR\n        GLOB_LIMIT\n        GLOB_MARK\n        GLOB_NOCASE\n        GLOB_NOCHECK\n        GLOB_NOMAGIC\n        GLOB_NOSORT\n        GLOB_NOSPACE\n        GLOB_QUOTE\n        GLOB_TILDE\n        glob\n        bsd_glob\n    ) ],\n);\n\n@EXPORT_OK   = (@{$EXPORT_TAGS{'glob'}}, 'csh_glob');\n\n$VERSION = '1.13';\n\nsub import {\n    require Exporter;\n    local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;\n    Exporter::import(grep {\n\tmy $passthrough;\n\tgiven ($_) {\n\t    $DEFAULT_FLAGS &= ~GLOB_NOCASE() when ':case';\n\t    $DEFAULT_FLAGS |= GLOB_NOCASE() when ':nocase';\n\t    when (':globally') {\n\t\tno warnings 'redefine';\n\t\t*CORE::GLOBAL::glob = \\&File::Glob::csh_glob;\n\t    }\n\t    $passthrough = 1;\n\t}\n\t$passthrough;\n    } @_);\n}\n\nXSLoader::load();\n\n$DEFAULT_FLAGS = GLOB_CSH();\nif ($^O =~ /^(?:MSWin32|VMS|os2|dos|riscos)$/) {\n    $DEFAULT_FLAGS |= GLOB_NOCASE();\n}\n\n# File::Glob::glob() is deprecated because its prototype is different from\n# CORE::glob() (use bsd_glob() instead)\nsub glob {\n    splice @_, 1; # don't pass PL_glob_index as flags!\n    goto &bsd_glob;\n}\n\n## borrowed heavily from gsar's File::DosGlob\nmy %iter;\nmy %entries;\n\nsub csh_glob {\n    my $pat = shift;\n    my $cxix = shift;\n    my @pat;\n\n    # glob without args defaults to $_\n    $pat = $_ unless defined $pat;\n\n    # extract patterns\n    $pat =~ s/^\\s+//;\t# Protect against empty elements in\n    $pat =~ s/\\s+$//;\t# things like < *.c> and <*.c >.\n\t\t\t# These alone shouldn't trigger ParseWords.\n    if ($pat =~ /\\s/) {\n        # XXX this is needed for compatibility with the csh\n\t# implementation in Perl.  Need to support a flag\n\t# to disable this behavior.\n\trequire Text::ParseWords;\n\t@pat = Text::ParseWords::parse_line('\\s+',0,$pat);\n    }\n\n    # assume global context if not provided one\n    $cxix = '_G_' unless defined $cxix;\n    $iter{$cxix} = 0 unless exists $iter{$cxix};\n\n    # if we're just beginning, do it all first\n    if ($iter{$cxix} == 0) {\n\tif (@pat) {\n\t    $entries{$cxix} = [ map { doglob($_, $DEFAULT_FLAGS) } @pat ];\n\t}\n\telse {\n\t    $entries{$cxix} = [ doglob($pat, $DEFAULT_FLAGS) ];\n\t}\n    }\n\n    # chuck it all out, quick or slow\n    if (wantarray) {\n        delete $iter{$cxix};\n        return @{delete $entries{$cxix}};\n    }\n    else {\n        if ($iter{$cxix} = scalar @{$entries{$cxix}}) {\n            return shift @{$entries{$cxix}};\n        }\n        else {\n            # return undef for EOL\n            delete $iter{$cxix};\n            delete $entries{$cxix};\n            return undef;\n        }\n    }\n}\n\n1;\n__END__\n\n", 8192) = 3008
09:01:57.116000 brk(0xd9e000)           = 0xd9e000
09:01:57.116063 stat("modules/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116126 stat("modules/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116179 stat("modules/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116229 stat("modules/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116280 stat("/etc/perl/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116333 stat("/etc/perl/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116384 stat("/usr/local/lib/perl/5.14.2/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116437 stat("/usr/local/lib/perl/5.14.2/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116490 stat("/usr/local/share/perl/5.14.2/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116548 stat("/usr/local/share/perl/5.14.2/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116601 stat("/usr/lib/perl5/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116654 stat("/usr/lib/perl5/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116706 stat("/usr/share/perl5/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116757 stat("/usr/share/perl5/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116809 stat("/usr/lib/perl/5.14/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116863 stat("/usr/lib/perl/5.14/feature.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.116915 stat("/usr/share/perl/5.14/feature.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.116968 stat("/usr/share/perl/5.14/feature.pm", {st_mode=S_IFREG|0644, st_size=2592, ...}) = 0
09:01:57.117029 open("/usr/share/perl/5.14/feature.pm", O_RDONLY) = 9
09:01:57.117084 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.117135 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.117198 read(9, "package feature;\n\nour $VERSION = '1.20';\n\n# (feature name) => (internal name, used in %^H)\nmy %feature = (\n    switch          => 'feature_switch',\n    say             => \"feature_say\",\n    state           => \"feature_state\",\n    unicode_strings => \"feature_unicode\",\n);\n\n# This gets set (for now) in $^H as well as in %^H,\n# for runtime speed of the uc/lc/ucfirst/lcfirst functions.\n# See HINT_UNI_8_BIT in perl.h.\nour $hint_uni8bit = 0x00000800;\n\n# NB. the latest bundle must be loaded by the -E switch (see toke.c)\n\nmy %feature_bundle = (\n    \"5.10\" => [qw(switch say state)],\n    \"5.11\" => [qw(switch say state unicode_strings)],\n    \"5.12\" => [qw(switch say state unicode_strings)],\n    \"5.13\" => [qw(switch say state unicode_strings)],\n    \"5.14\" => [qw(switch say state unicode_strings)],\n);\n\n# special case\n$feature_bundle{\"5.9.5\"} = $feature_bundle{\"5.10\"};\n\n# TODO:\n# - think about versioned features (use feature switch => 2)\n\nsub import {\n    my $class = shift;\n    if (@_ == 0) {\n\tcroak(\"No features specified\");\n    }\n    while (@_) {\n\tmy $name = shift(@_);\n\tif (substr($name, 0, 1) eq \":\") {\n\t    my $v = substr($name, 1);\n\t    if (!exists $feature_bundle{$v}) {\n\t\t$v =~ s/^([0-9]+)\\.([0-9]+).[0-9]+$/$1.$2/;\n\t\tif (!exists $feature_bundle{$v}) {\n\t\t    unknown_feature_bundle(substr($name, 1));\n\t\t}\n\t    }\n\t    unshift @_, @{$feature_bundle{$v}};\n\t    next;\n\t}\n\tif (!exists $feature{$name}) {\n\t    unknown_feature($name);\n\t}\n\t$^H{$feature{$name}} = 1;\n        $^H |= $hint_uni8bit if $name eq 'unicode_strings';\n    }\n}\n\nsub unimport {\n    my $class = shift;\n\n    # A bare C<no feature> should disable *all* features\n    if (!@_) {\n\tdelete @^H{ values(%feature) };\n        $^H &= ~ $hint_uni8bit;\n\treturn;\n    }\n\n    while (@_) {\n\tmy $name = shift;\n\tif (substr($name, 0, 1) eq \":\") {\n\t    my $v = substr($name, 1);\n\t    if (!exists $feature_bundle{$v}) {\n\t\t$v =~ s/^([0-9]+)\\.([0-9]+).[0-9]+$/$1.$2/;\n\t\tif (!exists $feature_bundle{$v}) {\n\t\t    unknown_feature_bundle(substr($name, 1));\n\t\t}\n\t    }\n\t    unshift @_, @{$feature_bundle{$v}};\n\t    next;\n\t}\n\tif (!exists($feature{$name})) {\n\t    unknown_feature($name);\n\t}\n\telse {\n\t    delete $^H{$feature{$name}};\n            $^H &= ~ $hint_uni8bit if $name eq 'unicode_strings';\n\t}\n    }\n}\n\nsub unknown_feature {\n    my $feature = shift;\n    croak(sprintf('Feature \"%s\" is not supported by Perl %vd',\n\t    $feature, $^V));\n}\n\nsub unknown_feature_bundle {\n    my $feature = shift;\n    croak(sprintf('Feature bundle \"%s\" is not supported by Perl %vd',\n\t    $feature, $^V));\n}\n\nsub croak {\n    require Carp;\n    Carp::croak(@_);\n}\n\n1;\n", 8192) = 2592
09:01:57.117690 read(9, "", 8192)       = 0
09:01:57.117743 close(9)                = 0
09:01:57.118217 lseek(8, 3007, SEEK_SET) = 3007
09:01:57.118267 lseek(8, 0, SEEK_CUR)   = 3007
09:01:57.118326 close(8)                = 0
09:01:57.118432 stat("/usr/lib/perl/5.14/auto/File/Glob/Glob.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.118497 stat("/usr/lib/perl/5.14/auto/File/Glob/Glob.so", {st_mode=S_IFREG|0644, st_size=22952, ...}) = 0
09:01:57.118561 stat("/usr/lib/perl/5.14/auto/File/Glob/Glob.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.118636 open("/usr/lib/perl/5.14/auto/File/Glob/Glob.so", O_RDONLY) = 8
09:01:57.118693 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\32\0\0\0\0\0\0@\0\0\0\0\0\0\0\250R\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\?\0\0\0\0\0\0\\?\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0 L\0\0\0\0\0\0 L \0\0\0\0\0 L \0\0\0\0\0\204\5\0\0\0\0\0\0\210\5\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\300M\0\0\0\0\0\0\300M \0\0\0\0\0\300M \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\3709\0\0\0\0\0\0\3709\0\0\0\0\0\0\3709\0\0\0\0\0\0\254\0\0\0\0\0\0\0\254\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0 L\0\0\0\0\0\0 L \0\0\0\0\0 L \0\0\0\0\0\340\3\0\0\0\0\0\0\340\3\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0003MC\367n\27\321\243t\207\320\236P\270\26\341\374\210\344d\0\0\0\0C\0\0\0E\0\0\0\0\0\0\0-\0\0\0005\0\0\0002\0\0\0004\0\0\0)\0\0\0\0\0\0\0!\0\0\0\0\0\0\0+\0\0\0003\0\0\0\0\0\0\0.\0\0\0\22\0\0\0\0\0\0\0007\0\0\0#\0\0\0\0\0\0\0\6\0\0\0\25\0\0\0\0\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\0\0\0;\0\0\0\3\0\0\0000\0\0\0\23\0\0\0009\0\0\0\37\0\0\0\33\0\0\0006\0\0\0(\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\21\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0\0\0\0\0,\0\0\0?\0\0\0\36\0\0\0 \0\0\0\0\0\0\0\0\0\0\0&\0\0\0/\0\0\0\35\0\0\0\24\0\0\0\27\0\0\0\n\0\0\0008\0\0\0\30\0\0\0\32\0\0\0$\0\0\0\17\0\0\0%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0", 832) = 832
09:01:57.118836 fstat(8, {st_mode=S_IFREG|0644, st_size=22952, ...}) = 0
09:01:57.118897 mmap(NULL, 2118056, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f74348f7000
09:01:57.118952 mprotect(0x7f74348fb000, 2097152, PROT_NONE) = 0
09:01:57.119005 mmap(0x7f7434afb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4000) = 0x7f7434afb000
09:01:57.119068 close(8)                = 0
09:01:57.119134 mprotect(0x7f7434afb000, 4096, PROT_READ) = 0
09:01:57.119381 stat("modules/File/Spec/Functions.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.119436 stat("modules/File/Spec/Functions.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.119489 stat("modules/File/Spec/Functions.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.119541 stat("modules/File/Spec/Functions.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.119593 stat("/etc/perl/File/Spec/Functions.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.119645 stat("/etc/perl/File/Spec/Functions.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.119698 stat("/usr/local/lib/perl/5.14.2/File/Spec/Functions.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.119756 stat("/usr/local/lib/perl/5.14.2/File/Spec/Functions.pm", {st_mode=S_IFREG|0444, st_size=2389, ...}) = 0
09:01:57.119818 open("/usr/local/lib/perl/5.14.2/File/Spec/Functions.pm", O_RDONLY) = 8
09:01:57.119891 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.119937 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.119998 read(8, "package File::Spec::Functions;\n\nuse File::Spec;\nuse strict;\n\nuse vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);\n\n$VERSION = '3.62';\n$VERSION =~ tr/_//d;\n\nrequire Exporter;\n\n@ISA = qw(Exporter);\n\n@EXPORT = qw(\n\tcanonpath\n\tcatdir\n\tcatfile\n\tcurdir\n\trootdir\n\tupdir\n\tno_upwards\n\tfile_name_is_absolute\n\tpath\n);\n\n@EXPORT_OK = qw(\n\tdevnull\n\ttmpdir\n\tsplitpath\n\tsplitdir\n\tcatpath\n\tabs2rel\n\trel2abs\n\tcase_tolerant\n);\n\n%EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );\n\nrequire File::Spec::Unix;\nmy %udeps = (\n    canonpath => [],\n    catdir => [qw(canonpath)],\n    catfile => [qw(canonpath catdir)],\n    case_tolerant => [],\n    curdir => [],\n    devnull => [],\n    rootdir => [],\n    updir => [],\n);\n\nforeach my $meth (@EXPORT, @EXPORT_OK) {\n    my $sub = File::Spec->can($meth);\n    no strict 'refs';\n    if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&\n\t    !(grep {\n\t\tFile::Spec->can($_) != File::Spec::Unix->can($_)\n\t    } @{$udeps{$meth}}) &&\n\t    defined(&{\"File::Spec::Unix::_fn_$meth\"})) {\n\t*{$meth} = \\&{\"File::Spec::Unix::_fn_$meth\"};\n    } else {\n\t*{$meth} = sub {&$sub('File::Spec', @_)};\n    }\n}\n\n\n1;\n__END__\n\n=head1 NAME\n\nFile::Spec::Functions - portably perform operations on file names\n\n=head1 SYNOPSIS\n\n\tuse File::Spec::Functions;\n\t$x = catfile('a','b');\n\n=head1 DESCRIPTION\n\nThis module exports convenience functions for all of the class methods\nprovided by File::Spec.\n\nFor a reference of available functions, please consult L<File::Spec::Unix>,\nwhich contains the entire set, and which is inherited by the modules for\nother platforms. For further information, please see L<File::Spec::Mac>,\nL<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.\n\n=head2 Exports\n\nThe following functions are exported by default.\n\n\tcanonpath\n\tcatdir\n\tcatfile\n\tcurdir\n\trootdir\n\tupdir\n\tno_upwards\n\tfile_name_is_absolute\n\tpath\n\n\nThe following functions are exported only by request.\n\n\tdevnull\n\ttmpdir\n\tsplitpath\n\tsplitdir\n\tcatpath\n\tabs2rel\n\trel2abs\n\tcase_tolerant\n\nAll the functions may be imported using the C<:ALL> tag.\n\n=head1 COPYRIGHT\n\nCopyright (c) 2004 by the Perl 5 Porters.  All rights reserved.\n\nThis program is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nFile::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,\nFile::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker\n\n=cut\n\n", 8192) = 2389
09:01:57.120395 lseek(8, 1142, SEEK_SET) = 1142
09:01:57.120446 lseek(8, 0, SEEK_CUR)   = 1142
09:01:57.120493 close(8)                = 0
09:01:57.121173 brk(0xdbf000)           = 0xdbf000
09:01:57.121994 read(7, "ith a DCC CHAT connection!\\n\";\n        return;\n    }\n\n    $self->{dcc}->{$id}->{wheel}->put(join \"\\n\", @data);\n    return;\n}\n\n# Terminate a DCC connection manually.\nsub _U_dcc_close {\n    my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];\n    my $irc = $self->{irc};\n\n    if (!defined $id) {\n        warn \"The 'dcc_close' command requires an id argument\\n\";\n        return;\n    }\n\n    if (!exists $self->{dcc}->{$id}) {\n        warn \"dcc_close: Unknown wheel ID: $id\\n\";\n        return;\n    }\n\n    if (!exists $self->{dcc}->{$id}->{wheel}) {\n        warn \"dcc_close: No DCC wheel for id $id!\\n\";\n        return;\n    }\n\n    # pending data, wait till it has been flushed\n    if ($self->{dcc}->{$id}->{wheel}->get_driver_out_octets()) {\n        $kernel->delay_set(_U_dcc_close => 2, $id);\n        return;\n    }\n\n    $irc->send_event(\n        'irc_dcc_done',\n        $id,\n        @{ $self->{dcc}->{$id} }{qw(\n            nick type port file size done peeraddr\n        )},\n    );\n\n    # Reclaim our port if necessary.\n    if ($self->{dcc}->{$id}->{listener} && $self->{dccports}) {\n        push ( @{ $self->{dccports} }, $self->{dcc}->{$id}->{port} );\n    }\n\n    $self->_remove_dcc($id);\n    return;\n}\n\n## no critic (InputOutput::RequireBriefOpen)\nsub _U_dcc_resume {\n    my ($self, $cookie, $myfile) = @_[OBJECT, ARG0, ARG1];\n    my $irc = $self->{irc};\n\n    my $sender_file = _quote_file($cookie->{file});\n    $cookie->{file} = $myfile if defined $myfile;\n    $cookie->{done} = -s $cookie->{file};\n    $cookie->{resuming} = 1;\n\n    if (open(my $handle, '>>', $cookie->{file})) {\n        $irc->yield(ctcp => $cookie->{nick} => \"DCC RESUME $sender_file $cookie->{port} $cookie->{done}\");\n        $self->{resuming}->{\"$cookie->{port}+$cookie->{nick}\"} = $cookie;\n    }\n    else {\n        warn \"dcc_resume: Can't append to file '$cookie->{file}'\\n\";\n        return;\n    }\n\n    return;\n}\n\n# Accept incoming data on a DCC socket.\nsub _dcc_read {\n    my ($kernel, $self, $data, $id) = @_[KERNEL, OBJECT, ARG0, ARG1];\n    my $irc = $self->{irc};\n\n    $id = $self->{wheelmap}->{$id};\n    if ($self->{dcc}{$id}{alarm_id}) {\n        $kernel->call($self->{session_id}, '_cancel_timeout', $id);\n    }\n\n    if ($self->{dcc}->{$id}->{type} eq 'GET') {\n        # Acknowledge the received data.\n        print {$self->{dcc}->{$id}->{fh}} $data;\n        $self->{dcc}->{$id}->{done} += length $data;\n        $self->{dcc}->{$id}->{wheel}->put(\n            pack 'N', $self->{dcc}->{$id}->{done}\n        );\n\n        # Send an event to let people know about the newly arrived data.\n        $irc->send_event(\n            'irc_dcc_get',\n            $id,\n            @{ $self->{dcc}->{$id} }{qw(\n                nick port file size done peeraddr\n            )},\n        );\n    }\n    elsif ($self->{dcc}->{$id}->{type} eq 'SEND') {\n        # Record the client's download progress.\n        $self->{dcc}->{$id}->{done} = unpack 'N', substr( $data, -4 );\n\n        $irc->send_event(\n            'irc_dcc_send',\n            $id,\n            @{ $self->{dcc}->{$id} }{qw(\n                nick port file size done peeraddr\n            )},\n        );\n\n        # Are we done yet?\n        if ($self->{dcc}->{$id}->{done} >= $self->{dcc}->{$id}->{size}) {\n            # Reclaim our port if necessary.\n            if ( $self->{dcc}->{$id}->{listener} && $self->{dccports}) {\n                push @{ $self->{dccports} }, $self->{dcc}->{$id}->{port};\n            }\n\n            $irc->send_event(\n                'irc_dcc_done',\n                $id,\n                @{ $self->{dcc}->{$id} }{qw(\n                    nick type port file size done peeraddr\n                )},\n            );\n\n            $self->_remove_dcc($id);\n            return;\n        }\n\n        # Send the next 'blocksize'-sized packet.\n        read $self->{dcc}->{$id}->{fh}, $data,\n            $self->{dcc}->{$id}->{blocksize};\n        $self->{dcc}->{$id}->{wheel}->put( $data );\n    }\n    else {\n        $irc->send_event(\n            'irc_dcc_' . lc $self->{dcc}->{$id}->{type},\n            $id,\n            @{ $self->{dcc}->{$id} }{qw(nick port)},\n            $data,\n            $self->{dcc}->{$id}->{peeraddr},\n        );\n    }\n\n    return;\n}\n\n# What happens when an attempted DCC connection fails.\nsub _dcc_failed {\n    my ($self, $operation, $errnum, $errstr, $id) = @_[OBJECT, ARG0 .. ARG3];\n    my $irc = $self->{irc};\n\n    if (!exists $self->{dcc}->{$id}) {\n        if (exists $self->{wheelmap}->{$id}) {\n            $id = $self->{wheelmap}->{$id};\n        }\n        else {\n            warn \"_dcc_failed: Unknown wheel ID: $id\\n\";\n            return;\n        }\n    }\n\n    # Reclaim our port if necessary.\n    if ( $self->{dcc}->{$id}->{listener} && $self->{dccports}) {\n        push ( @{ $self->{dccports} }, $self->{dcc}->{$id}->{port} );\n    }\n\n    DCC: {\n        last DCC if $errnum != 0;\n\n        # Did the peer of a DCC GET connection close the socket after the file\n        # transfer finished? If so, it's not really an error.\n        if ($self->{dcc}->{$id}->{type} eq 'GET') {\n            if ($self->{dcc}->{$id}->{done} < $self->{dcc}->{$id}->{size}) {\n                last DCC;\n            }\n        }\n\n        if ($self->{dcc}->{$id}->{type} =~ /^(GET|CHAT)$/) {\n            $irc->send_event(\n                'irc_dcc_done',\n                $id,\n                @{ $self->{dcc}->{$id} }{qw(\n                    nick type port file size done peeraddr\n                )},\n            );\n\n            $self->_remove_dcc($id);\n        }\n\n        return;\n    }\n\n    # something went wrong\n    if ($errnum == 0 && $self->{dcc}->{$id}->{type} eq 'GET') {\n        $errstr = 'Aborted by sender';\n    }\n    else {\n        $errstr = $errstr\n            ? $errstr = \"$operation error $errnum: $errstr\"\n            : $errstr = \"$operation error $errnum\"\n        ;\n    }\n\n    $irc->send_event(\n        'irc_dcc_error',\n        $id,\n        $errstr,\n        @{ $self->{dcc}->{$id} }{qw(\n            nick type port file size done peeraddr\n        )},\n    );\n\n    $self->_remove_dcc($id);\n    return;\n}\n\n# What happens when a DCC connection sits waiting for the other end to\n# pick up the phone for too long.\nsub _dcc_timeout {\n    my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];\n\n    if (exists $self->{dcc}->{$id} && !$self->{dcc}->{$id}->{open}) {\n        $kernel->yield(\n            '_dcc_failed',\n            'connection',\n            0,\n            'DCC connection timed out',\n            $id,\n        );\n    }\n    return;\n}\n\n# This event occurs when a DCC connection is established.\n## no critic (InputOutput::RequireBriefOpen)\nsub _dcc_up {\n    my ($kernel, $self, $sock, $peeraddr, $id) =\n        @_[KERNEL, OBJECT, ARG0, ARG1, ARG3];\n    my $irc = $self->{irc};\n\n    # Delete the listening socket and monitor the accepted socket\n    # for incoming data\n    delete $self->{dcc}->{$id}->{factory};\n    $self->{dcc}->{$id}->{open} = 1;\n    $self->{dcc}->{$id}->{peeraddr} = inet_ntoa($peeraddr);\n\n    $self->{dcc}->{$id}->{wheel} = POE::Wheel::ReadWrite->new(\n        Handle => $sock,\n        Driver => ($self->{dcc}->{$id}->{type} eq 'GET'\n            ? POE::Driver::SysRW->new( BlockSize => IN_BLOCKSIZE )\n            : POE::Driver::SysRW->new()\n        ),\n        Filter => ($self->{dcc}->{$id}->{type} eq 'CHAT'\n            ? POE::Filter::Line->new( Literal => \"\\012\" )\n            : POE::Filter::Stream->new()\n        ),\n        InputEvent => '_dcc_read',\n        ErrorEvent => '_dcc_failed',\n    );\n\n    $self->{wheelmap}->{ $self->{dcc}->{$id}->{wheel}->ID } = $id;\n\n    my $handle;\n    if ($self->{dcc}->{$id}->{type} eq 'GET') {\n        # check if we're resuming\n        my $mode = $self->{dcc}->{$id}->{resuming} ? '>>' : '>';\n\n        if ( !open $handle, $mode, $self->{dcc}->{$id}->{file} ) {\n            $kernel->yield(_dcc_failed => 'open file', $! + 0, $!, $id);\n            return;\n        }\n\n        binmode $handle;\n        $self->{dcc}->{$id}->{fh} = $handle;\n    }\n    elsif ($self->{dcc}->{$id}->{type} eq 'SEND') {\n        if (!open $handle, '<', $self->{dcc}->{$id}->{file}) {\n            $kernel->yield(_dcc_failed => 'open file', $! + 0, $!, $id);\n            return;\n        }\n\n        binmode $handle;\n        seek $handle", 8192) = 8192
09:01:57.122529 brk(0xde0000)           = 0xde0000
09:01:57.123271 brk(0xe01000)           = 0xe01000
09:01:57.123366 read(7, ", $self->{dcc}{$id}{done}, 0;\n        # Send the first packet to get the ball rolling.\n        read $handle, my $buffer, $self->{dcc}->{$id}->{blocksize};\n        $self->{dcc}->{$id}->{wheel}->put($buffer);\n        $self->{dcc}->{$id}->{fh} = $handle;\n    }\n\n    # Tell any listening sessions that the connection is up.\n    $irc->send_event(\n        'irc_dcc_start',\n        $id,\n        @{ $self->{dcc}->{$id} }{qw(\n            nick type port file size peeraddr\n        )},\n    );\n\n    return;\n}\n\nsub _cancel_timeout {\n    my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];\n    my $alarm_id = delete $self->{dcc}{$id}{alarm_id};\n    $kernel->alarm_remove($alarm_id);\n    return;\n}\n\nsub _remove_dcc {\n    my ($self, $id) = @_;\n\n    if (exists $self->{dcc}{$id}{alarm_id}) {\n        $poe_kernel->call($self->{session_id}, '_cancel_timeout', $id);\n    }\n\n    if (exists $self->{dcc}{$id}{wheel}) {\n        delete $self->{wheelmap}{ $self->{dcc}{$id}{wheel}->ID };\n        if ($^O =~ /cygwin|MSWin/) {\n          $self->{dcc}{$id}{wheel}->$_ for qw(shutdown_input shutdown_output);\n        }\n    }\n\n    # flush the filehandle\n    close $self->{dcc}{$id}{fh} if $self->{dcc}{$id}{type} eq 'GET';\n\n    delete $self->{dcc}{$id};\n    return;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC::Plugin::DCC - A PoCo-IRC plugin providing support for\nDCC transfers\n\n=head1 SYNOPSIS\n\n # send a file\n my $file = '/home/user/secret.pdf';\n my $recipient = 'that_guy';\n $irc->yield(dcc => $recipient => SEND => $file);\n\n # receive a file\n sub irc_dcc_request {\n     my ($user, $type, $port, $cookie, $file, $size, $addr) = @_[ARG0..$#_];\n     return if $type ne 'SEND';\n\n     my $irc = $_[SENDER]->get_heap();\n     my $nick = (split /!/, $user)[0];\n\n     print \"$nick wants to send me '$file' ($size bytes) from $addr:$port\\n\");\n     $irc->yield(dcc_accept => $cookie);\n }\n\n=head1 DESCRIPTION\n\nThis plugin provides the IRC commands needed to make use of DCC. It is used\ninternally by L<POE::Component::IRC|POE::Component::IRC> so there's no\nneed to add it manually.\n\n=head1 METHODS\n\n=head2 C<new>\n\nTakes no arguments.\n\nReturns a plugin object suitable for feeding to\nL<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.\n\n=head2 C<dccports>\n\nSets the TCP ports that can be used for DCC sends. Takes one argument,\nan arrayref containing the port numbers.\n\n=head2 C<nataddr>\n\nSets the public NAT address to be used for DCC sends.\n\n=head2 C<dcc_info>\n\nTakes one argument, a DCC connection id (see below). Returns a hash of\ninformation about the connection. The keys are: B<'nick'>, B<'type'>,\nB<'port'>, B<'file'>, B<'size'>, B<'done,'>, and B<'peeraddr'>.\n\n=head1 COMMANDS\n\nThe plugin responds to the following\nL<POE::Component::IRC|POE::Component::IRC> commands.\n\n=head2 C<dcc>\n\nSend a DCC SEND or CHAT request to another person. Takes at least two\narguments: the nickname of the person to send the request to and the type\nof DCC request (SEND or CHAT). For SEND requests, be sure to add a third\nargument for the filename you want to send. Optionally, you can add a fourth\nargument for the DCC transfer blocksize, but the default of 1024 should\nusually be fine. The fifth (and optional) argument is the request timeout\nvalue in seconds (default: 300).\n\nIncidentally, you can send other weird nonstandard kinds of DCCs too;\njust put something besides 'SEND' or 'CHAT' (say, 'FOO') in the type\nfield, and you'll get back C<irc_dcc_foo> events (with the same arguments as\nL<C<irc_dcc_chat>|/irc_dcc_chat>) when data arrives on its DCC connection.\n\nIf you are behind a firewall or Network Address Translation, you may want to\nconsult L<POE::Component::IRC|POE::Component::IRC>'s\nL<C<connect>|POE::Component::IRC/spawn> for some parameters that are\nuseful with this command.\n\n=head2 C<dcc_accept>\n\nAccepts an incoming DCC connection from another host. First argument:\nthe magic cookie from an L<C<irc_dcc_request>|/irc_dcc_request> event.\nIn the case of a DCC GET, the second argument can optionally specify a\nnew name for the destination file of the DCC transfer, instead of using\nthe sender's name for it. (See the L<C<irc_dcc_request>|/irc_dcc_request>\nsection below for more details.)\n\n=head2 C<dcc_resume>\n\nResumes a DCC SEND file transfer. First argument: the magic cookie from an\nL<C<irc_dcc_request>|/irc_dcc_request> event. An optional second argument\nprovides the name of the file to which you want to write.\n\n=head2 C<dcc_chat>\n\nSends lines of data to the person on the other side of a DCC CHAT connection.\nThe first argument should be the wheel id of the connection which you got\nfrom an L<C<irc_dcc_start>|/irc_dcc_start> event, followed by all the data\nyou wish to send (it'll be separated with newlines for you).\n\n=head2 C<dcc_close>\n\nTerminates a DCC SEND or GET connection prematurely, and causes DCC CHAT\nconnections to close gracefully. Takes one argument: the wheel id of the\nconnection which you got from an L<C<irc_dcc_start>|/irc_dcc_start>\n(or similar) event.\n\n=head1 OUTPUT EVENTS\n\n=head2 C<irc_dcc_request>\n\nB<Note:> This event is actually emitted by\nL<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat>, but documented here\nto keep all the DCC documentation in one place. In case you were wondering.\n\nYou receive this event when another IRC client sends you a DCC\n(e.g. SEND or CHAT) request out of the blue. You can examine the request\nand decide whether or not to accept it (with L<C<dcc_accept>|/dcc_accept>)\nhere. In the case of DCC SENDs, you can also request to resume the file with\nL<C<dcc_resume>|/dcc_resume>.\n\nB<Note:> DCC doesn't provide a way to explicitly reject requests, so if you\ndon't intend to accept one, just ignore it or send a\nL<NOTICE|POE::Component::IRC/notice> or L<PRIVMSG|POE::Component::IRC/privmsg>\nto the peer explaining why you're not going to accept.\n\n=over 4\n\n=item * C<ARG0>: the peer's nick!user@host\n\n=item * C<ARG1>: the DCC type (e.g. 'CHAT' or 'SEND')\n\n=item * C<ARG2>: the port which the peer is listening on\n\n=item * C<ARG3>: this connection's \"magic cookie\"\n\n=item * C<ARG4>: the file name (SEND only)\n\n=item * C<ARG5>: the file size (SEND only)\n\n=item * C<ARG6>: the IP address which the peer is listening on\n\n=back\n\n=head2 C<irc_dcc_start>\n\nThis event notifies you that a DCC connection has been successfully\nestablished.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the peer's nickname\n\n=item * C<ARG2>: the DCC type\n\n=item * C<ARG3>: the port number\n\n=item * C<ARG4>: the file name (SEND/GET only)\n\n=item * C<ARG5>: the file size (SEND/GET only)\n\n=item * C<ARG6>: the peer's IP address\n\n=back\n\n=head2 C<irc_dcc_chat>\n\nNotifies you that one line of text has been received from the\nclient on the other end of a DCC CHAT connection.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the peer's nickname\n\n=item * C<ARG2>: the port number\n\n=item * C<ARG3>: the text they sent\n\n=item * C<ARG4>: the peer's IP address\n\n=back\n\n=head2 C<irc_dcc_get>\n\nNotifies you that another block of data has been successfully\ntransferred from the client on the other end of your DCC GET connection.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the peer's nickname\n\n=item * C<ARG2>: the port number\n\n=item * C<ARG3>: the file name\n\n=item * C<ARG4>: the file size\n\n=item * C<ARG5>: transferred file size\n\n=item * C<ARG6>: the peer's IP address\n\n=back\n\n=head2 C<irc_dcc_send>\n\nNotifies you that another block of data has been successfully\ntransferred from you to the client on the other end of a DCC SEND\nconnection.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the peer's nickname\n\n=item * C<ARG2>: the port number\n\n=item * C<ARG3>: the file name\n\n=item * C<ARG4>: the file size\n\n=item * C<ARG5>: transferred file size\n\n=item * C<ARG6>: the peer's IP address\n\n=back\n\n=head2 C<irc_dcc_done>\n\nYou receive this event when a DCC connection terminates normally.\nAbnormal terminations are reported by L<C<irc_dcc_error>|/irc_dcc_error>.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the peer's nickname\n\n=item * C<ARG2>: the DCC type\n\n=item * C<ARG3>: the port number\n\n=item * C<ARG4>: the filename (SEND/GET only)\n\n=item * C<A", 8192) = 8192
09:01:57.124012 read(7, "RG5>: file size (SEND/GET only)\n\n=item * C<ARG6>: transferred file size (SEND/GET only)\n\n=item * C<ARG7>: the peer's IP address\n\n=back\n\n=head2 C<irc_dcc_error>\n\nYou get this event whenever a DCC connection or connection attempt\nterminates unexpectedly or suffers some fatal error. Some of the\nfollowing values might be undefined depending the stage at which\nthe connection/attempt failed.\n\n=over 4\n\n=item * C<ARG0>: the connection's wheel id\n\n=item * C<ARG1>: the error string\n\n=item * C<ARG2>: the peer's nickname\n\n=item * C<ARG3>: the DCC type\n\n=item * C<ARG4>: the port number\n\n=item * C<ARG5>: the file name\n\n=item * C<ARG6>: file size in bytes\n\n=item * C<ARG7>: transferred file size in bytes\n\n=item * C<ARG8>: the peer's IP address\n\n=back\n\n=head1 AUTHOR\n\nDennis 'C<fimmtiu>' Taylor and Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com\n\n=cut\n", 8192) = 853
09:01:57.124122 read(7, "", 8192)       = 0
09:01:57.124171 close(7)                = 0
09:01:57.124250 stat("modules/POE/Component/IRC/Plugin/ISupport.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.124305 stat("modules/POE/Component/IRC/Plugin/ISupport.pm", {st_mode=S_IFREG|0600, st_size=6135, ...}) = 0
09:01:57.124366 open("modules/POE/Component/IRC/Plugin/ISupport.pm", O_RDONLY) = 7
09:01:57.124420 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.124468 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.124524 read(7, "package POE::Component::IRC::Plugin::ISupport;\nBEGIN {\n  $POE::Component::IRC::Plugin::ISupport::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::Plugin::ISupport::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\nuse POE::Component::IRC::Plugin qw(:ALL);\n\nsub new {\n    return bless { }, shift;\n}\n\nsub PCI_register {\n    my ($self, $irc) = splice @_, 0, 2;\n\n    $irc->plugin_register( $self => SERVER => qw(all) );\n    $self->{irc} = $irc;\n    $self->{parser} = {\n        CASEMAPPING => sub {\n            my ($support, $key, $val) = @_;\n            $support->{$key} = $val;\n        },\n        CHANLIMIT => sub {\n            my ($support, $key, $val) = @_;\n            while ($val =~ /([^:]+):(\\d+),?/g) {\n                my ($k, $v) = ($1, $2);\n                @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;\n            }\n        },\n        CHANMODES => sub {\n            my ($support, $key, $val) = @_;\n            $support->{$key} = [ split(/,/, $val) ];\n        },\n        CHANTYPES => sub {\n            my ($support, $key, $val) = @_;\n            $support->{$key} = [ split(//, $val) ];\n        },\n        ELIST => sub {\n            my ($support, $key, $val) = @_;\n            $support->{$key} = [ split(//, $val) ];\n        },\n        IDCHAN => sub {\n            my ($support, $key, $val) = @_;\n            while ($val =~ /([^:]+):(\\d+),?/g) {\n                my ($k, $v) = ($1, $2);\n                @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;\n            }\n        },\n        MAXLIST => sub {\n            my ($support, $key, $val) = @_;\n            while ($val =~ /([^:]+):(\\d+),?/g) {\n                my ($k, $v) = ($1, $2);\n                @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;\n            }\n        },\n        PREFIX => sub {\n            my ($support, $key, $val) = @_;\n            if (my ($k, $v) = $val =~ /\\(([^)]+)\\)(.*)/ ) {\n                @{ $support->{$key} }{ split(//, $k) } = split(//, $v);\n            }\n        },\n        STATUSMSG => sub {\n            my ($support, $key, $val) = @_;\n            $support->{$key} = [ split(//, $val) ];\n        },\n        TARGMAX => sub {\n            my ($support, $key, $val) = @_;\n            while ($val =~ /([^:]+):(\\d*),?/g) {\n                my ($k, $v) = ($1, $2);\n                $support->{$key}->{$k} = $v;\n            }\n        },\n        EXCEPTS => sub {\n            my ($support, $flag) = @_;\n            $support->{$flag} = 'e';\n        },\n        INVEX => sub {\n            my ($support, $flag) = @_;\n            $support->{$flag} = 'I';\n        },\n    };\n\n    return 1;\n}\n\nsub PCI_unregister {\n    my ($self, $irc) = splice @_, 0, 2;\n    delete $self->{irc};\n    return 1;\n}\n\nsub S_connected {\n    my ($self, $irc) = splice @_, 0, 2;\n\n    $self->{server}   = { };\n    $self->{got_005}  = 0;\n    $self->{done_005} = 0;\n    return PCI_EAT_NONE;\n}\n\nsub S_005 {\n    my ($self, $irc, @args) = @_;\n    my @vals = @{ ${ $args[2] } };\n    pop @vals;\n    my $support = $self->{server};\n\n    for my $val (@vals) {\n        if ($val =~ /=/) {\n            my $key;\n            ($key, $val) = split(/=/, $val, 2);\n            if (defined $self->{parser}->{$key}) {\n                $self->{parser}->{$key}->($support, $key, $val);\n            }\n            else {\n                # AWAYLEN CHANNELLEN CHIDLEN CHARSET EXCEPTS INVEX KICKLEN\n                # MAXBANS MAXCHANNELS MAXTARGETS MODES NETWORK NICKLEN STD\n                # TOPICLEN WATCH\n                $support->{$key} = $val;\n            }\n        }\n        else {\n            if (defined $self->{parser}->{$val}) {\n                $self->{parser}->{$val}->($support, $val);\n            }\n            else {\n                # ACCEPT CALLERID CAPAB CNOTICE CPRIVMSG FNC KNOCK MAXNICKLEN\n                # NAMESX NOQUIT PENALTY RFC2812 SAFELIST UHNAMES USERIP\n                # VCHANS WALLCHOPS WALLVOICES WHOX\n                $support->{$val} = 'on';\n            }\n        }\n    }\n\n    $self->{got_005}++;\n    return PCI_EAT_NONE;\n}\n\nsub _default {\n    my ($self, $irc, $event) = @_;\n\n    return PCI_EAT_NONE if $self->{done_005};\n    return PCI_EAT_NONE if !$self->{got_005};\n\n    if ($event =~ /^S_(\\d+)/ and $1 > 5) {\n        $self->{done_005} = 1;\n        $irc->send_event_now(irc_isupport => $self);\n    }\n\n    return PCI_EAT_NONE;\n}\n\nsub isupport {\n    my $self = shift;\n    my $value = uc ( $_[0] ) || return;\n\n    return $self->{server}->{$value} if defined $self->{server}->{$value};\n    return;\n}\n\nsub isupport_dump_keys {\n    my $self = shift;\n\n    if ( keys %{ $self->{server} } > 0 ) {\n        return keys %{ $self->{server} };\n    }\n    return;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC::Plugin::ISupport - A PoCo-IRC plugin that handles server\ncapabilities\n\n=head1 DESCRIPTION\n\nThis handles the C<irc_005> messages that come from the server.  They\ndefine the capabilities support by the server.\n\n=head1 METHODS\n\n=head2 C<new>\n\nTakes no arguments.\n\nReturns a plugin object suitable for feeding to\nL<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.\n\n=head2 C<isupport>\n\nTakes one argument. the server capability to query. Returns a false value on\nfailure or a value representing the applicable capability. A full list of\ncapabilities is available at L<http://www.irc.org/tech_docs/005.html>.\n\n=head2 C<isupport_dump_keys>\n\nTakes no arguments, returns a list of the available server capabilities,\nwhich can be used with C<isupport>.\n\n=head1 INPUT\n\nThis module handles the following PoCo-IRC signals:\n\n=head2 C<irc_005> (RPL_ISUPPORT or RPL_PROTOCTL)\n\nDenotes the capabilities of the server.\n\n=head2 C<all>\n\nOnce the next signal is received that is I<greater> than C<irc_005>,\nit emits an C<irc_isupport> signal.\n\n=head1 OUTPUT EVENTS\n\n=head2 C<irc_isupport>\n\nEmitted by: the first signal received after C<irc_005>\n\nC<ARG0> will be the plugin object itself for ease of use.\n\nThis is emitted when the support report has finished.\n\n=head1 AUTHOR\n\nJeff C<japhy> Pinyan, F<japhy@perlmonk.org>\n\n=head1 SEE ALSO\n\nL<POE::Component::IRC|POE::Component::IRC>\n\nL<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>\n\n=cut\n", 8192) = 6135
09:01:57.125448 brk(0xe22000)           = 0xe22000
09:01:57.125682 read(7, "", 8192)       = 0
09:01:57.125733 close(7)                = 0
09:01:57.125812 stat("modules/POE/Component/IRC/Plugin/Whois.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.125866 stat("modules/POE/Component/IRC/Plugin/Whois.pm", {st_mode=S_IFREG|0600, st_size=5376, ...}) = 0
09:01:57.125926 open("modules/POE/Component/IRC/Plugin/Whois.pm", O_RDONLY) = 7
09:01:57.125981 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.126037 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.126112 read(7, "package POE::Component::IRC::Plugin::Whois;\nBEGIN {\n  $POE::Component::IRC::Plugin::Whois::AUTHORITY = 'cpan:HINRIK';\n}\n$POE::Component::IRC::Plugin::Whois::VERSION = '6.88';\nuse strict;\nuse warnings FATAL => 'all';\nuse POE;\nuse POE::Component::IRC::Plugin qw( PCI_EAT_NONE );\nuse IRC::Utils qw(uc_irc);\n\nsub new {\n    return bless { }, shift;\n}\n\nsub PCI_register {\n    my( $self, $irc ) = @_;\n    $irc->plugin_register( $self, 'SERVER', qw(307 310 311 312 313 314 317 318 319 330 338 369) );\n    return 1;\n}\n\nsub PCI_unregister {\n    return 1;\n}\n\n# RPL_WHOISUSER\nsub S_311 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my @args = @{ ${ $_[2] } };\n    my $real = pop @args;\n    my ($rnick,$user,$host) = @args;\n    my $nick = uc_irc $rnick, $mapping;\n\n    $self->{WHOIS}->{ $nick }->{nick} = $rnick;\n    $self->{WHOIS}->{ $nick }->{user} = $user;\n    $self->{WHOIS}->{ $nick }->{host} = $host;\n    $self->{WHOIS}->{ $nick }->{real} = $real;\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOISOPERATOR\nsub S_313 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my $nick = uc_irc ${ $_[2] }->[0], $mapping;\n    my $oper = ${ $_[2] }->[1];\n\n    $self->{WHOIS}->{ $nick }->{oper} = $oper;\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOISSERVER\nsub S_312 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my ($nick,$server) = @{ ${ $_[2] } };\n    $nick = uc_irc $nick, $mapping;\n\n    # This can be returned in reply to either a WHOIS or a WHOWAS *sigh*\n    if ( defined $self->{WHOWAS}->{ $nick } ) {\n        $self->{WHOWAS}->{ $nick }->{server} = $server;\n    }\n    else {\n        $self->{WHOIS}->{ $nick }->{server} = $server;\n    }\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOISIDLE\nsub S_317 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my ($nick,@args) = @{ ${ $_[2] } };\n    $nick = uc_irc $nick, $mapping;\n\n    $self->{WHOIS}->{ $nick }->{idle} = $args[0];\n    $self->{WHOIS}->{ $nick }->{signon} = $args[1];\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOISCHANNELS\nsub S_319 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my @args = @{ ${ $_[2] } };\n    my $nick = uc_irc shift ( @args ), $mapping;\n    my @chans = split / /, shift @args;\n\n    if ( !defined $self->{WHOIS}->{ $nick }->{channels} ) {\n        $self->{WHOIS}->{ $nick }->{channels} = [ @chans ];\n    }\n    else {\n        push( @{ $self->{WHOIS}->{ $nick }->{channels} }, @chans );\n    }\n\n  return PCI_EAT_NONE;\n}\n\n# RPL_WHOISACCOUNT\nsub S_330 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my ($nick, $ident) = @{ ${ $_[2] } };\n\n    $self->{WHOIS}->{ uc_irc ( $nick, $mapping  ) }->{identified} = $ident;\n\n    return PCI_EAT_NONE;\n}\n\n{\n    no warnings 'once';\n    *S_307 = \\&S_330;   # RPL_WHOISREGNICK\n}\n\n# RPL_WHOISMODES\nsub S_310 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my ($nick, $modes) = @{ ${ $_[2] } };\n\n    $self->{WHOIS}->{ uc_irc ( $nick, $mapping  ) }->{modes} = $modes;\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOISACTUALLY (Hybrid/Ratbox/others)\nsub S_338 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my $nick = uc_irc ${ $_[2] }->[0], $mapping;\n    my $ip = ${ $_[2] }->[1];\n\n    $self->{WHOIS}->{ $nick }->{actually} = $ip;\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_ENDOFWHOIS\nsub S_318 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my $nick = uc_irc ${ $_[2] }->[0], $mapping;\n    my $whois = delete $self->{WHOIS}->{ $nick };\n\n    $irc->send_event_next( 'irc_whois', $whois ) if defined $whois;\n    return PCI_EAT_NONE;\n}\n\n# RPL_WHOWASUSER\nsub S_314 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my @args = @{ ${ $_[2] } };\n    my $real = pop @args;\n    my ($rnick,$user,$host) = @args;\n    my $nick = uc_irc $rnick, $mapping;\n\n    $self->{WHOWAS}->{ $nick }->{nick} = $rnick;\n    $self->{WHOWAS}->{ $nick }->{user} = $user;\n    $self->{WHOWAS}->{ $nick }->{host} = $host;\n    $self->{WHOWAS}->{ $nick }->{real} = $real;\n\n    return PCI_EAT_NONE;\n}\n\n# RPL_ENDOFWHOWAS\nsub S_369 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $mapping = $irc->isupport('CASEMAPPING');\n    my $nick = uc_irc ${ $_[2] }->[0], $mapping;\n\n    my $whowas = delete $self->{WHOWAS}->{ $nick };\n    $irc->send_event_next( 'irc_whowas', $whowas ) if defined $whowas;\n    return PCI_EAT_NONE;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC::Plugin::Whois - A PoCo-IRC plugin that generates events\nfor WHOIS and WHOWAS replies\n\n=head1 DESCRIPTION\n\nPOE::Component::IRC::Plugin::Whois is the reimplementation of the C<irc_whois>\nand C<irc_whowas> code from L<POE::Component::IRC|POE::Component::IRC> as a\nplugin. It is used internally by L<POE::Component::IRC|POE::Component::IRC>\nso there is no need to use this plugin yourself.\n\n=head1 METHODS\n\n=head2 C<new>\n\nNo arguments required. Returns a plugin object suitable for feeding to\nL<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.\n\n\n=head1 AUTHOR\n\nChris \"BinGOs\" Williams\n\n=head1 SEE ALSO\n\nL<POE::Component::IRC|POE::Component::IRC>\n\nL<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>\n\n=cut\n", 8192) = 5376
09:01:57.126598 stat("modules/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.126654 stat("modules/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.126705 stat("modules/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.126755 stat("modules/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.126805 stat("/etc/perl/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.126855 stat("/etc/perl/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.126906 stat("/usr/local/lib/perl/5.14.2/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.126959 stat("/usr/local/lib/perl/5.14.2/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.127011 stat("/usr/local/share/perl/5.14.2/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.127063 stat("/usr/local/share/perl/5.14.2/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.127114 stat("/usr/lib/perl5/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.127165 stat("/usr/lib/perl5/IRC/Utils.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.127215 stat("/usr/share/perl5/IRC/Utils.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.127267 stat("/usr/share/perl5/IRC/Utils.pm", {st_mode=S_IFREG|0644, st_size=29932, ...}) = 0
09:01:57.127327 open("/usr/share/perl5/IRC/Utils.pm", O_RDONLY) = 8
09:01:57.127381 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.127428 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.127527 read(8, "package IRC::Utils;\nBEGIN {\n  $IRC::Utils::AUTHORITY = 'cpan:HINRIK';\n}\nBEGIN {\n  $IRC::Utils::VERSION = '0.12';\n}\n\nuse strict;\nuse warnings FATAL => 'all';\n\nuse Encode qw(decode);\nuse Encode::Guess;\n\nrequire Exporter;\nuse base qw(Exporter);\nour @EXPORT_OK = qw(\n    uc_irc lc_irc parse_mode_line normalize_mask matches_mask matches_mask_array\n    unparse_mode_line gen_mode_change parse_user is_valid_nick_name eq_irc\n    decode_irc is_valid_chan_name has_color has_formatting strip_color\n    strip_formatting NORMAL BOLD UNDERLINE REVERSE ITALIC FIXED WHITE BLACK\n    BLUE GREEN RED BROWN PURPLE ORANGE YELLOW LIGHT_GREEN TEAL LIGHT_CYAN\n    LIGHT_BLUE PINK GREY LIGHT_GREY numeric_to_name name_to_numeric\n);\nour %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );\n\nuse constant {\n    # cancel all formatting and colors\n    NORMAL      => \"\\x0f\",\n\n    # formatting\n    BOLD        => \"\\x02\",\n    UNDERLINE   => \"\\x1f\",\n    REVERSE     => \"\\x16\",\n    ITALIC      => \"\\x1d\",\n    FIXED       => \"\\x11\",\n    BLINK       => \"\\x06\",\n\n    # mIRC colors\n    WHITE       => \"\\x0300\",\n    BLACK       => \"\\x0301\",\n    BLUE        => \"\\x0302\",\n    GREEN       => \"\\x0303\",\n    RED         => \"\\x0304\",\n    BROWN       => \"\\x0305\",\n    PURPLE      => \"\\x0306\",\n    ORANGE      => \"\\x0307\",\n    YELLOW      => \"\\x0308\",\n    LIGHT_GREEN => \"\\x0309\",\n    TEAL        => \"\\x0310\",\n    LIGHT_CYAN  => \"\\x0311\",\n    LIGHT_BLUE  => \"\\x0312\",\n    PINK        => \"\\x0313\",\n    GREY        => \"\\x0314\",\n    LIGHT_GREY  => \"\\x0315\",\n};\n\n# list originally snatched from AnyEvent::IRC::Util\nour %NUMERIC2NAME = (\n   '001' => 'RPL_WELCOME',           # RFC2812\n   '002' => 'RPL_YOURHOST',          # RFC2812\n   '003' => 'RPL_CREATED',           # RFC2812\n   '004' => 'RPL_MYINFO',            # RFC2812\n   '005' => 'RPL_ISUPPORT',          # draft-brocklesby-irc-isupport-03\n   '008' => 'RPL_SNOMASK',           # Undernet\n   '009' => 'RPL_STATMEMTOT',        # Undernet\n   '010' => 'RPL_STATMEM',           # Undernet\n   '020' => 'RPL_CONNECTING',        # IRCnet\n   '014' => 'RPL_YOURCOOKIE',        # IRCnet\n   '042' => 'RPL_YOURID',            # IRCnet\n   '043' => 'RPL_SAVENICK',          # IRCnet\n   '050' => 'RPL_ATTEMPTINGJUNC',    # aircd\n   '051' => 'RPL_ATTEMPTINGREROUTE', # aircd\n   '200' => 'RPL_TRACELINK',         # RFC1459\n   '201' => 'RPL_TRACECONNECTING',   # RFC1459\n   '202' => 'RPL_TRACEHANDSHAKE',    # RFC1459\n   '203' => 'RPL_TRACEUNKNOWN',      # RFC1459\n   '204' => 'RPL_TRACEOPERATOR',     # RFC1459\n   '205' => 'RPL_TRACEUSER',         # RFC1459\n   '206' => 'RPL_TRACESERVER',       # RFC1459\n   '207' => 'RPL_TRACESERVICE',      # RFC2812\n   '208' => 'RPL_TRACENEWTYPE',      # RFC1459\n   '209' => 'RPL_TRACECLASS',        # RFC2812\n   '210' => 'RPL_STATS',             # aircd\n   '211' => 'RPL_STATSLINKINFO',     # RFC1459\n   '212' => 'RPL_STATSCOMMANDS',     # RFC1459\n   '213' => 'RPL_STATSCLINE',        # RFC1459\n   '214' => 'RPL_STATSNLINE',        # RFC1459\n   '215' => 'RPL_STATSILINE',        # RFC1459\n   '216' => 'RPL_STATSKLINE',        # RFC1459\n   '217' => 'RPL_STATSQLINE',        # RFC1459\n   '218' => 'RPL_STATSYLINE',        # RFC1459\n   '219' => 'RPL_ENDOFSTATS',        # RFC1459\n   '221' => 'RPL_UMODEIS',           # RFC1459\n   '231' => 'RPL_SERVICEINFO',       # RFC1459\n   '233' => 'RPL_SERVICE',           # RFC1459\n   '234' => 'RPL_SERVLIST',          # RFC1459\n   '235' => 'RPL_SERVLISTEND',       # RFC1459\n   '239' => 'RPL_STATSIAUTH',        # IRCnet\n   '241' => 'RPL_STATSLLINE',        # RFC1459\n   '242' => 'RPL_STATSUPTIME',       # RFC1459\n   '243' => 'RPL_STATSOLINE',        # RFC1459\n   '244' => 'RPL_STATSHLINE',        # RFC1459\n   '245' => 'RPL_STATSSLINE',        # Bahamut, IRCnet, Hybrid\n   '250' => 'RPL_STATSCONN',         # ircu, Unreal\n   '251' => 'RPL_LUSERCLIENT',       # RFC1459\n   '252' => 'RPL_LUSEROP',           # RFC1459\n   '253' => 'RPL_LUSERUNKNOWN',      # RFC1459\n   '254' => 'RPL_LUSERCHANNELS',     # RFC1459\n   '255' => 'RPL_LUSERME',           # RFC1459\n   '256' => 'RPL_ADMINME',           # RFC1459\n   '257' => 'RPL_ADMINLOC1',         # RFC1459\n   '258' => 'RPL_ADMINLOC2',         # RFC1459\n   '259' => 'RPL_ADMINEMAIL',        # RFC1459\n   '261' => 'RPL_TRACELOG',          # RFC1459\n   '262' => 'RPL_TRACEEND',          # RFC2812\n   '263' => 'RPL_TRYAGAIN',          # RFC2812\n   '265' => 'RPL_LOCALUSERS',        # aircd, Bahamut, Hybrid\n   '266' => 'RPL_GLOBALUSERS',       # aircd, Bahamut, Hybrid\n   '267' => 'RPL_START_NETSTAT',     # aircd\n   '268' => 'RPL_NETSTAT',           # aircd\n   '269' => 'RPL_END_NETSTAT',       # aircd\n   '270' => 'RPL_PRIVS',             # ircu\n   '271' => 'RPL_SILELIST',          # ircu\n   '272' => 'RPL_ENDOFSILELIST',     # ircu\n   '300' => 'RPL_NONE',              # RFC1459\n   '301' => 'RPL_AWAY',              # RFC1459\n   '302' => 'RPL_USERHOST',          # RFC1459\n   '303' => 'RPL_ISON',              # RFC1459\n   '305' => 'RPL_UNAWAY',            # RFC1459\n   '306' => 'RPL_NOWAWAY',           # RFC1459\n   '307' => 'RPL_WHOISREGNICK',      # Bahamut, Unreal, Plexus\n   '310' => 'RPL_WHOISMODES',        # Plexus\n   '311' => 'RPL_WHOISUSER',         # RFC1459\n   '312' => 'RPL_WHOISSERVER',       # RFC1459\n   '313' => 'RPL_WHOISOPERATOR',     # RFC1459\n   '314' => 'RPL_WHOWASUSER',        # RFC1459\n   '315' => 'RPL_ENDOFWHO',          # RFC1459\n   '317' => 'RPL_WHOISIDLE',         # RFC1459\n   '318' => 'RPL_ENDOFWHOIS',        # RFC1459\n   '319' => 'RPL_WHOISCHANNELS',     # RFC1459\n   '321' => 'RPL_LISTSTART',         # RFC1459\n   '322' => 'RPL_LIST',              # RFC1459\n   '323' => 'RPL_LISTEND',           # RFC1459\n   '324' => 'RPL_CHANNELMODEIS',     # RFC1459\n   '325' => 'RPL_UNIQOPIS',          # RFC2812\n   '328' => 'RPL_CHANNEL_URL',       # Bahamut, AustHex\n   '329' => 'RPL_CREATIONTIME',      # Bahamut\n   '330' => 'RPL_WHOISACCOUNT',      # ircu\n   '331' => 'RPL_NOTOPIC',           # RFC1459\n   '332' => 'RPL_TOPIC',             # RFC1459\n   '333' => 'RPL_TOPICWHOTIME',      # ircu\n   '338' => 'RPL_WHOISACTUALLY',     # Bahamut, ircu\n   '340' => 'RPL_USERIP',            # ircu\n   '341' => 'RPL_INVITING',          # RFC1459\n   '342' => 'RPL_SUMMONING',         # RFC1459\n   '345' => 'RPL_INVITED',           # GameSurge\n   '346' => 'RPL_INVITELIST',        # RFC2812\n   '347' => 'RPL_ENDOFINVITELIST',   # RFC2812\n   '348' => 'RPL_EXCEPTLIST',        # RFC2812\n   '349' => 'RPL_ENDOFEXCEPTLIST',   # RFC2812\n   '351' => 'RPL_VERSION',           # RFC1459\n   '352' => 'RPL_WHOREPLY',          # RFC1459\n   '353' => 'RPL_NAMREPLY',          # RFC1459\n   '354' => 'RPL_WHOSPCRPL',         # ircu\n   '355' => 'RPL_NAMREPLY_',         # QuakeNet\n   '361' => 'RPL_KILLDONE',          # RFC1459\n   '362' => 'RPL_CLOSING',           # RFC1459\n   '363' => 'RPL_CLOSEEND',          # RFC1459\n   '364' => 'RPL_LINKS',             # RFC1459\n   '365' => 'RPL_ENDOFLINKS',        # RFC1459\n   '366' => 'RPL_ENDOFNAMES',        # RFC1459\n   '367' => 'RPL_BANLIST',           # RFC1459\n   '368' => 'RPL_ENDOFBANLIST',      # RFC1459\n   '369' => 'RPL_ENDOFWHOWAS',       # RFC1459\n   '371' => 'RPL_INFO',              # RFC1459\n   '372' => 'RPL_MOTD',              # RFC1459\n   '373' => 'RPL_INFOSTART',         # RFC1459\n   '374' => 'RPL_ENDOFINFO',         # RFC1459\n   '375' => 'RPL_MOTDSTART',         # RFC1459\n   '376' => 'RPL_ENDOFMOTD',         # RFC1459\n   '381' => 'RPL_YOUREOPER',         # RFC1459\n   '382' => 'RPL_REHASHING',         # RFC1459\n   '383' => 'RPL_YOURESERVICE',      # RFC2812\n   '384' => 'RPL_MYPORTIS',          # RFC1459\n   '385' => 'RPL_NOTOPERANYMORE',    # AustHex, Hybrid, Unreal\n   '391' => 'RPL_TIME',              # RFC1459\n   '392' => 'RPL_USERSSTART',        # RFC1459\n   '393' => 'RPL_USERS',             # RFC1459\n   '394' => 'RPL_ENDOFUSERS',        # RFC1459\n   '395' => 'RPL_NOUSERS',           # RFC1459\n   '396' => 'RPL_HOSTHIDDEN',        # Undernet\n   '401' => 'ERR_NOSUCHNICK',        # RFC1459\n   '402' => 'ERR_NOSUCHSERVER',      # RFC1459\n   '403' => 'ERR_NOSUCHCHANNEL',     # RFC1459\n   '404' => 'ERR_CANNOTSENDTOCHAN',  # RFC1459\n   '405' => 'ERR_TOOMANYCHANNELS',   # RFC1459\n   '406' => 'ERR_WASNOSUCHNICK',     ", 8192) = 8192
09:01:57.128013 stat("modules/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128078 stat("modules/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128133 stat("modules/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128182 stat("modules/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128232 stat("/etc/perl/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128283 stat("/etc/perl/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128334 stat("/usr/local/lib/perl/5.14.2/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128386 stat("/usr/local/lib/perl/5.14.2/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128443 stat("/usr/local/share/perl/5.14.2/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128495 stat("/usr/local/share/perl/5.14.2/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128548 stat("/usr/lib/perl5/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128599 stat("/usr/lib/perl5/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128650 stat("/usr/share/perl5/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128701 stat("/usr/share/perl5/Encode.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.128753 stat("/usr/lib/perl/5.14/Encode.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.128805 stat("/usr/lib/perl/5.14/Encode.pm", {st_mode=S_IFREG|0644, st_size=30155, ...}) = 0
09:01:57.128866 open("/usr/lib/perl/5.14/Encode.pm", O_RDONLY) = 9
09:01:57.128920 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.128968 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.129029 read(9, "#\n# $Id: Encode.pm,v 2.42 2010/12/31 22:48:10 dankogai Exp $\n#\npackage Encode;\nuse strict;\nuse warnings;\nour $VERSION = sprintf \"%d.%02d_01\", q$Revision: 2.42 $ =~ /(\\d+)/g;\nsub DEBUG () { 0 }\nuse XSLoader ();\nXSLoader::load( __PACKAGE__, $VERSION );\n\nrequire Exporter;\nuse base qw/Exporter/;\n\n# Public, encouraged API is exported by default\n\nour @EXPORT = qw(\n  decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str\n  encodings  find_encoding clone_encoding\n);\nour @FB_FLAGS = qw(\n  DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC\n  PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL\n);\nour @FB_CONSTS = qw(\n  FB_DEFAULT FB_CROAK FB_QUIET FB_WARN\n  FB_PERLQQ FB_HTMLCREF FB_XMLCREF\n);\nour @EXPORT_OK = (\n    qw(\n      _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit\n      is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade\n      ),\n    @FB_FLAGS, @FB_CONSTS,\n);\n\nour %EXPORT_TAGS = (\n    all          => [ @EXPORT,    @EXPORT_OK ],\n    default      => [ @EXPORT ],\n    fallbacks    => [ @FB_CONSTS ],\n    fallback_all => [ @FB_CONSTS, @FB_FLAGS ],\n);\n\n# Documentation moved after __END__ for speed - NI-S\n\nour $ON_EBCDIC = ( ord(\"A\") == 193 );\n\nuse Encode::Alias;\n\n# Make a %Encoding package variable to allow a certain amount of cheating\nour %Encoding;\nour %ExtModule;\nrequire Encode::Config;\n#  See\n#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2\n#  to find why sig handers inside eval{} are disabled.\neval {\n    local $SIG{__DIE__};\n    local $SIG{__WARN__};\n    require Encode::ConfigLocal;\n};\n\nsub encodings {\n    my $class = shift;\n    my %enc;\n    if ( @_ and $_[0] eq \":all\" ) {\n        %enc = ( %Encoding, %ExtModule );\n    }\n    else {\n        %enc = %Encoding;\n        for my $mod ( map { m/::/o ? $_ : \"Encode::$_\" } @_ ) {\n            DEBUG and warn $mod;\n            for my $enc ( keys %ExtModule ) {\n                $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;\n            }\n        }\n    }\n    return sort { lc $a cmp lc $b }\n      grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;\n}\n\nsub perlio_ok {\n    my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );\n    $obj->can(\"perlio_ok\") and return $obj->perlio_ok();\n    return 0;    # safety net\n}\n\nsub define_encoding {\n    my $obj  = shift;\n    my $name = shift;\n    $Encoding{$name} = $obj;\n    my $lc = lc($name);\n    define_alias( $lc => $obj ) unless $lc eq $name;\n    while (@_) {\n        my $alias = shift;\n        define_alias( $alias, $obj );\n    }\n    return $obj;\n}\n\nsub getEncoding {\n    my ( $class, $name, $skip_external ) = @_;\n\n    ref($name) && $name->can('renew') and return $name;\n    exists $Encoding{$name} and return $Encoding{$name};\n    my $lc = lc $name;\n    exists $Encoding{$lc} and return $Encoding{$lc};\n\n    my $oc = $class->find_alias($name);\n    defined($oc) and return $oc;\n    $lc ne $name and $oc = $class->find_alias($lc);\n    defined($oc) and return $oc;\n\n    unless ($skip_external) {\n        if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {\n            $mod =~ s,::,/,g;\n            $mod .= '.pm';\n            eval { require $mod; };\n            exists $Encoding{$name} and return $Encoding{$name};\n        }\n    }\n    return;\n}\n\nsub find_encoding($;$) {\n    my ( $name, $skip_external ) = @_;\n    return __PACKAGE__->getEncoding( $name, $skip_external );\n}\n\nsub resolve_alias($) {\n    my $obj = find_encoding(shift);\n    defined $obj and return $obj->name;\n    return;\n}\n\nsub clone_encoding($) {\n    my $obj = find_encoding(shift);\n    ref $obj or return;\n    eval { require Storable };\n    $@ and return;\n    return Storable::dclone($obj);\n}\n\nsub encode($$;$) {\n    my ( $name, $string, $check ) = @_;\n    return undef unless defined $string;\n    $string .= '' if ref $string;    # stringify;\n    $check ||= 0;\n    unless ( defined $name ) {\n        require Carp;\n        Carp::croak(\"Encoding name should not be undef\");\n    }\n    my $enc = find_encoding($name);\n    unless ( defined $enc ) {\n        require Carp;\n        Carp::croak(\"Unknown encoding '$name'\");\n    }\n    my $octets = $enc->encode( $string, $check );\n    $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );\n    return $octets;\n}\n*str2bytes = \\&encode;\n\nsub decode($$;$) {\n    my ( $name, $octets, $check ) = @_;\n    return undef unless defined $octets;\n    $octets .= '' if ref $octets;\n    $check ||= 0;\n    my $enc = find_encoding($name);\n    unless ( defined $enc ) {\n        require Carp;\n        Carp::croak(\"Unknown encoding '$name'\");\n    }\n    my $string = $enc->decode( $octets, $check );\n    $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );\n    return $string;\n}\n*bytes2str = \\&decode;\n\nsub from_to($$$;$) {\n    my ( $string, $from, $to, $check ) = @_;\n    return undef unless defined $string;\n    $check ||= 0;\n    my $f = find_encoding($from);\n    unless ( defined $f ) {\n        require Carp;\n        Carp::croak(\"Unknown encoding '$from'\");\n    }\n    my $t = find_encoding($to);\n    unless ( defined $t ) {\n        require Carp;\n        Carp::croak(\"Unknown encoding '$to'\");\n    }\n    my $uni = $f->decode($string);\n    $_[0] = $string = $t->encode( $uni, $check );\n    return undef if ( $check && length($uni) );\n    return defined( $_[0] ) ? length($string) : undef;\n}\n\nsub encode_utf8($) {\n    my ($str) = @_;\n    utf8::encode($str);\n    return $str;\n}\n\nmy $utf8enc;\n\nsub decode_utf8($;$) {\n    my ( $octets, $check ) = @_;\n    return $octets if is_utf8($octets);\n    return undef unless defined $octets;\n    $octets .= '' if ref $octets;\n    $check   ||= 0;\n    $utf8enc ||= find_encoding('utf8');\n    my $string = $utf8enc->decode( $octets, $check );\n    $_[0] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );\n    return $string;\n}\n\n# sub decode_utf8($;$) {\n#     my ( $str, $check ) = @_;\n#     return $str if is_utf8($str);\n#     if ($check) {\n#         return decode( \"utf8\", $str, $check );\n#     }\n#     else {\n#         return decode( \"utf8\", $str );\n#         return $str;\n#     }\n# }\n\npredefine_encodings(1);\n\n#\n# This is to restore %Encoding if really needed;\n#\n\nsub predefine_encodings {\n    require Encode::Encoding;\n    no warnings 'redefine';\n    my $use_xs = shift;\n    if ($ON_EBCDIC) {\n\n        # was in Encode::UTF_EBCDIC\n        package Encode::UTF_EBCDIC;\n        push @Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';\n        *decode = sub {\n            my ( $obj, $str, $chk ) = @_;\n            my $res = '';\n            for ( my $i = 0 ; $i < length($str) ; $i++ ) {\n                $res .=\n                  chr(\n                    utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )\n                  );\n            }\n            $_[1] = '' if $chk;\n            return $res;\n        };\n        *encode = sub {\n            my ( $obj, $str, $chk ) = @_;\n            my $res = '';\n            for ( my $i = 0 ; $i < length($str) ; $i++ ) {\n                $res .=\n                  chr(\n                    utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )\n                  );\n            }\n            $_[1] = '' if $chk;\n            return $res;\n        };\n        $Encode::Encoding{Unicode} =\n          bless { Name => \"UTF_EBCDIC\" } => \"Encode::UTF_EBCDIC\";\n    }\n    else {\n\n        package Encode::Internal;\n        push @Encode::Internal::ISA, 'Encode::Encoding';\n        *decode = sub {\n            my ( $obj, $str, $chk ) = @_;\n            utf8::upgrade($str);\n            $_[1] = '' if $chk;\n            return $str;\n        };\n        *encode = \\&decode;\n        $Encode::Encoding{Unicode} =\n          bless { Name => \"Internal\" } => \"Encode::Internal\";\n    }\n\n    {\n\n        # was in Encode::utf8\n        package Encode::utf8;\n        push @Encode::utf8::ISA, 'Encode::Encoding';\n\n        #\n        if ($use_xs) {\n            Encode::DEBUG and warn __PACKAGE__, \" XS on\";\n            *decode = \\&decode_xs;\n            *encode = \\&encode_xs;\n        }\n        else {\n            Encode::DEBUG and warn __PACKAGE__, \" XS off\";\n            *decode = sub {\n                my ( $obj, $octets, $chk ) = @_;\n                my $str = Encode::decode_utf8($octets);\n                if ( defined $str ) {\n                    $_[1] = '' if $chk;\n      ", 8192) = 8192
09:01:57.129631 stat("modules/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.129691 stat("modules/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.129742 stat("modules/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.129792 stat("modules/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.129842 stat("/etc/perl/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.129893 stat("/etc/perl/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.129943 stat("/usr/local/lib/perl/5.14.2/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.129995 stat("/usr/local/lib/perl/5.14.2/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.130071 stat("/usr/local/share/perl/5.14.2/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.130125 stat("/usr/local/share/perl/5.14.2/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.130176 stat("/usr/lib/perl5/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.130226 stat("/usr/lib/perl5/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.130275 stat("/usr/share/perl5/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.130338 stat("/usr/share/perl5/Encode/Alias.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.130389 stat("/usr/lib/perl/5.14/Encode/Alias.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.130443 stat("/usr/lib/perl/5.14/Encode/Alias.pm", {st_mode=S_IFREG|0644, st_size=12032, ...}) = 0
09:01:57.130504 open("/usr/lib/perl/5.14/Encode/Alias.pm", O_RDONLY) = 10
09:01:57.130559 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.130607 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.130672 read(10, "package Encode::Alias;\nuse strict;\nuse warnings;\nno warnings 'redefine';\nour $VERSION = do { my @r = ( q$Revision: 2.13 $ =~ /\\d+/g ); sprintf \"%d.\" . \"%02d\" x $#r, @r };\nsub DEBUG () { 0 }\n\nuse base qw(Exporter);\n\n# Public, encouraged API is exported by default\n\nour @EXPORT =\n  qw (\n  define_alias\n  find_alias\n);\n\nour @Alias;    # ordered matching list\nour %Alias;    # cached known aliases\n\nsub find_alias {\n    require Encode;\n    my $class = shift;\n    my $find  = shift;\n    unless ( exists $Alias{$find} ) {\n        $Alias{$find} = undef;    # Recursion guard\n        for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {\n            my $alias = $Alias[$i];\n            my $val   = $Alias[ $i + 1 ];\n            my $new;\n            if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {\n                DEBUG and warn \"eval $val\";\n                $new = eval $val;\n                DEBUG and $@ and warn \"$val, $@\";\n            }\n            elsif ( ref($alias) eq 'CODE' ) {\n                DEBUG and warn \"$alias\", \"->\", \"($find)\";\n                $new = $alias->($find);\n            }\n            elsif ( lc($find) eq lc($alias) ) {\n                $new = $val;\n            }\n            if ( defined($new) ) {\n                next if $new eq $find;    # avoid (direct) recursion on bugs\n                DEBUG and warn \"$alias, $new\";\n                my $enc =\n                  ( ref($new) ) ? $new : Encode::find_encoding($new);\n                if ($enc) {\n                    $Alias{$find} = $enc;\n                    last;\n                }\n            }\n        }\n\n        # case insensitive search when canonical is not in all lowercase\n        # RT ticket #7835\n        unless ( $Alias{$find} ) {\n            my $lcfind = lc($find);\n            for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )\n            {\n                $lcfind eq lc($name) or next;\n                $Alias{$find} = Encode::find_encoding($name);\n                DEBUG and warn \"$find => $name\";\n            }\n        }\n    }\n    if (DEBUG) {\n        my $name;\n        if ( my $e = $Alias{$find} ) {\n            $name = $e->name;\n        }\n        else {\n            $name = \"\";\n        }\n        warn \"find_alias($class, $find)->name = $name\";\n    }\n    return $Alias{$find};\n}\n\nsub define_alias {\n    while (@_) {\n        my ( $alias, $name ) = splice( @_, 0, 2 );\n        unshift( @Alias, $alias => $name );    # newer one has precedence\n        if ( ref($alias) ) {\n\n            # clear %Alias cache to allow overrides\n            my @a = keys %Alias;\n            for my $k (@a) {\n                if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {\n                    DEBUG and warn \"delete \\$Alias\\{$k\\}\";\n                    delete $Alias{$k};\n                }\n                elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {\n                    DEBUG and warn \"delete \\$Alias\\{$k\\}\";\n                    delete $Alias{$k};\n                }\n            }\n        }\n        else {\n            DEBUG and warn \"delete \\$Alias\\{$alias\\}\";\n            delete $Alias{$alias};\n        }\n    }\n}\n\n# Allow latin-1 style names as well\n# 0  1  2  3  4  5   6   7   8   9  10\nour @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );\n\n# Allow winlatin1 style names as well\nour %Winlatin2cp = (\n    'latin1'     => 1252,\n    'latin2'     => 1250,\n    'cyrillic'   => 1251,\n    'greek'      => 1253,\n    'turkish'    => 1254,\n    'hebrew'     => 1255,\n    'arabic'     => 1256,\n    'baltic'     => 1257,\n    'vietnamese' => 1258,\n);\n\ninit_aliases();\n\nsub undef_aliases {\n    @Alias = ();\n    %Alias = ();\n}\n\nsub init_aliases {\n    require Encode;\n    undef_aliases();\n\n    # Try all-lower-case version should all else fails\n    define_alias( qr/^(.*)$/ => '\"\\L$1\"' );\n\n    # UTF/UCS stuff\n    define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '\"UTF-7\"' );\n    define_alias( qr/^UCS-?2-?LE$/i => '\"UCS-2LE\"' );\n    define_alias(\n        qr/^UCS-?2-?(BE)?$/i    => '\"UCS-2BE\"',\n        qr/^UCS-?4-?(BE|LE)?$/i => 'uc(\"UTF-32$1\")',\n        qr/^iso-10646-1$/i      => '\"UCS-2BE\"'\n    );\n    define_alias(\n        qr/^UTF-?(16|32)-?BE$/i => '\"UTF-$1BE\"',\n        qr/^UTF-?(16|32)-?LE$/i => '\"UTF-$1LE\"',\n        qr/^UTF-?(16|32)$/i     => '\"UTF-$1\"',\n    );\n\n    # ASCII\n    define_alias( qr/^(?:US-?)ascii$/i       => '\"ascii\"' );\n    define_alias( 'C'                        => 'ascii' );\n    define_alias( qr/\\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '\"ascii\"' );\n\n    # Allow variants of iso-8859-1 etc.\n    define_alias( qr/\\biso[-_]?(\\d+)[-_](\\d+)$/i => '\"iso-$1-$2\"' );\n\n    # At least HP-UX has these.\n    define_alias( qr/\\biso8859(\\d+)$/i => '\"iso-8859-$1\"' );\n\n    # More HP stuff.\n    define_alias(\n        qr/\\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>\n          '\"${1}8\"' );\n\n    # The Official name of ASCII.\n    define_alias( qr/\\bANSI[-_]?X3\\.4[-_]?1968$/i => '\"ascii\"' );\n\n    # This is a font issue, not an encoding issue.\n    # (The currency symbol of the Latin 1 upper half\n    #  has been redefined as the euro symbol.)\n    define_alias( qr/^(.+)\\@euro$/i => '\"$1\"' );\n\n    define_alias( qr/\\b(?:iso[-_]?)?latin[-_]?(\\d+)$/i =>\n'defined $Encode::Alias::Latin2iso[$1] ? \"iso-8859-$Encode::Alias::Latin2iso[$1]\" : undef'\n    );\n\n    define_alias(\n        qr/\\bwin(latin[12]|cyrillic|baltic|greek|turkish|\n             hebrew|arabic|baltic|vietnamese)$/ix =>\n          '\"cp\" . $Encode::Alias::Winlatin2cp{lc($1)}'\n    );\n\n    # Common names for non-latin preferred MIME names\n    define_alias(\n        'ascii'    => 'US-ascii',\n        'cyrillic' => 'iso-8859-5',\n        'arabic'   => 'iso-8859-6',\n        'greek'    => 'iso-8859-7',\n        'hebrew'   => 'iso-8859-8',\n        'thai'     => 'iso-8859-11',\n    );\n    # RT #20781\n    define_alias(qr/\\btis-?620\\b/i  => '\"iso-8859-11\"');\n\n    # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.\n    # And Microsoft has their own naming (again, surprisingly).\n    # And windows-* is registered in IANA!\n    define_alias(\n        qr/\\b(?:cp|ibm|ms|windows)[-_ ]?(\\d{2,4})$/i => '\"cp$1\"' );\n\n    # Sometimes seen with a leading zero.\n    # define_alias( qr/\\bcp037\\b/i => '\"cp37\"');\n\n    # Mac Mappings\n    # predefined in *.ucm; unneeded\n    # define_alias( qr/\\bmacIcelandic$/i => '\"macIceland\"');\n    define_alias( qr/^mac_(.*)$/i => '\"mac$1\"' );\n    # http://rt.cpan.org/Ticket/Display.html?id=36326\n    define_alias( qr/^macintosh$/i => '\"MacRoman\"' );\n\n    # Ououououou. gone.  They are differente!\n    # define_alias( qr/\\bmacRomanian$/i => '\"macRumanian\"');\n\n    # Standardize on the dashed versions.\n    define_alias( qr/\\bkoi8[\\s\\-_]*([ru])$/i => '\"koi8-$1\"' );\n\n    unless ($Encode::ON_EBCDIC) {\n\n        # for Encode::CN\n        define_alias( qr/\\beuc.*cn$/i => '\"euc-cn\"' );\n        define_alias( qr/\\bcn.*euc$/i => '\"euc-cn\"' );\n\n        # define_alias( qr/\\bGB[- ]?(\\d+)$/i => '\"euc-cn\"' )\n        # CP936 doesn't have vendor-addon for GBK, so they're identical.\n        define_alias( qr/^gbk$/i => '\"cp936\"' );\n\n        # This fixes gb2312 vs. euc-cn confusion, practically\n        define_alias( qr/\\bGB[-_ ]?2312(?!-?raw)/i => '\"euc-cn\"' );\n\n        # for Encode::JP\n        define_alias( qr/\\bjis$/i         => '\"7bit-jis\"' );\n        define_alias( qr/\\beuc.*jp$/i     => '\"euc-jp\"' );\n        define_alias( qr/\\bjp.*euc$/i     => '\"euc-jp\"' );\n        define_alias( qr/\\bujis$/i        => '\"euc-jp\"' );\n        define_alias( qr/\\bshift.*jis$/i  => '\"shiftjis\"' );\n        define_alias( qr/\\bsjis$/i        => '\"shiftjis\"' );\n        define_alias( qr/\\bwindows-31j$/i => '\"cp932\"' );\n\n        # for Encode::KR\n        define_alias( qr/\\beuc.*kr$/i => '\"euc-kr\"' );\n        define_alias( qr/\\bkr.*euc$/i => '\"euc-kr\"' );\n\n        # This fixes ksc5601 vs. euc-kr confusion, practically\n        define_alias( qr/(?:x-)?uhc$/i         => '\"cp949\"' );\n        define_alias( qr/(?:x-)?windows-949$/i => '\"cp949\"' );\n        define_alias( qr/\\bks_c_5601-1987$/i   => '\"cp949\"' );\n\n        # for Encode::TW\n        define_alias( qr/\\bbig-?5$/i              => '\"big5-eten\"' );\n        define_alias( qr/\\bbig5-?et(?:en)?$/i     => '\"big5-eten\"' );\n        define_alias( qr/\\btca[-_]?big5$/i        => '\"big5-eten", 8192) = 8192
09:01:57.131087 brk(0xe43000)           = 0xe43000
09:01:57.132053 read(10, "\"' );\n        define_alias( qr/\\bbig5-?hk(?:scs)?$/i    => '\"big5-hkscs\"' );\n        define_alias( qr/\\bhk(?:scs)?[-_]?big5$/i => '\"big5-hkscs\"' );\n    }\n\n    # utf8 is blessed :)\n    define_alias( qr/\\bUTF-8$/i => '\"utf-8-strict\"' );\n\n    # At last, Map white space and _ to '-'\n    define_alias( qr/^(\\S+)[\\s_]+(.*)$/i => '\"$1-$2\"' );\n}\n\n1;\n__END__\n\n# TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8\n# TODO: HP-UX '15' encodings japanese15 korean15 roi15\n# TODO: Cyrillic encoding ISO-IR-111 (useful?)\n# TODO: Armenian encoding ARMSCII-8\n# TODO: Hebrew encoding ISO-8859-8-1\n# TODO: Thai encoding TCVN\n# TODO: Vietnamese encodings VPS\n# TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese\n#       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic\n#       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese\n#       Kannada Khmer Korean Laotian Malayalam Mongolian\n#       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese\n\n=head1 NAME\n\nEncode::Alias - alias definitions to encodings\n\n=head1 SYNOPSIS\n\n  use Encode;\n  use Encode::Alias;\n  define_alias( \"newName\" => ENCODING);\n  define_alias( qr/.../ => ENCODING);\n  define_alias( sub { return ENCODING if ...; } );\n\n=head1 DESCRIPTION\n\nAllows newName to be used as an alias for ENCODING. ENCODING may be\neither the name of an encoding or an encoding object (as described \nin L<Encode>).\n\nCurrently the first argument to define_alias() can be specified in the\nfollowing ways:\n\n=over 4\n\n=item As a simple string.\n\n=item As a qr// compiled regular expression, e.g.:\n\n  define_alias( qr/^iso8859-(\\d+)$/i => '\"iso-8859-$1\"' );\n\nIn this case, if I<ENCODING> is not a reference, it is C<eval>-ed\nin order to allow C<$1> etc. to be substituted.  The example is one\nway to alias names as used in X11 fonts to the MIME names for the\niso-8859-* family.  Note the double quotes inside the single quotes.\n\n(or, you don't have to do this yourself because this example is predefined)\n\nIf you are using a regex here, you have to use the quotes as shown or\nit won't work.  Also note that regex handling is tricky even for the\nexperienced.  Use this feature with caution.\n\n=item As a code reference, e.g.:\n\n  define_alias( sub {shift =~ /^iso8859-(\\d+)$/i ? \"iso-8859-$1\" : undef } );\n\nThe same effect as the example above in a different way.  The coderef\ntakes the alias name as an argument and returns a canonical name on\nsuccess or undef if not.  Note the second argument is ignored if provided.\nUse this with even more caution than the regex version.\n\n=back\n\n=head3 Changes in code reference aliasing\n\nAs of Encode 1.87, the older form\n\n  define_alias( sub { return  /^iso8859-(\\d+)$/i ? \"iso-8859-$1\" : undef } );\n\nno longer works. \n\nEncode up to 1.86 internally used \"local $_\" to implement ths older\nform.  But consider the code below;\n\n  use Encode;\n  $_ = \"eeeee\" ;\n  while (/(e)/g) {\n    my $utf = decode('aliased-encoding-name', $1);\n    print \"position:\",pos,\"\\n\";\n  }\n\nPrior to Encode 1.86 this fails because of \"local $_\".\n\n=head2 Alias overloading\n\nYou can override predefined aliases by simply applying define_alias().\nThe new alias is always evaluated first, and when necessary,\ndefine_alias() flushes the internal cache to make the new definition\navailable.\n\n  # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a\n  # superset of SHIFT_JIS\n\n  define_alias( qr/shift.*jis$/i  => '\"cp932\"' );\n  define_alias( qr/sjis$/i        => '\"cp932\"' );\n\nIf you want to zap all predefined aliases, you can use\n\n  Encode::Alias->undef_aliases;\n\nto do so.  And\n\n  Encode::Alias->init_aliases;\n\ngets the factory settings back.\n\nNote that define_alias() will not be able to override the canonical name\nof encodings. Encodings are first looked up by canonical name before\npotential aliases are tried.\n\n=head1 SEE ALSO\n\nL<Encode>, L<Encode::Supported>\n\n=cut\n\n", 8192) = 3840
09:01:57.132358 lseek(10, 8543, SEEK_SET) = 8543
09:01:57.132412 lseek(10, 0, SEEK_CUR)  = 8543
09:01:57.132458 close(10)               = 0
09:01:57.132838 brk(0xe64000)           = 0xe64000
09:01:57.133650 read(9, "              return $str;\n                }\n                return undef;\n            };\n            *encode = sub {\n                my ( $obj, $string, $chk ) = @_;\n                my $octets = Encode::encode_utf8($string);\n                $_[1] = '' if $chk;\n                return $octets;\n            };\n        }\n        *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)\n                               # currently ignores $chk\n            my ( $obj, undef, undef, $pos, $trm ) = @_;\n            my ( $rdst, $rsrc, $rpos ) = \\@_[ 1, 2, 3 ];\n            use bytes;\n            if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {\n                $$rdst .=\n                  substr( $$rsrc, $pos, $npos - $pos + length($trm) );\n                $$rpos = $npos + length($trm);\n                return 1;\n            }\n            $$rdst .= substr( $$rsrc, $pos );\n            $$rpos = length($$rsrc);\n            return '';\n        };\n        $Encode::Encoding{utf8} =\n          bless { Name => \"utf8\" } => \"Encode::utf8\";\n        $Encode::Encoding{\"utf-8-strict\"} =\n          bless { Name => \"utf-8-strict\", strict_utf8 => 1 } =>\n          \"Encode::utf8\";\n    }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nEncode - character encodings\n\n=head1 SYNOPSIS\n\n    use Encode;\n\n=head2 Table of Contents\n\nEncode consists of a collection of modules whose details are too big\nto fit in one document.  This POD itself explains the top-level APIs\nand general topics at a glance.  For other topics and more details,\nsee the PODs below:\n\n  Name\t\t\t        Description\n  --------------------------------------------------------\n  Encode::Alias         Alias definitions to encodings\n  Encode::Encoding      Encode Implementation Base Class\n  Encode::Supported     List of Supported Encodings\n  Encode::CN            Simplified Chinese Encodings\n  Encode::JP            Japanese Encodings\n  Encode::KR            Korean Encodings\n  Encode::TW            Traditional Chinese Encodings\n  --------------------------------------------------------\n\n=head1 DESCRIPTION\n\nThe C<Encode> module provides the interfaces between Perl's strings\nand the rest of the system.  Perl strings are sequences of\nB<characters>.\n\nThe repertoire of characters that Perl can represent is at least that\ndefined by the Unicode Consortium. On most platforms the ordinal\nvalues of the characters (as returned by C<ord(ch)>) is the \"Unicode\ncodepoint\" for the character (the exceptions are those platforms where\nthe legacy encoding is some variant of EBCDIC rather than a super-set\nof ASCII - see L<perlebcdic>).\n\nTraditionally, computer data has been moved around in 8-bit chunks\noften called \"bytes\". These chunks are also known as \"octets\" in\nnetworking standards. Perl is widely used to manipulate data of many\ntypes - not only strings of characters representing human or computer\nlanguages but also \"binary\" data being the machine's representation of\nnumbers, pixels in an image - or just about anything.\n\nWhen Perl is processing \"binary data\", the programmer wants Perl to\nprocess \"sequences of bytes\". This is not a problem for Perl - as a\nbyte has 256 possible values, it easily fits in Perl's much larger\n\"logical character\".\n\n=head2 TERMINOLOGY\n\n=over 2\n\n=item *\n\nI<character>: a character in the range 0..(2**32-1) (or more).\n(What Perl's strings are made of.)\n\n=item *\n\nI<byte>: a character in the range 0..255\n(A special case of a Perl character.)\n\n=item *\n\nI<octet>: 8 bits of data, with ordinal values 0..255\n(Term for bytes passed to or from a non-Perl context, e.g. a disk file.)\n\n=back\n\n=head1 PERL ENCODING API\n\n=over 2\n\n=item $octets  = encode(ENCODING, $string [, CHECK])\n\nEncodes a string from Perl's internal form into I<ENCODING> and returns\na sequence of octets.  ENCODING can be either a canonical name or\nan alias.  For encoding names and aliases, see L</\"Defining Aliases\">.\nFor CHECK, see L</\"Handling Malformed Data\">.\n\nFor example, to convert a string from Perl's internal format to\niso-8859-1 (also known as Latin1),\n\n  $octets = encode(\"iso-8859-1\", $string);\n\nB<CAVEAT>: When you run C<$octets = encode(\"utf8\", $string)>, then\n$octets B<may not be equal to> $string.  Though they both contain the\nsame data, the UTF8 flag for $octets is B<always> off.  When you\nencode anything, UTF8 flag of the result is always off, even when it\ncontains completely valid utf8 string. See L</\"The UTF8 flag\"> below.\n\nIf the $string is C<undef> then C<undef> is returned.\n\n=item $string = decode(ENCODING, $octets [, CHECK])\n\nDecodes a sequence of octets assumed to be in I<ENCODING> into Perl's\ninternal form and returns the resulting string.  As in encode(),\nENCODING can be either a canonical name or an alias. For encoding names\nand aliases, see L</\"Defining Aliases\">.  For CHECK, see\nL</\"Handling Malformed Data\">.\n\nFor example, to convert ISO-8859-1 data to a string in Perl's internal format:\n\n  $string = decode(\"iso-8859-1\", $octets);\n\nB<CAVEAT>: When you run C<$string = decode(\"utf8\", $octets)>, then $string\nB<may not be equal to> $octets.  Though they both contain the same data,\nthe UTF8 flag for $string is on unless $octets entirely consists of\nASCII data (or EBCDIC on EBCDIC machines).  See L</\"The UTF8 flag\">\nbelow.\n\nIf the $string is C<undef> then C<undef> is returned.\n\n=item [$obj =] find_encoding(ENCODING)\n\nReturns the I<encoding object> corresponding to ENCODING.  Returns\nundef if no matching ENCODING is find.\n\nThis object is what actually does the actual (en|de)coding.\n\n  $utf8 = decode($name, $bytes);\n\nis in fact\n\n  $utf8 = do{\n    $obj = find_encoding($name);\n    croak qq(encoding \"$name\" not found) unless ref $obj;\n    $obj->decode($bytes)\n  };\n\nwith more error checking.\n\nTherefore you can save time by reusing this object as follows;\n\n  my $enc = find_encoding(\"iso-8859-1\");\n  while(<>){\n     my $utf8 = $enc->decode($_);\n     # and do someting with $utf8;\n  }\n\nBesides C<< ->decode >> and C<< ->encode >>, other methods are\navailable as well.  For instance, C<< -> name >> returns the canonical\nname of the encoding object.\n\n  find_encoding(\"latin1\")->name; # iso-8859-1\n\nSee L<Encode::Encoding> for details.\n\n=item [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])\n\nConverts B<in-place> data between two encodings. The data in $octets\nmust be encoded as octets and not as characters in Perl's internal\nformat. For example, to convert ISO-8859-1 data to Microsoft's CP1250\nencoding:\n\n  from_to($octets, \"iso-8859-1\", \"cp1250\");\n\nand to convert it back:\n\n  from_to($octets, \"cp1250\", \"iso-8859-1\");\n\nNote that because the conversion happens in place, the data to be\nconverted cannot be a string constant; it must be a scalar variable.\n\nfrom_to() returns the length of the converted string in octets on\nsuccess, I<undef> on error.\n\nB<CAVEAT>: The following operations look the same but are not quite so;\n\n  from_to($data, \"iso-8859-1\", \"utf8\"); #1\n  $data = decode(\"iso-8859-1\", $data);  #2\n\nBoth #1 and #2 make $data consist of a completely valid UTF-8 string\nbut only #2 turns UTF8 flag on.  #1 is equivalent to\n\n  $data = encode(\"utf8\", decode(\"iso-8859-1\", $data));\n\nSee L</\"The UTF8 flag\"> below.\n\nAlso note that\n\n  from_to($octets, $from, $to, $check);\n\nis equivalent to\n\n  $octets = encode($to, decode($from, $octets), $check);\n\nYes, it does not respect the $check during decoding.  It is\ndeliberately done that way.  If you need minute control, C<decode>\nthen C<encode> as follows;\n\n  $octets = encode($to, decode($from, $octets, $check_from), $check_to);\n\n=item $octets = encode_utf8($string);\n\nEquivalent to C<$octets = encode(\"utf8\", $string);> The characters\nthat comprise $string are encoded in Perl's internal format and the\nresult is returned as a sequence of octets. All possible\ncharacters have a UTF-8 representation so this function cannot fail.\n\n\n=item $string = decode_utf8($octets [, CHECK]);\n\nequivalent to C<$string = decode(\"utf8\", $octets [, CHECK])>.\nThe sequence of octets represented by\n$octets is decoded from UTF-8 into a sequence of logical\ncharacters. Not all sequences of octets form valid UTF-8 encodings, so\nit is possible for this call to fail.  For CHECK, see\nL</\"Handling Malformed Data\">.\n\n=back\n\n=head2 Listing available encodings\n\n ", 8192) = 8192
09:01:57.134158 brk(0xe85000)           = 0xe85000
09:01:57.134294 lseek(9, 9386, SEEK_SET) = 9386
09:01:57.134354 lseek(9, 0, SEEK_CUR)   = 9386
09:01:57.134400 close(9)                = 0
09:01:57.134488 stat("/usr/lib/perl/5.14/auto/Encode/Encode.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.134548 stat("/usr/lib/perl/5.14/auto/Encode/Encode.so", {st_mode=S_IFREG|0644, st_size=39432, ...}) = 0
09:01:57.134609 stat("/usr/lib/perl/5.14/auto/Encode/Encode.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.134671 open("/usr/lib/perl/5.14/auto/Encode/Encode.so", O_RDONLY) = 9
09:01:57.134726 read(9, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`,\0\0\0\0\0\0@\0\0\0\0\0\0\0\10\223\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\34\202\0\0\0\0\0\0\34\202\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0008\211\0\0\0\0\0\0008\211 \0\0\0\0\0008\211 \0\0\0\0\0\310\10\0\0\0\0\0\0\320\10\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\260\214\0\0\0\0\0\0\260\214 \0\0\0\0\0\260\214 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0 y\0\0\0\0\0\0 y\0\0\0\0\0\0 y\0\0\0\0\0\0\\\1\0\0\0\0\0\0\\\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0008\211\0\0\0\0\0\0008\211 \0\0\0\0\0008\211 \0\0\0\0\0\310\6\0\0\0\0\0\0\310\6\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0e\1[\336z\351H\261\351#\271\327\25\303\345\2559\5w^\0\0\0\0a\0\0\0p\0\0\0I\0\0\0\20\0\0\0\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\21\0\0\0\26\0\0\0N\0\0\0\0\0\0\0U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0X\0\0\0003\0\0\0J\0\0\0\7\0\0\0004\0\0\0\0\0\0\0W\0\0\0j\0\0\0`\0\0\0\4\0\0\0\37\0\0\0l\0\0\0n\0\0\0\0\0\0\0\0\0\0\0001\0\0\0\0\0\0\0005\0\0\0o\0\0\0\27\0\0\0\25\0\0\0\0\0\0\0c\0\0\0Y\0\0\0\0\0\0\0G\0\0\0\31\0\0\0?\0\0\0\0\0\0\0>\0\0\0000\0\0\0&\0\0\0V\0\0\0k\0\0\0\0\0\0\0\0\0\0\0009\0\0\0\30\0\0\0\0\0\0\0\22\0\0\0f\0\0\0+\0\0\0)\0\0\0T\0\0\0 \0\0\0\0\0\0\0[\0\0\0008\0\0\0\r\0\0\0\10\0\0\0i\0\0\0\0\0\0\0^\0\0\0@\0\0\0:\0\0\0\n\0\0\0a\0\0\0\0\0\0\0\t\0\0\0\"\0\0\0\0\0\0\0H\0\0\0d\0\0\0", 832) = 832
09:01:57.134863 fstat(9, {st_mode=S_IFREG|0644, st_size=39432, ...}) = 0
09:01:57.134921 mmap(NULL, 2134536, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0x7f74346ed000
09:01:57.134972 mprotect(0x7f74346f6000, 2093056, PROT_NONE) = 0
09:01:57.135022 mmap(0x7f74348f5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x8000) = 0x7f74348f5000
09:01:57.135082 close(9)                = 0
09:01:57.135149 mprotect(0x7f74348f5000, 4096, PROT_READ) = 0
09:01:57.135309 stat("modules/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135362 stat("modules/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135413 stat("modules/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135462 stat("modules/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135513 stat("/etc/perl/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135563 stat("/etc/perl/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135614 stat("/usr/local/lib/perl/5.14.2/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135678 stat("/usr/local/lib/perl/5.14.2/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135730 stat("/usr/local/share/perl/5.14.2/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135782 stat("/usr/local/share/perl/5.14.2/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135837 stat("/usr/lib/perl5/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135900 stat("/usr/lib/perl5/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.135949 stat("/usr/share/perl5/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.135999 stat("/usr/share/perl5/Encode/Config.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.136051 stat("/usr/lib/perl/5.14/Encode/Config.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.136116 stat("/usr/lib/perl/5.14/Encode/Config.pm", {st_mode=S_IFREG|0644, st_size=6065, ...}) = 0
09:01:57.136178 open("/usr/lib/perl/5.14/Encode/Config.pm", O_RDONLY) = 9
09:01:57.136233 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.136281 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.136343 read(9, "#\n# Demand-load module list\n#\npackage Encode::Config;\nour $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\\d+/g ); sprintf \"%d.\" . \"%02d\" x $#r, @r };\n\nuse strict;\nuse warnings;\n\nour %ExtModule = (\n\n    # Encode::Byte\n    #iso-8859-1 is in Encode.pm itself\n    'iso-8859-2'            => 'Encode::Byte',\n    'iso-8859-3'            => 'Encode::Byte',\n    'iso-8859-4'            => 'Encode::Byte',\n    'iso-8859-5'            => 'Encode::Byte',\n    'iso-8859-6'            => 'Encode::Byte',\n    'iso-8859-7'            => 'Encode::Byte',\n    'iso-8859-8'            => 'Encode::Byte',\n    'iso-8859-9'            => 'Encode::Byte',\n    'iso-8859-10'           => 'Encode::Byte',\n    'iso-8859-11'           => 'Encode::Byte',\n    'iso-8859-13'           => 'Encode::Byte',\n    'iso-8859-14'           => 'Encode::Byte',\n    'iso-8859-15'           => 'Encode::Byte',\n    'iso-8859-16'           => 'Encode::Byte',\n    'koi8-f'                => 'Encode::Byte',\n    'koi8-r'                => 'Encode::Byte',\n    'koi8-u'                => 'Encode::Byte',\n    'viscii'                => 'Encode::Byte',\n    'cp424'                 => 'Encode::Byte',\n    'cp437'                 => 'Encode::Byte',\n    'cp737'                 => 'Encode::Byte',\n    'cp775'                 => 'Encode::Byte',\n    'cp850'                 => 'Encode::Byte',\n    'cp852'                 => 'Encode::Byte',\n    'cp855'                 => 'Encode::Byte',\n    'cp856'                 => 'Encode::Byte',\n    'cp857'                 => 'Encode::Byte',\n    'cp858'                 => 'Encode::Byte',\n    'cp860'                 => 'Encode::Byte',\n    'cp861'                 => 'Encode::Byte',\n    'cp862'                 => 'Encode::Byte',\n    'cp863'                 => 'Encode::Byte',\n    'cp864'                 => 'Encode::Byte',\n    'cp865'                 => 'Encode::Byte',\n    'cp866'                 => 'Encode::Byte',\n    'cp869'                 => 'Encode::Byte',\n    'cp874'                 => 'Encode::Byte',\n    'cp1006'                => 'Encode::Byte',\n    'cp1250'                => 'Encode::Byte',\n    'cp1251'                => 'Encode::Byte',\n    'cp1252'                => 'Encode::Byte',\n    'cp1253'                => 'Encode::Byte',\n    'cp1254'                => 'Encode::Byte',\n    'cp1255'                => 'Encode::Byte',\n    'cp1256'                => 'Encode::Byte',\n    'cp1257'                => 'Encode::Byte',\n    'cp1258'                => 'Encode::Byte',\n    'AdobeStandardEncoding' => 'Encode::Byte',\n    'MacArabic'             => 'Encode::Byte',\n    'MacCentralEurRoman'    => 'Encode::Byte',\n    'MacCroatian'           => 'Encode::Byte',\n    'MacCyrillic'           => 'Encode::Byte',\n    'MacFarsi'              => 'Encode::Byte',\n    'MacGreek'              => 'Encode::Byte',\n    'MacHebrew'             => 'Encode::Byte',\n    'MacIcelandic'          => 'Encode::Byte',\n    'MacRoman'              => 'Encode::Byte',\n    'MacRomanian'           => 'Encode::Byte',\n    'MacRumanian'           => 'Encode::Byte',\n    'MacSami'               => 'Encode::Byte',\n    'MacThai'               => 'Encode::Byte',\n    'MacTurkish'            => 'Encode::Byte',\n    'MacUkrainian'          => 'Encode::Byte',\n    'nextstep'              => 'Encode::Byte',\n    'hp-roman8'             => 'Encode::Byte',\n    #'gsm0338'               => 'Encode::Byte',\n    'gsm0338'               => 'Encode::GSM0338',\n\n    # Encode::EBCDIC\n    'cp37'     => 'Encode::EBCDIC',\n    'cp500'    => 'Encode::EBCDIC',\n    'cp875'    => 'Encode::EBCDIC',\n    'cp1026'   => 'Encode::EBCDIC',\n    'cp1047'   => 'Encode::EBCDIC',\n    'posix-bc' => 'Encode::EBCDIC',\n\n    # Encode::Symbol\n    'dingbats'      => 'Encode::Symbol',\n    'symbol'        => 'Encode::Symbol',\n    'AdobeSymbol'   => 'Encode::Symbol',\n    'AdobeZdingbat' => 'Encode::Symbol',\n    'MacDingbats'   => 'Encode::Symbol',\n    'MacSymbol'     => 'Encode::Symbol',\n\n    # Encode::Unicode\n    'UCS-2BE'  => 'Encode::Unicode',\n    'UCS-2LE'  => 'Encode::Unicode',\n    'UTF-16'   => 'Encode::Unicode',\n    'UTF-16BE' => 'Encode::Unicode',\n    'UTF-16LE' => 'Encode::Unicode',\n    'UTF-32'   => 'Encode::Unicode',\n    'UTF-32BE' => 'Encode::Unicode',\n    'UTF-32LE' => 'Encode::Unicode',\n    'UTF-7'    => 'Encode::Unicode::UTF7',\n);\n\nunless ( ord(\"A\") == 193 ) {\n    %ExtModule = (\n        %ExtModule,\n        'euc-cn'         => 'Encode::CN',\n        'gb12345-raw'    => 'Encode::CN',\n        'gb2312-raw'     => 'Encode::CN',\n        'hz'             => 'Encode::CN',\n        'iso-ir-165'     => 'Encode::CN',\n        'cp936'          => 'Encode::CN',\n        'MacChineseSimp' => 'Encode::CN',\n\n        '7bit-jis'      => 'Encode::JP',\n        'euc-jp'        => 'Encode::JP',\n        'iso-2022-jp'   => 'Encode::JP',\n        'iso-2022-jp-1' => 'Encode::JP',\n        'jis0201-raw'   => 'Encode::JP',\n        'jis0208-raw'   => 'Encode::JP',\n        'jis0212-raw'   => 'Encode::JP',\n        'cp932'         => 'Encode::JP',\n        'MacJapanese'   => 'Encode::JP',\n        'shiftjis'      => 'Encode::JP',\n\n        'euc-kr'      => 'Encode::KR',\n        'iso-2022-kr' => 'Encode::KR',\n        'johab'       => 'Encode::KR',\n        'ksc5601-raw' => 'Encode::KR',\n        'cp949'       => 'Encode::KR',\n        'MacKorean'   => 'Encode::KR',\n\n        'big5-eten'      => 'Encode::TW',\n        'big5-hkscs'     => 'Encode::TW',\n        'cp950'          => 'Encode::TW',\n        'MacChineseTrad' => 'Encode::TW',\n\n        #'big5plus'           => 'Encode::HanExtra',\n        #'euc-tw'             => 'Encode::HanExtra',\n        #'gb18030'            => 'Encode::HanExtra',\n\n        'MIME-Header' => 'Encode::MIME::Header',\n        'MIME-B'      => 'Encode::MIME::Header',\n        'MIME-Q'      => 'Encode::MIME::Header',\n\n        'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',\n    );\n}\n\n#\n# Why not export ? to keep ConfigLocal Happy!\n#\nwhile ( my ( $enc, $mod ) = each %ExtModule ) {\n    $Encode::ExtModule{$enc} = $mod;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nEncode::Config -- internally used by Encode\n\n=cut\n", 8192) = 6065
09:01:57.136879 lseek(9, 6001, SEEK_SET) = 6001
09:01:57.136928 lseek(9, 0, SEEK_CUR)   = 6001
09:01:57.136974 close(9)                = 0
09:01:57.137226 stat("modules/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137279 stat("modules/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137330 stat("modules/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137379 stat("modules/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137437 stat("/etc/perl/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137489 stat("/etc/perl/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137540 stat("/usr/local/lib/perl/5.14.2/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137592 stat("/usr/local/lib/perl/5.14.2/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137643 stat("/usr/local/share/perl/5.14.2/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137699 stat("/usr/local/share/perl/5.14.2/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137751 stat("/usr/lib/perl5/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137801 stat("/usr/lib/perl5/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137851 stat("/usr/share/perl5/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.137903 stat("/usr/share/perl5/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.137955 stat("/usr/lib/perl/5.14/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138007 stat("/usr/lib/perl/5.14/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138089 stat("/usr/share/perl/5.14/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138143 stat("/usr/share/perl/5.14/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138196 stat("/usr/local/lib/site_perl/Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138246 stat("/usr/local/lib/site_perl/Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138309 stat("./Encode/ConfigLocal.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138359 stat("./Encode/ConfigLocal.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138423 stat("modules/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138474 stat("modules/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138525 stat("modules/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138574 stat("modules/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138624 stat("/etc/perl/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138674 stat("/etc/perl/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138725 stat("/usr/local/lib/perl/5.14.2/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138776 stat("/usr/local/lib/perl/5.14.2/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138828 stat("/usr/local/share/perl/5.14.2/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138879 stat("/usr/local/share/perl/5.14.2/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.138931 stat("/usr/lib/perl5/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.138981 stat("/usr/lib/perl5/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.139032 stat("/usr/share/perl5/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.139084 stat("/usr/share/perl5/Encode/Encoding.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.139137 stat("/usr/lib/perl/5.14/Encode/Encoding.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.139190 stat("/usr/lib/perl/5.14/Encode/Encoding.pm", {st_mode=S_IFREG|0644, st_size=9095, ...}) = 0
09:01:57.139250 open("/usr/lib/perl/5.14/Encode/Encoding.pm", O_RDONLY) = 9
09:01:57.139310 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.139358 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.139421 read(9, "package Encode::Encoding;\n\n# Base class for classes which implement encodings\nuse strict;\nuse warnings;\nour $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\\d+/g ); sprintf \"%d.\" . \"%02d\" x $#r, @r };\n\nrequire Encode;\n\nsub DEBUG { 0 }\n\nsub Define {\n    my $obj       = shift;\n    my $canonical = shift;\n    $obj = bless { Name => $canonical }, $obj unless ref $obj;\n\n    # warn \"$canonical => $obj\\n\";\n    Encode::define_encoding( $obj, $canonical, @_ );\n}\n\nsub name { return shift->{'Name'} }\n\nsub mime_name{\n    require Encode::MIME::Name;\n    return Encode::MIME::Name::get_mime_name(shift->name);\n}\n\n# sub renew { return $_[0] }\n\nsub renew {\n    my $self = shift;\n    my $clone = bless {%$self} => ref($self);\n    $clone->{renewed}++;    # so the caller can see it\n    DEBUG and warn $clone->{renewed};\n    return $clone;\n}\n\nsub renewed { return $_[0]->{renewed} || 0 }\n\n*new_sequence = \\&renew;\n\nsub needs_lines { 0 }\n\nsub perlio_ok {\n    eval { require PerlIO::encoding };\n    return $@ ? 0 : 1;\n}\n\n# (Temporary|legacy) methods\n\nsub toUnicode   { shift->decode(@_) }\nsub fromUnicode { shift->encode(@_) }\n\n#\n# Needs to be overloaded or just croak\n#\n\nsub encode {\n    require Carp;\n    my $obj = shift;\n    my $class = ref($obj) ? ref($obj) : $obj;\n    Carp::croak( $class . \"->encode() not defined!\" );\n}\n\nsub decode {\n    require Carp;\n    my $obj = shift;\n    my $class = ref($obj) ? ref($obj) : $obj;\n    Carp::croak( $class . \"->encode() not defined!\" );\n}\n\nsub DESTROY { }\n\n1;\n__END__\n\n=head1 NAME\n\nEncode::Encoding - Encode Implementation Base Class\n\n=head1 SYNOPSIS\n\n  package Encode::MyEncoding;\n  use base qw(Encode::Encoding);\n\n  __PACKAGE__->Define(qw(myCanonical myAlias));\n\n=head1 DESCRIPTION\n\nAs mentioned in L<Encode>, encodings are (in the current\nimplementation at least) defined as objects. The mapping of encoding\nname to object is via the C<%Encode::Encoding> hash.  Though you can\ndirectly manipulate this hash, it is strongly encouraged to use this\nbase class module and add encode() and decode() methods.\n\n=head2 Methods you should implement\n\nYou are strongly encouraged to implement methods below, at least\neither encode() or decode().\n\n=over 4\n\n=item -E<gt>encode($string [,$check])\n\nMUST return the octet sequence representing I<$string>. \n\n=over 2\n\n=item *\n\nIf I<$check> is true, it SHOULD modify I<$string> in place to remove\nthe converted part (i.e.  the whole string unless there is an error).\nIf perlio_ok() is true, SHOULD becomes MUST.\n\n=item *\n\nIf an error occurs, it SHOULD return the octet sequence for the\nfragment of string that has been converted and modify $string in-place\nto remove the converted part leaving it starting with the problem\nfragment.  If perlio_ok() is true, SHOULD becomes MUST.\n\n=item *\n\nIf I<$check> is is false then C<encode> MUST  make a \"best effort\" to\nconvert the string - for example, by using a replacement character.\n\n=back\n\n=item -E<gt>decode($octets [,$check])\n\nMUST return the string that I<$octets> represents. \n\n=over 2\n\n=item *\n\nIf I<$check> is true, it SHOULD modify I<$octets> in place to remove\nthe converted part (i.e.  the whole sequence unless there is an\nerror).  If perlio_ok() is true, SHOULD becomes MUST.\n\n=item *\n\nIf an error occurs, it SHOULD return the fragment of string that has\nbeen converted and modify $octets in-place to remove the converted\npart leaving it starting with the problem fragment.  If perlio_ok() is\ntrue, SHOULD becomes MUST.\n\n=item *\n\nIf I<$check> is false then C<decode> should make a \"best effort\" to\nconvert the string - for example by using Unicode's \"\\x{FFFD}\" as a\nreplacement character.\n\n=back\n\n=back\n\nIf you want your encoding to work with L<encoding> pragma, you should\nalso implement the method below.\n\n=over 4\n\n=item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])\n\nMUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.\nDecoding will terminate when $terminator (a string) appears in output.\nI<$offset> will be modified to the last $octets position at end of decode.\nReturns true if $terminator appears output, else returns false.\n\n=back\n\n=head2 Other methods defined in Encode::Encodings\n\nYou do not have to override methods shown below unless you have to.\n\n=over 4\n\n=item -E<gt>name\n\nPredefined As:\n\n  sub name  { return shift->{'Name'} }\n\nMUST return the string representing the canonical name of the encoding.\n\n=item -E<gt>mime_name\n\nPredefined As:\n\n  sub mime_name{\n    require Encode::MIME::Name;\n    return Encode::MIME::Name::get_mime_name(shift->name);\n  }\n\nMUST return the string representing the IANA charset name of the encoding.\n\n=item -E<gt>renew\n\nPredefined As:\n\n  sub renew {\n    my $self = shift;\n    my $clone = bless { %$self } => ref($self);\n    $clone->{renewed}++;\n    return $clone;\n  }\n\nThis method reconstructs the encoding object if necessary.  If you need\nto store the state during encoding, this is where you clone your object.\n\nPerlIO ALWAYS calls this method to make sure it has its own private\nencoding object.\n\n=item -E<gt>renewed\n\nPredefined As:\n\n  sub renewed { $_[0]->{renewed} || 0 }\n\nTells whether the object is renewed (and how many times).  Some\nmodules emit C<Use of uninitialized value in null operation> warning\nunless the value is numeric so return 0 for false.\n\n=item -E<gt>perlio_ok()\n\nPredefined As:\n\n  sub perlio_ok { \n      eval{ require PerlIO::encoding };\n      return $@ ? 0 : 1;\n  }\n\nIf your encoding does not support PerlIO for some reasons, just;\n\n sub perlio_ok { 0 }\n\n=item -E<gt>needs_lines()\n\nPredefined As:\n\n  sub needs_lines { 0 };\n\nIf your encoding can work with PerlIO but needs line buffering, you\nMUST define this method so it returns true.  7bit ISO-2022 encodings\nare one example that needs this.  When this method is missing, false\nis assumed.\n\n=back\n\n=head2 Example: Encode::ROT13\n\n  package Encode::ROT13;\n  use strict;\n  use base qw(Encode::Encoding);\n\n  __PACKAGE__->Define('rot13');\n\n  sub encode($$;$){\n      my ($obj, $str, $chk) = @_;\n      $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;\n      $_[1] = '' if $chk; # this is what in-place edit means\n      return $str;\n  }\n\n  # Jr pna or ynml yvxr guvf;\n  *decode = \\&encode;\n\n  1;\n\n=head1 Why the heck Encode API is different?\n\nIt should be noted that the I<$check> behaviour is different from the\nouter public API. The logic is that the \"unchecked\" case is useful\nwhen the encoding is part of a stream which may be reporting errors\n(e.g. STDERR).  In such cases, it is desirable to get everything\nthrough somehow without causing additional errors which obscure the\noriginal one. Also, the encoding is best placed to know what the\ncorrect replacement character is, so if that is the desired behaviour\nthen letting low level code do it is the most efficient.\n\nBy contrast, if I<$check> is true, the scheme above allows the\nencoding to do as much as it can and tell the layer above how much\nthat was. What is lacking at present is a mechanism to report what\nwent wrong. The most likely interface will be an additional method\ncall to the object, or perhaps (to avoid forcing per-stream objects\non otherwise stateless encodings) an additional parameter.\n\nIt is also highly desirable that encoding classes inherit from\nC<Encode::Encoding> as a base class. This allows that class to define\nadditional behaviour for all encoding objects.\n\n  package Encode::MyEncoding;\n  use base qw(Encode::Encoding);\n\n  __PACKAGE__->Define(qw(myCanonical myAlias));\n\nto create an object with C<< bless {Name => ...}, $class >>, and call\ndefine_encoding.  They inherit their C<name> method from\nC<Encode::Encoding>.\n\n=head2 Compiled Encodings\n\nFor the sake of speed and efficiency, most of the encodings are now\nsupported via a I<compiled form>: XS modules generated from UCM\nfiles.   Encode provides the enc2xs tool to achieve that.  Please see\nL<enc2xs> for more details.\n\n=head1 SEE ALSO\n\nL<perlmod>, L<enc2xs>\n\n=begin future\n\n=over 4\n\n=item Scheme 1\n\nThe fixup routine gets passed the remaining fragment of string being\nprocessed.  It modifies it in place to remove bytes/characters it can\nunderstand and returns a string used to represent them.  For example:\n\n sub fixup {\n   my $ch = substr($_[0],0,1,'');\n   return sprintf(\"\\", 8192) = 8192
09:01:57.140037 brk(0xea6000)           = 0xea6000
09:01:57.140156 lseek(9, 1496, SEEK_SET) = 1496
09:01:57.140204 lseek(9, 0, SEEK_CUR)   = 1496
09:01:57.140251 close(9)                = 0
09:01:57.140393 stat("modules/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140446 stat("modules/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.140497 stat("modules/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140548 stat("modules/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.140598 stat("/etc/perl/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140649 stat("/etc/perl/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.140700 stat("/usr/local/lib/perl/5.14.2/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140751 stat("/usr/local/lib/perl/5.14.2/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.140803 stat("/usr/local/share/perl/5.14.2/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140856 stat("/usr/local/share/perl/5.14.2/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.140907 stat("/usr/lib/perl5/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.140958 stat("/usr/lib/perl5/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.141008 stat("/usr/share/perl5/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.141061 stat("/usr/share/perl5/Encode/Guess.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.141112 stat("/usr/lib/perl/5.14/Encode/Guess.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.141170 stat("/usr/lib/perl/5.14/Encode/Guess.pm", {st_mode=S_IFREG|0644, st_size=10060, ...}) = 0
09:01:57.141231 open("/usr/lib/perl/5.14/Encode/Guess.pm", O_RDONLY) = 9
09:01:57.141286 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.141333 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.141395 read(9, "package Encode::Guess;\nuse strict;\nuse warnings;\nuse Encode qw(:fallbacks find_encoding);\nour $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\\d+/g ); sprintf \"%d.\" . \"%02d\" x $#r, @r };\n\nmy $Canon = 'Guess';\nsub DEBUG () { 0 }\nour %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);\n$Encode::Encoding{$Canon} = bless {\n    Name     => $Canon,\n    Suspects => {%DEF_SUSPECTS},\n} => __PACKAGE__;\n\nuse base qw(Encode::Encoding);\nsub needs_lines { 1 }\nsub perlio_ok   { 0 }\n\nour @EXPORT         = qw(guess_encoding);\nour $NoUTFAutoGuess = 0;\nour $UTF8_BOM       = pack( \"C3\", 0xef, 0xbb, 0xbf );\n\nsub import {    # Exporter not used so we do it on our own\n    my $callpkg = caller;\n    for my $item (@EXPORT) {\n        no strict 'refs';\n        *{\"$callpkg\\::$item\"} = \\&{\"$item\"};\n    }\n    set_suspects(@_);\n}\n\nsub set_suspects {\n    my $class = shift;\n    my $self = ref($class) ? $class : $Encode::Encoding{$Canon};\n    $self->{Suspects} = {%DEF_SUSPECTS};\n    $self->add_suspects(@_);\n}\n\nsub add_suspects {\n    my $class = shift;\n    my $self = ref($class) ? $class : $Encode::Encoding{$Canon};\n    for my $c (@_) {\n        my $e = find_encoding($c) or die \"Unknown encoding: $c\";\n        $self->{Suspects}{ $e->name } = $e;\n        DEBUG and warn \"Added: \", $e->name;\n    }\n}\n\nsub decode($$;$) {\n    my ( $obj, $octet, $chk ) = @_;\n    my $guessed = guess( $obj, $octet );\n    unless ( ref($guessed) ) {\n        require Carp;\n        Carp::croak($guessed);\n    }\n    my $utf8 = $guessed->decode( $octet, $chk || 0 );\n    $_[1] = $octet if $chk;\n    return $utf8;\n}\n\nsub guess_encoding {\n    guess( $Encode::Encoding{$Canon}, @_ );\n}\n\nsub guess {\n    my $class = shift;\n    my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};\n    my $octet = shift;\n\n    # sanity check\n    return \"Empty string, empty guess\" unless defined $octet and length $octet;\n\n    # cheat 0: utf8 flag;\n    if ( Encode::is_utf8($octet) ) {\n        return find_encoding('utf8') unless $NoUTFAutoGuess;\n        Encode::_utf8_off($octet);\n    }\n\n    # cheat 1: BOM\n    use Encode::Unicode;\n    unless ($NoUTFAutoGuess) {\n        my $BOM = pack( 'C3', unpack( \"C3\", $octet ) );\n        return find_encoding('utf8')\n          if ( defined $BOM and $BOM eq $UTF8_BOM );\n        $BOM = unpack( 'N', $octet );\n        return find_encoding('UTF-32')\n          if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );\n        $BOM = unpack( 'n', $octet );\n        return find_encoding('UTF-16')\n          if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );\n        if ( $octet =~ /\\x00/o )\n        {    # if \\x00 found, we assume UTF-(16|32)(BE|LE)\n            my $utf;\n            my ( $be, $le ) = ( 0, 0 );\n            if ( $octet =~ /\\x00\\x00/o ) {    # UTF-32(BE|LE) assumed\n                $utf = \"UTF-32\";\n                for my $char ( unpack( 'N*', $octet ) ) {\n                    $char & 0x0000ffff and $be++;\n                    $char & 0xffff0000 and $le++;\n                }\n            }\n            else {                            # UTF-16(BE|LE) assumed\n                $utf = \"UTF-16\";\n                for my $char ( unpack( 'n*', $octet ) ) {\n                    $char & 0x00ff and $be++;\n                    $char & 0xff00 and $le++;\n                }\n            }\n            DEBUG and warn \"$utf, be == $be, le == $le\";\n            $be == $le\n              and return\n              \"Encodings ambiguous between $utf BE and LE ($be, $le)\";\n            $utf .= ( $be > $le ) ? 'BE' : 'LE';\n            return find_encoding($utf);\n        }\n    }\n    my %try = %{ $obj->{Suspects} };\n    for my $c (@_) {\n        my $e = find_encoding($c) or die \"Unknown encoding: $c\";\n        $try{ $e->name } = $e;\n        DEBUG and warn \"Added: \", $e->name;\n    }\n    my $nline = 1;\n    for my $line ( split /\\r\\n?|\\n/, $octet ) {\n\n        # cheat 2 -- \\e in the string\n        if ( $line =~ /\\e/o ) {\n            my @keys = keys %try;\n            delete @try{qw/utf8 ascii/};\n            for my $k (@keys) {\n                ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};\n            }\n        }\n        my %ok = %try;\n\n        # warn join(\",\", keys %try);\n        for my $k ( keys %try ) {\n            my $scratch = $line;\n            $try{$k}->decode( $scratch, FB_QUIET );\n            if ( $scratch eq '' ) {\n                DEBUG and warn sprintf( \"%4d:%-24s ok\\n\", $nline, $k );\n            }\n            else {\n                use bytes ();\n                DEBUG\n                  and warn sprintf( \"%4d:%-24s not ok; %d bytes left\\n\",\n                    $nline, $k, bytes::length($scratch) );\n                delete $ok{$k};\n            }\n        }\n        %ok or return \"No appropriate encodings found!\";\n        if ( scalar( keys(%ok) ) == 1 ) {\n            my ($retval) = values(%ok);\n            return $retval;\n        }\n        %try = %ok;\n        $nline++;\n    }\n    $try{ascii}\n      or return \"Encodings too ambiguous: \", join( \" or \", keys %try );\n    return $try{ascii};\n}\n\n1;\n__END__\n\n=head1 NAME\n\nEncode::Guess -- Guesses encoding from data\n\n=head1 SYNOPSIS\n\n  # if you are sure $data won't contain anything bogus\n\n  use Encode;\n  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;\n  my $utf8 = decode(\"Guess\", $data);\n  my $data = encode(\"Guess\", $utf8);   # this doesn't work!\n\n  # more elaborate way\n  use Encode::Guess;\n  my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);\n  ref($enc) or die \"Can't guess: $enc\"; # trap error this way\n  $utf8 = $enc->decode($data);\n  # or\n  $utf8 = decode($enc->name, $data)\n\n=head1 ABSTRACT\n\nEncode::Guess enables you to guess in what encoding a given data is\nencoded, or at least tries to.  \n\n=head1 DESCRIPTION\n\nBy default, it checks only ascii, utf8 and UTF-16/32 with BOM.\n\n  use Encode::Guess; # ascii/utf8/BOMed UTF\n\nTo use it more practically, you have to give the names of encodings to\ncheck (I<suspects> as follows).  The name of suspects can either be\ncanonical names or aliases.\n\nCAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.\n\n # tries all major Japanese Encodings as well\n  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;\n\nIf the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true\nvalue, no heuristics will be applied to UTF8/16/32, and the result\nwill be limited to the suspects and C<ascii>.\n\n=over 4\n\n=item Encode::Guess->set_suspects\n\nYou can also change the internal suspects list via C<set_suspects>\nmethod. \n\n  use Encode::Guess;\n  Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);\n\n=item Encode::Guess->add_suspects\n\nOr you can use C<add_suspects> method.  The difference is that\nC<set_suspects> flushes the current suspects list while\nC<add_suspects> adds.\n\n  use Encode::Guess;\n  Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);\n  # now the suspects are euc-jp,shiftjis,7bit-jis, AND\n  # euc-kr,euc-cn, and big5-eten\n  Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);\n\n=item Encode::decode(\"Guess\" ...)\n\nWhen you are content with suspects list, you can now\n\n  my $utf8 = Encode::decode(\"Guess\", $data);\n\n=item Encode::Guess->guess($data)\n\nBut it will croak if:\n\n=over\n\n=item *\n\nTwo or more suspects remain\n\n=item *\n\nNo suspects left\n\n=back\n\nSo you should instead try this;\n\n  my $decoder = Encode::Guess->guess($data);\n\nOn success, $decoder is an object that is documented in\nL<Encode::Encoding>.  So you can now do this;\n\n  my $utf8 = $decoder->decode($data);\n\nOn failure, $decoder now contains an error message so the whole thing\nwould be as follows;\n\n  my $decoder = Encode::Guess->guess($data);\n  die $decoder unless ref($decoder);\n  my $utf8 = $decoder->decode($data);\n\n=item guess_encoding($data, [, I<list of suspects>])\n\nYou can also try C<guess_encoding> function which is exported by\ndefault.  It takes $data to check and it also takes the list of\nsuspects by option.  The optional suspect list is I<not reflected> to\nthe internal suspects list.\n\n  my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);\n  die $decoder unless ref($decoder);\n  my $utf8 = $decoder->decode($data);\n  # check only ascii, utf8 and UTF-(16|32) with BOM\n  my $decoder = guess_encoding($data);\n\n=back\n\n=head1 CAVEATS\n\n=over ", 8192) = 8192
09:01:57.142298 stat("modules/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142354 stat("modules/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142405 stat("modules/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142454 stat("modules/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142504 stat("/etc/perl/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142553 stat("/etc/perl/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142603 stat("/usr/local/lib/perl/5.14.2/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142654 stat("/usr/local/lib/perl/5.14.2/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142704 stat("/usr/local/share/perl/5.14.2/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142762 stat("/usr/local/share/perl/5.14.2/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142813 stat("/usr/lib/perl5/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142863 stat("/usr/lib/perl5/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.142912 stat("/usr/share/perl5/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.142962 stat("/usr/share/perl5/Encode/Unicode.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.143014 stat("/usr/lib/perl/5.14/Encode/Unicode.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.143066 stat("/usr/lib/perl/5.14/Encode/Unicode.pm", {st_mode=S_IFREG|0644, st_size=8955, ...}) = 0
09:01:57.143125 open("/usr/lib/perl/5.14/Encode/Unicode.pm", O_RDONLY) = 10
09:01:57.143179 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.143225 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.143285 read(10, "package Encode::Unicode;\n\nuse strict;\nuse warnings;\nno warnings 'redefine';\n\nour $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\\d+/g ); sprintf \"%d.\" . \"%02d\" x $#r, @r };\n\nuse XSLoader;\nXSLoader::load( __PACKAGE__, $VERSION );\n\n#\n# Object Generator 8 transcoders all at once!\n#\n\nrequire Encode;\n\nour %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);\n\nfor my $name (\n    qw(UTF-16 UTF-16BE UTF-16LE\n    UTF-32 UTF-32BE UTF-32LE\n    UCS-2BE  UCS-2LE)\n  )\n{\n    my ( $size, $endian, $ucs2, $mask );\n    $name =~ /^(\\w+)-(\\d+)(\\w*)$/o;\n    if ( $ucs2 = ( $1 eq 'UCS' ) ) {\n        $size = 2;\n    }\n    else {\n        $size = $2 / 8;\n    }\n    $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';\n    $size == 4 and $endian = uc($endian);\n\n    $Encode::Encoding{$name} = bless {\n        Name   => $name,\n        size   => $size,\n        endian => $endian,\n        ucs2   => $ucs2,\n    } => __PACKAGE__;\n}\n\nuse base qw(Encode::Encoding);\n\nsub renew {\n    my $self = shift;\n    $BOM_Unknown{ $self->name } or return $self;\n    my $clone = bless {%$self} => ref($self);\n    $clone->{renewed}++;    # so the caller knows it is renewed.\n    return $clone;\n}\n\n# There used to be a perl implemntation of (en|de)code but with\n# XS version is ripe, perl version is zapped for optimal speed\n\n*decode = \\&decode_xs;\n*encode = \\&encode_xs;\n\n1;\n__END__\n\n=head1 NAME\n\nEncode::Unicode -- Various Unicode Transformation Formats\n\n=cut\n\n=head1 SYNOPSIS\n\n    use Encode qw/encode decode/;\n    $ucs2 = encode(\"UCS-2BE\", $utf8);\n    $utf8 = decode(\"UCS-2BE\", $ucs2);\n\n=head1 ABSTRACT\n\nThis module implements all Character Encoding Schemes of Unicode that\nare officially documented by Unicode Consortium (except, of course,\nfor UTF-8, which is a native format in perl).\n\n=over 4\n\n=item L<http://www.unicode.org/glossary/> says:\n\nI<Character Encoding Scheme> A character encoding form plus byte\nserialization. There are Seven character encoding schemes in Unicode:\nUTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and\nUTF-32LE (UCS-4LE), and UTF-7.\n\nSince UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of\nUnicode's Character Encoding Scheme.  It is separately implemented in\nEncode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.\n\n=item Quick Reference\n\n                Decodes from ord(N)           Encodes chr(N) to...\n       octet/char BOM S.P d800-dfff  ord > 0xffff     \\x{1abcd} ==\n  ---------------+-----------------+------------------------------\n  UCS-2BE       2   N   N  is bogus                  Not Available\n  UCS-2LE       2   N   N     bogus                  Not Available\n  UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE\n  UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd\n  UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf\n  UTF-32        4   Y   -  is bogus         As is            BE/LE\n  UTF-32BE      4   N   -     bogus         As is       0x0001abcd\n  UTF-32LE      4   N   -     bogus         As is       0xcdab0100\n  UTF-8       1-4   -   -     bogus   >= 4 octets   \\xf0\\x9a\\af\\8d\n  ---------------+-----------------+------------------------------\n\n=back\n\n=head1 Size, Endianness, and BOM\n\nYou can categorize these CES by 3 criteria:  size of each character,\nendianness, and Byte Order Mark.\n\n=head2 by size\n\nUCS-2 is a fixed-length encoding with each character taking 16 bits.\nIt B<does not> support I<surrogate pairs>.  When a surrogate pair\nis encountered during decode(), its place is filled with \\x{FFFD}\nif I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a\ncharacter whose ord value is larger than 0xFFFF is encountered,\nits place is filled with \\x{FFFD} if I<CHECK> is 0, or the routine\ncroaks if I<CHECK> is 1.\n\nUTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.\nWhen it encounters a high surrogate (0xD800-0xDBFF), it fetches the\nfollowing low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to\nform a character.  Bogus surrogates result in death.  When \\x{10000}\nor above is encountered during encode(), it C<ensurrogate>s them and\npushes the surrogate pair to the output stream.\n\nUTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.\nSince it is 32-bit, there is no need for I<surrogate pairs>.\n\n=head2 by endianness\n\nThe first (and now failed) goal of Unicode was to map all character\nrepertoires into a fixed-length integer so that programmers are happy.\nSince each character is either a I<short> or I<long> in C, you have to\npay attention to the endianness of each platform when you pass data\nto one another.\n\nAnything marked as BE is Big Endian (or network byte order) and LE is\nLittle Endian (aka VAX byte order).  For anything not marked either\nBE or LE, a character called Byte Order Mark (BOM) indicating the\nendianness is prepended to the string.\n\nCAVEAT: Though BOM in utf8 (\\xEF\\xBB\\xBF) is valid, it is meaningless\nand as of this writing Encode suite just leave it as is (\\x{FeFF}).\n\n=over 4\n\n=item BOM as integer when fetched in network byte order\n\n              16         32 bits/char\n  -------------------------\n  BE      0xFeFF 0x0000FeFF\n  LE      0xFFFe 0xFFFe0000\n  -------------------------\n\n=back\n\nThis modules handles the BOM as follows.\n\n=over 4\n\n=item *\n\nWhen BE or LE is explicitly stated as the name of encoding, BOM is\nsimply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).\n\n=item *\n\nWhen BE or LE is omitted during decode(), it checks if BOM is at the\nbeginning of the string; if one is found, the endianness is set to\nwhat the BOM says.  If no BOM is found, the routine dies.\n\n=item *\n\nWhen BE or LE is omitted during encode(), it returns a BE-encoded\nstring with BOM prepended.  So when you want to encode a whole text\nfile, make sure you encode() the whole text at once, not line by line\nor each line, not file, will have a BOM prepended.\n\n=item *\n\nC<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.\nUCS-2 is already registered by IANA and others that way.\n\n=back\n\n=head1 Surrogate Pairs\n\nTo say the least, surrogate pairs were the biggest mistake of the\nUnicode Consortium.  But according to the late Douglas Adams in I<The\nHitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the\nUniverse was created. This has made a lot of people very angry and\nbeen widely regarded as a bad move>.  Their mistake was not of this\nmagnitude so let's forgive them.\n\n(I don't dare make any comparison with Unicode Consortium and the\nVogons here ;)  Or, comparing Encode to Babel Fish is completely\nappropriate -- if you can only stick this into your ear :)\n\nSurrogate pairs were born when the Unicode Consortium finally\nadmitted that 16 bits were not big enough to hold all the world's\ncharacter repertoires.  But they already made UCS-2 16-bit.  What\ndo we do?\n\nBack then, the range 0xD800-0xDFFF was not allocated.  Let's split\nthat range in half and use the first half to represent the C<upper\nhalf of a character> and the second half to represent the C<lower\nhalf of a character>.  That way, you can represent 1024 * 1024 =\n1048576 more characters.  Now we can store character ranges up to\n\\x{10ffff} even with 16-bit encodings.  This pair of half-character is\nnow called a I<surrogate pair> and UTF-16 is the name of the encoding\nthat embraces them.\n\nHere is a formula to ensurrogate a Unicode character \\x{10000} and\nabove;\n\n  $hi = ($uni - 0x10000) / 0x400 + 0xD800;\n  $lo = ($uni - 0x10000) % 0x400 + 0xDC00;\n\nAnd to desurrogate;\n\n $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);\n\nNote this move has made \\x{D800}-\\x{DFFF} into a forbidden zone but\nperl does not prohibit the use of characters within this range.  To perl,\nevery one of \\x{0000_0000} up to \\x{ffff_ffff} (*) is I<a character>.\n\n  (*) or \\x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit\n  integer support!\n\n=head1 Error Checking\n\nUnlike most encodings which accept various ways to handle errors,\nUnicode encodings simply croaks.\n\n  % perl -MEncode -e'$_ = \"\\xfe\\xff\\xd8\\xd9\\xda\\xdb\\0\\n\"' \\\n         -e'Encode::from_to($_, \"utf16\",\"shift_jis\", 0); print'\n  UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.\n  % perl -MEncode -e'$a = \"BOM missin", 8192) = 8192
09:01:57.143951 lseek(10, 1345, SEEK_SET) = 1345
09:01:57.143999 lseek(10, 0, SEEK_CUR)  = 1345
09:01:57.144044 close(10)               = 0
09:01:57.144133 stat("/usr/lib/perl/5.14/auto/Encode/Unicode/Unicode.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.144192 stat("/usr/lib/perl/5.14/auto/Encode/Unicode/Unicode.so", {st_mode=S_IFREG|0644, st_size=18584, ...}) = 0
09:01:57.144252 stat("/usr/lib/perl/5.14/auto/Encode/Unicode/Unicode.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.144314 open("/usr/lib/perl/5.14/auto/Encode/Unicode/Unicode.so", O_RDONLY) = 10
09:01:57.144368 read(10, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360\17\0\0\0\0\0\0@\0\0\0\0\0\0\0\330A\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\224=\0\0\0\0\0\0\224=\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\300=\0\0\0\0\0\0\300= \0\0\0\0\0\300= \0\0\0\0\0 \3\0\0\0\0\0\0(\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\330=\0\0\0\0\0\0\330= \0\0\0\0\0\330= \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\330;\0\0\0\0\0\0\330;\0\0\0\0\0\0\330;\0\0\0\0\0\0<\0\0\0\0\0\0\0<\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\300=\0\0\0\0\0\0\300= \0\0\0\0\0\300= \0\0\0\0\0@\2\0\0\0\0\0\0@\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0?\370(\246fk\202\262\20K?F%qh\253?^\331\257\0\0\0\0%\0\0\0*\0\0\0\0\0\0\0\32\0\0\0\v\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\34\0\0\0\33\0\0\0\f\0\0\0\22\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\36\0\0\0\26\0\0\0\5\0\0\0\"\0\0\0(\0\0\0\21\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0\30\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\25\0\0\0#\0\0\0\31\0\0\0\0\0\0\0'\0\0\0\27\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\24\0\0\0\23\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0&\0\0\0\r\0\0\0\0\0\0\0\17\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\t\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0!\0\0\0", 832) = 832
09:01:57.144502 fstat(10, {st_mode=S_IFREG|0644, st_size=18584, ...}) = 0
09:01:57.144558 mmap(NULL, 2113768, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0x7f74344e8000
09:01:57.144608 mprotect(0x7f74344ec000, 2093056, PROT_NONE) = 0
09:01:57.144657 mmap(0x7f74346eb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x3000) = 0x7f74346eb000
09:01:57.144720 close(10)               = 0
09:01:57.144777 mprotect(0x7f74346eb000, 4096, PROT_READ) = 0
09:01:57.145244 lseek(9, 5025, SEEK_SET) = 5025
09:01:57.145291 lseek(9, 0, SEEK_CUR)   = 5025
09:01:57.145335 close(9)                = 0
09:01:57.145794 read(8, "# RFC1459\n   '407' => 'ERR_TOOMANYTARGETS',    # RFC1459\n   '408' => 'ERR_NOSUCHSERVICE',     # RFC2812\n   '409' => 'ERR_NOORIGIN',          # RFC1459\n   '411' => 'ERR_NORECIPIENT',       # RFC1459\n   '412' => 'ERR_NOTEXTTOSEND',      # RFC1459\n   '413' => 'ERR_NOTOPLEVEL',        # RFC1459\n   '414' => 'ERR_WILDTOPLEVEL',      # RFC1459\n   '415' => 'ERR_BADMASK',           # RFC2812\n   '421' => 'ERR_UNKNOWNCOMMAND',    # RFC1459\n   '422' => 'ERR_NOMOTD',            # RFC1459\n   '423' => 'ERR_NOADMININFO',       # RFC1459\n   '424' => 'ERR_FILEERROR',         # RFC1459\n   '425' => 'ERR_NOOPERMOTD',        # Unreal\n   '429' => 'ERR_TOOMANYAWAY',       # Bahamut\n   '430' => 'ERR_EVENTNICKCHANGE',   # AustHex\n   '431' => 'ERR_NONICKNAMEGIVEN',   # RFC1459\n   '432' => 'ERR_ERRONEUSNICKNAME',  # RFC1459\n   '433' => 'ERR_NICKNAMEINUSE',     # RFC1459\n   '436' => 'ERR_NICKCOLLISION',     # RFC1459\n   '439' => 'ERR_TARGETTOOFAST',     # ircu\n   '440' => 'ERR_SERCVICESDOWN',     # Bahamut, Unreal\n   '441' => 'ERR_USERNOTINCHANNEL',  # RFC1459\n   '442' => 'ERR_NOTONCHANNEL',      # RFC1459\n   '443' => 'ERR_USERONCHANNEL',     # RFC1459\n   '444' => 'ERR_NOLOGIN',           # RFC1459\n   '445' => 'ERR_SUMMONDISABLED',    # RFC1459\n   '446' => 'ERR_USERSDISABLED',     # RFC1459\n   '447' => 'ERR_NONICKCHANGE',      # Unreal\n   '449' => 'ERR_NOTIMPLEMENTED',    # Undernet\n   '451' => 'ERR_NOTREGISTERED',     # RFC1459\n   '455' => 'ERR_HOSTILENAME',       # Unreal\n   '459' => 'ERR_NOHIDING',          # Unreal\n   '460' => 'ERR_NOTFORHALFOPS',     # Unreal\n   '461' => 'ERR_NEEDMOREPARAMS',    # RFC1459\n   '462' => 'ERR_ALREADYREGISTRED',  # RFC1459\n   '463' => 'ERR_NOPERMFORHOST',     # RFC1459\n   '464' => 'ERR_PASSWDMISMATCH',    # RFC1459\n   '465' => 'ERR_YOUREBANNEDCREEP',  # RFC1459\n   '466' => 'ERR_YOUWILLBEBANNED',   # RFC1459\n   '467' => 'ERR_KEYSET',            # RFC1459\n   '469' => 'ERR_LINKSET',           # Unreal\n   '471' => 'ERR_CHANNELISFULL',     # RFC1459\n   '472' => 'ERR_UNKNOWNMODE',       # RFC1459\n   '473' => 'ERR_INVITEONLYCHAN',    # RFC1459\n   '474' => 'ERR_BANNEDFROMCHAN',    # RFC1459\n   '475' => 'ERR_BADCHANNELKEY',     # RFC1459\n   '476' => 'ERR_BADCHANMASK',       # RFC2812\n   '477' => 'ERR_NOCHANMODES',       # RFC2812\n   '478' => 'ERR_BANLISTFULL',       # RFC2812\n   '481' => 'ERR_NOPRIVILEGES',      # RFC1459\n   '482' => 'ERR_CHANOPRIVSNEEDED',  # RFC1459\n   '483' => 'ERR_CANTKILLSERVER',    # RFC1459\n   '484' => 'ERR_RESTRICTED',        # RFC2812\n   '485' => 'ERR_UNIQOPPRIVSNEEDED', # RFC2812\n   '488' => 'ERR_TSLESSCHAN',        # IRCnet\n   '491' => 'ERR_NOOPERHOST',        # RFC1459\n   '492' => 'ERR_NOSERVICEHOST',     # RFC1459\n   '493' => 'ERR_NOFEATURE',         # ircu\n   '494' => 'ERR_BADFEATURE',        # ircu\n   '495' => 'ERR_BADLOGTYPE',        # ircu\n   '496' => 'ERR_BADLOGSYS',         # ircu\n   '497' => 'ERR_BADLOGVALUE',       # ircu\n   '498' => 'ERR_ISOPERLCHAN',       # ircu\n   '501' => 'ERR_UMODEUNKNOWNFLAG',  # RFC1459\n   '502' => 'ERR_USERSDONTMATCH',    # RFC1459\n   '503' => 'ERR_GHOSTEDCLIENT',     # Hybrid\n);\n\nour %NAME2NUMERIC;\nwhile (my ($key, $val) = each %NUMERIC2NAME) {\n    $NAME2NUMERIC{$val} = $key;\n}\n\nsub numeric_to_name {\n   my ($code) = @_;\n   return $NUMERIC2NAME{$code};\n}\n\nsub name_to_numeric {\n   my ($name) = @_;\n   return $NAME2NUMERIC{$name};\n}\n\nsub uc_irc {\n    my ($value, $type) = @_;\n    return if !defined $value;\n    $type = 'rfc1459' if !defined $type;\n    $type = lc $type;\n\n    if ($type eq 'ascii') {\n        $value =~ tr/a-z/A-Z/;\n    }\n    elsif ($type eq 'strict-rfc1459') {\n        $value =~ tr/a-z{}|/A-Z[]\\\\/;\n    }\n    else {\n        $value =~ tr/a-z{}|^/A-Z[]\\\\~/;\n    }\n\n    return $value;\n}\n\nsub lc_irc {\n    my ($value, $type) = @_;\n    return if !defined $value;\n    $type = 'rfc1459' if !defined $type;\n    $type = lc $type;\n\n    if ($type eq 'ascii') {\n        $value =~ tr/A-Z/a-z/;\n    }\n    elsif ($type eq 'strict-rfc1459') {\n        $value =~ tr/A-Z[]\\\\/a-z{}|/;\n    }\n    else {\n        $value =~ tr/A-Z[]\\\\~/a-z{}|^/;\n    }\n\n    return $value;\n}\n\nsub eq_irc {\n    my ($first, $second, $type) = @_;\n    return if !defined $first || !defined $second;\n    return 1 if lc_irc($first, $type) eq lc_irc($second, $type);\n    return;\n}\n\nsub parse_mode_line {\n    my @args = @_;\n\n    my $chanmodes = [qw(beI k l imnpstaqr)];\n    my $statmodes = 'ohv';\n    my $hashref = { };\n    my $count = 0;\n\n    while (my $arg = shift @args) {\n        if ( ref $arg eq 'ARRAY' ) {\n           $chanmodes = $arg;\n           next;\n        }\n        elsif (ref $arg eq 'HASH') {\n           $statmodes = join '', keys %{ $arg };\n           next;\n        }\n        elsif ($arg =~ /^[-+]/ or $count == 0) {\n            my $action = '+';\n            for my $char (split //, $arg) {\n                if ($char eq '+' or $char eq '-') {\n                   $action = $char;\n                }\n                else {\n                   push @{ $hashref->{modes} }, $action . $char;\n                }\n\n                if (length $chanmodes->[0] && length $chanmodes->[1] && length $statmodes\n                    && $char =~ /[$statmodes$chanmodes->[0]$chanmodes->[1]]/) {\n                    push @{ $hashref->{args} }, shift @args;\n                }\n\n                if (length $chanmodes->[2] && $action eq '+' && $char =~ /[$chanmodes->[2]]/) {\n                    push @{ $hashref->{args} }, shift @args;\n                }\n            }\n        }\n        else {\n            push @{ $hashref->{args} }, $arg;\n        }\n        $count++;\n    }\n\n    return $hashref;\n}\n\nsub normalize_mask {\n    my ($arg) = @_;\n    return if !defined $arg;\n\n    $arg =~ s/\\*{2,}/*/g;\n    my @mask;\n    my $remainder;\n    if ($arg !~ /!/ and $arg =~ /@/) {\n        $remainder = $arg;\n        $mask[0] = '*';\n    }\n    else {\n        ($mask[0], $remainder) = split /!/, $arg, 2;\n    }\n\n    $remainder =~ s/!//g if defined $remainder;\n    @mask[1..2] = split(/@/, $remainder, 2) if defined $remainder;\n    $mask[2] =~ s/@//g if defined $mask[2];\n\n    for my $i (1..2) {\n        $mask[$i] = '*' if !defined $mask[$i];\n    }\n    return $mask[0] . '!' . $mask[1] . '@' . $mask[2];\n}\n\nsub unparse_mode_line {\n    my ($line) = @_;\n    return if !defined $line || !length $line;\n\n    my $action; my $return;\n    for my $mode ( split(//,$line) ) {\n       if ($mode =~ /^(\\+|-)$/ && (!$action || $mode ne $action)) {\n         $return .= $mode;\n         $action = $mode;\n         next;\n       }\n       $return .= $mode if ($mode ne '+' and $mode ne '-');\n    }\n    $return =~ s/[+-]$//;\n    return $return;\n}\n\nsub gen_mode_change {\n    my ($before, $after) = @_;\n    $before = '' if !defined $before;\n    $after = '' if !defined $after;\n\n    my @before = split //, $before;\n    my @after  = split //, $after;\n    my $string = '';\n    my @hunks = _diff(\\@before, \\@after);\n    $string .= $_->[0] . $_->[1] for @hunks;\n\n    return unparse_mode_line($string);\n}\n\nsub is_valid_nick_name {\n    my ($nickname) = @_;\n    return if !defined $nickname || !length $nickname;\n    return 1 if $nickname =~ /^[A-Za-z_`\\-^\\|\\\\\\{}\\[\\]][A-Za-z_0-9`\\-^\\|\\\\\\{}\\[\\]]*$/;\n    return;\n}\n\nsub is_valid_chan_name {\n    my $channel = shift;\n    my $chantypes = shift || ['#', '&'];\n    return if !@$chantypes;\n    my $chanprefix = join '', @$chantypes;\n    return if !defined $channel || !length $channel;\n\n    return if bytes::length($channel) > 200;\n    return 1 if $channel =~ /^[$chanprefix][^ \\a\\0\\012\\015,:]+$/;\n    return;\n}\n\nsub matches_mask_array {\n    my ($masks, $matches, $mapping) = @_;\n\n    return if !defined $masks || !defined $matches;\n    return if ref $masks ne 'ARRAY';\n    return if ref $matches ne 'ARRAY';\n    my $ref = { };\n\n    for my $mask (@$masks) {\n        for my $match (@$matches) {\n            if (matches_mask($mask, $match, $mapping)) {\n                push @{ $ref->{ $mask } }, $match;\n            }\n        }\n    }\n\n    return $ref;\n}\n\nsub matches_mask {\n    my ($mask, $match, $mapping) = @_;\n    return if !defined $mask || !length $mask;\n    return if !defined $match || !length $match;\n\n    my $umask = quotemeta uc_irc($mask, $mapping);\n    $umask =~ s/\\\\\\*/[\\x01-\\xFF]{0,}/g;\n    $umask =~ s/\\\\\\?/[\\x01", 8192) = 8192
09:01:57.146340 brk(0xec7000)           = 0xec7000
09:01:57.147044 read(8, "-\\xFF]{1,1}/g;\n    $match = uc_irc($match, $mapping);\n\n    return 1 if $match =~ /^$umask$/;\n    return;\n}\n\nsub parse_user {\n    my ($user) = @_;\n    return if !defined $user;\n\n    my ($n, $u, $h) = split /[!@]/, $user;\n    return ($n, $u, $h) if wantarray();\n    return $n;\n}\n\nsub has_color {\n    my ($string) = @_;\n    return if !defined $string;\n    return 1 if $string =~ /[\\x03\\x04\\x1B]/;\n    return;\n}\n\nsub has_formatting {\n    my ($string) = @_;\n    return if !defined $string;\n    return 1 if $string =~/[\\x02\\x1f\\x16\\x1d\\x11\\x06]/;\n    return;\n}\n\nsub strip_color {\n    my ($string) = @_;\n    return if !defined $string;\n\n    # mIRC colors\n    $string =~ s/\\x03(?:,\\d{1,2}|\\d{1,2}(?:,\\d{1,2})?)?//g;\n\n    # RGB colors supported by some clients\n    $string =~ s/\\x04[0-9a-fA-F]{0,6}//ig;\n\n    # see ECMA-48 + advice by urxvt author\n    $string =~ s/\\x1B\\[.*?[\\x00-\\x1F\\x40-\\x7E]//g;\n\n    # strip cancellation codes too if there are no formatting codes\n    $string =~ s/\\x0f//g if !has_formatting($string);\n    return $string;\n}\n\nsub strip_formatting {\n    my ($string) = @_;\n    return if !defined $string;\n    $string =~ s/[\\x02\\x1f\\x16\\x1d\\x11\\x06]//g;\n\n    # strip cancellation codes too if there are no color codes\n    $string =~ s/\\x0f//g if !has_color($string);\n\n    return $string;\n}\n\nsub decode_irc {\n    my ($line) = @_;\n    my $utf8 = guess_encoding($line, 'utf8');\n    return ref $utf8 ? decode('utf8', $line) : decode('cp1252', $line);\n}\n\nsub _diff {\n    my ($before, $after) = @_;\n    my %in_before;\n    @in_before{@$before} = ();\n    my %in_after;\n    @in_after{@$after} = ();\n    my (@diff, %seen);\n\n    for my $seen (@$before) {\n        next if exists $seen{$seen} || exists $in_after{$seen};\n        $seen{$seen} = 1;\n        push @diff, ['-', $seen];\n    }\n\n    %seen = ();\n\n    for my $seen (@$after) {\n        next if exists $seen{$seen} || exists $in_before{$seen};\n        $seen{$seen} = 1;\n        push @diff, ['+', $seen];\n    }\n\n    return @diff;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nIRC::Utils - Common utilities for IRC-related tasks\n\n=head1 SYNOPSIS\n\n use strict;\n use warnings;\n\n use IRC::Utils ':ALL';\n\n my $nickname = '^Lame|BOT[moo]';\n my $uppercase_nick = uc_irc($nickname);\n my $lowercase_nick = lc_irc($nickname);\n\n print \"They're equivalent\\n\" if eq_irc($uppercase_nick, $lowercase_nick);\n\n my $mode_line = 'ov+b-i Bob sue stalin*!*@*';\n my $hashref = parse_mode_line($mode_line);\n\n my $banmask = 'stalin*';\n my $full_banmask = normalize_mask($banmask);\n\n if (matches_mask($full_banmask, 'stalin!joe@kremlin.ru')) {\n     print \"EEK!\";\n }\n\n my $decoded = irc_decode($raw_irc_message);\n print $decoded, \"\\n\";\n\n if (has_color($message)) {\n    print 'COLOR CODE ALERT!\\n\";\n }\n\n my $results_hashref = matches_mask_array(\\@masks, \\@items_to_match_against);\n\n my $nick = parse_user('stalin!joe@kremlin.ru');\n my ($nick, $user, $host) = parse_user('stalin!joe@kremlin.ru');\n\n=head1 DESCRIPTION\n\nThe functions in this module take care of many of the tasks you are faced\nwith when working with IRC. Mode lines, ban masks, message encoding and\nformatting, etc.\n\n=head1 FUNCTIONS\n\n=head2 C<uc_irc>\n\nTakes one mandatory parameter, a string to convert to IRC uppercase, and one\noptional parameter, the casemapping of the ircd (which can be B<'rfc1459'>,\nB<'strict-rfc1459'> or B<'ascii'>. Default is B<'rfc1459'>). Returns the IRC\nuppercase equivalent of the passed string.\n\n=head2 C<lc_irc>\n\nTakes one mandatory parameter, a string to convert to IRC lowercase, and one\noptional parameter, the casemapping of the ircd (which can be B<'rfc1459'>,\nB<'strict-rfc1459'> or B<'ascii'>. Default is B<'rfc1459'>). Returns the IRC\nlowercase equivalent of the passed string.\n\n=head2 C<eq_irc>\n\nTakes two mandatory parameters, IRC strings (channels or nicknames) to\ncompare. A third, optional parameter specifies the casemapping. Returns true\nif the two strings are equivalent, false otherwise\n\n # long version\n lc_irc($one, $map) eq lc_irc($two, $map)\n\n # short version\n eq_irc($one, $two, $map)\n\n=head2 C<parse_mode_line>\n\nTakes a list representing an IRC mode line. Returns a hashref. Optionally\nyou can also supply an arrayref and a hashref to specify valid channel\nmodes (default: C<[qw(beI k l imnpstaqr)]>) and status modes (default:\nC<< {o => '@', h => '%', v => '+'} >>), respectively.\n\nIf the modeline\ncouldn't be parsed the hashref will be empty. On success the following keys\nwill be available in the hashref:\n\nB<'modes'>, an arrayref of normalised modes;\n\nB<'args'>, an arrayref of applicable arguments to the modes;\n\nExample:\n\n my $hashref = parse_mode_line( 'ov+b-i', 'Bob', 'sue', 'stalin*!*@*' );\n\n # $hashref will be:\n {\n    modes => [ '+o', '+v', '+b', '-i' ],\n    args  => [ 'Bob', 'sue', 'stalin*!*@*' ],\n }\n\n=head2 C<normalize_mask>\n\nTakes one parameter, a string representing an IRC mask. Returns a normalised\nfull mask.\n\nExample:\n\n $fullbanmask = normalize_mask( 'stalin*' );\n\n # $fullbanmask will be: 'stalin*!*@*';\n\n=head2 C<matches_mask>\n\nTakes two parameters, a string representing an IRC mask and something to\nmatch against the IRC mask, such as a nick!user@hostname string. Returns\na true value if they match, a false value otherwise. Optionally, one may\npass the casemapping (see L<C<uc_irc>|/uc_irc>), as this function uses\nC<uc_irc> internally.\n\n=head2 C<matches_mask_array>\n\nTakes two array references, the first being a list of strings representing\nIRC masks, the second a list of somethings to test against the masks. Returns\nan empty hashref if there are no matches. Otherwise, the keys will be the\nmasks matched, each value being an arrayref of the strings that matched it.\nOptionally, one may pass the casemapping (see L<C<uc_irc>|/uc_irc>), as\nthis function uses C<uc_irc> internally.\n\n=head2 C<unparse_mode_line>\n\nTakes one argument, a string representing a number of mode changes. Returns\na condensed version of the changes.\n\n  my $mode_line = unparse_mode_line('+o+o+o-v+v');\n  $mode_line is now '+ooo-v+v'\n\n=head2 C<gen_mode_change>\n\nTakes two arguments, strings representing a set of IRC user modes before and\nafter a change. Returns a string representing what changed.\n\n  my $mode_change = gen_mode_change('abcde', 'befmZ');\n  $mode_change is now '-acd+fmZ'\n\n=head2 C<parse_user>\n\nTakes one parameter, a string representing a user in the form\nnick!user@hostname. In a scalar context it returns just the nickname.\nIn a list context it returns a list consisting of the nick, user and hostname,\nrespectively.\n\n=head2 C<is_valid_chan_name>\n\nTakes one argument, a channel name to validate. Returns true or false if the\nchannel name is valid or not. You can supply a second argument, an array of\ncharacters of allowed channel prefixes. Defaults to C<['#', '&']>.\n\n=head2 C<is_valid_nick_name>\n\nTakes one argument, a nickname to validate. Returns true or false if the\nnickname is valid or not.\n\n=head2 C<numeric_to_name>\n\nTakes an IRC server numerical reply code (e.g. '001') as an argument, and\nreturns the corresponding name (e.g. 'RPL_WELCOME').\n\n=head2 C<name_to_numeric>\n\nTakes an IRC server reply name (e.g. 'RPL_WELCOME') as an argument, and returns the\ncorresponding numerical code (e.g. '001').\n\n=head2 C<has_color>\n\nTakes one parameter, a string of IRC text. Returns true if it contains any IRC\ncolor codes, false otherwise. Useful if you want your bot to kick users for\n(ab)using colors. :)\n\n=head2 C<has_formatting>\n\nTakes one parameter, a string of IRC text. Returns true if it contains any IRC\nformatting codes, false otherwise.\n\n=head2 C<strip_color>\n\nTakes one parameter, a string of IRC text. Returns the string stripped of all\nIRC color codes.\n\n=head2 C<strip_formatting>\n\nTakes one parameter, a string of IRC text. Returns the string stripped of all\nIRC formatting codes.\n\n=head2 C<decode_irc>\n\nThis function takes a byte string (i.e. an unmodified IRC message) and\nreturns a text string. Since the source encoding might have been UTF-8,\nyou should store it with UTF-8 or some other Unicode encoding in your\nfile/database/whatever to be safe. For a more detailed discussion, see\nL</ENCODING>.\n\n use IRC::Utils qw(decode_irc);\n\n sub message_handler {\n     my ($nick, $channel, $message) = @_;\n\n     # not wise, $messa", 8192) = 8192
09:01:57.147534 brk(0xee8000)           = 0xee8000
09:01:57.147800 read(8, "ge is a byte string of unknown encoding\n     print $message, \"\\n\";\n\n     $message = decode_irc($what);\n\n     # good, $message is a text string\n     print $message, \"\\n\";\n }\n\n=head1 CONSTANTS\n\nUse the following constants to add formatting and mIRC color codes to IRC\nmessages.\n\nNormal text:\n\n NORMAL\n\nFormatting:\n\n BOLD\n UNDERLINE\n REVERSE\n ITALIC\n FIXED\n\nColors:\n\n WHITE\n BLACK\n BLUE\n GREEN\n RED\n BROWN\n PURPLE\n ORANGE\n YELLOW\n LIGHT_GREEN\n TEAL\n LIGHT_CYAN\n LIGHT_BLUE\n PINK\n GREY\n LIGHT_GREY\n\nIndividual non-color formatting codes can be cancelled with their\ncorresponding constant, but you can also cancel all of them at once with\nC<NORMAL>. To cancel the effect of color codes, you must use C<NORMAL>.\nwhich of course has the side effect of cancelling all other formatting codes\nas well.\n\n $msg = 'This word is '.YELLOW.'yellow'.NORMAL.' while this word is'.BOLD.'bold'.BOLD;\n $msg = UNDERLINE.BOLD.'This sentence is both underlined and bold.'.NORMAL;\n\n=head1 ENCODING\n\n=head2 Messages\n\nThe only encoding requirement the IRC protocol places on its messages is\nthat they be 8-bits and ASCII-compatible. This has resulted in most of the\nWestern world settling on ASCII-compatible Latin-1 (usually Microsoft's\nCP1252, a Latin-1 variant) as a convention. Recently, popular IRC clients\n(mIRC, xchat, certain irssi configurations) have begun sending a mixture of\nCP1252 and UTF-8 over the wire to allow more characters without breaking\nbackward compatibility (too much). They send CP1252 encoded messages if the\ncharacters fit within that encoding, otherwise falling back to UTF-8, and\nlikewise autodetecting the encoding (UTF-8 or CP1252) of incoming messages.\nSince writing text with mixed encoding to a file, terminal, or database is\nnot a good idea, you need a way to decode messages from IRC.\nL<C<decode_irc>|/decode_irc> will do that.\n\n=head2 Channel names\n\nThe matter is complicated further by the fact that some servers allow\nnon-ASCII characters in channel names. IRC modules generally don't\nexplicitly encode or decode any IRC traffic, but they do have to\nconcatenate parts of a message (e.g. a channel name and a message) before\nsending it over the wire. So when you do something like\nC<< privmsg($channel, '\303\246\303\260i') >>, where C<$channel> is the unmodified\nchannel name (a byte string) you got from an earlier IRC message, the\nchannel name will get double-encoded when concatenated with your message (a\nnon-ASCII text string) if the channel name contains non-ASCII bytes.\n\nTo prevent this, you can't simply L<decode|/decode_irc> the channel name and\nthen use it. C<'#\303\246\303\260i'> in CP1252 is not the same channel as C<'#\303\246\303\260i'> in\nUTF-8, since they are encoded as different sequences of bytes, and the IRC\nserver only cares about the byte representation. Therefore, when using a\nchannel name you got from the server (e.g. when replying to message), you\nshould use the original byte string (before it has been decoded with\nL<C<decode_irc>|/decode_irc>), and encode any other parameters (with\nL<C<encode_utf8>|Encode>) so that your message will be concatenated\ncorrectly. At some point, you'll probably want to print the channel name,\nwrite it to a log file or use it in a filename, so you'll eventually have to\ndecode it, at which point the UTF-8 C<#\303\246\303\260i> and CP1252 C<#\303\246\303\260i> will have to\nbe considered equivalent.\n\n use Encode qw(encode_utf8 encode);\n\n sub message_handler {\n     # these three are all byte strings\n     my ($nick, $channel, $message) = @_;\n\n     # bad: if $channel has any non-ASCII bytes, they will get double-encoded\n     privmsg($channel, '\303\246\303\260i');\n\n     # bad: if $message has any non-ASCII bytes, they will get double-encoded\n     privmsg('#\303\246\303\260i', $message);\n\n     # good: both are byte strings already, so they will concatenate correctly\n     privmsg($channel, $message);\n\n     # good: both are text strings (Latin1 as per Perl's default), so\n     # they'll be concatenated correctly\n     privmsg('#\303\246\303\260i', '\303\246\303\260i');\n\n     # good: similar to the last one, except now they're using UTF-8, which\n     # means that the channel is actually not the same as above\n     use utf8;\n     privmsg('#\303\246\303\260i', '\303\246\303\260i');\n\n     # good: $channel and $msg_bytes are both byte strings\n     my $msg_bytes = encode_utf8('\303\246\303\260i');\n     privmsg($channel, $msg_bytes);\n\n     # good: $chan_bytes and $message are both byte strings\n     # here we're sending a message to the utf8-encoded #\303\246\303\260i\n     my $utf8_bytes = encode_utf8('#\303\246\303\260i');\n     privmsg($utf8_bytes, $message);\n\n     # good: $chan_bytes and $message are both byte strings\n     # here we're sending a message to the cp1252-encoded #\303\246\303\260i\n     my $cp1252_bytes = encode('cp1252', '#\303\246\303\260i');\n     privmsg($cp1252_bytes, $message);\n\n     # bad: $channel is in an undetermined encoding\n     log_message(\"Got message from $channel\");\n\n     # good: using the decoded version of $channel\n     log_message(\"Got message from \".decode_irc($channel));\n }\n\nSee also L<Encode|Encode>, L<perluniintro|perluniintro>,\nL<perlunitut|perlunitut>, L<perlunicode|perlunicode>, and\nL<perlunifaq|perlunifaq>.\n\n=head1 AUTHOR\n\nHinrik E<Ouml>rn SigurE<eth>sson <hinrik.sig@gmail.com> (C<Hinrik> irc.perl.org, or C<literal> @ FreeNode).\n\nChris C<BinGOs> Williams <chris@bingosnet.co.uk>\n\n=head1 SEE ALSO\n\nL<POE::Component::IRC|POE::Component::IRC>\n\nL<POE::Component::Server::IRC|POE::Component::Server::IRC>\n\n=cut\n", 8192) = 5356
09:01:57.148096 read(8, "", 8192)       = 0
09:01:57.148144 close(8)                = 0
09:01:57.148988 brk(0xf09000)           = 0xf09000
09:01:57.149133 read(7, "", 8192)       = 0
09:01:57.149183 close(7)                = 0
09:01:57.149313 stat("modules/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149366 stat("modules/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149418 stat("modules/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149467 stat("modules/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149517 stat("/etc/perl/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149567 stat("/etc/perl/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149617 stat("/usr/local/lib/perl/5.14.2/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149672 stat("/usr/local/lib/perl/5.14.2/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149724 stat("/usr/local/share/perl/5.14.2/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149783 stat("/usr/local/share/perl/5.14.2/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149835 stat("/usr/lib/perl5/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149885 stat("/usr/lib/perl5/POE/Component/Syndicator.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.149935 stat("/usr/share/perl5/POE/Component/Syndicator.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.149986 stat("/usr/share/perl5/POE/Component/Syndicator.pm", {st_mode=S_IFREG|0644, st_size=30018, ...}) = 0
09:01:57.150058 open("/usr/share/perl5/POE/Component/Syndicator.pm", O_RDONLY) = 7
09:01:57.150115 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.150162 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.150218 read(7, "package POE::Component::Syndicator;\nBEGIN {\n  $POE::Component::Syndicator::AUTHORITY = 'cpan:HINRIK';\n}\nBEGIN {\n  $POE::Component::Syndicator::VERSION = '0.06';\n}\n\nuse strict;\nuse warnings FATAL => 'all';\nuse Carp qw(carp croak);\nuse Object::Pluggable::Constants qw(:ALL);\nuse POE;\nuse base 'Object::Pluggable';\n\nuse constant REFCOUNT_TAG => 'POE::Component::Syndicator registered';\n\nsub _pluggable_event {\n    my ($self, $event, @args) = @_;\n    $self->send_event($event, @args);\n    return;\n}\n\nsub _syndicator_init {\n    my ($self, %args) = @_;\n\n    $args{prefix} = 'syndicator_' if !defined $args{prefix};\n    $self->{_syndicator}{prefix} = $args{prefix};\n\n    if (defined $args{types}) {\n        croak(\"'types' argument must be an array\") if ref $args{types} ne 'ARRAY';\n        if (@{ $args{types} } == 4) {\n            $self->{_syndicator}{server_event} = $args{types}[0];\n            $self->{_syndicator}{user_event} = $args{types}[2];\n            $args{types} = { @{ $args{types} } };\n        }\n        elsif (@{ $args{types} } == 2) {\n            $self->{_syndicator}{server_event} = $args{types}[0];\n            $self->{_syndicator}{user_event} = $args{types}[1];\n        }\n        else {\n            croak('Only two event types are supported');\n        }\n    }\n    else {\n        $args{types} = { SERVER => 'S', USER => 'U' };\n        $self->{_syndicator}{server_event} = 'SERVER';\n        $self->{_syndicator}{user_event} = 'USER';\n    }\n\n    # set up the plugin system\n    $self->_pluggable_init(\n        prefix     => delete $args{prefix},\n        reg_prefix => delete $args{reg_prefix},\n        debug      => delete $args{debug},\n        types      => delete $args{types},\n    );\n\n    if (ref $args{object_states} eq 'ARRAY') {\n        my $start_stop = \"Don't install handlers for _start or _stop. Use\"\n                    . \"_syndicator_started or _syndicator_stopped instead\";\n        my $reg_unreg = \"Don't install handlers for register or unregister.\"\n                        . \" Those are handled by POE::Component::Syndicator\";\n\n        for (my $i = 1; $i <= $#{ $args{object_states} }; $i += 2) {\n            my $events = $args{object_states}[$i];\n            if (ref $events eq 'HASH') {\n                if (defined $events->{_start} || defined $events->{_stop}) {\n                    croak($start_stop);\n                }\n                elsif (defined $events->{register} || defined $events->{unregister}) {\n                    croak($reg_unreg);\n                }\n            }\n            elsif (ref $events eq 'ARRAY') {\n                for my $event (@$events) {\n                    if ($event eq '_start' || $event eq '_stop') {\n                        croak($start_stop);\n                    }\n                    elsif ($event eq 'register' || $event eq 'unregister') {\n                        croak($reg_unreg);\n                    }\n                }\n            }\n        }\n    }\n\n    # set up our POE session\n    POE::Session->create(\n        object_states => [\n            $self => {\n                _start     => '_syndicator_start',\n                _default   => '_syndicator_default',\n                _stop      => '_syndicator_stop',\n                register   => '_syndicator_register',\n                unregister => '_syndicator_unregister',\n            },\n            $self => [qw(\n                _syndicator_shutdown\n                _syndicator_send_pending_events\n                _syndicator_delay\n                _syndicator_delay_remove\n                _syndicator_sig_register\n                _syndicator_sig_shutdown\n                _syndicator_sig_die\n            )],\n            ($args{object_states} ? @{ $args{object_states} } : ()),\n        ],\n        ($args{options} ? (options => delete $args{options}) : ()),\n        args => [%args],\n        heap => $self,\n    );\n\n    return;\n}\n\nsub _syndicator_sig_die {\n    my ($kernel, $self, $ex) = @_[KERNEL, OBJECT, ARG1];\n    chomp $ex->{error_str};\n\n    my $error = \"Event $ex->{event} in session \".$ex->{dest_session}->ID\n        .\" raised exception:\\n    $ex->{error_str}\";\n\n    warn $error, \"\\n\";\n    $kernel->sig_handled();\n    return;\n}\n\nsub _syndicator_destroy {\n    my ($self, @args) = @_;\n    $self->call('_syndicator_shutdown', @args);\n    return;\n}\n\nsub _syndicator_shutdown {\n    my ($kernel, $self, @args) = @_[KERNEL, OBJECT, ARG0..$#_];\n    return if $self->{_shutting_down};\n    $kernel->alarm_remove_all();\n    $self->_pluggable_destroy();\n    $self->send_event($self->{_syndicator}{prefix} . 'shutdown', @args);\n    $self->{_shutting_down} = 1;\n    return;\n}\n\nsub _syndicator_start {\n    my ($kernel, $sender, $session, $self, %args)\n        = @_[KERNEL, SENDER, SESSION, OBJECT, ARG0..$#_];\n\n    $kernel->sig('DIE', '_syndicator_sig_die');\n    $self->{_syndicator}{session_id} = $session->ID();\n\n    # set an alias to keep our session alive\n    if (defined $args{alias}) {\n        $kernel->alias_set($args{alias});\n        $self->{_syndicator}{session_alias} = $args{alias};\n    }\n    else {\n        $kernel->alias_set(\"$self\");\n        $self->{_syndicator}{session_alias} = \"$self\";\n    }\n\n    $args{register_signal} = 'SYNDICATOR_REGISTER' if !defined $args{register_signal};\n    $kernel->sig($args{register_signal}, '_syndicator_sig_register');\n    $args{shutdown_signal} = 'SYNDICATOR_SHUTDOWN' if !defined $args{shutdown_signal};\n    $kernel->sig($args{shutdown_signal}, '_syndicator_sig_shutdown');\n\n    # if called from a parent session, register the parent for all events\n    # and detach our session from the parent\n    if ($sender != $kernel) {\n        my $sender_id = $sender->ID;\n        my $prefix = $self->{_syndicator}{prefix};\n        $self->{_syndicator}{events}{all}{$sender_id} = $sender_id;\n        $self->{_syndicator}{sessions}{$sender_id}{ref} = $sender_id;\n        $self->{_syndicator}{sessions}{$sender_id}{refcnt}++;\n        $kernel->refcount_increment($sender_id, REFCOUNT_TAG);\n        $kernel->post($sender, \"${prefix}registered\", $self);\n        $kernel->detach_myself();\n    }\n\n    $kernel->call($session, 'syndicator_started');\n    return;\n}\n\nsub _syndicator_default {\n    my ($self, $event, $args) = @_[OBJECT, ARG0, ARG1];\n    return if $event =~ /^_/;\n    return if $event =~ /^syndicator_(?:started|stopped)$/;\n    $self->send_user_event($event, [@$args]);\n    return;\n}\n\nsub _syndicator_stop {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    $kernel->call($self->{_syndicator}{session_id}, 'syndicator_stopped');\n    return;\n}\n\nsub _syndicator_unregister_sessions {\n    my ($self) = @_;\n\n    for my $session_id ( keys %{ $self->{_syndicator}{sessions} } ) {\n        my $refcnt = $self->{_syndicator}{sessions}{$session_id}{refcnt};\n        while ($refcnt-- > 0) {\n            $poe_kernel->refcount_decrement($session_id, REFCOUNT_TAG);\n        }\n        delete $self->{_syndicator}{sessions}{$session_id};\n    }\n\n    return;\n}\n\nsub yield {\n    my ($self, @args) = @_;\n    $poe_kernel->post($self->{_syndicator}{session_id}, @args);\n    return;\n}\n\nsub _syndicator_sig_register {\n    my ($kernel, $self, $session, $signal, $sender, @events)\n        = @_[KERNEL, OBJECT, SESSION, ARG0..$#_];\n\n    if (!@events || !defined $sender) {\n        warn \"Signal $signal: not enough arguments\\n\";\n        return;\n    }\n\n    my $sender_id;\n    if (my $ref = $kernel->alias_resolve($sender)) {\n        $sender_id = $ref->ID();\n    }\n    else {\n        warn \"Signal $signal: can't resolve sender $sender\\n\";\n        return;\n    }\n\n    $self->_syndicator_reg($sender_id, @events);\n    return;\n}\n\nsub _syndicator_sig_shutdown {\n    my ($kernel, $self, @args) = @_[KERNEL, OBJECT, ARG2..$#_];\n    $kernel->yield('shutdown', @args) if !$self->{_shutdown_event_sent};\n    $self->{_shutdown_event_sent} = 1;\n    return;\n}\n\nsub _syndicator_register {\n    my ($kernel, $self, $session, $sender, @events)\n        = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0 .. $#_];\n\n    @events = 'all' if !@events;\n    my $sender_id = $sender->ID();\n    $self->_syndicator_reg($sender_id, @events);\n    return;\n}\n\nsub _syndicator_reg {\n    my ($self, $sender_id, @events) = @_;\n    my $prefix = $self->{_syndicator}{prefix};\n\n    for my $event (@events) {\n        $self->{_s", 8192) = 8192
09:01:57.150728 stat("modules/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.150782 stat("modules/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.150833 stat("modules/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.150882 stat("modules/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.150932 stat("/etc/perl/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.150982 stat("/etc/perl/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.151032 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.151084 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.151135 stat("/usr/local/share/perl/5.14.2/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.151187 stat("/usr/local/share/perl/5.14.2/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.151238 stat("/usr/lib/perl5/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.151289 stat("/usr/lib/perl5/Object/Pluggable/Constants.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.151339 stat("/usr/share/perl5/Object/Pluggable/Constants.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.151392 stat("/usr/share/perl5/Object/Pluggable/Constants.pm", {st_mode=S_IFREG|0644, st_size=1575, ...}) = 0
09:01:57.151451 open("/usr/share/perl5/Object/Pluggable/Constants.pm", O_RDONLY) = 8
09:01:57.151505 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.151551 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.151610 read(8, "package Object::Pluggable::Constants;\nBEGIN {\n  $Object::Pluggable::Constants::AUTHORITY = 'cpan:HINRIK';\n}\nBEGIN {\n  $Object::Pluggable::Constants::VERSION = '1.29';\n}\n\nuse strict;\nuse warnings;\n\nrequire Exporter;\nuse base qw(Exporter);\nour @EXPORT_OK = qw(\n    PLUGIN_EAT_NONE PLUGIN_EAT_CLIENT PLUGIN_EAT_PLUGIN PLUGIN_EAT_ALL\n);\nour %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );\n\nuse constant {\n    PLUGIN_EAT_NONE   => 1,\n    PLUGIN_EAT_CLIENT => 2,\n    PLUGIN_EAT_PLUGIN => 3,\n    PLUGIN_EAT_ALL    => 4,\n};\n\n1;\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nObject::Pluggable::Constants - Importable constants for Object::Pluggable\n\n=head1 SYNOPSIS\n\n use Object::Pluggable::Constants qw(:ALL);\n\n=head1 DESCRIPTION\n\nObject::Pluggable::Constants defines a number of constants that are\nrequired by the plugin system.\n\n=head1 EXPORTS\n\n=head2 C<PLUGIN_EAT_NONE>\n\nValue: 1\n\nThis means the event will continue to be processed by remaining plugins and\nfinally, sent to interested sessions that registered for it.\n\n=head2 C<PLUGIN_EAT_CLIENT>\n\nValue: 2\n\nThis means the event will continue to be processed by remaining plugins but\nit will not be sent to any sessions that registered for it.\n\n=head2 C<PLUGIN_EAT_PLUGIN>\n\nValue: 3\n\nThis means the event will not be processed by remaining plugins, it will go\nstraight to interested sessions.\n\n=head2 C<PLUGIN_EAT_ALL>\n\nValue: 4\n\nThis means the event will be completely discarded, no plugin or session will\nsee it.\n\n=head1 MAINTAINER\n\nChris 'BinGOs' Williams <chris@bingosnet.co.uk>\n\n=head1 SEE ALSO\n\nL<Object::Pluggable|Object::Pluggable>\n\n=cut\n", 8192) = 1575
09:01:57.151905 lseek(8, 520, SEEK_SET) = 520
09:01:57.151954 lseek(8, 0, SEEK_CUR)   = 520
09:01:57.151998 close(8)                = 0
09:01:57.152215 stat("modules/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152267 stat("modules/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152317 stat("modules/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152366 stat("modules/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152415 stat("/etc/perl/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152464 stat("/etc/perl/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152514 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152564 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152615 stat("/usr/local/share/perl/5.14.2/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152666 stat("/usr/local/share/perl/5.14.2/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152718 stat("/usr/lib/perl5/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152767 stat("/usr/lib/perl5/Object/Pluggable.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.152817 stat("/usr/share/perl5/Object/Pluggable.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.152867 stat("/usr/share/perl5/Object/Pluggable.pm", {st_mode=S_IFREG|0644, st_size=20489, ...}) = 0
09:01:57.152925 open("/usr/share/perl5/Object/Pluggable.pm", O_RDONLY) = 8
09:01:57.152978 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.153024 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.153079 read(8, "package Object::Pluggable;\nBEGIN {\n  $Object::Pluggable::AUTHORITY = 'cpan:HINRIK';\n}\nBEGIN {\n  $Object::Pluggable::VERSION = '1.29';\n}\n\nuse strict;\nuse warnings;\nuse Carp;\nuse Object::Pluggable::Pipeline;\nuse Object::Pluggable::Constants qw(:ALL);\n\nsub _pluggable_init {\n    my ($self, %opts) = @_;\n  \n    $self->{'_pluggable_' . lc $_} = delete $opts{$_} for keys %opts;\n    $self->{_pluggable_reg_prefix} = 'plugin_' if !$self->{_pluggable_reg_prefix};\n    $self->{_pluggable_prefix} = 'pluggable_' if !$self->{_pluggable_prefix};\n  \n    if (ref $self->{_pluggable_types} eq 'ARRAY') {\n        $self->{_pluggable_types} = { map { $_ => $_ } @{ $self->{_pluggable_types} } };\n    }\n    elsif (ref $self->{_pluggable_types} ne 'HASH') {\n        croak \"Argument 'types' must be supplied\";\n    }\n  \n    return 1;\n}\n\nsub _pluggable_destroy {\n    my ($self) = @_;\n    $self->plugin_del( $_ ) for keys %{ $self->plugin_list() };\n    return;\n}\n\nsub _pluggable_event {\n    return;\n}\n\nsub _pluggable_process {\n    my ($self, $type, $event, $args) = @_;\n\n    if (!defined $type || !defined $event) {\n        carp 'Please supply an event type and name!';\n        return;\n    }\n\n    $event = lc $event;\n    my $pipeline = $self->pipeline;\n    my $prefix = $self->{_pluggable_prefix};\n    $event =~ s/^\\Q$prefix\\E//;\n    my $sub = join '_', $self->{_pluggable_types}{$type}, $event;\n    my $return = PLUGIN_EAT_NONE;\n    my $self_ret = $return;\n    my @extra_args;\n\n    local $@;\n    if ($self->can($sub)) {\n        eval { $self_ret = $self->$sub($self, \\(@$args), \\@extra_args ) };\n        $self->_handle_error($self, $sub, $self_ret);\n    }\n    elsif ( $self->can('_default') ) {\n        eval { $self_ret = $self->_default($self, $sub, \\(@$args), \\@extra_args) };\n        $self->_handle_error($self, '_default', $self_ret);\n    }\n\n    $self_ret = PLUGIN_EAT_NONE unless defined $self_ret;\n    return $return if $self_ret == PLUGIN_EAT_PLUGIN;\n    $return = PLUGIN_EAT_ALL if $self_ret == PLUGIN_EAT_CLIENT;\n    return PLUGIN_EAT_ALL if $self_ret == PLUGIN_EAT_ALL;\n\n    if (@extra_args) {\n        push @$args, @extra_args;\n        @extra_args = ();\n    }\n\n    for my $plugin (@{ $pipeline->{PIPELINE} }) {\n        if ($self eq $plugin\n          || !$pipeline->{HANDLES}{$plugin}{$type}{$event}\n          && !$pipeline->{HANDLES}{$plugin}{$type}{all}) {\n            next;\n        }\n\n        my $ret = PLUGIN_EAT_NONE;\n\n        my $alias = ($pipeline->get($plugin))[1];\n        if ($plugin->can($sub)) {\n            eval { $ret = $plugin->$sub($self, \\(@$args), \\@extra_args) };\n            $self->_handle_error($plugin, $sub, $ret, $alias);\n        }\n        elsif ( $plugin->can('_default') ) {\n            eval { $ret = $plugin->_default($self, $sub, \\(@$args), \\@extra_args) };\n            $self->_handle_error($plugin, '_default', $ret, $alias);\n        }\n\n\t$ret = PLUGIN_EAT_NONE unless defined $ret;\n        return $return if $ret == PLUGIN_EAT_PLUGIN;\n        $return = PLUGIN_EAT_ALL if $ret == PLUGIN_EAT_CLIENT;\n        return PLUGIN_EAT_ALL if $ret == PLUGIN_EAT_ALL;\n\n        if (@extra_args) {\n            push @$args, @extra_args;\n            @extra_args = ();\n        }\n    }\n\n    return $return;\n}\n\nsub _handle_error {\n    my ($self, $object, $sub, $return, $source) = @_;\n    $source = defined $source ? \"plugin '$source'\" : 'self';\n\n    if ($@) {\n        chomp $@;\n        my $error = \"$sub call on $source failed: $@\";\n        warn \"$error\\n\" if $self->{_pluggable_debug};\n\n        $self->_pluggable_event(\n            \"$self->{_pluggable_prefix}plugin_error\",\n            $error, ($object == $self ? ($object, $source) : ()),\n        );\n    }\n    elsif ( !defined $return || \n      ($return != PLUGIN_EAT_NONE\n      && $return != PLUGIN_EAT_PLUGIN\n      && $return != PLUGIN_EAT_CLIENT\n      && $return != PLUGIN_EAT_ALL) ) {\n        my $error = \"$sub call on $source did not return a valid EAT constant\";\n        warn \"$error\\n\" if $self->{_pluggable_debug};\n\n        $self->_pluggable_event(\n            \"$self->{_pluggable_prefix}plugin_error\",\n            $error, ($object == $self ? ($object, $source) : ()),\n        );\n    }\n\n    return;\n}\n\n# accesses the plugin pipeline\nsub pipeline {\n    my ($self) = @_;\n    local $@;\n    eval { $self->{_PLUGINS}->isa('Object::Pluggble::Pipeline') };\n    $self->{_PLUGINS} = Object::Pluggable::Pipeline->new($self) if $@;\n    return $self->{_PLUGINS};\n}\n\n# Adds a new plugin object\nsub plugin_add {\n    my ($self, $name, $plugin, @args) = @_;\n\n    if (!defined $name || !defined $plugin) {\n        carp 'Please supply a name and the plugin object to be added!';\n        return;\n    }\n\n    return $self->pipeline->push($name, $plugin, @args);\n}\n\n# Removes a plugin object\nsub plugin_del {\n    my ($self, $name, @args) = @_;\n\n    if (!defined $name) {\n        carp 'Please supply a name/object for the plugin to be removed!';\n        return;\n    }\n\n    my $return = scalar $self->pipeline->remove($name, @args);\n    return $return;\n}\n\n# Gets the plugin object\nsub plugin_get {\n    my ($self, $name) = @_;  \n\n    if (!defined $name) {\n        carp 'Please supply a name/object for the plugin to be removed!';\n        return;\n    }\n\n    return scalar $self->pipeline->get($name);\n}\n\n# Lists loaded plugins\nsub plugin_list {\n    my ($self) = @_;\n    my $pipeline = $self->pipeline;\n  \n    my %return = map {$pipeline->{PLUGS}{$_} => $_} @{ $pipeline->{PIPELINE} };\n    return \\%return;\n}\n\n# Lists loaded plugins in order!\nsub plugin_order {\n    my ($self) = @_;\n    return $self->pipeline->{PIPELINE};\n}\n\nsub plugin_register {\n    my ($self, $plugin, $type, @events) = @_;\n    my $pipeline = $self->pipeline;\n\n    if (!grep { $_ eq $type } keys %{ $self->{_pluggable_types} }) {\n        carp \"The event type '$type' is not supported!\";\n        return;\n    }\n\n    if (!defined $plugin) {\n        carp 'Please supply the plugin object to register events for!';\n        return;\n    }\n\n    if (!@events) {\n        carp 'Please supply at least one event to register!';\n        return;\n    }\n\n    for my $ev (@events) {\n        if (ref $ev and ref $ev eq 'ARRAY') {\n            $pipeline->{HANDLES}{$plugin}{$type}{lc $_} = 1 for @$ev;\n        }\n        else {\n            $pipeline->{HANDLES}{$plugin}{$type}{lc $ev} = 1;\n        }\n    }\n\n    return 1;\n}\n\nsub plugin_unregister {\n    my ($self, $plugin, $type, @events) = @_;\n    my $pipeline = $self->pipeline;\n\n    if (!grep { $_ eq $type } keys %{ $self->{_pluggable_types} }) {\n        carp \"The event type '$type' is not supported!\";\n        return;\n    }\n\n    if (!defined $plugin) {\n        carp 'Please supply the plugin object to register!';\n        return;\n    }\n\n    if (!@events) {\n        carp 'Please supply at least one event to unregister!';\n        return;\n    }\n\n    for my $ev (@events) {\n        if (ref $ev and ref $ev eq \"ARRAY\") {\n            for my $e (map { lc } @$ev) {\n                if (!delete $pipeline->{HANDLES}{$plugin}{$type}{$e}) {\n                    carp \"The event '$e' does not exist!\";\n                    next;\n                }\n            }\n        }\n        else {\n            $ev = lc $ev;\n            if (!delete $pipeline->{HANDLES}{$plugin}{$type}{$ev}) {\n                carp \"The event '$ev' does not exist!\";\n                next;\n            }\n        }\n    }\n\n    return 1;\n}\n\n1;\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nObject::Pluggable - A base class for creating plugin-enabled objects\n\n=head1 SYNOPSIS\n\n # A simple POE Component that sends ping events to registered sessions\n # and plugins every second.\n\n {\n     package SimplePoCo;\n\n     use strict;\n     use warnings;\n     use base qw(Object::Pluggable);\n     use POE;\n     use Object::Pluggable::Constants qw(:ALL);\n\n     sub spawn {\n         my ($package, %opts) = @_;\n         my $self = bless \\%opts, $package;\n\n         $self->_pluggable_init(\n             prefix => 'simplepoco_',\n             types  => [qw(EXAMPLE)],\n             debug  => 1,\n         );\n\n         POE::Session->create(\n             object_states => [\n                 $self => { shutdown => '_shutdown' },\n                 $self => [qw(_send_ping _start register unregister __send_event)],\n             ],\n        ", 8192) = 8192
09:01:57.153561 stat("modules/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.153615 stat("modules/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.153670 stat("modules/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.153721 stat("modules/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.153771 stat("/etc/perl/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.153820 stat("/etc/perl/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.153869 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.153925 stat("/usr/local/lib/perl/5.14.2/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.153976 stat("/usr/local/share/perl/5.14.2/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.154035 stat("/usr/local/share/perl/5.14.2/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.154094 stat("/usr/lib/perl5/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.154145 stat("/usr/lib/perl5/Object/Pluggable/Pipeline.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.154194 stat("/usr/share/perl5/Object/Pluggable/Pipeline.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.154244 stat("/usr/share/perl5/Object/Pluggable/Pipeline.pm", {st_mode=S_IFREG|0644, st_size=17377, ...}) = 0
09:01:57.154303 open("/usr/share/perl5/Object/Pluggable/Pipeline.pm", O_RDONLY) = 9
09:01:57.154356 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.154402 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.154462 read(9, "package Object::Pluggable::Pipeline;\nBEGIN {\n  $Object::Pluggable::Pipeline::AUTHORITY = 'cpan:HINRIK';\n}\nBEGIN {\n  $Object::Pluggable::Pipeline::VERSION = '1.29';\n}\n\nuse strict;\nuse warnings;\nuse Carp;\nuse Scalar::Util qw(weaken);\n\nsub new {\n    my ($package, $pluggable) = @_;\n\n    my $self = bless {\n        PLUGS    => {},\n        PIPELINE => [],\n        HANDLES  => {},\n        OBJECT   => $pluggable,\n    }, $package;\n\n    weaken($self->{OBJECT});\n\n    return $self;\n}\n\nsub push {\n    my ($self, $alias, $plug, @register_args) = @_;\n\n    if ($self->{PLUGS}{$alias}) {\n        $@ = \"Plugin named '$alias' already exists ($self->{PLUGS}{$alias})\";\n        return;\n    }\n\n    my $return = $self->_register($alias, $plug, @register_args);\n    return if !$return;\n\n    push @{ $self->{PIPELINE} }, $plug;\n    return scalar @{ $self->{PIPELINE} };\n}\n\nsub pop {\n    my ($self, @unregister_args) = @_;\n\n    return if !@{ $self->{PIPELINE} };\n\n    my $plug = pop @{ $self->{PIPELINE} };\n    my $alias = $self->{PLUGS}{$plug};\n    $self->_unregister($alias, $plug, @unregister_args);\n\n    return wantarray ? ($plug, $alias) : $plug;\n}\n\nsub unshift {\n    my ($self, $alias, $plug, @register_args) = @_;\n\n    if ($self->{PLUGS}{$alias}) {\n        $@ = \"Plugin named '$alias' already exists ($self->{PLUGS}{$alias}\";\n        return;\n    }\n\n    my $return = $self->_register($alias, $plug, @register_args);\n    return if !$return;\n\n    unshift @{ $self->{PIPELINE} }, $plug;\n    return scalar @{ $self->{PIPELINE} };\n}\n\nsub shift {\n    my ($self, @unregister_args) = @_;\n\n    return if !@{ $self->{PIPELINE} };\n\n    my $plug = shift @{ $self->{PIPELINE} };\n    my $alias = $self->{PLUGS}{$plug};\n    $self->_unregister($alias, $plug, @unregister_args);\n\n    return wantarray ? ($plug, $alias) : $plug;\n}\n\nsub replace {\n    my ($self, $old, $new_a, $new_p, $unregister_args, $register_args) = @_;\n    \n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return;\n    }\n\n    $self->_unregister(\n        $old_a,\n        $old_p,\n        (ref $unregister_args eq 'ARRAY'\n            ? @$unregister_args\n            : ()\n        )\n    );\n\n    if ($self->{PLUGS}{$new_a}) {\n        $@ = \"Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}\";\n        return;\n    }\n\n    my $return = $self->_register(\n        $new_a,\n        $new_p,\n        (ref $register_args eq 'ARRAY'\n            ? @$register_args\n            : ()\n        )\n    );\n    return if !$return;\n\n    for my $plugin (@{ $self->{PIPELINE} }) {\n        if ($plugin == $old_p) {\n            $plugin = $new_p;\n            last;\n        }\n    }\n\n    return 1;\n}\n\nsub remove {\n    my ($self, $old, @unregister_args) = @_;\n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return;\n    }\n\n    my $i = 0;\n    for my $plugin (@{ $self->{PIPELINE} }) {\n        if ($plugin == $old_p) {\n            splice(@{ $self->{PIPELINE} }, $i, 1);\n            last;\n        }\n        $i++;\n    }\n\n    $self->_unregister($old_a, $old_p, @unregister_args);\n\n    return wantarray ? ($old_p, $old_a) : $old_p;\n}\n\nsub get {\n    my ($self, $old) = @_;\n    \n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return;\n    }\n\n    return wantarray ? ($old_p, $old_a) : $old_p;\n}\n\nsub get_index {\n    my ($self, $old) = @_;\n    \n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return -1;\n    }\n\n    my $i = 0;\n    for my $plugin (@{ $self->{PIPELINE} }) {\n        return $i if $plugin == $old_p;\n        $i++;\n    }\n\n    return -1;\n}\n\nsub insert_before {\n    my ($self, $old, $new_a, $new_p, @register_args) = @_;\n    \n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return;\n    }\n\n    if ($self->{PLUGS}{$new_a}) {\n        $@ = \"Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}\";\n        return;\n    }\n\n    my $return = $self->_register($new_a, $new_p, @register_args);\n    return if !$return;\n\n    my $i = 0;\n    for my $plugin (@{ $self->{PIPELINE} }) {\n        if ($plugin == $old_p) {\n            splice(@{ $self->{PIPELINE} }, $i, 0, $new_p);\n            last;\n        }\n        $i++;\n    }\n\n    return 1;\n}\n\nsub insert_after {\n    my ($self, $old, $new_a, $new_p, @register_args) = @_;\n    my ($old_a, $old_p) = ref $old\n        ? ($self->{PLUGS}{$old}, $old)\n        : ($old, $self->{PLUGS}{$old})\n    ;\n\n    if (!$old_p) {\n        $@ = \"Plugin '$old_a' does not exist\";\n        return;\n    }\n\n    if ($self->{PLUGS}{$new_a}) {\n        $@ = \"Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}\";\n        return;\n    }\n\n    my $return = $self->_register($new_a, $new_p, @register_args);\n    return if !$return;\n\n    my $i = 0;\n    for my $plugin (@{ $self->{PIPELINE} }) {\n        if ($plugin == $old_p) {\n            splice(@{ $self->{PIPELINE} }, $i+1, 0, $new_p);\n            last;\n        }\n        $i++;\n    }\n\n    return 1;\n}\n\nsub bump_up {\n    my ($self, $old, $diff) = @_;\n    my $idx = $self->get_index($old);\n\n    return -1 if $idx < 0;\n\n    my $pipeline = $self->{PIPELINE};\n    $diff ||= 1;\n\n    my $pos = $idx - $diff;\n\n    if ($pos < 0) {\n        carp \"$idx - $diff is negative, moving to head of the pipeline\";\n    }\n\n    splice(@$pipeline, $pos, 0, splice(@$pipeline, $idx, 1));\n    return $pos;\n}\n\nsub bump_down {\n    my ($self, $old, $diff) = @_;\n    my $idx = $self->get_index($old);\n\n    return -1 if $idx < 0;\n\n    my $pipeline = $self->{PIPELINE};\n    $diff ||= 1;\n\n    my $pos = $idx + $diff;\n\n    if ($pos >= @$pipeline) {\n        carp \"$idx + $diff is too high, moving to back of the pipeline\";\n    }\n\n    splice(@$pipeline, $pos, 0, splice(@$pipeline, $idx, 1));\n    return $pos;\n}\n\nsub _register {\n    my ($self, $alias, $plug, @register_args) = @_;\n    return if !defined $self->{OBJECT};\n\n    my $return;\n    my $sub = \"$self->{OBJECT}{_pluggable_reg_prefix}register\";\n    local $@;\n    eval { $return = $plug->$sub($self->{OBJECT}, @register_args) };\n\n    if ($@) {\n        chomp $@;\n        my $error = \"$sub call on plugin '$alias' failed: $@\";\n        $self->_handle_error($error, $plug, $alias);\n    }\n    elsif (!$return) {\n        my $error = \"$sub call on plugin '$alias' did not return a true value\";\n        $self->_handle_error($error, $plug, $alias);\n    }\n\n    $self->{PLUGS}{$plug} = $alias;\n    $self->{PLUGS}{$alias} = $plug;\n    \n    $self->{OBJECT}->_pluggable_event(\n        \"$self->{OBJECT}{_pluggable_prefix}plugin_add\",\n        $alias, $plug,\n    );\n\n    return $return;\n}\n\nsub _unregister {\n    my ($self, $alias, $plug, @unregister_args) = @_;\n    return if !defined $self->{OBJECT};\n\n    my $return;\n    my $sub = \"$self->{OBJECT}{_pluggable_reg_prefix}unregister\";\n    local $@;\n    eval { $return = $plug->$sub($self->{OBJECT}, @unregister_args) };\n\n    if ($@) {\n        chomp $@;\n        my $error = \"$sub call on plugin '$alias' failed: $@\";\n        $self->_handle_error($error, $plug, $alias);\n    }\n    elsif (!$return) {\n        my $error = \"$sub call on plugin '$alias' did not return a true value\";\n        $self->_handle_error($error, $plug, $alias);\n    }\n\n    delete $self->{PLUGS}{$plug};\n    delete $self->{PLUGS}{$alias};\n    delete $self->{HANDLES}{$plug};\n\n    $self->{OBJECT}->_pluggable_event(\n        \"$self->{OBJECT}{_pluggable_prefix}plugin_del\",\n        $alias, $plug,\n    );\n\n    return $return;\n}\n\nsub _handle_error {\n    my ($self, $error, $plugin, $alias) = @_;\n\n    warn \"$error\\n\" if $self->{OBJECT}{_pluggable_debug};\n    $self->{OBJECT}->_pluggable_event(\n        \"$self->{OBJECT}{_pluggable_prefix}plugin_error\",\n        $error, $pl", 8192) = 8192
09:01:57.154951 stat("modules/Scalar/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.155004 stat("modules/Scalar/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.155054 stat("modules/Scalar/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.155102 stat("modules/Scalar/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.155150 stat("/etc/perl/Scalar/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.155199 stat("/etc/perl/Scalar/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.155249 stat("/usr/local/lib/perl/5.14.2/Scalar/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.155301 stat("/usr/local/lib/perl/5.14.2/Scalar/Util.pm", {st_mode=S_IFREG|0444, st_size=10303, ...}) = 0
09:01:57.155359 open("/usr/local/lib/perl/5.14.2/Scalar/Util.pm", O_RDONLY) = 10
09:01:57.155412 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.155458 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.155516 read(10, "# Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n#\n# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>\n\npackage Scalar::Util;\n\nuse strict;\nrequire Exporter;\n\nour @ISA       = qw(Exporter);\nour @EXPORT_OK = qw(\n  blessed refaddr reftype weaken unweaken isweak\n\n  dualvar isdual isvstring looks_like_number openhandle readonly set_prototype\n  tainted\n);\nour $VERSION    = \"1.42\";\n$VERSION   = eval $VERSION;\n\nrequire List::Util; # List::Util loads the XS\nList::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)\n\nour @EXPORT_FAIL;\n\nunless (defined &weaken) {\n  push @EXPORT_FAIL, qw(weaken);\n}\nunless (defined &isweak) {\n  push @EXPORT_FAIL, qw(isweak isvstring);\n}\nunless (defined &isvstring) {\n  push @EXPORT_FAIL, qw(isvstring);\n}\n\nsub export_fail {\n  if (grep { /^(?:weaken|isweak)$/ } @_ ) {\n    require Carp;\n    Carp::croak(\"Weak references are not implemented in the version of perl\");\n  }\n\n  if (grep { /^isvstring$/ } @_ ) {\n    require Carp;\n    Carp::croak(\"Vstrings are not implemented in the version of perl\");\n  }\n\n  @_;\n}\n\n# set_prototype has been moved to Sub::Util with a different interface\nsub set_prototype(&$)\n{\n  my ( $code, $proto ) = @_;\n  return Sub::Util::set_prototype( $proto, $code );\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nScalar::Util - A selection of general-utility scalar subroutines\n\n=head1 SYNOPSIS\n\n    use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype\n                        tainted weaken isweak isvstring looks_like_number\n                        set_prototype);\n                        # and other useful utils appearing below\n\n=head1 DESCRIPTION\n\nC<Scalar::Util> contains a selection of subroutines that people have expressed\nwould be nice to have in the perl core, but the usage would not really be high\nenough to warrant the use of a keyword, and the size so small such that being\nindividual extensions would be wasteful.\n\nBy default C<Scalar::Util> does not export any subroutines.\n\n=cut\n\n=head1 FUNCTIONS FOR REFERENCES\n\nThe following functions all perform some useful activity on reference values.\n\n=head2 blessed\n\n    my $pkg = blessed( $ref );\n\nIf C<$ref> is a blessed reference the name of the package that it is blessed\ninto is returned. Otherwise C<undef> is returned.\n\n    $scalar = \"foo\";\n    $class  = blessed $scalar;           # undef\n\n    $ref    = [];\n    $class  = blessed $ref;              # undef\n\n    $obj    = bless [], \"Foo\";\n    $class  = blessed $obj;              # \"Foo\"\n\nTake care when using this function simply as a truth test (such as in\nC<if(blessed $ref)...>) because the package name C<\"0\"> is defined yet false.\n\n=head2 refaddr\n\n    my $addr = refaddr( $ref );\n\nIf C<$ref> is reference the internal memory address of the referenced value is\nreturned as a plain integer. Otherwise C<undef> is returned.\n\n    $addr = refaddr \"string\";           # undef\n    $addr = refaddr \\$var;              # eg 12345678\n    $addr = refaddr [];                 # eg 23456784\n\n    $obj  = bless {}, \"Foo\";\n    $addr = refaddr $obj;               # eg 88123488\n\n=head2 reftype\n\n    my $type = reftype( $ref );\n\nIf C<$ref> is a reference the basic Perl type of the variable referenced is\nreturned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>\nis returned.\n\n    $type = reftype \"string\";           # undef\n    $type = reftype \\$var;              # SCALAR\n    $type = reftype [];                 # ARRAY\n\n    $obj  = bless {}, \"Foo\";\n    $type = reftype $obj;               # HASH\n\n=head2 weaken\n\n    weaken( $ref );\n\nThe lvalue C<$ref> will be turned into a weak reference. This means that it\nwill not hold a reference count on the object it references. Also when the\nreference count on that object reaches zero, the reference will be set to\nundef. This function mutates the lvalue passed as its argument and returns no\nvalue.\n\nThis is useful for keeping copies of references, but you don't want to prevent\nthe object being DESTROY-ed at its usual time.\n\n    {\n      my $var;\n      $ref = \\$var;\n      weaken($ref);                     # Make $ref a weak reference\n    }\n    # $ref is now undef\n\nNote that if you take a copy of a scalar with a weakened reference, the copy\nwill be a strong reference.\n\n    my $var;\n    my $foo = \\$var;\n    weaken($foo);                       # Make $foo a weak reference\n    my $bar = $foo;                     # $bar is now a strong reference\n\nThis may be less obvious in other situations, such as C<grep()>, for instance\nwhen grepping through a list of weakened references to objects that may have\nbeen destroyed already:\n\n    @object = grep { defined } @object;\n\nThis will indeed remove all references to destroyed objects, but the remaining\nreferences to objects will be strong, causing the remaining objects to never be\ndestroyed because there is now always a strong reference to them in the @object\narray.\n\n=head2 unweaken\n\n    unweaken( $ref );\n\nI<Since version 1.36.>\n\nThe lvalue C<REF> will be turned from a weak reference back into a normal\n(strong) reference again. This function mutates the lvalue passed as its\nargument and returns no value. This undoes the action performed by\nL</weaken>.\n\nThis function is slightly neater and more convenient than the\notherwise-equivalent code\n\n    my $tmp = $REF;\n    undef $REF;\n    $REF = $tmp;\n\n(because in particular, simply assigning a weak reference back to itself does\nnot work to unweaken it; C<$REF = $REF> does not work).\n\n=head2 isweak\n\n    my $weak = isweak( $ref );\n\nReturns true if C<$ref> is a weak reference.\n\n    $ref  = \\$foo;\n    $weak = isweak($ref);               # false\n    weaken($ref);\n    $weak = isweak($ref);               # true\n\nB<NOTE>: Copying a weak reference creates a normal, strong, reference.\n\n    $copy = $ref;\n    $weak = isweak($copy);              # false\n\n=head1 OTHER FUNCTIONS\n\n=head2 dualvar\n\n    my $var = dualvar( $num, $string );\n\nReturns a scalar that has the value C<$num> in a numeric context and the value\nC<$string> in a string context.\n\n    $foo = dualvar 10, \"Hello\";\n    $num = $foo + 2;                    # 12\n    $str = $foo . \" world\";             # Hello world\n\n=head2 isdual\n\n    my $dual = isdual( $var );\n\nI<Since version 1.26.>\n\nIf C<$var> is a scalar that has both numeric and string values, the result is\ntrue.\n\n    $foo = dualvar 86, \"Nix\";\n    $dual = isdual($foo);               # true\n\nNote that a scalar can be made to have both string and numeric content through\nnumeric operations:\n\n    $foo = \"10\";\n    $dual = isdual($foo);               # false\n    $bar = $foo + 0;\n    $dual = isdual($foo);               # true\n\nNote that although C<$!> appears to be dual-valued variable, it is actually\nimplemented using a tied scalar:\n\n    $! = 1;\n    print(\"$!\\n\");                      # \"Operation not permitted\"\n    $dual = isdual($!);                 # false\n\nYou can capture its numeric and string content using:\n\n    $err = dualvar $!, $!;\n    $dual = isdual($err);               # true\n\n=head2 isvstring\n\n    my $vstring = isvstring( $var );\n\nIf C<$var> is a scalar which was coded as a vstring the result is true.\n\n    $vs   = v49.46.48;\n    $fmt  = isvstring($vs) ? \"%vd\" : \"%s\"; #true\n    printf($fmt,$vs);\n\n=head2 looks_like_number\n\n    my $isnum = looks_like_number( $var );\n\nReturns true if perl thinks C<$var> is a number. See\nL<perlapi/looks_like_number>.\n\n=head2 openhandle\n\n    my $fh = openhandle( $fh );\n\nReturns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is\nis a tied handle. Otherwise C<undef> is returned.\n\n    $fh = openhandle(*STDIN);           # \\*STDIN\n    $fh = openhandle(\\*STDIN);          # \\*STDIN\n    $fh = openhandle(*NOTOPEN);         # undef\n    $fh = openhandle(\"scalar\");         # undef\n\n=head2 readonly\n\n    my $ro = readonly( $var );\n\nReturns true if C<$var> is readonly.\n\n    sub foo { readonly($_[0]) }\n\n    $readonly = foo($bar);              # false\n    $readonly = foo(0);                 # true\n\n=head2 set_prototype\n\n    my $code = set_prototype( $code, $prototype );\n\nSets the prototype of the function g", 8192) = 8192
09:01:57.156059 brk(0xf2a000)           = 0xf2a000
09:01:57.156157 lseek(10, 1406, SEEK_SET) = 1406
09:01:57.156203 lseek(10, 0, SEEK_CUR)  = 1406
09:01:57.156247 close(10)               = 0
09:01:57.156322 stat("modules/List/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.156372 stat("modules/List/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.156421 stat("modules/List/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.156469 stat("modules/List/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.156517 stat("/etc/perl/List/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.156566 stat("/etc/perl/List/Util.pm", 0x7ffe1233a950) = -1 ENOENT (No such file or directory)
09:01:57.156615 stat("/usr/local/lib/perl/5.14.2/List/Util.pmc", 0x7ffe1233aa00) = -1 ENOENT (No such file or directory)
09:01:57.156667 stat("/usr/local/lib/perl/5.14.2/List/Util.pm", {st_mode=S_IFREG|0444, st_size=16389, ...}) = 0
09:01:57.156731 open("/usr/local/lib/perl/5.14.2/List/Util.pm", O_RDONLY) = 10
09:01:57.156784 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.156831 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.156889 read(10, "# Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n#\n# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>\n\npackage List::Util;\n\nuse strict;\nrequire Exporter;\n\nour @ISA        = qw(Exporter);\nour @EXPORT_OK  = qw(\n  all any first min max minstr maxstr none notall product reduce sum sum0 shuffle\n  pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst\n);\nour $VERSION    = \"1.42\";\nour $XS_VERSION = $VERSION;\n$VERSION    = eval $VERSION;\n\nrequire XSLoader;\nXSLoader::load('List::Util', $XS_VERSION);\n\nsub import\n{\n  my $pkg = caller;\n\n  # (RT88848) Touch the caller's $a and $b, to avoid the warning of\n  #   Name \"main::a\" used only once: possible typo\" warning\n  no strict 'refs';\n  ${\"${pkg}::a\"} = ${\"${pkg}::a\"};\n  ${\"${pkg}::b\"} = ${\"${pkg}::b\"};\n\n  goto &Exporter::import;\n}\n\n# For objects returned by pairs()\nsub List::Util::_Pair::key   { shift->[0] }\nsub List::Util::_Pair::value { shift->[1] }\n\n1;\n\n__END__\n\n=head1 NAME\n\nList::Util - A selection of general-utility list subroutines\n\n=head1 SYNOPSIS\n\n    use List::Util qw(first max maxstr min minstr reduce shuffle sum);\n\n=head1 DESCRIPTION\n\nC<List::Util> contains a selection of subroutines that people have expressed\nwould be nice to have in the perl core, but the usage would not really be high\nenough to warrant the use of a keyword, and the size so small such that being\nindividual extensions would be wasteful.\n\nBy default C<List::Util> does not export any subroutines.\n\n=cut\n\n=head1 LIST-REDUCTION FUNCTIONS\n\nThe following set of functions all reduce a list down to a single value.\n\n=cut\n\n=head2 $result = reduce { BLOCK } @list\n\nReduces C<@list> by calling C<BLOCK> in a scalar context multiple times,\nsetting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>\nset to the first two elements of the list, subsequent calls will be done by\nsetting C<$a> to the result of the previous call and C<$b> to the next element\nin the list.\n\nReturns the result of the last call to the C<BLOCK>. If C<@list> is empty then\nC<undef> is returned. If C<@list> only contains one element then that element\nis returned and C<BLOCK> is not executed.\n\nThe following examples all demonstrate how C<reduce> could be used to implement\nthe other list-reduction functions in this module. (They are not in fact\nimplemented like this, but instead in a more efficient manner in individual C\nfunctions).\n\n    $foo = reduce { defined($a)            ? $a :\n                    $code->(local $_ = $b) ? $b :\n                                             undef } undef, @list # first\n\n    $foo = reduce { $a > $b ? $a : $b } 1..10       # max\n    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr\n    $foo = reduce { $a < $b ? $a : $b } 1..10       # min\n    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr\n    $foo = reduce { $a + $b } 1 .. 10               # sum\n    $foo = reduce { $a . $b } @bar                  # concat\n\n    $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any\n    $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all\n    $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none\n    $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall\n       # Note that these implementations do not fully short-circuit\n\nIf your algorithm requires that C<reduce> produce an identity value, then make\nsure that you always pass that identity value as the first argument to prevent\nC<undef> being returned\n\n  $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value\n\nThe remaining list-reduction functions are all specialisations of this generic\nidea.\n\n=head2 any\n\n    my $bool = any { BLOCK } @list;\n\nI<Since version 1.33.>\n\nSimilar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element\nof C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>\nreturn a true value. If C<BLOCK> never returns true or C<@list> was empty then\nit returns false.\n\nMany cases of using C<grep> in a conditional can be written using C<any>\ninstead, as it can short-circuit after the first true result.\n\n    if( any { length > 10 } @strings ) {\n        # at least one string has more than 10 characters\n    }\n\n=head2 all\n\n    my $bool = all { BLOCK } @list;\n\nI<Since version 1.33.>\n\nSimilar to L</any>, except that it requires all elements of the C<@list> to\nmake the C<BLOCK> return true. If any element returns false, then it returns\nfalse. If the C<BLOCK> never returns false or the C<@list> was empty then it\nreturns true.\n\n=head2 none\n\n=head2 notall\n\n    my $bool = none { BLOCK } @list;\n\n    my $bool = notall { BLOCK } @list;\n\nI<Since version 1.33.>\n\nSimilar to L</any> and L</all>, but with the return sense inverted. C<none>\nreturns true only if no value in the C<@list> causes the C<BLOCK> to return\ntrue, and C<notall> returns true only if not all of the values do.\n\n=head2 first\n\n    my $val = first { BLOCK } @list;\n\nSimilar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element\nof C<@list> in turn. C<first> returns the first element where the result from\nC<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty\nthen C<undef> is returned.\n\n    $foo = first { defined($_) } @list    # first defined value in @list\n    $foo = first { $_ > $value } @list    # first value in @list which\n                                          # is greater than $value\n\n=head2 max\n\n    my $num = max @list;\n\nReturns the entry in the list with the highest numerical value. If the list is\nempty then C<undef> is returned.\n\n    $foo = max 1..10                # 10\n    $foo = max 3,9,12               # 12\n    $foo = max @bar, @baz           # whatever\n\n=head2 maxstr\n\n    my $str = maxstr @list;\n\nSimilar to L</max>, but treats all the entries in the list as strings and\nreturns the highest string as defined by the C<gt> operator. If the list is\nempty then C<undef> is returned.\n\n    $foo = maxstr 'A'..'Z'          # 'Z'\n    $foo = maxstr \"hello\",\"world\"   # \"world\"\n    $foo = maxstr @bar, @baz        # whatever\n\n=head2 min\n\n    my $num = min @list;\n\nSimilar to L</max> but returns the entry in the list with the lowest numerical\nvalue. If the list is empty then C<undef> is returned.\n\n    $foo = min 1..10                # 1\n    $foo = min 3,9,12               # 3\n    $foo = min @bar, @baz           # whatever\n\n=head2 minstr\n\n    my $str = minstr @list;\n\nSimilar to L</min>, but treats all the entries in the list as strings and\nreturns the lowest string as defined by the C<lt> operator. If the list is\nempty then C<undef> is returned.\n\n    $foo = minstr 'A'..'Z'          # 'A'\n    $foo = minstr \"hello\",\"world\"   # \"hello\"\n    $foo = minstr @bar, @baz        # whatever\n\n=head2 product\n\n    my $num = product @list;\n\nI<Since version 1.35.>\n\nReturns the numerical product of all the elements in C<@list>. If C<@list> is\nempty then C<1> is returned.\n\n    $foo = product 1..10            # 3628800\n    $foo = product 3,9,12           # 324\n\n=head2 sum\n\n    my $num_or_undef = sum @list;\n\nReturns the numerical sum of all the elements in C<@list>. For backwards\ncompatibility, if C<@list> is empty then C<undef> is returned.\n\n    $foo = sum 1..10                # 55\n    $foo = sum 3,9,12               # 24\n    $foo = sum @bar, @baz           # whatever\n\n=head2 sum0\n\n    my $num = sum0 @list;\n\nI<Since version 1.26.>\n\nSimilar to L</sum>, except this returns 0 when given an empty list, rather\nthan C<undef>.\n\n=cut\n\n=head1 KEY/VALUE PAIR LIST FUNCTIONS\n\nThe following set of functions, all inspired by L<List::Pairwise>, consume an\neven-sized list of pairs. The pairs may be key/value associations from a hash,\nor just a list of values. The functions will all preserve the original ordering\nof the pairs, and will not be confused by multiple pairs having the same \"key\"\nvalue - nor even do they require that the first of each pair be a plain string.\n\nB<NOTE>: At the time of writing, the following C<pair*> functions that take a\nblock do not modify the value of C<$_> within the block, and instead operate\nusing the C<$a> and C<$b> globals instead. Th", 8192) = 8192
09:01:57.157420 lseek(10, 1074, SEEK_SET) = 1074
09:01:57.157471 lseek(10, 0, SEEK_CUR)  = 1074
09:01:57.157516 close(10)               = 0
09:01:57.157614 stat("/usr/local/lib/perl/5.14.2/auto/List/Util/Util.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.157678 stat("/usr/local/lib/perl/5.14.2/auto/List/Util/Util.so", {st_mode=S_IFREG|0555, st_size=212379, ...}) = 0
09:01:57.157737 stat("/usr/local/lib/perl/5.14.2/auto/List/Util/Util.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.157798 open("/usr/local/lib/perl/5.14.2/auto/List/Util/Util.so", O_RDONLY) = 10
09:01:57.157858 read(10, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20-\0\0\0\0\0\0@\0\0\0\0\0\0\0\270\31\3\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0$\0!\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\254\0\0\0\0\0\0\\\254\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0\260\0\0\0\0\0\0\0\260 \0\0\0\0\0\0\260 \0\0\0\0\0\320\5\0\0\0\0\0\0@\6\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\30\260\0\0\0\0\0\0\30\260 \0\0\0\0\0\30\260 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\270\242\0\0\0\0\0\0\270\242\0\0\0\0\0\0\270\242\0\0\0\0\0\0\24\1\0\0\0\0\0\0\24\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0c\223y\215\355 \377H\0354\v?\3t,\371\316\365\371@\0\0\0\0a\0\0\0\200\0\0\0008\0\0\0?\0\0\0@\0\0\0K\0\0\0U\0\0\0\23\0\0\0\0\0\0\0<\0\0\0d\0\0\0'\0\0\0}\0\0\0)\0\0\0\0\0\0\0L\0\0\0,\0\0\0^\0\0\0j\0\0\0;\0\0\0\0\0\0\0\21\0\0\0E\0\0\0]\0\0\0\t\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\36\0\0\0e\0\0\0\5\0\0\0B\0\0\0\0\0\0\0\0\0\0\0z\0\0\0004\0\0\0C\0\0\0\2\0\0\0\0\0\0\0`\0\0\0T\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\0\0\0|\0\0\0\"\0\0\0X\0\0\0/\0\0\0W\0\0\0\0\0\0\0\\\0\0\0005\0\0\0G\0\0\0\0\0\0\0_\0\0\0Q\0\0\0l\0\0\0\n\0\0\0Y\0\0\0\0\0\0\0=\0\0\0:\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\10\0\0\0O\0\0\0\17\0\0\0f\0\0\0 \0\0\0c\0\0\0F\0\0\0\25\0\0\0R\0\0\0H\0\0\0\0\0\0\0\0\0\0\0%\0\0\0001\0\0\0i\0\0\0\0\0\0\0\0\0\0\0J\0\0\0r\0\0\0>\0\0\0Z\0\0\0k\0\0\0\0\0\0\0\0\0\0\0b\0\0\0P\0\0\0003\0\0\0\0\0\0\0M\0\0\0[\0\0\0{\0\0\0", 832) = 832
09:01:57.157992 fstat(10, {st_mode=S_IFREG|0555, st_size=212379, ...}) = 0
09:01:57.158061 mmap(NULL, 2143808, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0x7f74342dc000
09:01:57.158113 mprotect(0x7f74342e7000, 2097152, PROT_NONE) = 0
09:01:57.158163 mmap(0x7f74344e7000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0xb000) = 0x7f74344e7000
09:01:57.158217 close(10)               = 0
09:01:57.159040 brk(0xf4b000)           = 0xf4b000
09:01:57.159358 read(9, "ugin, $alias,\n    );\n\n    return;\n}\n\n1;\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nObject::Pluggable::Pipeline - The plugin pipeline for Object::Pluggable.\n\n=head1 SYNOPSIS\n\n  use Object::Pluggable;\n  use Object::Pluggable::Pipeline;\n  use My::Plugin;\n\n  my $self = Object::Pluggable->new();\n\n  # the following operations are presented in pairs\n  # the first is the general procedure, the second is\n  # the specific way using the pipeline directly\n\n  # to install a plugin\n  $self->plugin_add(mine => My::Plugin->new);\n  $self->pipeline->push(mine => My::Plugin->new);  \n\n  # to remove a plugin\n  $self->plugin_del('mine');        # or the object\n  $self->pipeline->remove('mine');  # or the object\n\n  # to get a plugin\n  my $plug = $self->plugin_get('mine');\n  my $plug = $self->pipeline->get('mine');\n\n  # there are other very specific operations that\n  # the pipeline offers, demonstrated here:\n\n  # to get the pipeline object itself\n  my $pipe = $self->pipeline;\n\n  # to install a plugin at the front of the pipeline\n  $pipe->unshift(mine => My::Plugin->new);\n\n  # to remove the plugin at the end of the pipeline\n  my $plug = $pipe->pop;\n\n  # to remove the plugin at the front of the pipeline\n  my $plug = $pipe->shift;\n\n  # to replace a plugin with another\n  $pipe->replace(mine => newmine => My::Plugin->new);\n\n  # to insert a plugin before another\n  $pipe->insert_before(mine => newmine => My::Plugin->new);\n\n  # to insert a plugin after another\n  $pipe->insert_after(mine => newmine => My::Plugin->new);\n\n  # to get the location in the pipeline of a plugin\n  my $index = $pipe->get_index('mine');\n\n  # to move a plugin closer to the front of the pipeline\n  $pipe->bump_up('mine');\n\n  # to move a plugin closer to the end of the pipeline\n  $pipe->bump_down('mine');\n\n=head1 DESCRIPTION\n\nObject::Pluggable::Pipeline defines the Plugin pipeline system for\nL<Object::Pluggable|Object::Pluggable> instances.\n\n=head1 METHODS\n\n=head2 C<new>\n\nTakes one argument, the Object::Pluggable object to attach to.\n\n=head2 C<push>\n\nTakes at least two arguments, an alias for a plugin and the plugin object\nitself. Any extra arguments will be passed to the register method of the\nplugin object. If a plugin with that alias already exists, C<$@> will be set\nand C<undef> will be returned. Otherwise, it adds the plugin to the end of\nthe pipeline and registers it. This will yield a C<plugin_add> event. If\nsuccessful, it returns the size of the pipeline.\n\n my $new_size = $pipe->push($name, $plug, @register_args);\n\n=head2 C<unshift>\n\nTakes at least two arguments, an alias for a plugin and the plugin object\nitself. Any extra arguments will be passed to the register method of the\nplugin object. If a plugin with that alias already exists, C<$@> will be set\nand C<undef> will be returned. Otherwise, it adds the plugin to the beginning\nof the pipeline and registers it. This will yield a C<plugin_add> event. If\nsuccessful, it returns the size of the pipeline.\n\n my $new_size = $pipe->push($name, $plug, @register_args);\n\n=head2 C<shift>\n\nTakes any number of arguments. The first plugin in the pipeline is removed.\nAny arguments will be passed to the unregister method of the plugin object.\nThis will yield a C<plugin_del> event. In list context, it returns the plugin\nand its alias; in scalar context, it returns only the plugin. If there were\nno elements, an empty list or C<undef> will be returned.\n\n my ($plug, $name) = $pipe->shift(@unregister_args);\n my $plug = $pipe->shift(@unregister_args);\n\n=head2 C<pop>\n\nTakes any number of arguments. The last plugin in the pipeline is removed.\nAny arguments will be passed to the unregister method of the plugin object.\nThis will yield an C<plugin_del> event. In list context, it returns the\nplugin and its alias; in scalar context, it returns only the plugin. If\nthere were no elements, an empty list or C<undef> will be returned.\n\n my ($plug, $name) = $pipe->pop(@unregister_args);\n my $plug = $pipe->pop(@unregister_args);\n\n=head2 C<replace>\n\nTakes at least three arguments, the old plugin or its alias, an alias for the\nnew plugin and the new plugin object itself. You can optionally pass two\narray references of arguments which will be delivered to the unregister method\nof the old plugin and the register method of the new plugin, respectively.\nIf you only want to pass the latter, you can put C<undef> in place of the\nformer. If the old plugin doesn't exist, or if there is already a plugin with\nthe new alias (besides the old plugin), C<$@> will be set and C<undef> will be\nreturned. Otherwise, it removes the old plugin (yielding an C<plugin_del>\nevent) and replaces it with the new plugin. This will yield an C<plugin_add>\nevent. If successful, it returns 1.\n\n my $success = $pipe->replace($name, $new_name, $new_plug, \\@unregister_args, \\@register_args);\n my $success = $pipe->replace($plug, $new_name, $new_plug, \\@unregister_args, \\@register_args);\n\n=head2 C<insert_before>\n\nTakes at least three arguments, the plugin that is relative to the operation,\nan alias for the new plugin and the new plugin object itself. Any extra\narguments will be passed to the register method of the new plugin object. If\nthe first plugin doesn't exist, or if there is already a plugin with the new\nalias, C<$@> will be set and C<undef> will be returned. Otherwise, the new\nplugin is placed just prior to the other plugin in the pipeline. If\nsuccessful, it returns 1.\n\n my $success = $pipe->insert_before($name, $new_name, $new_plug, @register_args);\n my $success = $pipe->insert_before($plug, $new_name, $new_plug, @register_args);\n\n=head2 C<insert_after>\n\nTakes at least three arguments, the plugin that is relative to the operation,\nan alias for the new plugin and the new plugin object itself. any extra\narguments will be passed to the register method of the new plugin object. If\nthe first plugin doesn't exist, or if there is already a plugin with the new\nalias, C<$@> will be set and C<undef> will be returned. Otherwise, the new\nplugin is placed just after to the other plugin in the pipeline. If\nsuccessful, it returns 1.\n\n my $success = $pipe->insert_after($name, $new_name, $new_plug, @register_args);\n my $success = $pipe->insert_after($plug, $new_name, $new_plug, @register_args);\n\n=head2 C<bump_up>\n\nTakes one or two arguments, the plugin or its alias, and the distance to\nbump the plugin. The distance defaults to 1. If the plugin doesn't exist,\nC<$@> will be set and B<-1 will be returned, not undef>. Otherwise, the\nplugin will be moved the given distance closer to the front of the\npipeline. A warning is issued alerting you if it would have been moved\npast the beginning of the pipeline, and the plugin is placed at the\nbeginning. If successful, the new index of the plugin in the pipeline is\nreturned.\n\n my $pos = $pipe->bump_up($name);\n my $pos = $pipe->bump_up($plug);\n my $pos = $pipe->bump_up($name, $delta);\n my $pos = $pipe->bump_up($plug, $delta);\n\n=head2 C<bump_down>\n\nTakes one or two arguments, the plugin or its alias, and the distance to\nbump the plugin. The distance defaults to 1. If the plugin doesn't exist,\nC<$@> will be set and B<-1 will be returned, not C<undef>>. Otherwise, the\nplugin will be moved the given distance closer to the end of the pipeline.\nA warning is issued alerting you if it would have been moved past the end\nof the pipeline, and the plugin is placed at the end. If successful, the new\nindex of the plugin in the pipeline is returned.\n\n my $pos = $pipe->bump_down($name);\n my $pos = $pipe->bump_down($plug);\n my $pos = $pipe->bump_down($name, $delta);\n my $pos = $pipe->bump_down($plug, $delta);\n\n=head2 C<remove>\n\nTakes at least one argument, a plugin or its alias. Any arguments will be\npassed to the unregister method of the plugin object. If the plugin doesn't\nexist, C<$@> will be set and C<undef> will be returned. Otherwise, the plugin\nis removed from the pipeline. This will yield an C<plugin_del> event. In list\ncontext, it returns the plugin and its alias; in scalar context, it returns\nonly the plugin.\n\n my ($plug, $name) = $pipe->remove($the_name, @unregister_args);\n my ($plug, $name) = $pipe->remove($the_plug, @unregister_args);\n my $plug = $pipe->remove($the_name, @unregister_args);\n my $pl", 8192) = 8192
09:01:57.159793 lseek(9, 8240, SEEK_SET) = 8240
09:01:57.159843 lseek(9, 0, SEEK_CUR)   = 8240
09:01:57.159889 close(9)                = 0
09:01:57.160633 brk(0xf6c000)           = 0xf6c000
09:01:57.160853 lseek(8, 7336, SEEK_SET) = 7336
09:01:57.160900 lseek(8, 0, SEEK_CUR)   = 7336
09:01:57.160945 close(8)                = 0
09:01:57.161713 brk(0xf8d000)           = 0xf8d000
09:01:57.161881 read(7, "yndicator}{events}{$event}{$sender_id} = $sender_id;\n        $self->{_syndicator}{sessions}{$sender_id}{ref} = $sender_id;\n\n        if (!$self->{_syndicator}{sessions}{$sender_id}{refcnt}\n            && $sender_id ne $self->{_syndicator}{session_id}) {\n            $poe_kernel->refcount_increment($sender_id, REFCOUNT_TAG);\n        }\n\n        $self->{_syndicator}{sessions}{$sender_id}{refcnt}++;\n    }\n\n    # BINGOS:\n    # Apocalypse is gonna hate me for this as 'registered' events will bypass\n    # the plugin system, but I can't see how this event will be relevant\n    # without some sort of reference, like what session has registered. I'm\n    # not going to start hurling session references around at this point :)\n    $poe_kernel->post($sender_id, \"${prefix}registered\", $self);\n    return;\n}\n\nsub _syndicator_unregister {\n    my ($kernel, $self, $session, $sender, @events)\n        = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0 .. $#_];\n\n    @events = 'all' if !@events;\n    my $sender_id = $sender->ID();\n    my $prefix = $self->{_syndicator}{prefix};\n\n    for my $event (@events) {\n        my $blah = delete $self->{_syndicator}{events}{$event}{$sender_id};\n        if (!defined $blah) {\n            warn \"Sender $sender_id hasn't registered for '$event' events\";\n            next;\n        }\n        if (!keys %{ $self->{_syndicator}{events}{$event} }) {\n            delete $self->{_syndicator}{events}{$event};\n        }\n\n        if (--$self->{_syndicator}{sessions}{$sender_id}{refcnt} <= 0) {\n            delete $self->{_syndicator}{sessions}{$sender_id};\n            if ($session != $sender) {\n                $kernel->refcount_decrement($sender_id, REFCOUNT_TAG);\n            }\n        }\n    }\n\n    return;\n}\n\nsub delay {\n    my ($self, $arrayref, $time) = @_;\n\n    if (!defined $arrayref || ref $arrayref ne 'ARRAY' || !@$arrayref) {\n        croak('First argument to delay() must be a populated ARRAYREF');\n    }\n\n    croak('No time specified') if !defined $time;\n\n    return $self->call('_syndicator_delay', [@$arrayref], $time);\n}\n\nsub _syndicator_delay {\n    my ($kernel, $self, $arrayref, $time) = @_[KERNEL, OBJECT, ARG0, ARG1];\n\n    my $event = shift @$arrayref;\n    my $alarm_id = $kernel->delay_set($event, $time, @$arrayref);\n    if ($alarm_id) {\n        my $prefix = $self->{_syndicator}{prefix};\n        $self->send_event(\"${prefix}delay_set\", $alarm_id, $event, @$arrayref);\n    }\n    return $alarm_id;\n}\n\nsub delay_remove {\n    my ($self, $alarm_id) = @_;\n    croak('No alarm id specified') if !defined $alarm_id;\n    return $self->call('_syndicator_delay_remove', $alarm_id);\n}\n\nsub _syndicator_delay_remove {\n    my ($kernel, $self, $alarm_id) = @_[KERNEL, OBJECT, ARG0];\n\n    my @old_alarm_list = $kernel->alarm_remove($alarm_id);\n    if (@old_alarm_list) {\n        my $args = $old_alarm_list[-1];\n        my $prefix = $self->{_syndicator}{prefix};\n        $self->send_event(\"${prefix}delay_removed\", $alarm_id, $args);\n        return $args;\n    }\n\n    return;\n}\n\nsub call {\n    my ($self, @args) = @_;\n    return $poe_kernel->call($self->{_syndicator}{session_id}, @args);\n}\n\nsub session_id {\n    my ($self) = @_;\n    return $self->{_syndicator}{session_id};\n}\n\nsub session_alias {\n    my ($self) = @_;\n    return $self->{_syndicator}{session_alias};\n}\n\nsub send_user_event {\n    my ($self, $event, $args) = @_;\n\n    push @{ $self->{_syndicator}{pending_events} }, [];\n    my $user_type = $self->{_syndicator}{user_event};\n    my $eat = $self->_pluggable_process($user_type, $event, $args);\n    $self->call('_syndicator_send_pending_events');\n    return $eat;\n}\n\nsub send_event {\n    my ($self, $event, @args) = @_;\n    $self->yield('_syndicator_send_pending_events', $event, @args);\n    return;\n}\n\nsub send_event_now {\n    my ($self, $event, @args) = @_;\n    $self->call('_syndicator_send_pending_events', $event, @args);\n    return;\n}\n\nsub send_event_next {\n    my ($self, $event, @args) = @_;\n\n    if (!$self->{_syndicator}{pending_events}\n        || !@{ $self->{_syndicator}{pending_events} }) {\n        croak('send_event_next() can only be called from an event handler');\n    }\n    else {\n        $event =~ s/^\\Q$self->{_syndicator}{prefix}//;\n        push @{ $self->{_syndicator}{pending_events}[-1] }, [$event, \\@args];\n    }\n    return;\n}\n\nsub _syndicator_send_pending_events {\n    my ($kernel, $session, $self, $new_event, @args)\n        = @_[KERNEL, SESSION, OBJECT, ARG0, ARG1..$#_];\n    my $session_id = $session->ID();\n    my %sessions;\n    my $prefix = $self->{_syndicator}{prefix};\n\n    # create new context if we were passed an event directly\n    if (defined $new_event) {\n        $new_event =~ s/^\\Q$prefix//;\n        my @our_events = [$new_event, \\@args];\n        push @{ $self->{_syndicator}{pending_events} }, \\@our_events;\n    }\n\n    while (my ($ev) = shift @{ $self->{_syndicator}{pending_events}[-1] }) {\n        last if !defined $ev;\n        my ($event, $args) = @$ev;\n\n        my @ids = (\n            (exists $self->{_syndicator}{events}{all}\n                ? values %{ $self->{_syndicator}{events}{all} }\n                : ()),\n            (exists $self->{_syndicator}{events}{$event}\n                ? values %{ $self->{_syndicator}{events}{$event} }\n                : ()),\n        );\n\n        $sessions{$_} = $_ for @ids;\n\n        # Make sure our session gets notified of any requested events before\n        # any other bugger\n        if (delete $sessions{$session_id}) {\n            $kernel->call($session_id, \"$prefix$event\", @$args);\n        }\n\n        # then let the plugin system process this\n        my $server_type = $self->{_syndicator}{server_event};\n        if ($self->_pluggable_process($server_type, $event, $args) != PLUGIN_EAT_ALL) {\n            # and finally, let registered sessions process it\n            for my $session (values %sessions) {\n                # We have to use call() here to maintain consistency, for\n                # example if a subclass maintains state which needs to make\n                # sense at the time this event is delivered (e.g.\n                # POE::Component::IRC::State). But this is not good if the\n                # user decides to use $poe_kernel->run_while() (which\n                # POE::Quickie and LWP::UserAgent::POE do). But then again\n                # that's a risk for everyone using call(), and the user\n                # should know not to use such modules in event handlers\n                # which might get call()ed by foreign sessions.\n                $kernel->call($session, \"$prefix$event\", @$args);\n            }\n        }\n\n        # unregister all sessions if we're shutting down\n        if ($event eq 'shutdown') {\n            $self->_syndicator_unregister_sessions();\n        }\n    }\n\n    pop @{ $self->{_syndicator}{pending_events} };\n    return;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::Syndicator - A POE component base class which implements the Observer pattern\n\n=head1 SYNOPSIS\n\n package POE::Component::IRC;\n\n use strict;\n use warnings;\n use POE;\n use base 'POE::Component::Syndicator';\n\n # our constructor\n sub spawn {\n     my ($package, %args) = @_;\n\n     # process arguments...\n\n     my $self = bless \\%args, $package;\n\n     # set up our plugin system and POE session\n     $self->_syndicator_init(\n         prefix        => 'irc_',\n         reg_prefix    => 'PCI_',\n         types         => [SERVER => 'S', USER => 'U'],\n         object_states => [qw(\n             syndicator_started\n             shutdown\n         )],\n     );\n\n     return $self;\n }\n\n sub syndicator_started {\n     my ($kernel, $self) = @_[KERNEL, OBJECT];\n\n     # connect to a server, etc...\n }\n\n # plugin handler for SERVER event 'hlagh'\n sub S_hlagh {\n     # ...\n }\n\n sub shutdown {\n     my ($kernel, $self) = @_[KERNEL, OBJECT];\n\n     # disconnect from a server, etc...\n\n     # shut down the syndicator\n     $self->_syndicator_destroy();\n }\n\n=head1 DESCRIPTION\n\nPOE::Component::Syndicator is a base class for POE components which need\nto handle a persistent resource (e.g. a connection to an IRC server) for\none or more sessions in an extendable way.\n\nThis module (as well as L<Object::Pluggable|Object::Pluggable>, which this\nmodule inherits from) was born out of\nL<", 8192) = 8192
09:01:57.162822 brk(0xfae000)           = 0xfae000
09:01:57.163001 read(7, "POE::Component::IRC|POE::Component::IRC>, the guts of which quickly\nspread to other POE components. Now they can all inherit from this module\ninstead.\n\nThe component provides an event queue, which can be managed with the methods\ndocumented below. It handles delivery of events to the object itself, all\ninterested plugins, and all interested sessions.\n\n=head2 Component lifetime\n\nYou start by calling L<C<_syndicator_init>|/_syndicator_init>, which will\ncreate a POE session with your object as its heap, and a few event handlers\ninstalled. The events described in L</Local events> delimit the start and\nend of the session's lifetime. In between those, interested plugins and\nsessions will receive various events, usually starting with\nL<C<syndicator_registered>|/_syndicator_registered>. In this phase, your\nsubclass and plugins can call the L<methods|/METHODS> and send the\nL<events|/Input events> documented below. When the component has been shut\ndown, sessions (but not plugins) will receive a\nL<C<syndicator_shutdown>|/_syndicator_shutdown> event. After this, the\ncomponent will become unusable.\n\n=head2 A note on events\n\nIn this document, an I<event> (unless explicitly referred to as a I<POE event>)\nis defined as a message originating from POE::Component::Syndicator, delivered\nto plugins (and the subclass) via plugin methods and to registered sessions as\nPOE events.\n\nInterested sessions are considered consumers only, so they always receive\ncopies of event arguments, whereas interested plugins and subclasses receive\nscalar references to them. This allows them to alter, add, or remove event\narguments before sessions (or even other plugins) receive them. For more\ninformation about plugins, see L<Object::Pluggable|Object::Pluggable>'s\ndocumentation. A subclass does not have to register for plugin events.\n\nTwo event types are supported: SERVER and USER, though their names can be\noverridden (see L<C<_syndicator_init>|/_syndicator_init>).\n\n=head3 SERVER events\n\nThese represent data received from the network or some other outside resource\n(usually a server, hence the default name).\n\nSERVER events are generated by the L<C<send_event*>|/send_event> methods.\nThese events are delivered to the subclass and plugins (method C<S_foo>) and\ninterested sessions (event C<syndicator_foo>).\n\n=head3 USER events\n\nThese represent commands about to be sent to a server or some other resource.\n\nUSER events are generated by L<C<send_user_event>|/send_user_event>. In\naddition, all POE events sent to this component's session (e.g. with\nL<C<yield>|/yield>) which do not have a handler will generate corresponding\nUSER events. USER events are considered more private, so they are only\ndelivered to the subclass and plugins, not to sessions.\n\n=head1 PRIVATE METHODS\n\nThe following methods should only be called by a subclass.\n\n=head2 C<_syndicator_init>\n\nYou should call this in your constructor. It initializes\nL<Object::Pluggable|Object::Pluggable>, creates the Syndicator's POE session,\nand calls the L<C<syndicator_started>|/syndicator_started> POE events. It\ntakes the following arguments:\n\nB<'prefix'>, a prefix for all your event names, when sent to interested\nsessions. If you don't supply this, L<Object::Pluggable|Object::Pluggable>'s\ndefault (B<'pluggable'>) will be used.\n\nB<'reg_prefix'>, the prefix for the C<register()>/C<unregister()>\nplugin methods  If you don't supply this, L<Object::Pluggable|Object::Pluggable>'s\ndefault (B<'plugin_'>) will be used.\n\nB<'debug'>, a boolean, if true, will cause a warning to be printed\nevery time a plugin event handler raises an exception.\n\nB<'types'>, a 2-element arrayref of the types of events that your\ncomponent will support, or a 4-element (2 pairs) arrayref where the event\ntypes are keys and their abbrevations (used as plugin event method prefixes)\nare values (see L</A note on events> and L<Object::Pluggable|Object::Pluggable>\nfor more information). The two event types are fundamentally different, so\nmake sure you supply them in the right order. If you don't provide this\nargument, C<< [ SERVER => 'S', USER => 'U' ] >> will be used.\n\nB<'register_signal'>, the name of the register signal (see L</SIGNALS>).\nDefaults to B<'SYNDICATOR_REGISTER'>.\n\nB<'shutdown_signal'>, the name of the shutdown signal (see L</SIGNALS>).\nDefaults to B<'SYNDICATOR_SHUTDOWN'>.\n\nB<'object_states'> an arrayref of additional object states to add to\nthe POE session. Same as the 'object_states' argument to\nL<POE::Session|POE::Session>'s C<create> method. You'll want to add a handler\nfor at least the L<C<syndicator_started>|/syndicator_started> event.\n\nB<'options'>, a hash of options for L<POE::Session|POE::Session>'s\nconstructor.\n\nIf you call C<_syndicator_init> from inside another POE session, the\ncomponent will automatically register that session as wanting all events.\nThat session will first receive a\nL<C<syndicator_registered>|/syndicator_registered> event.\n\n=head2 C<_syndicator_destroy>\n\nCall this method when you want Syndicator to clean up (delete all plugins,\netc) and make sure it won't keep the POE session alive after all remaining\nevents have been processed. A L<C<syndicator_shutdown>|/syndicator_shutdown>\nevent (or similar, depending on the prefix you chose) will be generated.\nAny argument passed to C<_syndicator_destroy> will be passed along with that\nevent.\n\nB<Note:> this method will clear all alarms for the POE session.\n\n=head1 PUBLIC METHODS\n\n=head2 C<session_id>\n\nReturns the component's POE session id.\n\n=head2 C<session_alias>\n\nReturns the component's POE session alias.\n\n=head2 C<yield>\n\nThis method provides an alternative, object-based means of posting events to the\ncomponent. First argument is the event to post, following arguments are sent as\narguments to the resultant post.\n\n=head2 C<call>\n\nThis method provides an alternative, object-based means of calling events to the\ncomponent. First argument is the event to call, following arguments are sent as\narguments to the resultant call.\n\n=head2 C<send_event>\n\nAdds a new SERVER event onto the end of the queue. The event will be\nprocessed after other pending events, if any. First argument is an event name,\nthe rest are the event arguments.\n\n $component->send_event('irc_public, 'foo!bar@baz.com', ['#mychan'], 'message');\n\n=head2 C<send_event_next>\n\nAdds a new SERVER event to the start of the queue. The event will be the next\none to be processed. First argument is an event name, the rest are the event\narguments.\n\n=head2 C<send_event_now>\n\nSends a new SERVER event immediately. Execution of the current POE event will\nbe suspended (i.e. this call will block) until the new event has been\nprocessed by the component class and all plugins. First argument is an event\nname, the rest are the event arguments.\n\n=head2 C<send_user_event>\n\nSends a new USER event immediately. You should call this before every command\nyou send to your remote server/resource. Only the subclass and plugins will\nsee this event. Takes two arguments, an event name and an arrayref of\narguments. Returns one of the C<EAT> constants listed in\nL<Object::Pluggable::Constants|Object::Pluggable::Constants>. After this\nmethod returns, the arrayref's contents may have been modified by the\nsubclass or plugins.\n\n $component->send_user_event('PRIVMSG', '#mychan', 'message');\n\n=head2 C<delay>\n\nThis method provides a way of posting delayed events to the component. The\nfirst argument is an arrayref consisting of the delayed command to post and\nany command arguments. The second argument is the time in seconds that one\nwishes to delay the command being posted.\n\n my $alarm_id = $component->delay(['mode', $channel, '+o', $dude], 60);\n\n=head2 C<delay_remove>\n\nThis method removes a previously scheduled delayed event from the component.\nTakes one argument, the C<alarm_id> that was returned by a\nL<C<delay>|/delay> method call. Returns an arrayref of arguments to the\nevent that was originally requested to be delayed.\n\n my $arrayref = $component->delay_remove($alarm_id);\n\n=head1 EVENTS\n\n=head2 Local events\n\nThe component will send the following POE events to its session.\n\n=head3 C<syndicator_started>\n\nCalled after the session has been started (like C<_start> in\nL<POE::Kernel|P", 8192) = 8192
09:01:57.163422 read(7, "OE::Kernel/Session Management>. This is where you should do\nyour POE-related setup work such as adding new event handlers to the session.\n\n=head3 C<syndicator_stopped>\n\nCalled right before the session is about to die (like C<_stop> in\nL<POE::Kernel|POE::Kernel/Session Management>).\n\n=head2 Input events\n\nOther POE sessions can send the following POE events to the Syndicator's\nsession.\n\n=head3 C<register>\n\nTakes any amount of arguments: a list of event names that your session wants\nto listen for, minus the prefix (specified in\nL<C<syndicator_init>/_syndicator_init>).\n\n $kernel->post('my syndicator', 'register', qw(join part quit kick));\n\nRegistering for the special event B<'all'> will cause it to send all\nevents to your session. Calling it with no event names is equivalent to\ncalling it with B<'all'> as an argumente.\n\nRegistering will generate a L<C<syndicator_registered>|/syndicator_registered>\nevent that your session can trap.\n\nRegistering with multiple component sessions can be tricky, especially if\none wants to marry up sessions/objects, etc. Check the L<SIGNALS|/SIGNALS>\nsection for an alternative method of registering with multiple components.\n\n=head3 C<unregister>\n\nTakes any amount of arguments: a list of event names which you I<don't> want\nto receive. If you've previously done a L<C<register>|/register>\nfor a particular event which you no longer care about, this event will\ntell the component to stop sending them to you. (If you haven't, it just\nignores you. No big deal.) Calling it with no event names is equivalent to\ncalling it with B<'all'> as an argument.\n\nIf you have registered for the special event B<'all'>, attempting to\nunregister individual events will not work. This is a 'feature'.\n\n=head3 C<shutdown>\n\nBy default, POE::Component::Syndicator sessions never go away. You can send\nits session a C<shutdown> event manually to make it delete itself.\nTerminating multiple Syndicators can be tricky. Check the L</SIGNALS> section\nfor a method of doing that.\n\n=head3 C<_default>\n\nAny POE events sent to the Syndicator's session which do not have a handler\nwill go to the Syndicator's C<_default> handler, will generate\nL</USER events> of the same name. If you install your own C<_default>\nhandler, make sure you do the same thing before you handle an event:\n\n use Object::Pluggable::Constants 'PLUGIN_EAT_ALL';\n\n $poe_kernel->state('_default', $self, '__default');\n\n sub __default {\n     my ($self, $event, $args) = @_[OBJECT, ARG0, ARG1];\n\n     # do nothing if a plugin eats the event\n     return if $self->send_user_event($event, [@$args]) == PLUGIN_EAT_ALL;\n\n     # handle the event\n     # ...\n }\n\nNote that the handler for the C<_default> event must be named something other\nthan '_default', because that name is reserved for the plugin-type default\nhandler (see the L<Object::Pluggable|Object::Pluggable/PLUGINS> docs).\n\n=head2 Output events\n\nThe Syndicator will send the following events at various times. The\nB<'syndicator_'> prefix in these event names can be customized with a\nB<'prefix'> argument to L<C<_syndicator_init>/_syndicator_init>.\n\n=head3 C<syndicator_registered>\n\nSent once to the requesting session on registration (see\nL<C<register>|/register>). C<ARG0> is a reference to the component's object.\n\n=head3 C<syndicator_shutdown>\n\nSent to all interested sessions when the component has been shut down. See\nL<C<_syndicator_destroy>|/_syndicator_destroy>.\n\n=head3 C<syndicator_delay_set>\n\nSent to the subclass, plugins, and all interested sessions on a successful\naddition of a delayed event using the L<C<delay>|/delay> method. C<ARG0> will\nbe the alarm_id which can be used later with L<C<delay_remove>|/delay_remove>.\nSubsequent parameters are the arguments that were passed to L<C<delay>|/delay>.\n\n=head3 C<syndicator_delay_removed>\n\nSent to the subclass, plugins, and all interested sessions when a delayed\nevent is successfully removed. C<ARG0> will be the alarm_id that was removed.\nSubsequent parameters are the arguments that were passed to L<C<delay>|/delay>.\n\n=head3 All other events\n\nAll other events sent by the Syndicator are USER events (generated with\nL<C<send_user_event>|/send_user_event>) and SERVER events (generated with\nL<C<send_event*>|/send_event>) which will be delivered normally. Your\nsubclass and plugins are responsible for generating them.\n\n=head1 SIGNALS\n\nThe component will handle a number of custom signals that you may send using\nL<POE::Kernel|POE::Kernel>'s C<signal> method. They allow any session to\ncommunicate with every instance of the component in certain ways without\nhaving references to their objects or knowing about their sessions. The names\nof these signals can be customized with\nL<C<_syndicator_init>|/_syndicator_init>.\n\n=head2 C<SYNDICATOR_REGISTER>\n\nRegisters for an event with the component. See L<C<register>|/register>.\n\n=head2 C<SYNDICATOR_SHUTDOWN>\n\nCauses a 'shutdown' event to be sent to your session. Any arguments to the\nsignal will be passed along to the event. That's where you should clean up\nand call L<C<_syndicator_destroy>|/_syndicator_destroy>.\n\n=head1 AUTHOR\n\nHinrik E<Ouml>rn SigurE<eth>sson, L<hinrik.sig@gmail.com>,\nChris C<BinGOs> Williams L<chris@bingosnet.co.uk>,\nApocalypse L<apocal@cpan.org>, and probably others.\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright 2011 Hinrik E<Ouml>rn SigurE<eth>sson\n\nThis program is free software, you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=cut\n", 8192) = 5442
09:01:57.163716 read(7, "", 8192)       = 0
09:01:57.163764 close(7)                = 0
09:01:57.163959 stat("modules/POE/Component/SSLify.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.164013 stat("modules/POE/Component/SSLify.pm", {st_mode=S_IFREG|0600, st_size=35267, ...}) = 0
09:01:57.164072 open("modules/POE/Component/SSLify.pm", O_RDONLY) = 7
09:01:57.164124 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b9c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.164171 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.164230 read(7, "#\n# This file is part of POE-Component-SSLify\n#\n# This software is copyright (c) 2014 by Apocalypse.\n#\n# This is free software; you can redistribute it and/or modify it under\n# the same terms as the Perl 5 programming language system itself.\n#\nuse strict; use warnings;\npackage POE::Component::SSLify;\n# git description: release-1.011-1-g57b6383\n$POE::Component::SSLify::VERSION = '1.012';\nour $AUTHORITY = 'cpan:APOCAL';\n\n# ABSTRACT: Makes using SSL in the world of POE easy!\n\nBEGIN {\n\t# should fix netbsd smoke failures, thanks BinGOs!\n\t# <BinGOs> Apocal: okay cores with a 0.9.7d I've built myself from source. Doesn't if I comment out engine lines.\n\t# BinGOs did an awesome job building various versions of openssl to try and track down the problem, it seems like\n\t# newer versions of openssl worked fine on netbsd, but I don't want to do crazy stuff like probing openssl versions\n\t# as it's fragile - best to let the user figure it out :)\n\t#\n\t# see http://www.cpantesters.org/cpan/report/1a660280-6eb1-11e0-a462-e9956c33433b\n\t# http://www.cpantesters.org/cpan/report/49a9f2aa-6df2-11e0-a462-e9956c33433b\n\t# http://www.cpantesters.org/cpan/report/78d9a234-6df5-11e0-a462-e9956c33433b\n\t# and many other reports :(\n\t#\n\t#(gdb) bt\n\t##0  0xbd9d3e7e in engine_table_select () from /usr/lib/libcrypto.so.2\n\t##1  0xbd9b3bed in ENGINE_get_default_RSA () from /usr/lib/libcrypto.so.2\n\t##2  0xbd9b1f6d in RSA_new_method () from /usr/lib/libcrypto.so.2\n\t##3  0xbd9b1cf6 in RSA_new () from /usr/lib/libcrypto.so.2\n\t##4  0xbd9cf8a1 in RSAPrivateKey_asn1_meth () from /usr/lib/libcrypto.so.2\n\t##5  0xbd9da64b in ASN1_item_ex_new () from /usr/lib/libcrypto.so.2\n\t##6  0xbd9da567 in ASN1_item_ex_new () from /usr/lib/libcrypto.so.2\n\t##7  0xbd9d88cc in ASN1_item_ex_d2i () from /usr/lib/libcrypto.so.2\n\t##8  0xbd9d8437 in ASN1_item_d2i () from /usr/lib/libcrypto.so.2\n\t##9  0xbd9cf8d5 in d2i_RSAPrivateKey () from /usr/lib/libcrypto.so.2\n\t##10 0xbd9ad546 in d2i_PrivateKey () from /usr/lib/libcrypto.so.2\n\t##11 0xbd995e63 in PEM_read_bio_PrivateKey () from /usr/lib/libcrypto.so.2\n\t##12 0xbd980430 in PEM_read_bio_RSAPrivateKey () from /usr/lib/libcrypto.so.2\n\t##13 0xbda2e9dc in SSL_CTX_use_RSAPrivateKey_file () from /usr/lib/libssl.so.3\n\t##14 0xbda5aabe in XS_Net__SSLeay_CTX_use_RSAPrivateKey_file (cv=0x8682c80)\n\t#    at SSLeay.c:1716\n\t##15 0x08115401 in Perl_pp_entersub () at pp_hot.c:2885\n\t##16 0x080e0ab7 in Perl_runops_debug () at dump.c:2049\n\t##17 0x08078624 in S_run_body (oldscope=1) at perl.c:2308\n\t##18 0x08077ef2 in perl_run (my_perl=0x823f030) at perl.c:2233\n\t##19 0x0805e321 in main (argc=3, argv=0xbfbfe6a0, env=0xbfbfe6b0)\n\t#    at perlmain.c:117\n\t##20 0x0805e0c6 in ___start ()\n\t#(gdb)\n\tif ( ! defined &LOAD_SSL_ENGINES ) { *LOAD_SSL_ENGINES = sub () { 0 } }\n}\n\n# We need Net::SSLeay or all's a failure!\nBEGIN {\n\t# We need >= 1.36 because it contains a lot of important fixes\n\teval \"use Net::SSLeay 1.36 qw( die_now die_if_ssl_error FILETYPE_PEM )\";\n\n\t# Check for errors...\n\tif ( $@ ) {\n\t\t# Oh boy!\n\t\tdie $@;\n\t} else {\n\t\t# Finally, load our subclasses :)\n\t\t# ClientHandle isa ServerHandle so it will get loaded automatically\n\t\trequire POE::Component::SSLify::ClientHandle;\n\n\t\t# Initialize Net::SSLeay\n\t\t# Taken from http://search.cpan.org/~flora/Net-SSLeay-1.36/lib/Net/SSLeay.pm#Low_level_API\n\t\tNet::SSLeay::load_error_strings();\n\t\tNet::SSLeay::SSLeay_add_ssl_algorithms();\n\t\tif ( LOAD_SSL_ENGINES ) {\n\t\t\tNet::SSLeay::ENGINE_load_builtin_engines();\n\t\t\tNet::SSLeay::ENGINE_register_all_complete();\n\t\t}\n\t\tNet::SSLeay::randomize();\n\t}\n}\n\n# Do the exporting magic...\nuse parent 'Exporter';\nour @EXPORT_OK = qw(\n\tClient_SSLify Server_SSLify\n\tSSLify_Options SSLify_GetCTX SSLify_GetCipher SSLify_GetSocket SSLify_GetSSL SSLify_ContextCreate SSLify_GetStatus\n);\n\n# Bring in some socket-related stuff\nuse Symbol qw( gensym );\n\n# we need IO 1.24 for it's win32 fixes but it includes IO::Handle 1.27_02 which is dev...\n# unfortunately we have to jump to IO 1.25 which includes IO::Handle 1.28... argh!\nuse IO::Handle 1.28;\n\n# Use Scalar::Util's weaken() for the connref stuff\nuse Scalar::Util qw( weaken );\nuse Task::Weaken 1.03; # to make sure it actually works!\n\n# load POE ( just to fool dzil AutoPrereqs :)\nrequire POE;\n\n# The server-side CTX stuff\nmy $ctx;\n\n# global so users of this module can override it locally\nour $IGNORE_SSL_ERRORS = 0;\n\n#pod =func Client_SSLify\n#pod\n#pod This function sslifies a client-side socket. You can pass several options to it:\n#pod\n#pod \tmy $socket = shift;\n#pod \t$socket = Client_SSLify( $socket, $version, $options, $ctx, $callback );\n#pod \t\t$socket is the non-ssl socket you got from somewhere ( required )\n#pod \t\t$version is the SSL version you want to use\n#pod \t\t$options is the SSL options you want to use\n#pod \t\t$ctx is the custom SSL context you want to use\n#pod \t\t$callback is the callback hook on success/failure of sslification\n#pod\n#pod \t\t# This is an example of the callback and you should pass it as Client_SSLify( $socket, ... , \\&callback );\n#pod \t\tsub callback {\n#pod \t\t\tmy( $socket, $status, $errval ) = @_;\n#pod \t\t\t# $socket is the original sslified socket in case you need to play with it\n#pod \t\t\t# $status is either 1 or 0; with 1 signifying success and 0 failure\n#pod \t\t\t# $errval will be defined if $status == 0; it's the numeric SSL error code\n#pod \t\t\t# check http://www.openssl.org/docs/ssl/SSL_get_error.html for the possible error values ( and import them from Net::SSLeay! )\n#pod\n#pod \t\t\t# The return value from the callback is discarded\n#pod \t\t}\n#pod\n#pod If $ctx is defined, SSLify will ignore $version and $options. Otherwise, it will be created from the $version and\n#pod $options parameters. If all of them are undefined, it will follow the defaults in L</SSLify_ContextCreate>.\n#pod\n#pod BEWARE: If you passed in a CTX, SSLify will do Net::SSLeay::CTX_free( $ctx ) when the\n#pod socket is destroyed. This means you cannot reuse contexts!\n#pod\n#pod NOTE: The way to have a client socket with proper certificates set up is:\n#pod\n#pod \tmy $socket = shift;\t# get the socket from somewhere\n#pod \tmy $ctx = SSLify_ContextCreate( 'server.key', 'server.crt' );\n#pod \t$socket = Client_SSLify( $socket, undef, undef, $ctx );\n#pod\n#pod NOTE: You can pass the callback anywhere in the arguments, we'll figure it out for you! If you want to call a POE event, please look\n#pod into the postback/callback stuff in L<POE::Session>.\n#pod\n#pod \t# we got this from POE::Wheel::SocketFactory\n#pod \tsub event_SuccessEvent {\n#pod \t\tmy $socket = $_[ARG0];\n#pod \t\t$socket = Client_SSLify( $socket, $_[SESSION]->callback( 'sslify_result' ) );\n#pod \t\t$_[HEAP]->{client} = POE::Wheel::ReadWrite->new(\n#pod \t\t\tHandle => $socket,\n#pod \t\t\t...\n#pod \t\t);\n#pod \t\treturn;\n#pod \t}\n#pod\n#pod \t# the callback event\n#pod \tsub event_sslify_result {\n#pod \t\tmy ($creation_args, $called_args) = @_[ARG0, ARG1];\n#pod \t\tmy( $socket, $status, $errval ) = @$called_args;\n#pod\n#pod \t\tif ( $status ) {\n#pod \t\t\tprint \"Yay, SSLification worked!\";\n#pod \t\t} else {\n#pod \t\t\tprint \"Aw, SSLification failed with error $errval\";\n#pod \t\t}\n#pod \t}\n#pod =cut\n\nsub Client_SSLify {\n\t# Get the socket + version + options + ctx + callback\n\tmy( $socket, $version, $options, $custom_ctx, $callback ) = @_;\n\n\t# Validation...\n\tif ( ! defined $socket ) {\n\t\tdie \"Did not get a defined socket\";\n\t}\n\n\t# Mangle the callback stuff\n\tif ( defined $version and ref $version and ref( $version ) eq 'CODE' ) {\n\t\t$callback = $version;\n\t\t$version = $options = $custom_ctx = undef;\n\t} elsif ( defined $options and ref $options and ref( $options ) eq 'CODE' ) {\n\t\t$callback = $options;\n\t\t$options = $custom_ctx = undef;\n\t} elsif ( defined $custom_ctx and ref $custom_ctx and ref( $custom_ctx ) eq 'CODE' ) {\n\t\t$callback = $custom_ctx;\n\t\t$custom_ctx = undef;\n\t}\n\n\t# From IO::Handle POD\n\t# If an error occurs blocking will return undef and $! will be set.\n\tif ( ! defined $socket->blocking( 0 ) ) {\n\t\tdie \"Unable to set nonblocking mode on socket: $!\";\n\t}\n\n\t# Now, we create the new socket and bind it to our subclass of Net::SSLeay::Handle\n\tmy $newsock = gensym();\n\ttie( *$newsock, 'POE::Component::SSLify::ClientHandle', $socket, $version, $options, $custom_ctx, $callback ) or die \"Unable to tie to our ", 8192) = 8192
09:01:57.164772 stat("modules/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.164825 stat("modules/Net/SSLeay.pm", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.164874 stat("modules/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.164923 stat("modules/Net/SSLeay.pm", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.164972 stat("/etc/perl/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.165023 stat("/etc/perl/Net/SSLeay.pm", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.165074 stat("/usr/local/lib/perl/5.14.2/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.165126 stat("/usr/local/lib/perl/5.14.2/Net/SSLeay.pm", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.165179 stat("/usr/local/share/perl/5.14.2/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.165235 stat("/usr/local/share/perl/5.14.2/Net/SSLeay.pm", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.165286 stat("/usr/lib/perl5/Net/SSLeay.pmc", 0x7ffe1233b0e0) = -1 ENOENT (No such file or directory)
09:01:57.165337 stat("/usr/lib/perl5/Net/SSLeay.pm", {st_mode=S_IFREG|0644, st_size=50919, ...}) = 0
09:01:57.165396 open("/usr/lib/perl5/Net/SSLeay.pm", O_RDONLY) = 8
09:01:57.165449 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233adc0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.165495 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.165558 read(8, "# Net::SSLeay.pm - Perl module for using Eric Young's implementation of SSL\n#\n# Copyright (c) 1996-2003 Sampo Kellomaki <sampo@iki.fi>, All Rights Reserved.\n# Copyright (C) 2005 Florian Ragwitz <rafl@debian.org>, All Rights Reserved.\n# Copyright (C) 2005 Mike McCauley <mikem@open.com.au>, All Rights Reserved.\n#\n# $Id: SSLeay.pm 342 2012-04-25 07:00:45Z mikem-guest $\n#\n# Change data removed from here. See Changes\n# The distribution and use of this module are subject to the conditions\n# listed in LICENSE file at the root of OpenSSL-0.9.7b\n# distribution (i.e. free, but mandatory attribution and NO WARRANTY).\n\npackage Net::SSLeay;\n\nuse strict;\nuse Carp;\nuse vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD $CRLF);\nuse Socket;\nuse Errno;\nrequire 5.005_000;\n\nrequire Exporter;\nuse AutoLoader;\n\n# 0=no warns, 1=only errors, 2=ciphers, 3=progress, 4=dump data\n$Net::SSLeay::trace = 0;  # Do not change here, use\n                          # $Net::SSLeay::trace = [1-4]  in caller\n\n# 2 = insist on v2 SSL protocol\n# 3 = insist on v3 SSL\n# 10 = insist on TLSv1\n# 0 or undef = guess (v23)\n#\n$Net::SSLeay::ssl_version = 0;  # don't change here, use \n                                # Net::SSLeay::version=[2,3,0] in caller\n\n#define to enable the \"cat /proc/$$/stat\" stuff\n$Net::SSLeay::linux_debug = 0;\n\n# Number of seconds to sleep after sending message and before half\n# closing connection. Useful with antiquated broken servers.\n$Net::SSLeay::slowly = 0;\n\n# RANDOM NUMBER INITIALIZATION\n#\n# Edit to your taste. Using /dev/random would be more secure, but may\n# block if randomness is not available, thus the default is\n# /dev/urandom. $how_random determines how many bits of randomness to take\n# from the device. You should take enough (read SSLeay/doc/rand), but\n# beware that randomness is limited resource so you should not waste\n# it either or you may end up with randomness depletion (situation where\n# /dev/random would block and /dev/urandom starts to return predictable\n# numbers).\n#\n# N.B. /dev/urandom does not exit on all systems, such as Solaris 2.6. In that\n#      case you should get a third party package that emulates /dev/urandom\n#      (e.g. via named pipe) or supply a random number file. Some such\n#      packages are documented in Caveat section of the POD documentation.\n\n$Net::SSLeay::random_device = '/dev/urandom';\n$Net::SSLeay::how_random = 512;\n\n$VERSION = '1.48';\n@ISA = qw(Exporter);\n\n#BEWARE:\n# 3-columns part of @EXPORT_OK related to constants is the output of command:\n# perl helper_script/regen_openssl_constants.pl -gen-pod\n# if you add/remove any constant you need to update it manually\n\n@EXPORT_OK = qw(\n ASN1_STRFLGS_ESC_CTRL           NID_hmacWithSHA1                       OP_CRYPTOPRO_TLSEXT_BUG\n ASN1_STRFLGS_ESC_MSB            NID_id_ad                              OP_DONT_INSERT_EMPTY_FRAGMENTS\n ASN1_STRFLGS_ESC_QUOTE          NID_id_ce                              OP_EPHEMERAL_RSA\n ASN1_STRFLGS_RFC2253            NID_id_kp                              OP_LEGACY_SERVER_CONNECT\n CB_ACCEPT_EXIT                  NID_id_pbkdf2                          OP_MICROSOFT_BIG_SSLV3_BUFFER\n CB_ACCEPT_LOOP                  NID_id_pe                              OP_MICROSOFT_SESS_ID_BUG\n CB_CONNECT_EXIT                 NID_id_pkix                            OP_MSIE_SSLV2_RSA_PADDING\n CB_CONNECT_LOOP                 NID_id_qt_cps                          OP_NETSCAPE_CA_DN_BUG\n ERROR_NONE                      NID_id_qt_unotice                      OP_NETSCAPE_CHALLENGE_BUG\n ERROR_SSL                       NID_idea_cbc                           OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG\n ERROR_SYSCALL                   NID_idea_cfb64                         OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\n ERROR_WANT_ACCEPT               NID_idea_ecb                           OP_NON_EXPORT_FIRST\n ERROR_WANT_CONNECT              NID_idea_ofb64                         OP_NO_COMPRESSION\n ERROR_WANT_READ                 NID_info_access                        OP_NO_QUERY_MTU\n ERROR_WANT_WRITE                NID_initials                           OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n ERROR_WANT_X509_LOOKUP          NID_invalidity_date                    OP_NO_SSLv2\n ERROR_ZERO_RETURN               NID_issuer_alt_name                    OP_NO_SSLv3\n EVP_PKS_DSA                     NID_keyBag                             OP_NO_TICKET\n EVP_PKS_EC                      NID_key_usage                          OP_NO_TLSv1\n EVP_PKS_RSA                     NID_localKeyID                         OP_NO_TLSv1_1\n EVP_PKT_ENC                     NID_localityName                       OP_NO_TLSv1_2\n EVP_PKT_EXCH                    NID_md2                                OP_PKCS1_CHECK_1\n EVP_PKT_EXP                     NID_md2WithRSAEncryption               OP_PKCS1_CHECK_2\n EVP_PKT_SIGN                    NID_md5                                OP_SINGLE_DH_USE\n EVP_PK_DH                       NID_md5WithRSA                         OP_SINGLE_ECDH_USE\n EVP_PK_DSA                      NID_md5WithRSAEncryption               OP_SSLEAY_080_CLIENT_DH_BUG\n EVP_PK_EC                       NID_md5_sha1                           OP_SSLREF2_REUSE_CERT_TYPE_BUG\n EVP_PK_RSA                      NID_mdc2                               OP_TLS_BLOCK_PADDING_BUG\n FILETYPE_ASN1                   NID_mdc2WithRSA                        OP_TLS_D5_BUG\n FILETYPE_PEM                    NID_ms_code_com                        OP_TLS_ROLLBACK_BUG\n F_CLIENT_CERTIFICATE            NID_ms_code_ind                        READING\n F_CLIENT_HELLO                  NID_ms_ctl_sign                        RECEIVED_SHUTDOWN\n F_CLIENT_MASTER_KEY             NID_ms_efs                             RSA_3\n F_D2I_SSL_SESSION               NID_ms_ext_req                         RSA_F4\n F_GET_CLIENT_FINISHED           NID_ms_sgc                             R_BAD_AUTHENTICATION_TYPE\n F_GET_CLIENT_HELLO              NID_name                               R_BAD_CHECKSUM\n F_GET_CLIENT_MASTER_KEY         NID_netscape                           R_BAD_MAC_DECODE\n F_GET_SERVER_FINISHED           NID_netscape_base_url                  R_BAD_RESPONSE_ARGUMENT\n F_GET_SERVER_HELLO              NID_netscape_ca_policy_url             R_BAD_SSL_FILETYPE\n F_GET_SERVER_VERIFY             NID_netscape_ca_revocation_url         R_BAD_SSL_SESSION_ID_LENGTH\n F_I2D_SSL_SESSION               NID_netscape_cert_extension            R_BAD_STATE\n F_READ_N                        NID_netscape_cert_sequence             R_BAD_WRITE_RETRY\n F_REQUEST_CERTIFICATE           NID_netscape_cert_type                 R_CHALLENGE_IS_DIFFERENT\n F_SERVER_HELLO                  NID_netscape_comment                   R_CIPHER_TABLE_SRC_ERROR\n F_SSL_CERT_NEW                  NID_netscape_data_type                 R_INVALID_CHALLENGE_LENGTH\n F_SSL_GET_NEW_SESSION           NID_netscape_renewal_url               R_NO_CERTIFICATE_SET\n F_SSL_NEW                       NID_netscape_revocation_url            R_NO_CERTIFICATE_SPECIFIED\n F_SSL_READ                      NID_netscape_ssl_server_name           R_NO_CIPHER_LIST\n F_SSL_RSA_PRIVATE_DECRYPT       NID_ns_sgc                             R_NO_CIPHER_MATCH\n F_SSL_RSA_PUBLIC_ENCRYPT        NID_organizationName                   R_NO_PRIVATEKEY\n F_SSL_SESSION_NEW               NID_organizationalUnitName             R_NO_PUBLICKEY\n F_SSL_SESSION_PRINT_FP          NID_pbeWithMD2AndDES_CBC               R_NULL_SSL_CTX\n F_SSL_SET_FD                    NID_pbeWithMD2AndRC2_CBC               R_PEER_DID_NOT_RETURN_A_CERTIFICATE\n F_SSL_SET_RFD                   NID_pbeWithMD5AndCast5_CBC             R_PEER_ERROR\n F_SSL_SET_WFD                   NID_pbeWithMD5AndDES_CBC               R_PEER_ERROR_CERTIFICATE\n F_SSL_USE_CERTIFICATE           NID_pbeWithMD5AndRC2_CBC               R_PEER_ERROR_NO_CIPHER\n F_SSL_USE_CERTIFICATE_ASN1      NID_pbeWithSHA1AndDES_CBC              R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE\n F_SSL_USE_CERTIFICATE_FILE      NID_pbeWithSHA1AndRC2_CBC              R_PUBLIC_KEY_ENCRYPT_ERROR\n F_SSL_USE_PRIVATEKEY            NID_pbe_WithSHA1And128BitRC2_CBC       R_PUBLIC_KEY_IS_NOT_RSA\n F_SSL_USE_PRIVATEKEY_ASN1       NID_pbe_WithSHA1A", 8192) = 8192
09:01:57.166380 stat("/usr/lib/perl5/auto/Net/SSLeay/autosplit.ix", {st_mode=S_IFREG|0644, st_size=1581, ...}) = 0
09:01:57.166449 open("/usr/lib/perl5/auto/Net/SSLeay/autosplit.ix", O_RDONLY) = 9
09:01:57.166503 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a790) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.166550 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.166608 brk(0xfcf000)           = 0xfcf000
09:01:57.166662 read(9, "# Index created by AutoSplit for blib/lib/Net/SSLeay.pm\n#    (file acts as timestamp)\npackage Net::SSLeay;\nsub want_nothing  ;\nsub want_read  ;\nsub want_write  ;\nsub want_X509_lookup  ;\nsub open_tcp_connection  ;\nsub open_proxy_tcp_connection  ;\nsub debug_read  ;\nsub ssl_read_all  ;\nsub tcp_read_all  ;\nsub ssl_write_all  ;\nsub tcp_write_all  ;\nsub ssl_read_until  ($;$$);\nsub tcp_read_until  ;\nsub ssl_read_CRLF  ($;$);\nsub tcp_read_CRLF  ;\nsub ssl_write_CRLF  ($$);\nsub tcp_write_CRLF  ;\nsub dump_peer_certificate  ($);\nsub randomize  (;$$$);\nsub new_x_ctx  ;\nsub initialize \n;\nsub sslcat  ;\nsub tcpcat  ;\nsub tcpxcat  ;\nsub https_cat  ;\nsub http_cat  ;\nsub httpx_cat  ;\nsub set_cert_and_key  ($$$);\nsub set_server_cert_and_key  ($$$);\nsub set_proxy  ($$;**);\nsub make_form  ;\nsub make_headers  ;\nsub do_httpx3  ;\nsub do_https3  ;\nsub do_httpx2  ;\nsub do_https2  ;\nsub do_httpx4  ;\nsub do_https4  ;\nsub get_https   ;\nsub post_https  ;\nsub put_https   ;\nsub head_https  ;\nsub get_https3   ;\nsub post_https3  ;\nsub put_https3   ;\nsub head_https3  ;\nsub get_https4   ;\nsub post_https4  ;\nsub put_https4   ;\nsub head_https4  ;\nsub get_http   ;\nsub post_http  ;\nsub put_http   ;\nsub head_http  ;\nsub get_http3   ;\nsub post_http3  ;\nsub put_http3   ;\nsub head_http3  ;\nsub get_http4   ;\nsub post_http4  ;\nsub put_http4   ;\nsub head_http4  ;\nsub get_httpx   ;\nsub post_httpx  ;\nsub put_httpx   ;\nsub head_httpx  ;\nsub get_httpx3   ;\nsub post_httpx3  ;\nsub put_httpx3   ;\nsub head_httpx3  ;\nsub get_httpx4   ;\nsub post_httpx4  ;\nsub put_httpx4   ;\nsub head_httpx4  ;\nsub do_https  ;\n1;\n", 8192) = 1581
09:01:57.166944 read(9, "", 8192)       = 0
09:01:57.166993 close(9)                = 0
09:01:57.167108 read(8, "nd128BitRC4           R_READ_WRONG_PACKET_TYPE\n F_SSL_USE_PRIVATEKEY_FILE       NID_pbe_WithSHA1And2_Key_TripleDES_CBC R_SHORT_READ\n F_SSL_USE_RSAPRIVATEKEY         NID_pbe_WithSHA1And3_Key_TripleDES_CBC R_SSL_SESSION_ID_IS_DIFFERENT\n F_SSL_USE_RSAPRIVATEKEY_ASN1    NID_pbe_WithSHA1And40BitRC2_CBC        R_UNABLE_TO_EXTRACT_PUBLIC_KEY\n F_SSL_USE_RSAPRIVATEKEY_FILE    NID_pbe_WithSHA1And40BitRC4            R_UNKNOWN_REMOTE_ERROR_TYPE\n F_WRITE_PENDING                 NID_pbes2                              R_UNKNOWN_STATE\n GEN_DIRNAME                     NID_pbmac1                             R_X509_LIB\n GEN_DNS                         NID_pkcs                               SENT_SHUTDOWN\n GEN_EDIPARTY                    NID_pkcs3                              SESSION_ASN1_VERSION\n GEN_EMAIL                       NID_pkcs7                              ST_ACCEPT\n GEN_IPADD                       NID_pkcs7_data                         ST_BEFORE\n GEN_OTHERNAME                   NID_pkcs7_digest                       ST_CONNECT\n GEN_RID                         NID_pkcs7_encrypted                    ST_INIT\n GEN_URI                         NID_pkcs7_enveloped                    ST_OK\n GEN_X400                        NID_pkcs7_signed                       ST_READ_BODY\n MBSTRING_ASC                    NID_pkcs7_signedAndEnveloped           ST_READ_HEADER\n MBSTRING_BMP                    NID_pkcs8ShroudedKeyBag                VERIFY_CLIENT_ONCE\n MBSTRING_FLAG                   NID_pkcs9                              VERIFY_FAIL_IF_NO_PEER_CERT\n MBSTRING_UNIV                   NID_pkcs9_challengePassword            VERIFY_NONE\n MBSTRING_UTF8                   NID_pkcs9_contentType                  VERIFY_PEER\n MIN_RSA_MODULUS_LENGTH_IN_BYTES NID_pkcs9_countersignature             WRITING\n NID_OCSP_sign                   NID_pkcs9_emailAddress                 X509_LOOKUP\n NID_SMIMECapabilities           NID_pkcs9_extCertAttributes            X509_PURPOSE_ANY\n NID_X500                        NID_pkcs9_messageDigest                X509_PURPOSE_CRL_SIGN\n NID_X509                        NID_pkcs9_signingTime                  X509_PURPOSE_NS_SSL_SERVER\n NID_ad_OCSP                     NID_pkcs9_unstructuredAddress          X509_PURPOSE_OCSP_HELPER\n NID_ad_ca_issuers               NID_pkcs9_unstructuredName             X509_PURPOSE_SMIME_ENCRYPT\n NID_algorithm                   NID_private_key_usage_period           X509_PURPOSE_SMIME_SIGN\n NID_authority_key_identifier    NID_rc2_40_cbc                         X509_PURPOSE_SSL_CLIENT\n NID_basic_constraints           NID_rc2_64_cbc                         X509_PURPOSE_SSL_SERVER\n NID_bf_cbc                      NID_rc2_cbc                            X509_PURPOSE_TIMESTAMP_SIGN\n NID_bf_cfb64                    NID_rc2_cfb64                          X509_TRUST_COMPAT\n NID_bf_ecb                      NID_rc2_ecb                            X509_TRUST_EMAIL\n NID_bf_ofb64                    NID_rc2_ofb64                          X509_TRUST_OBJECT_SIGN\n NID_cast5_cbc                   NID_rc4                                X509_TRUST_OCSP_REQUEST\n NID_cast5_cfb64                 NID_rc4_40                             X509_TRUST_OCSP_SIGN\n NID_cast5_ecb                   NID_rc5_cbc                            X509_TRUST_SSL_CLIENT\n NID_cast5_ofb64                 NID_rc5_cfb64                          X509_TRUST_SSL_SERVER\n NID_certBag                     NID_rc5_ecb                            X509_TRUST_TSA\n NID_certificate_policies        NID_rc5_ofb64                          X509_V_FLAG_ALLOW_PROXY_CERTS\n NID_client_auth                 NID_ripemd160                          X509_V_FLAG_CB_ISSUER_CHECK\n NID_code_sign                   NID_ripemd160WithRSA                   X509_V_FLAG_CHECK_SS_SIGNATURE\n NID_commonName                  NID_rle_compression                    X509_V_FLAG_CRL_CHECK\n NID_countryName                 NID_rsa                                X509_V_FLAG_CRL_CHECK_ALL\n NID_crlBag                      NID_rsaEncryption                      X509_V_FLAG_EXPLICIT_POLICY\n NID_crl_distribution_points     NID_rsadsi                             X509_V_FLAG_EXTENDED_CRL_SUPPORT\n NID_crl_number                  NID_safeContentsBag                    X509_V_FLAG_IGNORE_CRITICAL\n NID_crl_reason                  NID_sdsiCertificate                    X509_V_FLAG_INHIBIT_ANY\n NID_delta_crl                   NID_secretBag                          X509_V_FLAG_INHIBIT_MAP\n NID_des_cbc                     NID_serialNumber                       X509_V_FLAG_NOTIFY_POLICY\n NID_des_cfb64                   NID_server_auth                        X509_V_FLAG_POLICY_CHECK\n NID_des_ecb                     NID_sha                                X509_V_FLAG_POLICY_MASK\n NID_des_ede                     NID_sha1                               X509_V_FLAG_USE_CHECK_TIME\n NID_des_ede3                    NID_sha1WithRSA                        X509_V_FLAG_USE_DELTAS\n NID_des_ede3_cbc                NID_sha1WithRSAEncryption              X509_V_FLAG_X509_STRICT\n NID_des_ede3_cfb64              NID_shaWithRSAEncryption               X509_V_OK\n NID_des_ede3_ofb64              NID_stateOrProvinceName                XN_FLAG_COMPAT\n NID_des_ede_cbc                 NID_subject_alt_name                   XN_FLAG_DN_REV\n NID_des_ede_cfb64               NID_subject_key_identifier             XN_FLAG_DUMP_UNKNOWN_FIELDS\n NID_des_ede_ofb64               NID_surname                            XN_FLAG_FN_ALIGN\n NID_des_ofb64                   NID_sxnet                              XN_FLAG_FN_LN\n NID_description                 NID_time_stamp                         XN_FLAG_FN_MASK\n NID_desx_cbc                    NID_title                              XN_FLAG_FN_NONE\n NID_dhKeyAgreement              NID_undef                              XN_FLAG_FN_OID\n NID_dnQualifier                 NID_uniqueIdentifier                   XN_FLAG_FN_SN\n NID_dsa                         NID_x509Certificate                    XN_FLAG_MULTILINE\n NID_dsaWithSHA                  NID_x509Crl                            XN_FLAG_ONELINE\n NID_dsaWithSHA1                 NID_zlib_compression                   XN_FLAG_RFC2253\n NID_dsaWithSHA1_2               NOTHING                                XN_FLAG_SEP_COMMA_PLUS\n NID_dsa_2                       OPENSSL_VERSION_NUMBER                 XN_FLAG_SEP_CPLUS_SPC\n NID_email_protect               OP_ALL                                 XN_FLAG_SEP_MASK\n NID_ext_key_usage               OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION   XN_FLAG_SEP_MULTILINE\n NID_ext_req                     OP_CIPHER_SERVER_PREFERENCE            XN_FLAG_SEP_SPLUS_SPC\n NID_friendlyName                OP_CISCO_ANYCONNECT                    XN_FLAG_SPC_EQ\n NID_givenName                   OP_COOKIE_EXCHANGE\n\n    BIO_eof\n    BIO_f_ssl\n    BIO_free\n    BIO_new\n    BIO_new_file\n    BIO_pending\n    BIO_read\n    BIO_s_mem\n    BIO_wpending\n    BIO_write\n    CTX_free\n    CTX_get_cert_store\n    CTX_new\n    CTX_use_RSAPrivateKey_file\n    CTX_use_certificate_file\n    CTX_v23_new\n    CTX_v2_new\n    CTX_v3_new\n    ERR_error_string\n    ERR_get_error\n    ERR_load_RAND_strings\n    ERR_load_SSL_strings\n    PEM_read_bio_X509_CRL\n    RSA_free\n    RSA_generate_key\n    SESSION\n    SESSION_free\n    SESSION_get_master_key\n    SESSION_new\n    SESSION_print\n    X509_NAME_get_text_by_NID\n    X509_NAME_oneline\n    X509_STORE_CTX_set_flags\n    X509_STORE_add_cert\n    X509_STORE_add_crl\n    X509_free\n    X509_get_issuer_name\n    X509_get_subject_name\n    X509_load_cert_crl_file\n    X509_load_cert_file\n    X509_load_crl_file\n    accept\n    add_session\n    clear\n    clear_error\n    connect\n    copy_session_id\n    d2i_SSL_SESSION\n    die_if_ssl_error\n    die_now\n    do_https\n    dump_peer_certificate\n    err\n    flush_sessions\n    free\n    get_cipher\n    get_cipher_list\n    get_client_random\n    get_fd\n    get_http\n    get_http4\n    get_https\n    get_https3\n    get_https4\n    get_httpx\n    get_httpx4\n    get_peer_certificate\n    get_rbio\n    get_read_ahead\n    get_server_random\n    get_shared_ciphers\n    get_time\n    get_timeout\n    get_wbio\n    i2d_SSL_SESSION\n    load_error_strings\n  ", 8192) = 8192
09:01:57.167548 read(8, "  make_form\n    make_headers\n    new\n    peek\n    pending\n    post_http\n    post_http4\n    post_https\n    post_https3\n    post_https4\n    post_httpx\n    post_httpx4\n    print_errs\n    read\n    remove_session\n    rstate_string\n    rstate_string_long\n    set_bio\n    set_cert_and_key\n    set_cipher_list\n    set_fd\n    set_read_ahead\n    set_rfd\n    set_server_cert_and_key\n    set_session\n    set_time\n    set_timeout\n    set_verify\n    set_wfd\n    ssl_read_CRLF\n    ssl_read_all\n    ssl_read_until\n    ssl_write_CRLF\n    ssl_write_all\n    sslcat\n    state_string\n    state_string_long\n    tcp_read_CRLF\n    tcp_read_all\n    tcp_read_until\n    tcp_write_CRLF\n    tcp_write_all\n    tcpcat\n    tcpxcat\n    use_PrivateKey\n    use_PrivateKey_ASN1\n    use_PrivateKey_file\n    use_RSAPrivateKey\n    use_RSAPrivateKey_ASN1\n    use_RSAPrivateKey_file\n    use_certificate\n    use_certificate_ASN1\n    use_certificate_file\n    write\n \n);\n\nsub AUTOLOAD {\n    # This AUTOLOAD is used to 'autoload' constants from the constant()\n    # XS function.  If a constant is not found then control is passed\n    # to the AUTOLOAD in AutoLoader.\n\n    my $constname;\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    my $val = constant($constname);\n    if ($! != 0) {\n\tif ($! =~ /((Invalid)|(not valid))/i || $!{EINVAL}) {\n\t    $AutoLoader::AUTOLOAD = $AUTOLOAD;\n\t    goto &AutoLoader::AUTOLOAD;\n\t}\n\telse {\n\t  croak \"Your vendor has not defined SSLeay macro $constname\";\n\t}\n    }\n    eval \"sub $AUTOLOAD { $val }\";\n    goto &$AUTOLOAD;\n}\n\neval {\n\trequire XSLoader;\n\tXSLoader::load('Net::SSLeay', $VERSION);\n\t1;\n} or do {\n\trequire DynaLoader;\n\tpush @ISA, 'DynaLoader';\n\tbootstrap Net::SSLeay $VERSION;\n};\n\n# Preloaded methods go here.\n\n$CRLF = \"\\x0d\\x0a\";  # because \\r\\n is not fully portable\n\n### Print SSLeay error stack\n\nsub print_errs {\n    my ($msg) = @_;\n    my ($count, $err, $errs, $e) = (0,0,'');\n    while ($err = ERR_get_error()) {\n        $count ++;\n\t$e = \"$msg $$: $count - \" . ERR_error_string($err) . \"\\n\";\n\t$errs .= $e;\n\twarn $e if $Net::SSLeay::trace;\n    }\n    return $errs;\n}\n\n# Death is conditional to SSLeay errors existing, i.e. this function checks\n# for errors and only dies in affirmative.\n# usage: Net::SSLeay::write($ssl, \"foo\") or die_if_ssl_error(\"SSL write ($!)\");\n\nsub die_if_ssl_error {\n    my ($msg) = @_;    \n    die \"$$: $msg\\n\" if print_errs($msg);\n}\n\n# Unconditional death. Used to print SSLeay errors before dying.\n# usage: Net::SSLeay::connect($ssl) or die_now(\"Failed SSL connect ($!)\");\n\nsub die_now {\n    my ($msg) = @_;    \n    print_errs($msg);\n    die \"$$: $msg\\n\";\n}\n\n# Perl 5.6.* unicode support causes that length() no longer reliably\n# reflects the byte length of a string. This eval is to fix that.\n# Thanks to Sean Burke for the snippet.\n\nBEGIN{ \neval 'use bytes; sub blength ($) { length $_[0] }'; \n$@ and eval '    sub blength ($) { length $_[0] }' ; \n}\n\n# Autoload methods go after __END__, and are processed by the autosplit program.\n\n\n1;\n__END__\n\n### Some methods that are macros in C\n\nsub want_nothing { want(shift) == 1 }\nsub want_read { want(shift) == 2 }\nsub want_write { want(shift) == 3 }\nsub want_X509_lookup { want(shift) == 4 }\n\n###\n### Open TCP stream to given host and port, looking up the details\n### from system databases or DNS.\n###\n\nsub open_tcp_connection {\n    my ($dest_serv, $port) = @_;\n    my ($errs);\n\n    $port = getservbyname($port, 'tcp') unless $port =~ /^\\d+$/;\n    my $dest_serv_ip = gethostbyname($dest_serv);\n    unless (defined($dest_serv_ip)) {\n\t$errs = \"$0 $$: open_tcp_connection: destination host not found:\"\n            . \" `$dest_serv' (port $port) ($!)\\n\";\n\twarn $errs if $trace;\n        return wantarray ? (0, $errs) : 0;\n    }\n    my $sin = sockaddr_in($port, $dest_serv_ip);\n    \n    warn \"Opening connection to $dest_serv:$port (\" .\n\tinet_ntoa($dest_serv_ip) . \")\" if $trace>2;\n    \n    my $proto = getprotobyname('tcp');\n    if (socket (SSLCAT_S, &PF_INET(), &SOCK_STREAM(), $proto)) {\n        warn \"next connect\" if $trace>3;\n        if (CORE::connect (SSLCAT_S, $sin)) {\n            my $old_out = select (SSLCAT_S); $| = 1; select ($old_out);\n            warn \"connected to $dest_serv, $port\" if $trace>3;\n            return wantarray ? (1, undef) : 1; # Success\n        }\n    }\n    $errs = \"$0 $$: open_tcp_connection: failed `$dest_serv', $port ($!)\\n\";\n    warn $errs if $trace;\n    close SSLCAT_S;\n    return wantarray ? (0, $errs) : 0; # Fail\n}\n\n### Open connection via standard web proxy, if one was defined\n### using set_proxy().\n\nsub open_proxy_tcp_connection {\n    my ($dest_serv, $port) = @_;\n    return open_tcp_connection($dest_serv, $port) if !$proxyhost;\n    \n    warn \"Connect via proxy: $proxyhost:$proxyport\" if $trace>2;\n    my ($ret, $errs) = open_tcp_connection($proxyhost, $proxyport);\n    return wantarray ? (0, $errs) : 0 if !$ret;  # Connection fail\n    \n    warn \"Asking proxy to connect to $dest_serv:$port\" if $trace>2;\n    #print SSLCAT_S \"CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF\";\n    #my $line = <SSLCAT_S>;   # *** bug? Mixing stdio with syscall read?\n    ($ret, $errs) =\n\ttcp_write_all(\"CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF\");\n    return wantarray ? (0,$errs) : 0 if $errs;\n    ($line, $errs) = tcp_read_until($CRLF . $CRLF, 1024);\n    warn \"Proxy response: $line\" if $trace>2;\n    return wantarray ? (0,$errs) : 0 if $errs;\n    return wantarray ? (1,'') : 1;  # Success\n}\n\n###\n### read and write helpers that block\n###\n\nsub debug_read {\n    my ($replyr, $gotr) = @_;\n    my $vm = $trace>2 && $linux_debug ?\n\t(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';\n    warn \"  got \" . blength($$gotr) . ':'\n\t. blength($$replyr) . \" bytes (VM=$vm).\\n\" if $trace == 3;\n    warn \"  got `$$gotr' (\" . blength($$gotr) . ':'\n\t. blength($$replyr) . \" bytes, VM=$vm)\\n\" if $trace>3;\n}\n\nsub ssl_read_all {\n    my ($ssl,$how_much) = @_;\n    $how_much = 2000000000 unless $how_much;\n    my ($got, $errs);\n    my $reply = '';\n\n    while ($how_much > 0) {\n        $got = Net::SSLeay::read($ssl,\n                ($how_much > 32768) ? 32768 : $how_much\n        );\n        last if $errs = print_errs('SSL_read');\n        $how_much -= blength($got);\n        debug_read(\\$reply, \\$got) if $trace>1;\n        last if $got eq '';  # EOF\n        $reply .= $got;\n    }\n\n    return wantarray ? ($reply, $errs) : $reply;\n}\n\nsub tcp_read_all {\n    my ($how_much) = @_;\n    $how_much = 2000000000 unless $how_much;\n    my ($n, $got, $errs);\n    my $reply = '';\n\n    my $bsize = 0x10000;\n    while ($how_much > 0) {\n\t$n = sysread(SSLCAT_S,$got, (($bsize < $how_much) ? $bsize : $how_much));\n\twarn \"Read error: $! ($n,$how_much)\" unless defined $n;\n\tlast if !$n;  # EOF\n\t$how_much -= $n;\n\tdebug_read(\\$reply, \\$got) if $trace>1;\n\t$reply .= $got;\n    }\n    return wantarray ? ($reply, $errs) : $reply;\n}\n\nsub ssl_write_all {\n    my $ssl = $_[0];    \n    my ($data_ref, $errs);\n    if (ref $_[1]) {\n\t$data_ref = $_[1];\n    } else {\n\t$data_ref = \\$_[1];\n    }\n    my ($wrote, $written, $to_write) = (0,0, blength($$data_ref));\n    my $vm = $trace>2 && $linux_debug ?\n\t(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';\n    warn \"  write_all VM at entry=$vm\\n\" if $trace>2;\n    while ($to_write) {\n\t#sleep 1; # *** DEBUG\n\twarn \"partial `$$data_ref'\\n\" if $trace>3;\n\t$wrote = write_partial($ssl, $written, $to_write, $$data_ref);\n\tif (defined $wrote && ($wrote > 0)) {  # write_partial can return -1\n\t    $written += $wrote;\n\t    $to_write -= $wrote;\n\t} else {\n\t  if (defined $wrote) {\n\t    # check error conditions via SSL_get_error per man page\n\t    if ( my $sslerr = get_error($ssl, $wrote) ) {\n\t      my $errstr = ERR_error_string($sslerr);\n\t      my $errname = '';\n\t      SWITCH: {\n\t\t$sslerr == constant(\"ERROR_NONE\") && do {\n\t\t  # according to map page SSL_get_error(3ssl):\n\t\t  #  The TLS/SSL I/O operation completed.  \n\t\t  #  This result code is returned if and only if ret > 0\n                  # so if we received it here complain...\n\t\t  warn \"ERROR_NONE unexpected with invalid return value!\" \n\t\t    if $trace;\n\t\t  $errname = \"SSL_ERROR_NONE\";\n\t\t};\n\t\t$sslerr == constant(\"ERROR_WANT_READ\") && do {\n\t\t  # operation did not complete, call again later, so do not\n\t\t  # set errname and ", 8192) = 8192
09:01:57.168324 lseek(8, 19357, SEEK_SET) = 19357
09:01:57.168372 lseek(8, 0, SEEK_CUR)   = 19357
09:01:57.168417 close(8)                = 0
09:01:57.168556 brk(0xff0000)           = 0xff0000
09:01:57.168644 stat("/usr/lib/perl5/auto/Net/SSLeay/SSLeay.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.168706 stat("/usr/lib/perl5/auto/Net/SSLeay/SSLeay.so", {st_mode=S_IFREG|0644, st_size=468936, ...}) = 0
09:01:57.168764 stat("/usr/lib/perl5/auto/Net/SSLeay/SSLeay.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.168837 open("/usr/lib/perl5/auto/Net/SSLeay/SSLeay.so", O_RDONLY) = 8
09:01:57.168891 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20j\1\0\0\0\0\0@\0\0\0\0\0\0\0H!\7\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\362\6\0\0\0\0\0d\362\6\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\210\376\6\0\0\0\0\0\210\376&\0\0\0\0\0\210\376&\0\0\0\0\0\354!\0\0\0\0\0\0h\"\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\260\376\6\0\0\0\0\0\260\376&\0\0\0\0\0\260\376&\0\0\0\0\0\260\1\0\0\0\0\0\0\260\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0`_\6\0\0\0\0\0`_\6\0\0\0\0\0`_\6\0\0\0\0\0\324\17\0\0\0\0\0\0\324\17\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\210\376\6\0\0\0\0\0\210\376&\0\0\0\0\0\210\376&\0\0\0\0\0x\21\0\0\0\0\0\0x\21\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\21088\334\272\3014m\217\263bzO2\314E\361\236\335\32\0\0\0\0\t\2\0\0\4\4\0\0#\0\0\0\270\2\0\0\35\1\0\0\316\1\0\0\344\3\0\0\27\1\0\0\6\2\0\0\0\0\0\0\202\1\0\0\36\1\0\0'\2\0\0\313\1\0\0m\1\0\0\\\0\0\0\217\1\0\0\0\0\0\0\0\0\0\0\333\0\0\0\203\3\0\0<\1\0\0K\0\0\0\0\4\0\0\277\1\0\0\350\2\0\0D\1\0\0\314\1\0\0\300\3\0\0n\2\0\0\16\2\0\0\345\3\0\0006\2\0\0\327\1\0\0\213\1\0\0\225\2\0\0\0\0\0\0d\2\0\0V\2\0\0?\1\0\0%\2\0\0\3\2\0\0\226\0\0\0\0\0\0\0f\1\0\0\227\1\0\0\203\1\0\0\0\0\0\0006\3\0\0\0\0\0\0\350\3\0\0\315\3\0\0z\2\0\0\0\0\0\0\0\0\0\0x\3\0\0\310\2\0\0v\0\0\0\0\0\0\0\207\3\0\0\0\0\0\0\233\2\0\0\366\2\0\0\321\1\0\0\217\3\0\0'\1\0\0\244\2\0\0\0\0\0\0s\2\0\0\0\0\0\0(\2\0\0\t\2\0\0\321\0\0\0\240\1\0\0\224\1\0\0\0\0\0\0I\3\0\0/\3\0\0003\2\0\0|\0\0\0\334\2\0\0R\2\0\0\0\0\0\0\230\0\0\0", 832) = 832
09:01:57.169026 fstat(8, {st_mode=S_IFREG|0644, st_size=468936, ...}) = 0
09:01:57.169085 mmap(NULL, 2564336, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f7434069000
09:01:57.169137 mprotect(0x7f74340d9000, 2093056, PROT_NONE) = 0
09:01:57.169187 mmap(0x7f74342d8000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x6f000) = 0x7f74342d8000
09:01:57.169246 close(8)                = 0
09:01:57.169300 open("/etc/ld.so.cache", O_RDONLY) = 8
09:01:57.169354 fstat(8, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.169406 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 8, 0) = 0x7f7436f01000
09:01:57.169453 close(8)                = 0
09:01:57.169501 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.169560 open("/usr/lib/x86_64-linux-gnu/libssl.so.1.0.0", O_RDONLY) = 8
09:01:57.169614 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260P\1\0\0\0\0\0@\0\0\0\0\0\0\0X\4\6\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\35\0\34\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264a\5\0\0\0\0\0\264a\5\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0Hq\5\0\0\0\0\0Hq%\0\0\0\0\0Hq%\0\0\0\0\0\370\221\0\0\0\0\0\0\350\222\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\350\234\5\0\0\0\0\0\350\234%\0\0\0\0\0\350\234%\0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\210\367\4\0\0\0\0\0\210\367\4\0\0\0\0\0\210\367\4\0\0\0\0\0<\22\0\0\0\0\0\0<\22\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0Hq\5\0\0\0\0\0Hq%\0\0\0\0\0Hq%\0\0\0\0\0\270.\0\0\0\0\0\0\270.\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\264{\362\227\324\3U\232qx`\0OD\347\311\266\r\232%\0\0\0\0\t\2\0\0\206\2\0\0\37\2\0\0\0\0\0\0002\0\0\0;\0\0\0/\2\0\0\266\0\0\0\0\0\0\0003\0\0\0\24\1\0\0\302\0\0\0\335\1\0\0I\1\0\0\355\0\0\0\276\0\0\0{\0\0\0\0\0\0\0_\1\0\0\220\1\0\0\0\0\0\0\r\1\0\0\0\0\0\0\0\0\0\0\333\1\0\0\201\1\0\0\322\0\0\0U\1\0\0\0\0\0\0\0\0\0\0\332\0\0\0\0\0\0\0w\2\0\0\0\0\0\0\206\1\0\0F\1\0\0Z\1\0\0\361\0\0\0\0\0\0\0\0\0\0\0>\2\0\0\0\0\0\0004\1\0\0\0\0\0\0\325\0\0\0\374\1\0\0\0\0\0\0\\\0\0\0\0\0\0\0I\0\0\0\0\0\0\0\0\0\0\0\243\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0i\1\0\0\0\0\0\0\374\0\0\0(\2\0\0\352\1\0\0n\0\0\0M\1\0\0\21\2\0\0\235\1\0\0J\2\0\0\203\1\0\0\177\0\0\0G\1\0\0\362\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\275\1\0\0\214\1\0\0\307\1\0\0\316\1\0\0B\2\0\0\301\1\0\0\0\0\0\0\31\1\0\0-\1\0\0\331\1\0\0", 832) = 832
09:01:57.169757 fstat(8, {st_mode=S_IFREG|0644, st_size=396184, ...}) = 0
09:01:57.169814 mmap(NULL, 2491440, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f7433e08000
09:01:57.169864 mprotect(0x7f7433e5f000, 2097152, PROT_NONE) = 0
09:01:57.169917 mmap(0x7f743405f000, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x57000) = 0x7f743405f000
09:01:57.169974 close(8)                = 0
09:01:57.170034 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.170098 open("/usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0", O_RDONLY) = 8
09:01:57.170152 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\207\7\0\0\0\0\0@\0\0\0\0\0\0\0\300:\37\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\35\0\34\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$\237\34\0\0\0\0\0$\237\34\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\240\247\34\0\0\0\0\0\240\247<\0\0\0\0\0\240\247<\0\0\0\0\0\4\222\2\0\0\0\0\0\330\315\2\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\220C\36\0\0\0\0\0\220C>\0\0\0\0\0\220C>\0\0\0\0\0 \2\0\0\0\0\0\0 \2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0xv\31\0\0\0\0\0xv\31\0\0\0\0\0xv\31\0\0\0\0\0\264\222\0\0\0\0\0\0\264\222\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\240\247\34\0\0\0\0\0\240\247<\0\0\0\0\0\240\247<\0\0\0\0\0`\250\1\0\0\0\0\0`\250\1\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\2\343\236\254\220y\266w,Z\276\305L\2\321` \f\217\32\0\0\0\0\5\10\0\0q\16\0\0\0\0\0\0\211\6\0\0\0\0\0\0=\10\0\0\0\0\0\0\0\0\0\0\304\v\0\0009\4\0\0\20\0\0\0P\f\0\0\247\1\0\0\330\f\0\0V\f\0\0\360\v\0\0\253\10\0\0\227\v\0\0\360\f\0\0\266\3\0\0\255\n\0\0q\6\0\0\265\10\0\0\2\5\0\0\n\t\0\0\244\6\0\0j\5\0\0\263\f\0\0'\n\0\0\305\3\0\0[\n\0\0\204\f\0\0K\3\0\0\0\0\0\0\362\0\0\0#\10\0\0l\0\0\0005\7\0\0\0\0\0\0\333\1\0\0\0\0\0\0Z\7\0\0\274\4\0\0\243\4\0\0_\0\0\0\0\0\0\0\236\n\0\0\267\4\0\0\0\0\0\0\262\6\0\0N\t\0\0\0\0\0\0\205\4\0\0\33\4\0\0\274\0\0\0\0\0\0\0Y\16\0\0\263\4\0\0h\0\0\0\205\t\0\0\0\0\0\0\210\1\0\0\335\4\0\0\212\v\0\0\312\2\0\0\300\1\0\0\314\n\0\0g\v\0\0s\0\0\0\0\0\0\0s\2\0\0\r\r\0\0\245\v\0\0\266\1\0\0K\v\0\0\21\n\0\0n\2\0\0\262\5\0\0\204\4\0\0\0\0\0\0\340\t\0\0\0\0\0\0\276\5\0\0\273\7\0\0", 832) = 832
09:01:57.170286 fstat(8, {st_mode=S_IFREG|0644, st_size=2048512, ...}) = 0
09:01:57.170342 mmap(NULL, 4158840, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f7433a10000
09:01:57.170392 mprotect(0x7f7433bda000, 2097152, PROT_NONE) = 0
09:01:57.170443 mmap(0x7f7433dda000, 172032, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x1ca000) = 0x7f7433dda000
09:01:57.170498 mmap(0x7f7433e04000, 13688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7433e04000
09:01:57.170552 close(8)                = 0
09:01:57.170605 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.170659 open("/lib/x86_64-linux-gnu/libz.so.1", O_RDONLY) = 8
09:01:57.170714 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340#\0\0\0\0\0\0@\0\0\0\0\0\0\0\20c\1\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\35\0\34\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$R\1\0\0\0\0\0$R\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\300\\\1\0\0\0\0\0\300\\!\0\0\0\0\0\300\\!\0\0\0\0\0@\5\0\0\0\0\0\0P\5\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\360]\1\0\0\0\0\0\360]!\0\0\0\0\0\360]!\0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\370:\1\0\0\0\0\0\370:\1\0\0\0\0\0\370:\1\0\0\0\0\0|\3\0\0\0\0\0\0|\3\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\300\\\1\0\0\0\0\0\300\\!\0\0\0\0\0\300\\!\0\0\0\0\0@\3\0\0\0\0\0\0@\3\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\36\376\267\37\324\231\234#\7W\rg:rN\244\341\330Rg\0\0\0\0a\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0<\0\0\0\0\0\0\0\0\0\0\0j\0\0\0\0\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0U\0\0\0\34\0\0\0 \0\0\0d\0\0\0Y\0\0\0D\0\0\0E\0\0\0\24\0\0\0k\0\0\0\0\0\0\0`\0\0\0\23\0\0\0*\0\0\0\0\0\0\0L\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0h\0\0\0m\0\0\0\10\0\0\0\21\0\0\0@\0\0\0008\0\0\0\0\0\0\0\22\0\0\0H\0\0\0\0\0\0\0g\0\0\0+\0\0\0Q\0\0\0\0\0\0\0001\0\0\0\0\0\0\0005\0\0\0\25\0\0\0a\0\0\0\0\0\0\0\0\0\0\0C\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\r\0\0\0\17\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0%\0\0\0.\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0G\0\0\0e\0\0\0\0\0\0\0\6\0\0\0\0\0\0\0\"\0\0\0\0\0\0\0(\0\0\0I\0\0\0000\0\0\0Z\0\0\0K\0\0\0O\0\0\0", 832) = 832
09:01:57.170854 fstat(8, {st_mode=S_IFREG|0644, st_size=92752, ...}) = 0
09:01:57.170913 mmap(NULL, 2187792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f74337f9000
09:01:57.170963 mprotect(0x7f743380f000, 2093056, PROT_NONE) = 0
09:01:57.171013 mmap(0x7f7433a0e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x15000) = 0x7f7433a0e000
09:01:57.171073 close(8)                = 0
09:01:57.171139 mprotect(0x7f7433a0e000, 4096, PROT_READ) = 0
09:01:57.171458 mprotect(0x7f7433dda000, 110592, PROT_READ) = 0
09:01:57.171548 mprotect(0x7f743405f000, 12288, PROT_READ) = 0
09:01:57.171711 mprotect(0x7f74342d8000, 8192, PROT_READ) = 0
09:01:57.171778 munmap(0x7f7436f01000, 98904) = 0
09:01:57.172025 brk(0x1015000)          = 0x1015000
09:01:57.172537 brk(0x1036000)          = 0x1036000
09:01:57.172855 stat("modules/POE/Component/SSLify/ClientHandle.pmc", 0x7ffe1233b700) = -1 ENOENT (No such file or directory)
09:01:57.172910 stat("modules/POE/Component/SSLify/ClientHandle.pm", {st_mode=S_IFREG|0600, st_size=3884, ...}) = 0
09:01:57.172969 open("modules/POE/Component/SSLify/ClientHandle.pm", O_RDONLY) = 8
09:01:57.173023 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b3e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.173069 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.173125 read(8, "#\n# This file is part of POE-Component-SSLify\n#\n# This software is copyright (c) 2014 by Apocalypse.\n#\n# This is free software; you can redistribute it and/or modify it under\n# the same terms as the Perl 5 programming language system itself.\n#\nuse strict; use warnings;\npackage POE::Component::SSLify::ClientHandle;\n$POE::Component::SSLify::ClientHandle::VERSION = '1.012';\nour $AUTHORITY = 'cpan:APOCAL';\n\n# ABSTRACT: Client-side handle for SSLify\n\n# Import the SSL death routines\nuse Net::SSLeay 1.36 qw( die_now die_if_ssl_error );\n\n# We inherit from ServerHandle\nuse parent 'POE::Component::SSLify::ServerHandle';\n\n# Override TIEHANDLE because we create a CTX\nsub TIEHANDLE {\n\tmy ( $class, $socket, $version, $options, $ctx, $connref ) = @_;\n\n\t# create a context, if necessary\n\tif ( ! defined $ctx ) {\n\t\t$ctx = POE::Component::SSLify::_createSSLcontext( undef, undef, $version, $options );\n\t}\n\n\tmy $ssl = Net::SSLeay::new( $ctx ) or die_now( \"Failed to create SSL $!\" );\n\n\tmy $fileno = fileno( $socket );\n\n\tNet::SSLeay::set_fd( $ssl, $fileno );   # Must use fileno\n\n\t# Socket is in non-blocking mode, so connect() will return immediately.\n\t# die_if_ssl_error won't die on non-blocking errors. We don't need to call connect()\n\t# again, because OpenSSL I/O functions (read, write, ...) can handle that entirely\n\t# by self (it's needed to connect() once to determine connection type).\n\tmy $res = Net::SSLeay::connect( $ssl ) or die_if_ssl_error( 'ssl connect' );\n\n\tmy $self = bless {\n\t\t'ssl'\t\t=> $ssl,\n\t\t'ctx'\t\t=> $ctx,\n\t\t'socket'\t=> $socket,\n\t\t'fileno'\t=> $fileno,\n\t\t'client'\t=> 1,\n\t\t'status'\t=> $res,\n\t\t'on_connect'\t=> $connref,\n\t}, $class;\n\n\treturn $self;\n}\n\n1;\n\n__END__\n\n=pod\n\n=encoding UTF-8\n\n=for :stopwords Apocalypse\n\n=head1 NAME\n\nPOE::Component::SSLify::ClientHandle - Client-side handle for SSLify\n\n=head1 VERSION\n\n  This document describes v1.012 of POE::Component::SSLify::ClientHandle - released November 14, 2014 as part of POE-Component-SSLify.\n\n=head1 DESCRIPTION\n\n\tThis is a subclass of ServerHandle to accomodate clients setting custom context objects.\n\n=head1 SEE ALSO\n\nPlease see those modules/websites for more information related to this module.\n\n=over 4\n\n=item *\n\nL<POE::Component::SSLify|POE::Component::SSLify>\n\n=item *\n\nL<POE::Component::SSLify::ServerHandle|POE::Component::SSLify::ServerHandle>\n\n=back\n\n=head1 AUTHOR\n\nApocalypse <APOCAL@cpan.org>\n\n=head1 COPYRIGHT AND LICENSE\n\nThis software is copyright (c) 2014 by Apocalypse.\n\nThis is free software; you can redistribute it and/or modify it under\nthe same terms as the Perl 5 programming language system itself.\n\nThe full text of the license can be found in the\nF<LICENSE> file included with this distribution.\n\n=head1 DISCLAIMER OF WARRANTY\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n=cut\n", 8192) = 3884
09:01:57.173440 stat("modules/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173494 stat("modules/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.173545 stat("modules/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173593 stat("modules/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.173642 stat("/etc/perl/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173696 stat("/etc/perl/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.173746 stat("/usr/local/lib/perl/5.14.2/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173797 stat("/usr/local/lib/perl/5.14.2/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.173847 stat("/usr/local/share/perl/5.14.2/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173897 stat("/usr/local/share/perl/5.14.2/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.173949 stat("/usr/lib/perl5/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.173999 stat("/usr/lib/perl5/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.174061 stat("/usr/share/perl5/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.174114 stat("/usr/share/perl5/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.174166 stat("/usr/lib/perl/5.14/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.174223 stat("/usr/lib/perl/5.14/parent.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.174275 stat("/usr/share/perl/5.14/parent.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.174326 stat("/usr/share/perl/5.14/parent.pm", {st_mode=S_IFREG|0644, st_size=2902, ...}) = 0
09:01:57.174385 open("/usr/share/perl/5.14/parent.pm", O_RDONLY) = 9
09:01:57.174438 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233adb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.174484 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.174547 read(9, "package parent;\nuse strict;\nuse vars qw($VERSION);\n$VERSION = '0.225';\n\nsub import {\n    my $class = shift;\n\n    my $inheritor = caller(0);\n\n    if ( @_ and $_[0] eq '-norequire' ) {\n        shift @_;\n    } else {\n        for ( my @filename = @_ ) {\n            if ( $_ eq $inheritor ) {\n                warn \"Class '$inheritor' tried to inherit from itself\\n\";\n            };\n\n            s{::|'}{/}g;\n            require \"$_.pm\"; # dies if the file is not found\n        }\n    }\n\n    {\n        no strict 'refs';\n        push @{\"$inheritor\\::ISA\"}, @_;\n    };\n};\n\n\"All your base are belong to us\"\n\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nparent - Establish an ISA relationship with base classes at compile time\n\n=head1 SYNOPSIS\n\n    package Baz;\n    use parent qw(Foo Bar);\n\n=head1 DESCRIPTION\n\nAllows you to both load one or more modules, while setting up inheritance from\nthose modules at the same time.  Mostly similar in effect to\n\n    package Baz;\n    BEGIN {\n        require Foo;\n        require Bar;\n        push @ISA, qw(Foo Bar);\n    }\n\nBy default, every base class needs to live in a file of its own.\nIf you want to have a subclass and its parent class in the same file, you\ncan tell C<parent> not to load any modules by using the C<-norequire> switch:\n\n  package Foo;\n  sub exclaim { \"I CAN HAS PERL\" }\n\n  package DoesNotLoadFooBar;\n  use parent -norequire, 'Foo', 'Bar';\n  # will not go looking for Foo.pm or Bar.pm\n\nThis is equivalent to the following code:\n\n  package Foo;\n  sub exclaim { \"I CAN HAS PERL\" }\n\n  package DoesNotLoadFooBar;\n  push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';\n\nThis is also helpful for the case where a package lives within\na differently named file:\n\n  package MyHash;\n  use Tie::Hash;\n  use parent -norequire, 'Tie::StdHash';\n\nThis is equivalent to the following code:\n\n  package MyHash;\n  require Tie::Hash;\n  push @ISA, 'Tie::StdHash';\n\nIf you want to load a subclass from a file that C<require> would\nnot consider an eligible filename (that is, it does not end in\neither C<.pm> or C<.pmc>), use the following code:\n\n  package MySecondPlugin;\n  require './plugins/custom.plugin'; # contains Plugin::Custom\n  use parent -norequire, 'Plugin::Custom';\n\n=head1 DIAGNOSTICS\n\n=over 4\n\n=item Class 'Foo' tried to inherit from itself\n\nAttempting to inherit from yourself generates a warning.\n\n    package Foo;\n    use parent 'Foo';\n\n=back\n\n=head1 HISTORY\n\nThis module was forked from L<base> to remove the cruft\nthat had accumulated in it.\n\n=head1 CAVEATS\n\n=head1 SEE ALSO\n\nL<base>\n\n=head1 AUTHORS AND CONTRIBUTORS\n\nRafa\303\253l Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern\n\n=head1 MAINTAINER\n\nMax Maischein C< corion@cpan.org >\n\nCopyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>\nBased on the idea of C<base.pm>, which was introduced with Perl 5.004_04.\n\n=head1 LICENSE\n\nThis module is released under the same terms as Perl itself.\n\n=cut\n", 8192) = 2902
09:01:57.174869 lseek(9, 606, SEEK_SET) = 606
09:01:57.174916 lseek(9, 0, SEEK_CUR)   = 606
09:01:57.174961 close(9)                = 0
09:01:57.175033 stat("modules/POE/Component/SSLify/ServerHandle.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.175085 stat("modules/POE/Component/SSLify/ServerHandle.pm", {st_mode=S_IFREG|0600, st_size=9624, ...}) = 0
09:01:57.175144 open("modules/POE/Component/SSLify/ServerHandle.pm", O_RDONLY) = 9
09:01:57.175202 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233adb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.175248 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.175303 read(9, "#\n# This file is part of POE-Component-SSLify\n#\n# This software is copyright (c) 2014 by Apocalypse.\n#\n# This is free software; you can redistribute it and/or modify it under\n# the same terms as the Perl 5 programming language system itself.\n#\nuse strict; use warnings;\npackage POE::Component::SSLify::ServerHandle;\n$POE::Component::SSLify::ServerHandle::VERSION = '1.012';\nour $AUTHORITY = 'cpan:APOCAL';\n\n# ABSTRACT: Server-side handle for SSLify\n\n# Import the SSL death routines\nuse Net::SSLeay 1.36 qw( die_now die_if_ssl_error ERROR_WANT_READ ERROR_WANT_WRITE );\n\n# Ties the socket\nsub TIEHANDLE {\n\tmy ( $class, $socket, $ctx, $connref ) = @_;\n\n\tmy $ssl = Net::SSLeay::new( $ctx ) or die_now( \"Failed to create SSL $!\" );\n\n\tmy $fileno = fileno( $socket );\n\n\tNet::SSLeay::set_fd( $ssl, $fileno );\n\n\t# Socket is in non-blocking mode, so accept() will return immediately.\n\t# die_if_ssl_error won't die on non-blocking errors. We don't need to call accept()\n\t# again, because OpenSSL I/O functions (read, write, ...) can handle that entirely\n\t# by self (it's needed to accept() once to determine connection type).\n\tmy $res = Net::SSLeay::accept( $ssl ) and die_if_ssl_error( 'ssl accept' );\n\n\tmy $self = bless {\n\t\t'ssl'\t\t=> $ssl,\n\t\t'ctx'\t\t=> $ctx,\n\t\t'socket'\t=> $socket,\n\t\t'fileno'\t=> $fileno,\n\t\t'status'\t=> $res,\n\t\t'on_connect'\t=> $connref,\n\t\t'ssl_started'\t=> 0,\n\t}, $class;\n\n\treturn $self;\n}\n\n# TODO should we make a convenience function to convert retval to string equivalents for easier debugging?\n# From OpenSSL 1.0.0d\n#define SSL_ERROR_NONE\t\t\t0\n#define SSL_ERROR_SSL\t\t\t1\n#define SSL_ERROR_WANT_READ\t\t2\n#define SSL_ERROR_WANT_WRITE\t\t3\n#define SSL_ERROR_WANT_X509_LOOKUP\t4\n#define SSL_ERROR_SYSCALL\t\t5 /* look at error stack/return value/errno */\n#define SSL_ERROR_ZERO_RETURN\t\t6\n#define SSL_ERROR_WANT_CONNECT\t\t7\n#define SSL_ERROR_WANT_ACCEPT\t\t8\n\nsub _check_status {\n\tmy $self = shift;\n\n\t# Okay, is negotiation done?\n\t# http://www.openssl.org/docs/ssl/SSL_connect.html#RETURN_VALUES\n\tif ( exists $self->{'client'} ) {\n\t\t$self->{'status'} = Net::SSLeay::connect( $self->{'ssl'} );\n\t} else {\n\t\t$self->{'status'} = Net::SSLeay::accept( $self->{'ssl'} );\n\t}\n\n\tif ( $self->{'status'} <= 0 ) {\n\t\t# http://www.openssl.org/docs/ssl/SSL_get_error.html\n\t\tmy $errval = Net::SSLeay::get_error( $self->{'ssl'}, $self->{'status'} );\n\n\t\t# Handle the case of ERROR_WANT_READ and ERROR_WANT_WRITE\n\t\t# TODO should we skip ERROR_WANT_ACCEPT and ERROR_WANT_CONNECT ?\n\t\t# also, ERROR_WANT_ACCEPT isn't exported by Net::SSLeay, huh?\n\t\tif ( $errval == ERROR_WANT_READ or $errval == ERROR_WANT_WRITE ) {\n\t\t\t# continue reading/writing from the socket until we connect or not...\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t# call the hook function for error connect\n\t\t\tif ( defined $self->{'on_connect'} ) {\n\t\t\t\t$self->{'on_connect'}->( $self->{'orig_socket'}, 0, $errval );\n\t\t\t}\n\n\t\t\t# don't try to read/write from the socket anymore!\n\t\t\treturn 0;\n\t\t}\n\t} elsif ( $self->{'status'} == 1 ) {\n\t\t# SSL handshake is done!\n\t\t$self->{'ssl_started'} = 1;\n\n\t\t# call the hook function for successful connect\n\t\tif ( defined $self->{'on_connect'} ) {\n\t\t\t$self->{'on_connect'}->( $self->{'orig_socket'}, 1 );\n\t\t}\n\n\t\t# we can now read/write from the socket!\n\t\treturn 1;\n\t}\n}\n\n# Read something from the socket\nsub READ {\n\t# Get ourself!\n\tmy $self = shift;\n\n\t# Get the pointers to buffer, length, and the offset\n\tmy( $buf, $len, $offset ) = \\( @_ );\n\n\t# Check the status of the SSL handshake\n\tif ( ! $self->{'ssl_started'} ) {\n\t\treturn if $self->_check_status == 0;\n\t}\n\n\t# If we have no offset, replace the buffer with some input\n\tif ( ! defined $$offset ) {\n\t\t$$buf = Net::SSLeay::read( $self->{'ssl'}, $$len );\n\n\t\t# Are we done?\n\t\tif ( defined $$buf ) {\n\t\t\t# TODO do we need the same \"flush is success\" logic in WRITE?\n\n\t\t\treturn length( $$buf );\n\t\t} else {\n\t\t\t# Nah, clear the buffer too...\n\t\t\t$$buf = \"\";\n\t\t\treturn;\n\t\t}\n\t}\n\n\t# Now, actually read the data\n\tdefined( my $read = Net::SSLeay::read( $self->{'ssl'}, $$len ) ) or return;\n\n\t# TODO do we need the same \"flush is success\" logic in WRITE?\n\n\t# Figure out the buffer and offset\n\tmy $buf_len = length( $$buf );\n\n\t# If our offset is bigger, pad the buffer\n\tif ( $$offset > $buf_len ) {\n\t\t$$buf .= chr( 0 ) x ( $$offset - $buf_len );\n\t}\n\n\t# Insert what we just read into the buffer\n\tsubstr( $$buf, $$offset, 1, $read );\n\n\t# All done!\n\treturn length( $read );\n}\n\n# Write some stuff to the socket\nsub WRITE {\n\t# Get ourself + buffer + length + offset to write\n\tmy( $self, $len, $offset ) = ( $_[0], $_[2], $_[3] );\n\tmy $buf = \\$_[1]; # don't copy!\n\n\t# Check the status of the SSL handshake\n\tif ( ! $self->{'ssl_started'} ) {\n\t\t# The normal syswrite() POE uses expects 0 here.\n\t\treturn 0 if $self->_check_status == 0;\n\t}\n\n\t# If we have nothing to offset, then start from the beginning\n\tif ( ! defined $offset ) {\n\t\t$offset = 0;\n\t}\n\n\t# Thanks to RT#95071 and RT#58243 we need to clamp the length to the TLS 16K limit\n\t# seems like the same thing happened to https://www.mail-archive.com/openssl-users@openssl.org/msg28151.html\n\t$len = 16_384 if $len > 16_384;\n\n\t# don't trigger substr's magic as it is SLOOOOOOOOW!\n\t# see http://www.perlmonks.org/?node_id=732873\n\tmy $wrote_len = Net::SSLeay::write( $self->{'ssl'}, scalar substr( $$buf, $offset, $len ) );\n\n\t# Did we get an error or number of bytes written?\n\t# Net::SSLeay::write() returns the number of bytes written, or 0 on unsuccessful\n\t# operation (probably connection closed), or -1 on error.\n\tif ( $wrote_len < 0 ) {\n\t\t# The normal syswrite() POE uses expects 0 here.\n\t\treturn 0;\n\t} else {\n\t\t# We flushed some data, which means we finished the handshake!\n\t\t# This is IMPORTANT, as MIRE found out!\n\t\t# Otherwise openssl will zonk out and give us SSL_ERROR_SSL and things randomly break :(\n\t\t# this is because we tried to connect() or accept() and the handshake was done... or something like that hah\n\t\tif ( ! $self->{'ssl_started'} ) {\n\t\t\t$self->{'ssl_started'} = 1;\n\t\t\t$self->{'status'} = 1;\n\n\t\t\t# call the hook function for successful connect\n\t\t\tif ( defined $self->{'on_connect'} ) {\n\t\t\t\t$self->{'on_connect'}->( $self->{'orig_socket'}, 1 );\n\t\t\t}\n\t\t}\n\n\t\t# All done!\n\t\treturn $wrote_len;\n\t}\n}\n\n# Sets binmode on the socket\n# Thanks to RT #27117\nsub BINMODE {\n\tmy $self = shift;\n\tif (@_) {\n\t\tmy $mode = shift;\n\t\tbinmode $self->{'socket'}, $mode;\n\t} else {\n\t\tbinmode $self->{'socket'};\n\t}\n\n\treturn;\n}\n\n# Closes the socket\nsub CLOSE {\n\tmy $self = shift;\n\tif ( defined $self->{'socket'} ) {\n\t\tNet::SSLeay::free( $self->{'ssl'} );\n\n\t\t# TODO we ignore any close errors because there's no way to sanely propagate it up the stack...\n\t\tclose( $self->{'socket'} ); ## no critic ( InputOutput::RequireCheckedClose )\n\t\tundef $self->{'socket'};\n\n\t\t# do we need to do CTX_free?\n\t\tif ( exists $self->{'client'} ) {\n\t\t\tNet::SSLeay::CTX_free( $self->{'ctx'} );\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n# Add DESTROY handler\nsub DESTROY {\n\tmy $self = shift;\n\n\t# Did we already CLOSE?\n\tif ( defined $self->{'socket'} ) {\n\t\t# Guess not...\n\t\t$self->CLOSE();\n\t}\n\n\treturn;\n}\n\nsub FILENO {\n\tmy $self = shift;\n\treturn $self->{'fileno'};\n}\n\n# Not implemented TIE's\nsub READLINE {\n\tdie 'Not Implemented';\n}\n\nsub PRINT {\n\tdie 'Not Implemented';\n}\n\n1;\n\n__END__\n\n=pod\n\n=encoding UTF-8\n\n=for :stopwords Apocalypse\n\n=head1 NAME\n\nPOE::Component::SSLify::ServerHandle - Server-side handle for SSLify\n\n=head1 VERSION\n\n  This document describes v1.012 of POE::Component::SSLify::ServerHandle - released November 14, 2014 as part of POE-Component-SSLify.\n\n=head1 DESCRIPTION\n\n\tThis is a subclass of Net::SSLeay::Handle because their read() and sysread()\n\tdoes not cooperate well with POE. They block until length bytes are read from the\n\tsocket, and that is BAD in the world of POE...\n\n\tThis subclass behaves exactly the same, except that it doesn't block :)\n\n=head2 DIFFERENCES\n\n\tThis subclass doesn't know what to do with PRINT/READLINE, as they usually are not used in POE::Wheel operations...\n\n=head1 SEE ALSO\n\nPlease see those modules/websites for more information related to this module.\n\n=over 4\n\n=item *\n\nL<POE::Component::SSLify|POE::Component::SSLify>\n\n=back\n\n=head1 AUTHOR\n\nApocalypse <APOCAL@cpan.org>\n\n=head1 COPYRIGHT AND LICENSE\n\nThis software is copyright (c) 2014 by Apocal", 8192) = 8192
09:01:57.176237 lseek(9, 7171, SEEK_SET) = 7171
09:01:57.176286 lseek(9, 0, SEEK_CUR)   = 7171
09:01:57.176330 close(9)                = 0
09:01:57.176474 lseek(8, 1675, SEEK_SET) = 1675
09:01:57.176520 lseek(8, 0, SEEK_CUR)   = 1675
09:01:57.176565 close(8)                = 0
09:01:57.176703 open("/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 8
09:01:57.176760 fstat(8, {st_mode=S_IFREG|0644, st_size=26066, ...}) = 0
09:01:57.176814 mmap(NULL, 26066, PROT_READ, MAP_SHARED, 8, 0) = 0x7f7436f30000
09:01:57.176862 close(8)                = 0
09:01:57.176911 futex(0x7f74362f2f80, FUTEX_WAKE_PRIVATE, 2147483647) = 0
09:01:57.177530 brk(0x1058000)          = 0x1058000
09:01:57.178541 stat("/usr/lib/perl5/auto/Net/SSLeay/randomize.al", {st_mode=S_IFREG|0644, st_size=1088, ...}) = 0
09:01:57.178609 getgroups(0, NULL)      = 2
09:01:57.178657 getgroups(2, [1000, 1164]) = 2
09:01:57.178719 stat("/usr/lib/perl5/auto/Net/SSLeay/randomize.al", {st_mode=S_IFREG|0644, st_size=1088, ...}) = 0
09:01:57.178779 open("/usr/lib/perl5/auto/Net/SSLeay/randomize.al", O_RDONLY) = 8
09:01:57.178833 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b3e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.178879 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.178940 read(8, "# NOTE: Derived from blib/lib/Net/SSLeay.pm.\n# Changes made here will be lost when autosplit is run again.\n# See AutoSplit.pm.\npackage Net::SSLeay;\n\n#line 878 \"blib/lib/Net/SSLeay.pm (autosplit into blib/lib/auto/Net/SSLeay/randomize.al)\"\n### Arrange some randomness for eay PRNG\n\nsub randomize (;$$$) {\n    my ($rn_seed_file, $seed, $egd_path) = @_;\n    my $rnsf = defined($rn_seed_file) && -r $rn_seed_file;\n\n\t$egd_path = '';\n    $egd_path = $ENV{'EGD_PATH'} if $ENV{'EGD_PATH'};\n    \n    RAND_seed(rand() + $$);  # Stir it with time and pid\n    \n    unless ($rnsf || -r $Net::SSLeay::random_device || $seed || -S $egd_path) {\n\tmy $poll_retval = Net::SSLeay::RAND_poll();\n\twarn \"Random number generator not seeded!!!\" if $trace && !$poll_retval;\n    }\n    \n    RAND_load_file($rn_seed_file, -s _) if $rnsf;\n    RAND_seed($seed) if $seed;\n    RAND_seed($ENV{RND_SEED}) if $ENV{RND_SEED};\n    RAND_egd($egd_path) if -e $egd_path && -S _;\n    RAND_load_file($Net::SSLeay::random_device, $Net::SSLeay::how_random/8)\n\tif -r $Net::SSLeay::random_device;\n}\n\n# end of Net::SSLeay::randomize\n1;\n", 8192) = 1088
09:01:57.179146 read(8, "", 8192)       = 0
09:01:57.179195 close(8)                = 0
09:01:57.179258 open("/dev/urandom", O_RDONLY) = 8
09:01:57.179313 read(8, "\34\24\206\326", 4) = 4
09:01:57.179364 close(8)                = 0
09:01:57.179442 stat("/dev/urandom", {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0
09:01:57.179500 getgroups(0, NULL)      = 2
09:01:57.179545 getgroups(2, [1000, 1164]) = 2
09:01:57.179594 stat("", 0x65f138)      = -1 ENOENT (No such file or directory)
09:01:57.179643 stat("/dev/urandom", {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0
09:01:57.179698 getgroups(0, NULL)      = 2
09:01:57.179743 getgroups(2, [1000, 1164]) = 2
09:01:57.179796 stat("/dev/urandom", {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0
09:01:57.179863 open("/dev/urandom", O_RDONLY) = 8
09:01:57.179918 read(8, "\r\36\343x\215\315)\320\4Ywa\367qK\272\355\370 ]\7\3112)\223\300l\200;Dx\351H\347G\20\35\33GRPp\36\33\301\314\351* \31\242\365A \264\363\252h\231W\323\300\370^", 64) = 64
09:01:57.179987 close(8)                = 0
09:01:57.180171 stat("modules/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180223 stat("modules/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180272 stat("modules/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180320 stat("modules/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180369 stat("/etc/perl/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180419 stat("/etc/perl/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180468 stat("/usr/local/lib/perl/5.14.2/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180518 stat("/usr/local/lib/perl/5.14.2/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180568 stat("/usr/local/share/perl/5.14.2/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180619 stat("/usr/local/share/perl/5.14.2/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180668 stat("/usr/lib/perl5/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180717 stat("/usr/lib/perl5/Task/Weaken.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.180767 stat("/usr/share/perl5/Task/Weaken.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.180817 stat("/usr/share/perl5/Task/Weaken.pm", {st_mode=S_IFREG|0644, st_size=2538, ...}) = 0
09:01:57.180875 open("/usr/share/perl5/Task/Weaken.pm", O_RDONLY) = 8
09:01:57.180928 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b390) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.180974 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.181035 read(8, "package Task::Weaken;\n\nuse 5.005;\nuse strict;\n\nuse vars qw{$VERSION};\nBEGIN {\n\t$VERSION = '1.03';\n}\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nTask::Weaken - Ensure that a platform has weaken support\n\n=head1 DESCRIPTION\n\nOne recurring problem in modules that use L<Scalar::Util>'s C<weaken>\nfunction is that it is not present in the pure-perl variant.\n\nWhile this isn't necesarily always a problem in a straight CPAN-based\nPerl environment, some operating system distributions only include the\npure-Perl versions, don't include the XS version, and so weaken is\nthen \"missing\" from the platform, B<despite> passing a dependency on\nL<Scalar::Util> successfully.\n\nMost notably this is RedHat Linux at time of writing, but other come\nand go and do the same thing, hence \"recurring problem\".\n\nThe normal solution is to manually write tests in each distribution\nto ensure that C<weaken> is available.\n\nThis restores the functionality testing to a dependency you do once\nin your F<Makefile.PL>, rather than something you have to write extra\ntests for each time you write a module.\n\nIt should also help make the package auto-generators for the various\noperating systems play more nicely, because it introduces a dependency\nthat they B<have> to have a proper weaken in order to work.\n\n=head2 How this Task works\n\nPart of the problem seems to stem from the fact that some distributions\ncontinue to include modules even if they fail some of their tests.\n\nTo get around that for this module, it will do a few dirty tricks.\n\nIf L<Scalar::Util> is not available at all, it will issue a normal\ndependency on the module. However, if L<Scalar::Util> is relatively\nnew ( it is >= 1.19 ) and the module does B<not> have weaken, the\ninstall will bail out altogether with a long error encouraging the\nuser to seek support from their vendor (this problem happens most\noften in vendor-packaged Perl versions).\n\nThis distribution also contains tests to ensure that weaken is\navailable using more normal methods.\n\nSo if your module uses C<weaken>, you can just add the following to\nyour L<Module::Install>-based F<Makefile.PL> (or equivalent).\n\n  requires 'Task::Weaken' => 0;\n\n=head1 AUTHOR\n\nAdam Kennedy E<lt>adamk@cpan.orgE<gt>, L<http://ali.as/>\n\n=head1 SEE ALSO\n\nL<Task>, L<Scalar::Util>, L<http://ali.as/>\n\n=head1 COPYRIGHT\n\nCopyright 2006 - 2009 Adam Kennedy.\n\nThis program is free software; you can redistribute\nit and/or modify it under the same terms as Perl itself.\n\nThe full text of the license can be found in the\nLICENSE file included with this module.\n\n=cut\n", 8192) = 2538
09:01:57.181379 lseek(8, 113, SEEK_SET) = 113
09:01:57.181429 lseek(8, 0, SEEK_CUR)   = 113
09:01:57.181474 close(8)                = 0
09:01:57.181628 read(7, "subclass: $!\";\n\n\t# argh, store the newsock in the tied class to use for callback\n\tif ( defined $callback ) {\n\t\ttied( *$newsock )->{'orig_socket'} = $newsock;\n\t\tweaken( tied( *$newsock )->{'orig_socket'} );\n\t}\n\n\t# All done!\n\treturn $newsock;\n}\n\n#pod =func Server_SSLify\n#pod\n#pod This function sslifies a server-side socket. You can pass several options to it:\n#pod\n#pod \tmy $socket = shift;\n#pod \t$socket = Server_SSLify( $socket, $ctx, $callback );\n#pod \t\t$socket is the non-ssl socket you got from somewhere ( required )\n#pod \t\t$ctx is the custom SSL context you want to use; overrides the global ctx set in SSLify_Options\n#pod \t\t$callback is the callback hook on success/failure of sslification\n#pod\n#pod BEWARE: L</SSLify_Options> must be called first if you aren't passing a $ctx. If you want to set some options per-connection, do this:\n#pod\n#pod \tmy $socket = shift;\t# get the socket from somewhere\n#pod \tmy $ctx = SSLify_ContextCreate();\n#pod \t# set various options on $ctx as desired\n#pod \t$socket = Server_SSLify( $socket, $ctx );\n#pod\n#pod NOTE: You can use L</SSLify_GetCTX> to modify the global, and avoid doing this on every connection if the\n#pod options are the same...\n#pod\n#pod Please look at L</Client_SSLify> for more details on the callback hook.\n#pod =cut\n\nsub Server_SSLify {\n\t# Get the socket!\n\tmy( $socket, $custom_ctx, $callback ) = @_;\n\n\t# Validation...\n\tif ( ! defined $socket ) {\n\t\tdie \"Did not get a defined socket\";\n\t}\n\n\t# If we don't have a ctx ready, we can't do anything...\n\tif ( ! defined $ctx and ! defined $custom_ctx ) {\n\t\tdie 'Please do SSLify_Options() first ( or pass in a $ctx object )';\n\t}\n\n\t# mangle custom_ctx depending on callback\n\tif ( defined $custom_ctx and ref $custom_ctx and ref( $custom_ctx ) eq 'CODE' ) {\n\t\t$callback = $custom_ctx;\n\t\t$custom_ctx = undef;\n\t}\n\n\t# From IO::Handle POD\n\t# If an error occurs blocking will return undef and $! will be set.\n\tif ( ! defined $socket->blocking( 0 ) ) {\n\t\tdie \"Unable to set nonblocking mode on socket: $!\";\n\t}\n\n\t# Now, we create the new socket and bind it to our subclass of Net::SSLeay::Handle\n\tmy $newsock = gensym();\n\ttie( *$newsock, 'POE::Component::SSLify::ServerHandle', $socket, ( $custom_ctx || $ctx ), $callback ) or die \"Unable to tie to our subclass: $!\";\n\n\t# argh, store the newsock in the tied class to use for connref\n\tif ( defined $callback ) {\n\t\ttied( *$newsock )->{'orig_socket'} = $newsock;\n\t\tweaken( tied( *$newsock )->{'orig_socket'} );\n\t}\n\n\t# All done!\n\treturn $newsock;\n}\n\n#pod =func SSLify_ContextCreate\n#pod\n#pod Accepts some options, and returns a brand-new Net::SSLeay context object ( $ctx )\n#pod\n#pod \tmy $ctx = SSLify_ContextCreate( $key, $cert, $version, $options );\n#pod \t\t$key is the certificate key file\n#pod \t\t$cert is the certificate file\n#pod \t\t$version is the SSL version to use\n#pod \t\t$options is the SSL options to use\n#pod\n#pod You can then call various Net::SSLeay methods on the context\n#pod\n#pod \tmy $mode = Net::SSLeay::CTX_get_mode( $ctx );\n#pod\n#pod By default we don't use the SSL key + certificate files\n#pod\n#pod By default we use the version: default. Known versions of the SSL connection - look at\n#pod L<http://www.openssl.org/docs/ssl/SSL_CTX_new.html> for more info.\n#pod\n#pod \t* sslv2\n#pod \t* sslv3\n#pod \t* tlsv1\n#pod \t* sslv23\n#pod \t* default ( sslv23 )\n#pod\n#pod By default we don't set any options - look at L<http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html> for more info.\n#pod =cut\n\nsub SSLify_ContextCreate {\n\t# Get the key + cert + version + options\n\tmy( $key, $cert, $version, $options ) = @_;\n\n\treturn _createSSLcontext( $key, $cert, $version, $options );\n}\n\n#pod =func SSLify_Options\n#pod\n#pod Call this function to initialize the global server-side context object. This will be the default context whenever you call\n#pod L</Server_SSLify> without passing a custom context to it.\n#pod\n#pod \tSSLify_Options( $key, $cert, $version, $options );\n#pod \t\t$key is the certificate key file ( required )\n#pod \t\t$cert is the certificate file ( required )\n#pod \t\t$version is the SSL version to use\n#pod \t\t$options is the SSL options to use\n#pod\n#pod By default we use the version: default\n#pod\n#pod By default we use the options: Net::SSLeay::OP_ALL\n#pod\n#pod Please look at L</SSLify_ContextCreate> for more info on the available versions/options.\n#pod =cut\n\nsub SSLify_Options {\n\t# Get the key + cert + version + options\n\tmy( $key, $cert, $version, $options ) = @_;\n\n\t# sanity\n\tif ( ! defined $key or ! defined $cert ) {\n\t\tdie 'no key/cert specified';\n\t}\n\n\t# Set the default\n\tif ( ! defined $options ) {\n\t\t$options = Net::SSLeay::OP_ALL();\n\t}\n\n\t# set the context, possibly overwriting the previous one\n\tif ( defined $ctx ) {\n\t\tNet::SSLeay::CTX_free( $ctx );\n\t\tundef $ctx;\n\t}\n\t$ctx = _createSSLcontext( $key, $cert, $version, $options );\n\n\t# all done!\n\treturn 1;\n}\n\nsub _createSSLcontext {\n\tmy( $key, $cert, $version, $options ) = @_;\n\n\tmy $context;\n\tif ( defined $version and ! ref $version ) {\n\t\tif ( $version eq 'sslv2' ) {\n\t\t\t$context = Net::SSLeay::CTX_v2_new();\n\t\t} elsif ( $version eq 'sslv3' ) {\n\t\t\t$context = Net::SSLeay::CTX_v3_new();\n\t\t} elsif ( $version eq 'tlsv1' ) {\n\t\t\t$context = Net::SSLeay::CTX_tlsv1_new();\n\t\t} elsif ( $version eq 'sslv23' ) {\n\t\t\t$context = Net::SSLeay::CTX_v23_new();\n\t\t} elsif ( $version eq 'default' ) {\n\t\t\t$context = Net::SSLeay::CTX_new();\n\t\t} else {\n\t\t\tdie \"unknown SSL version: $version\";\n\t\t}\n\t} else {\n\t\t$context = Net::SSLeay::CTX_new();\n\t}\n\tif ( ! defined $context ) {\n\t\tdie_now( \"Failed to create SSL_CTX $!\" );\n\t\treturn;\n\t}\n\n\t# do we need to set options?\n\tif ( defined $options ) {\n\t\tNet::SSLeay::CTX_set_options( $context, $options );\n\t\tdie_if_ssl_error( 'ssl ctx set options' ) if ! $IGNORE_SSL_ERRORS;\n\t}\n\n\t# do we need to set key/etc?\n\tif ( defined $key ) {\n\t\t# Following will ask password unless private key is not encrypted\n\t\tNet::SSLeay::CTX_use_RSAPrivateKey_file( $context, $key, FILETYPE_PEM );\n\t\tdie_if_ssl_error( 'private key' ) if ! $IGNORE_SSL_ERRORS;\n\t}\n\n\t# Set the cert file\n\tif ( defined $cert ) {\n\t\tNet::SSLeay::CTX_use_certificate_chain_file( $context, $cert );\n\t\tdie_if_ssl_error( 'certificate' ) if ! $IGNORE_SSL_ERRORS;\n\t}\n\n\t# All done!\n\treturn $context;\n}\n\n#pod =func SSLify_GetCTX\n#pod\n#pod Returns the actual Net::SSLeay context object in case you wanted to play with it :)\n#pod\n#pod If passed in a socket, it will return that socket's $ctx instead of the global.\n#pod\n#pod \tmy $ctx = SSLify_GetCTX();\t\t\t# get the one set via SSLify_Options\n#pod \tmy $ctx = SSLify_GetCTX( $sslified_sock );\t# get the one in the object\n#pod =cut\n\nsub SSLify_GetCTX {\n\tmy $sock = shift;\n\tif ( ! defined $sock ) {\n\t\treturn $ctx;\n\t} else {\n\t\treturn tied( *$sock )->{'ctx'};\n\t}\n}\n\n#pod =func SSLify_GetCipher\n#pod\n#pod Returns the cipher used by the SSLified socket\n#pod\n#pod \tprint \"SSL Cipher is: \" . SSLify_GetCipher( $sslified_sock ) . \"\\n\";\n#pod\n#pod NOTE: Doing this immediately after Client_SSLify or Server_SSLify will result in \"(NONE)\" because the SSL handshake\n#pod is not done yet. The socket is nonblocking, so you will have to wait a little bit for it to get ready.\n#pod\n#pod \tapoc@blackhole:~/mygit/perl-poe-sslify/examples$ perl serverclient.pl\n#pod \tgot connection from: 127.0.0.1 - commencing Server_SSLify()\n#pod \tSSLified: 127.0.0.1 cipher type: ((NONE))\n#pod \tConnected to server, commencing Client_SSLify()\n#pod \tSSLified the connection to the server\n#pod \tConnected to SSL server\n#pod \tInput: hola\n#pod \tgot input from: 127.0.0.1 cipher type: (AES256-SHA) input: 'hola'\n#pod \tGot Reply: hola\n#pod \tInput: ^C\n#pod \tstopped at serverclient.pl line 126.\n#pod =cut\n\nsub SSLify_GetCipher {\n\tmy $sock = shift;\n\treturn Net::SSLeay::get_cipher( tied( *$sock )->{'ssl'} );\n}\n\n#pod =func SSLify_GetSocket\n#pod\n#pod Returns the actual socket used by the SSLified socket, useful for stuff like getpeername()/getsockname()\n#pod\n#pod \tprint \"Remote IP is: \" . inet_ntoa( ( unpack_sockaddr_in( getpeername( SSLify_GetSocket( $sslified_sock ) ) ) )[1] ) . \"\\n\";\n#pod =cut\n\nsub SSLify_GetSocket {\n\tmy $sock = shift;\n\treturn tied( *$sock )->{'socket'};\n}\n\n#pod =func SSLify_GetSSL\n#pod\n#pod Returns the actual Net::SSLeay object so you can call methods on it\n#pod\n#pod \tprint N", 8192) = 8192
09:01:57.182328 brk(0x1079000)          = 0x1079000
09:01:57.182499 read(7, "et::SSLeay::dump_peer_certificate( SSLify_GetSSL( $sslified_sock ) );\n#pod =cut\n\nsub SSLify_GetSSL {\n\tmy $sock = shift;\n\treturn tied( *$sock )->{'ssl'};\n}\n\n#pod =func SSLify_GetStatus\n#pod\n#pod Returns the status of the SSL negotiation/handshake/connection. See L<http://www.openssl.org/docs/ssl/SSL_connect.html#RETURN_VALUES>\n#pod for more info.\n#pod\n#pod \tmy $status = SSLify_GetStatus( $socket );\n#pod \t\t-1 = still in negotiation stage ( or error )\n#pod \t\t 0 = internal SSL error, connection will be dead\n#pod \t\t 1 = negotiation successful\n#pod =cut\n\nsub SSLify_GetStatus {\n\tmy $sock = shift;\n\treturn tied( *$sock )->{'status'};\n}\n\n1;\n\n__END__\n\n=pod\n\n=encoding UTF-8\n\n=for :stopwords Apocalypse cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee\ndiff irc mailto metadata placeholders metacpan\n\n=head1 NAME\n\nPOE::Component::SSLify - Makes using SSL in the world of POE easy!\n\n=head1 VERSION\n\n  This document describes v1.012 of POE::Component::SSLify - released November 14, 2014 as part of POE-Component-SSLify.\n\n=head1 SYNOPSIS\n\n\t# look at the DESCRIPTION for client and server example code\n\n=head1 DESCRIPTION\n\nThis component is a method to simplify the SSLification of a socket before it is passed\nto a L<POE::Wheel::ReadWrite> wheel in your application.\n\n=head2 Client usage\n\n\t# Import the module\n\tuse POE::Component::SSLify qw( Client_SSLify );\n\n\t# Create a normal SocketFactory wheel and connect to a SSL-enabled server\n\tmy $factory = POE::Wheel::SocketFactory->new;\n\n\t# Time passes, SocketFactory gives you a socket when it connects in SuccessEvent\n\t# Convert the socket into a SSL socket POE can communicate with\n\tmy $socket = shift;\n\teval { $socket = Client_SSLify( $socket ) };\n\tif ( $@ ) {\n\t\t# Unable to SSLify it...\n\t}\n\n\t# Now, hand it off to ReadWrite\n\tmy $rw = POE::Wheel::ReadWrite->new(\n\t\tHandle\t=>\t$socket,\n\t\t# other options as usual\n\t);\n\n=head2 Server usage\n\n\t# !!! Make sure you have a public key + certificate\n\t# excellent howto: http://www.akadia.com/services/ssh_test_certificate.html\n\n\t# Import the module\n\tuse POE::Component::SSLify qw( Server_SSLify SSLify_Options );\n\n\t# Set the key + certificate file\n\teval { SSLify_Options( 'server.key', 'server.crt' ) };\n\tif ( $@ ) {\n\t\t# Unable to load key or certificate file...\n\t}\n\n\t# Create a normal SocketFactory wheel to listen for connections\n\tmy $factory = POE::Wheel::SocketFactory->new;\n\n\t# Time passes, SocketFactory gives you a socket when it gets a connection in SuccessEvent\n\t# Convert the socket into a SSL socket POE can communicate with\n\tmy $socket = shift;\n\teval { $socket = Server_SSLify( $socket ) };\n\tif ( $@ ) {\n\t\t# Unable to SSLify it...\n\t}\n\n\t# Now, hand it off to ReadWrite\n\tmy $rw = POE::Wheel::ReadWrite->new(\n\t\tHandle\t=>\t$socket,\n\t\t# other options as usual\n\t);\n\n=head1 FUNCTIONS\n\n=head2 Client_SSLify\n\nThis function sslifies a client-side socket. You can pass several options to it:\n\n\tmy $socket = shift;\n\t$socket = Client_SSLify( $socket, $version, $options, $ctx, $callback );\n\t\t$socket is the non-ssl socket you got from somewhere ( required )\n\t\t$version is the SSL version you want to use\n\t\t$options is the SSL options you want to use\n\t\t$ctx is the custom SSL context you want to use\n\t\t$callback is the callback hook on success/failure of sslification\n\n\t\t# This is an example of the callback and you should pass it as Client_SSLify( $socket, ... , \\&callback );\n\t\tsub callback {\n\t\t\tmy( $socket, $status, $errval ) = @_;\n\t\t\t# $socket is the original sslified socket in case you need to play with it\n\t\t\t# $status is either 1 or 0; with 1 signifying success and 0 failure\n\t\t\t# $errval will be defined if $status == 0; it's the numeric SSL error code\n\t\t\t# check http://www.openssl.org/docs/ssl/SSL_get_error.html for the possible error values ( and import them from Net::SSLeay! )\n\n\t\t\t# The return value from the callback is discarded\n\t\t}\n\nIf $ctx is defined, SSLify will ignore $version and $options. Otherwise, it will be created from the $version and\n$options parameters. If all of them are undefined, it will follow the defaults in L</SSLify_ContextCreate>.\n\nBEWARE: If you passed in a CTX, SSLify will do Net::SSLeay::CTX_free( $ctx ) when the\nsocket is destroyed. This means you cannot reuse contexts!\n\nNOTE: The way to have a client socket with proper certificates set up is:\n\n\tmy $socket = shift;\t# get the socket from somewhere\n\tmy $ctx = SSLify_ContextCreate( 'server.key', 'server.crt' );\n\t$socket = Client_SSLify( $socket, undef, undef, $ctx );\n\nNOTE: You can pass the callback anywhere in the arguments, we'll figure it out for you! If you want to call a POE event, please look\ninto the postback/callback stuff in L<POE::Session>.\n\n\t# we got this from POE::Wheel::SocketFactory\n\tsub event_SuccessEvent {\n\t\tmy $socket = $_[ARG0];\n\t\t$socket = Client_SSLify( $socket, $_[SESSION]->callback( 'sslify_result' ) );\n\t\t$_[HEAP]->{client} = POE::Wheel::ReadWrite->new(\n\t\t\tHandle => $socket,\n\t\t\t...\n\t\t);\n\t\treturn;\n\t}\n\n\t# the callback event\n\tsub event_sslify_result {\n\t\tmy ($creation_args, $called_args) = @_[ARG0, ARG1];\n\t\tmy( $socket, $status, $errval ) = @$called_args;\n\n\t\tif ( $status ) {\n\t\t\tprint \"Yay, SSLification worked!\";\n\t\t} else {\n\t\t\tprint \"Aw, SSLification failed with error $errval\";\n\t\t}\n\t}\n\n=head2 Server_SSLify\n\nThis function sslifies a server-side socket. You can pass several options to it:\n\n\tmy $socket = shift;\n\t$socket = Server_SSLify( $socket, $ctx, $callback );\n\t\t$socket is the non-ssl socket you got from somewhere ( required )\n\t\t$ctx is the custom SSL context you want to use; overrides the global ctx set in SSLify_Options\n\t\t$callback is the callback hook on success/failure of sslification\n\nBEWARE: L</SSLify_Options> must be called first if you aren't passing a $ctx. If you want to set some options per-connection, do this:\n\n\tmy $socket = shift;\t# get the socket from somewhere\n\tmy $ctx = SSLify_ContextCreate();\n\t# set various options on $ctx as desired\n\t$socket = Server_SSLify( $socket, $ctx );\n\nNOTE: You can use L</SSLify_GetCTX> to modify the global, and avoid doing this on every connection if the\noptions are the same...\n\nPlease look at L</Client_SSLify> for more details on the callback hook.\n\n=head2 SSLify_ContextCreate\n\nAccepts some options, and returns a brand-new Net::SSLeay context object ( $ctx )\n\n\tmy $ctx = SSLify_ContextCreate( $key, $cert, $version, $options );\n\t\t$key is the certificate key file\n\t\t$cert is the certificate file\n\t\t$version is the SSL version to use\n\t\t$options is the SSL options to use\n\nYou can then call various Net::SSLeay methods on the context\n\n\tmy $mode = Net::SSLeay::CTX_get_mode( $ctx );\n\nBy default we don't use the SSL key + certificate files\n\nBy default we use the version: default. Known versions of the SSL connection - look at\nL<http://www.openssl.org/docs/ssl/SSL_CTX_new.html> for more info.\n\n\t* sslv2\n\t* sslv3\n\t* tlsv1\n\t* sslv23\n\t* default ( sslv23 )\n\nBy default we don't set any options - look at L<http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html> for more info.\n\n=head2 SSLify_Options\n\nCall this function to initialize the global server-side context object. This will be the default context whenever you call\nL</Server_SSLify> without passing a custom context to it.\n\n\tSSLify_Options( $key, $cert, $version, $options );\n\t\t$key is the certificate key file ( required )\n\t\t$cert is the certificate file ( required )\n\t\t$version is the SSL version to use\n\t\t$options is the SSL options to use\n\nBy default we use the version: default\n\nBy default we use the options: Net::SSLeay::OP_ALL\n\nPlease look at L</SSLify_ContextCreate> for more info on the available versions/options.\n\n=head2 SSLify_GetCTX\n\nReturns the actual Net::SSLeay context object in case you wanted to play with it :)\n\nIf passed in a socket, it will return that socket's $ctx instead of the global.\n\n\tmy $ctx = SSLify_GetCTX();\t\t\t# get the one set via SSLify_Options\n\tmy $ctx = SSLify_GetCTX( $sslified_sock );\t# get the one in the object\n\n=head2 SSLify_GetCipher\n\nReturns the cipher used by the SSLified socket\n\n\tprint \"SSL Cipher is: \" . SSLify_GetCipher( $sslified_sock ) . \"\\n\";\n\nNOTE: Doing this immediately after Client_SSLify or Server_SSLify will result in \"(NONE)\" because the SSL handshake\nis not done yet. The socket is ", 8192) = 8192
09:01:57.182943 lseek(7, 17032, SEEK_SET) = 17032
09:01:57.182991 lseek(7, 0, SEEK_CUR)   = 17032
09:01:57.183035 close(7)                = 0
09:01:57.183126 stat("modules/POE/Component/Client/DNS.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.183181 stat("modules/POE/Component/Client/DNS.pm", {st_mode=S_IFREG|0600, st_size=23866, ...}) = 0
09:01:57.183242 open("modules/POE/Component/Client/DNS.pm", O_RDONLY) = 7
09:01:57.183295 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b9c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.183342 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.183397 read(7, "# License and documentation are after __END__.\n# vim: ts=2 sw=2 expandtab\n\npackage POE::Component::Client::DNS;\n$POE::Component::Client::DNS::VERSION = '1.054';\nuse strict;\n\nuse Carp qw(croak);\n\nuse Socket qw(unpack_sockaddr_in inet_ntoa);\nuse Net::DNS;\nuse POE;\n\nuse constant DEBUG => 0;\n\n# A hosts file we found somewhere.\n\nmy $global_hosts_file;\n\n# Object fields.  \"SF\" stands for \"self\".\n\nuse constant SF_ALIAS       => 0;\nuse constant SF_TIMEOUT     => 1;\nuse constant SF_NAMESERVERS => 2;\nuse constant SF_RESOLVER    => 3;\nuse constant SF_HOSTS_FILE  => 4;\nuse constant SF_HOSTS_MTIME => 5;\nuse constant SF_HOSTS_CTIME => 6;\nuse constant SF_HOSTS_INODE => 7;\nuse constant SF_HOSTS_CACHE => 8;\nuse constant SF_HOSTS_BYTES => 9;\nuse constant SF_SHUTDOWN    => 10;\nuse constant SF_REQ_BY_SOCK => 11;\n\n# Spawn a new PoCo::Client::DNS session.  This basically is a\n# constructor, but it isn't named \"new\" because it doesn't create a\n# usable object.  Instead, it spawns the object off as a session.\n\nsub spawn {\n  my $type = shift;\n  croak \"$type requires an even number of parameters\" if @_ % 2;\n  my %params = @_;\n\n  my $alias = delete $params{Alias};\n  $alias = \"resolver\" unless $alias;\n\n  my $timeout = delete $params{Timeout};\n  $timeout = 90 unless $timeout;\n\n  my $nameservers = delete $params{Nameservers};\n  my $resolver = Net::DNS::Resolver->new();\n  $nameservers ||= [ $resolver->nameservers() ];\n\n  my $hosts = delete $params{HostsFile};\n\n  croak(\n    \"$type doesn't know these parameters: \", join(', ', sort keys %params)\n  ) if scalar keys %params;\n\n  # TODO - SF_NAMESERVERS isn't used right now.  It exists for future\n  # expansion.\n\n  my $self = bless [\n    $alias,                     # SF_ALIAS\n    $timeout,                   # SF_TIMEOUT\n    $nameservers,               # SF_NAMESERVERS\n    $resolver,                  # SF_RESOLVER\n    $hosts,                     # SF_HOSTS_FILE\n    0,                          # SF_HOSTS_MTIME\n    0,                          # SF_HOSTS_CTIME\n    0,                          # SF_HOSTS_INODE\n    { },                        # SF_HOSTS_CACHE\n    0,                          # SF_HOSTS_BYTES\n    0,                          # SF_SHUTDOWN\n  ], $type;\n\n  # Set the list of nameservers, if one was supplied.\n  # May redundantly reset itself.\n  $self->[SF_RESOLVER]->nameservers(@$nameservers);\n\n  POE::Session->create(\n    object_states => [\n      $self => {\n        _default         => \"_dns_default\",\n        _start           => \"_dns_start\",\n        _stop            => \"_dns_stop\",\n        got_dns_response => \"_dns_response\",\n        resolve          => \"_dns_resolve\",\n        send_request     => \"_dns_do_request\",\n        shutdown         => \"_dns_shutdown\",\n      },\n    ],\n  );\n\n  return $self;\n}\n\n# Public method interface.\n\nsub resolve {\n  my $self = shift;\n  croak \"resolve() needs an even number of parameters\" if @_ % 2;\n  my %args = @_;\n\n  croak \"resolve() must include an 'event'\"  unless exists $args{event};\n  croak \"resolve() must include a 'context'\" unless exists $args{context};\n  croak \"resolve() must include a 'host'\"    unless exists $args{host};\n\n  $poe_kernel->call( $self->[SF_ALIAS], \"resolve\", \\%args );\n\n  return undef;\n}\n\nsub shutdown {\n  my $self = shift;\n  $poe_kernel->call( $self->[SF_ALIAS], \"shutdown\" );\n}\n\n# Start the resolver session.  Record the parameters which were\n# validated in spawn(), create the internal resolver object, and set\n# an alias which we'll be known by.\n\nsub _dns_start {\n  my ($object, $kernel) = @_[OBJECT, KERNEL];\n  $kernel->alias_set($object->[SF_ALIAS]);\n}\n\n# Dummy handler to avoid ASSERT_DEFAULT problems.\n\nsub _dns_stop {\n  # do nothing\n}\n\n# Receive a request.  Version 4 API.  This uses extra reference counts\n# to keep the client sessions alive until responses are ready.\n\nsub _dns_resolve {\n  my ($self, $kernel, $sender, $event, $host, $type, $class) =\n    @_[OBJECT, KERNEL, SENDER, ARG0, ARG1, ARG2, ARG3];\n\n  my $debug_info =\n    \"in Client::DNS request at $_[CALLER_FILE] line $_[CALLER_LINE]\\n\";\n\n  my ($api_version, $context, $timeout);\n\n  my @nameservers;\n\n  # Version 3 API.  Pass the entire request as a hash.\n  if (ref($event) eq 'HASH') {\n    my %args = %$event;\n\n    $type = delete $args{type};\n    $type = \"A\" unless $type;\n\n    $class = delete $args{class};\n    $class = \"IN\" unless $class;\n\n    $event = delete $args{event};\n    die \"Must include an 'event' $debug_info\" unless $event;\n\n    $context = delete $args{context};\n    die \"Must include a 'context' $debug_info\" unless $context;\n\n    $timeout = delete $args{timeout};\n\n    @nameservers = @{delete $args{nameservers}} if $args{nameservers};\n\n    $host = delete $args{host};\n    die \"Must include a 'host' $debug_info\" unless $host;\n\n    $api_version = 3;\n  }\n\n  # Parse user args from the magical $response format.  Version 2 API.\n\n  elsif (ref($event) eq \"ARRAY\") {\n    $context     = $event;\n    $event       = shift @$context;\n    $api_version = 2;\n  }\n\n  # Whee.  Version 1 API.\n\n  else {\n    $context     = [ ];\n    $api_version = 1;\n  }\n\n  @nameservers = @{ $self->[SF_NAMESERVERS] } unless @nameservers;\n\n  # Default the request's timeout.\n  $timeout = $self->[SF_TIMEOUT] unless $timeout;\n\n  # Set an extra reference on the sender so it doesn't go away.\n  $kernel->refcount_increment($sender->ID, __PACKAGE__);\n\n  # If it's an IN type A request, check /etc/hosts or the equivalent.\n  # -><- This is not always the right thing to do, but it's more right\n  # more often than never checking at all.\n\n  if (($type eq \"A\" or $type eq \"AAAA\") and $class eq \"IN\") {\n    my $address = $self->_check_hosts_file($host, $type);\n\n    if (defined $address) {\n      # Pretend the request went through a name server.\n\n      my $packet = Net::DNS::Packet->new($address, $type, \"IN\");\n      $packet->push(\n        \"answer\",\n        Net::DNS::RR->new(\n          Name    => $host,\n          TTL     => 1,\n          Class   => $class,\n          Type    => $type,\n          Address => $address,\n        )\n      );\n\n      # Send the response immediately, and return.\n\n      _send_response(\n        api_ver  => $api_version,\n        sender   => $sender,\n        event    => $event,\n        host     => $host,\n        type     => $type,\n        class    => $class,\n        context  => $context,\n        response => $packet,\n        error    => \"\",\n      );\n\n      return;\n    }\n  }\n\n  # We are here.  Yield off to the state where the request will be\n  # sent.  This is done so that the do-it state can yield or delay\n  # back to itself for retrying.\n\n  my $now = time();\n  $kernel->call(\n    $self->[SF_ALIAS],\n    send_request => {\n      sender      => $sender,\n      event       => $event,\n      host        => $host,\n      type        => $type,\n      class       => $class,\n      context     => $context,\n      started     => $now,\n      ends        => $now + $timeout,\n      api_ver     => $api_version,\n      nameservers => \\@nameservers,\n    }\n  );\n}\n\n# Perform the real request.  May recurse to perform retries.\n\nsub _dns_do_request {\n  my ($self, $kernel, $req) = @_[OBJECT, KERNEL, ARG0];\n\n  # Did the request time out?\n  my $remaining = $req->{ends} - time();\n  if ($remaining <= 0) {\n    _send_response(\n      %$req,\n      response => undef,\n      error    => \"timeout\",\n    );\n    return;\n  }\n\n  # Send the request.\n\n  $self->[SF_RESOLVER]->nameservers(\n    @{ $req->{nameservers} || $self->[SF_NAMESERVERS] }\n  );\n  my $resolver_ref = $self->[SF_RESOLVER]->bgsend(\n    $req->{host},\n    $req->{type},\n    $req->{class}\n  );\n\n  # The request failed?  Attempt to retry.\n\n  unless ($resolver_ref) {\n    $remaining = 1 if $remaining > 1;\n    $kernel->delay_add(send_request => $remaining, $req);\n    return;\n  }\n\n  my $resolver_socket;\n\n  if ( ref( $resolver_ref ) eq 'IO::Select' ) {\n    ($resolver_socket) = [ $resolver_ref->handles ]->[0][0];\n  }\n  else {\n    $resolver_socket = $resolver_ref;\n  }\n\n  $req->{RES_REF} = $resolver_ref;\n\n  # Set a timeout for the request, and watch the response socket for\n  # activity.\n\n  $self->[SF_REQ_BY_SOCK]->{$resolver_socket} = $req;\n\n  $kernel->delay($resolver_socket, $remaining / 2, $resolver_socket);\n  $kernel->select_read($resolver_socket, 'got_dn", 8192) = 8192
09:01:57.183909 stat("modules/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.183962 stat("modules/Net/DNS.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.184012 stat("modules/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.184061 stat("modules/Net/DNS.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.184110 stat("/etc/perl/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.184160 stat("/etc/perl/Net/DNS.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.184211 stat("/usr/local/lib/perl/5.14.2/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.184261 stat("/usr/local/lib/perl/5.14.2/Net/DNS.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.184311 stat("/usr/local/share/perl/5.14.2/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.184361 stat("/usr/local/share/perl/5.14.2/Net/DNS.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.184411 stat("/usr/lib/perl5/Net/DNS.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.184462 stat("/usr/lib/perl5/Net/DNS.pm", {st_mode=S_IFREG|0644, st_size=26217, ...}) = 0
09:01:57.184525 open("/usr/lib/perl5/Net/DNS.pm", O_RDONLY) = 8
09:01:57.184579 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b390) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.184625 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.184683 read(8, "\npackage Net::DNS;\n#\n# $Id: DNS.pm 829 2009-12-23 15:39:59Z olaf $\n#\nuse strict;\n\n\nBEGIN { \n    eval { require bytes; }\n}\n\n\n\nuse vars qw(\n    $HAVE_XS\n    $VERSION\n    $SVNVERSION\n    $DNSSEC\n    $DN_EXPAND_ESCAPES\n    @ISA\n    @EXPORT\n    @EXPORT_OK\n    %typesbyname\n    %typesbyval\n    %qtypesbyname\n    %qtypesbyval\n    %metatypesbyname\n    %metatypesbyval\n    %classesbyname\n    %classesbyval\n    %opcodesbyname\n    %opcodesbyval\n    %rcodesbyname\n    %rcodesbyval\n);\n\n\n\nBEGIN {\n\n    require Exporter;\n    @ISA     = qw(Exporter );\n    # these need to live here because of dependencies further on.\n    @EXPORT = qw(mx yxrrset nxrrset yxdomain nxdomain rr_add rr_del);\n    @EXPORT_OK= qw(name2labels wire2presentation rrsort stripdot);\n\n\n\n    \n    $VERSION = '0.66';\n    $SVNVERSION = (qw$LastChangedRevision: 829 $)[1];\n\n\n\n\n    $HAVE_XS = eval { \n\tlocal $SIG{'__DIE__'} = 'DEFAULT';\n\n\n\teval {\n\t\trequire XSLoader;\n\t\tXSLoader::load('Net::DNS', $VERSION);\n\t\t1;\n\t} or do {\n\n\t\trequire DynaLoader;\n\t\tpush @ISA, 'DynaLoader';\n\t\tbootstrap Net::DNS $VERSION;\n\t\t1;\n\t};\n\n\t} ? 1 : 0;\n\n}\n\n\n\nBEGIN {\n\n    $DNSSEC = eval { \n\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t    require Net::DNS::SEC; \n\t    1 \n\t    } ? 1 : 0;\n\n\n}\n\n\nuse Net::DNS::Resolver;\nuse Net::DNS::Packet;\nuse Net::DNS::Update;\nuse Net::DNS::Header;\nuse Net::DNS::Question;\nuse Net::DNS::RR;   # use only after $Net::DNS::DNSSEC has been evaluated\nuse Carp;\n\n\n\n#\n# If you implement an RR record make sure you also add it to \n# %Net::DNS::RR::RR hash otherwise it will be treated as unknown type.\n# \n# See http://www.iana.org/assignments/dns-parameters for assignments and references.\n\n# Do not use these tybesby hashes directly. Use the interface\n# functions, see below.\n\n%typesbyname = (\n    'SIGZERO'   => 0,       # RFC2931 consider this a pseudo type\n    'A'         => 1,       # RFC 1035, Section 3.4.1\n    'NS'        => 2,       # RFC 1035, Section 3.3.11\n    'MD'        => 3,       # RFC 1035, Section 3.3.4 (obsolete)\t\tNOT IMPLEMENTED\n    'MF'        => 4,       # RFC 1035, Section 3.3.5 (obsolete)\t\tNOT IMPLEMENTED\n    'CNAME'     => 5,       # RFC 1035, Section 3.3.1\n    'SOA'       => 6,       # RFC 1035, Section 3.3.13\n    'MB'        => 7,       # RFC 1035, Section 3.3.3\n    'MG'        => 8,       # RFC 1035, Section 3.3.6\n    'MR'        => 9,       # RFC 1035, Section 3.3.8\n    'NULL'      => 10,      # RFC 1035, Section 3.3.10\n    'WKS'       => 11,      # RFC 1035, Section 3.4.2 (deprecated)\t\tNOT IMPLEMENTED\n    'PTR'       => 12,      # RFC 1035, Section 3.3.12\n    'HINFO'     => 13,      # RFC 1035, Section 3.3.2\n    'MINFO'     => 14,      # RFC 1035, Section 3.3.7\n    'MX'        => 15,      # RFC 1035, Section 3.3.9\n    'TXT'       => 16,      # RFC 1035, Section 3.3.14\n    'RP'        => 17,      # RFC 1183, Section 2.2\n    'AFSDB'     => 18,      # RFC 1183, Section 1\n    'X25'       => 19,      # RFC 1183, Section 3.1\n    'ISDN'      => 20,      # RFC 1183, Section 3.2\n    'RT'        => 21,      # RFC 1183, Section 3.3\n    'NSAP'      => 22,      # RFC 1706, Section 5 \n    'NSAP_PTR'  => 23,      # RFC 1348 (obsolete by RFC 1637)\t\t\tNOT IMPLEMENTED\n    'SIG'       => 24,      # RFC 2535, Section 4.1\t\t\t\timpemented in Net::DNS::SEC\n    'KEY'       => 25,      # RFC 2535, Section 3.1\t\t\t\timpemented in Net::DNS::SEC\n    'PX'        => 26,      # RFC 2163,\n    'GPOS'      => 27,      # RFC 1712 (obsolete ?)\t\t\t\tNOT IMPLEMENTED\n    'AAAA'      => 28,      # RFC 1886, Section 2.1\n    'LOC'       => 29,      # RFC 1876\n    'NXT'       => 30,      # RFC 2535, Section 5.2 obsoleted by RFC3755\timpemented in Net::DNS::SEC\n    'EID'       => 31,      # draft-ietf-nimrod-dns-xx.txt\n    'NIMLOC'    => 32,      # draft-ietf-nimrod-dns-xx.txt\n    'SRV'       => 33,      # RFC 2052\n    'ATMA'      => 34,      # non-standard    \t\t\t\t\tNOT IMPLEMENTED\n    'NAPTR'     => 35,      # RFC 2168\n    'KX'        => 36,      # RFC 2230\n    'CERT'      => 37,      # RFC 2538\n    'A6'        => 38,      # RFC3226, RFC2874. See RFC 3363 made A6 exp.\tNOT IMPLEMENTED\n    'DNAME'     => 39,      # RFC 2672\n    'SINK'      => 40,      # non-standard\t\t\t\t\tNOT IMPLEMENTED\n    'OPT'       => 41,      # RFC 2671\n    'APL'       => 42,      # RFC 3123\t\t\n    'DS'        => 43,      # RFC 4034  \t\t\t\t\timplemented in Net::DNS::SEC\n    'SSHFP'     => 44,      # RFC 4255\n    'IPSECKEY'  => 45,      # RFC 4025\n    'RRSIG'     => 46,      # RFC 4034 \t\t\t\t\t\timplemented in Net::DNS::SEC\n    'NSEC'      => 47,      # RFC 4034\t\t\t\t\t\timplemented in Net::DNS::SEC\n    'DNSKEY'    => 48,      # RFC 4034\t\t\t\t\t\tinplemented in Net::DNS::SEC\n    'DHCID'     => 49,      # RFC4701\n    'NSEC3'     => 50,      # RFC5155\n    'NSEC3PARAM' => 51,     # RFC5155\n# 52-54 are unassigned\t\t\n    'HIP'       => 55,      # RFC5205\n    'NINFO'     => 56,      # non-standard\t\t\t\t\tNOT IMPLEMENTED \n    'RKEY'      => 57,      # non-standard\t\t\t\t\tNOT IMPLEMENTED\n# 58-98 are unasigned\n    'SPF'       => 99,      # RFC 4408\n    'UINFO'     => 100,     # non-standard\n    'UID'       => 101,     # non-standard\n    'GID'       => 102,     # non-standard\n    'UNSPEC'    => 103,     # non-standard\n# 104-248 are unasigned\n    'TKEY'      => 249,     # RFC 2930\n    'TSIG'      => 250,     # RFC 2931\n    'IXFR'      => 251,     # RFC 1995\n    'AXFR'      => 252,     # RFC 1035\n    'MAILB'     => 253,     # RFC 1035 (MB, MG, MR)\n    'MAILA'     => 254,     # RFC 1035 (obsolete - see MX)\n    'ANY'       => 255,     # RFC 1035\n    'TA'        => 32768,    # non-standard\t\t\t\t\tNOT IMPLEMENTED\n    'DLV'       => 32769    # RFC 4431\t\t\t\t\t\timplemented in Net::DNS::SEC\t\t\n);\n%typesbyval = reverse %typesbyname;\n\n\n#\n# typesbyval and typesbyname functions are wrappers around the similarly named\n# hashes. They are used for 'unknown' DNS RR types (RFC3597)\n\n# typesbyname returns they TYPEcode as a function of the TYPE\n# mnemonic. If the TYPE mapping is not specified the generic mnemonic\n# TYPE### is returned.\n\n\n# typesbyval returns they TYPE mnemonic as a function of the TYPE\n# code. If the TYPE mapping is not specified the generic mnemonic\n# TYPE### is returned.\n#\n\nsub typesbyname {\n    my $name = uc shift;\n\n    return $typesbyname{$name} if defined $typesbyname{$name};\n\n    confess \"Net::DNS::typesbyname() argument ($name) is not TYPE###\" unless \n        $name =~ m/^\\s*TYPE(\\d+)\\s*$/o;  \n    \n    my $val = $1;\n    \n    confess 'Net::DNS::typesbyname() argument larger than ' . 0xffff if $val > 0xffff;\n    \n    return $val;\n}\n\n\n\nsub typesbyval {\n    my $val = shift;\n    confess \"Net::DNS::typesbyval() argument is not defined\" unless defined $val;\n    confess \"Net::DNS::typesbyval() argument ($val) is not numeric\" unless \n\t$val =~ s/^\\s*0*(\\d+)\\s*$/$1/o;\n\n    \n    \n    return $typesbyval{$val} if $typesbyval{$val};\n    \n    confess 'Net::DNS::typesbyval() argument larger than '. 0xffff if \n        $val > 0xffff;\n    \n    return \"TYPE$val\";\n}\n\n\n\n#\n# Do not use these classesby hashes directly. See below. \n#\n \n%classesbyname = (\n    'IN'        => 1,       # RFC 1035\n    'CH'        => 3,       # RFC 1035\n    'HS'        => 4,       # RFC 1035\n    'NONE'      => 254,     # RFC 2136\n    'ANY'       => 255,     # RFC 1035\n);\n%classesbyval = reverse %classesbyname;\n\n\n\n# classesbyval and classesbyname functions are wrappers around the\n# similarly named hashes. They are used for 'unknown' DNS RR classess\n# (RFC3597)\n\n# See typesbyval and typesbyname, these beasts have the same functionality\n\nsub classesbyname {\n    my $name = uc shift;\n    return $classesbyname{$name} if $classesbyname{$name};\n    \n    confess \"Net::DNS::classesbyval() argument is not CLASS### ($name)\" unless \n        $name =~ m/^\\s*CLASS(\\d+)\\s*$/o;\n    \n    my $val = $1;\n    \n    confess 'Net::DNS::classesbyval() argument larger than '. 0xffff if $val > 0xffff;\n    \n    return $val;\n}\n\n\n\nsub classesbyval {\n    my $val = shift;\n    \n    confess \"Net::DNS::classesbyname() argument is not numeric ($val)\" unless \n\t$val =~ s/^\\s*0*([0-9]+)\\s*$/$1/o;\n    \n    return $classesbyval{$val} if $classesbyval{$val};\n    \n    confess 'Net::DNS::classesbyname() argument larger than ' . 0xffff if $val > 0xffff;\n    \n    return \"CLASS$val\";\n}\n\n\n\n# The qtypesbyval a", 8192) = 8192
09:01:57.185333 stat("/usr/lib/perl5/auto/Net/DNS/DNS.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.185398 stat("/usr/lib/perl5/auto/Net/DNS/DNS.so", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
09:01:57.185456 stat("/usr/lib/perl5/auto/Net/DNS/DNS.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.185525 open("/usr/lib/perl5/auto/Net/DNS/DNS.so", O_RDONLY) = 9
09:01:57.185578 read(9, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\n\0\0\0\0\0\0@\0\0\0\0\0\0\0(\27\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324\23\0\0\0\0\0\0\324\23\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\330\23\0\0\0\0\0\0\330\23 \0\0\0\0\0\330\23 \0\0\0\0\0\200\2\0\0\0\0\0\0\220\2\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\0\24\0\0\0\0\0\0\0\24 \0\0\0\0\0\0\24 \0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\214\22\0\0\0\0\0\0\214\22\0\0\0\0\0\0\214\22\0\0\0\0\0\0,\0\0\0\0\0\0\0,\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\255\302\7\300(\241\301<8I\17[\334\351\31\276\217BH\26\0\0\0\0\21\0\0\0\34\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\21\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\32\0\0\0\f\0\0\0\30\0\0\0\17\0\0\0\26\0\0\0\r\0\0\0\31\0\0\0\v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\25\0\0\0\7\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\27\0\0\0\5\0\0\0\24\0\0\0\16\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\6\0\0\0\0\0\0\0\2\0\0\0\10\0\0\0\t\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\3\0\0\0\24\0\0\0\1\0\0\0\6\0\0\0\214\300 \1B\6@I\24\0\0\0\27\0\0\0\33\0\0\0BE\325\354BXX[\273\343\222|\240\17C=\330qX\34\2509\nb\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\n\0\220\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\1\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\177\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\314\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\1\0\0\22\0\0\0", 832) = 832
09:01:57.185719 fstat(9, {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
09:01:57.185775 mmap(NULL, 2102888, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0x7f74335f7000
09:01:57.185824 mprotect(0x7f74335f9000, 2093056, PROT_NONE) = 0
09:01:57.185872 mmap(0x7f74337f8000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x1000) = 0x7f74337f8000
09:01:57.185925 close(9)                = 0
09:01:57.186069 stat("modules/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186124 stat("modules/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186175 stat("modules/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186223 stat("modules/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186273 stat("/etc/perl/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186323 stat("/etc/perl/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186373 stat("/usr/local/lib/perl/5.14.2/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186423 stat("/usr/local/lib/perl/5.14.2/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186480 stat("/usr/local/share/perl/5.14.2/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186531 stat("/usr/local/share/perl/5.14.2/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186581 stat("/usr/lib/perl5/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186632 stat("/usr/lib/perl5/Net/DNS/SEC.pm", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.186683 stat("/usr/share/perl5/Net/DNS/SEC.pmc", 0x7ffe1233b0d0) = -1 ENOENT (No such file or directory)
09:01:57.186735 stat("/usr/share/perl5/Net/DNS/SEC.pm", {st_mode=S_IFREG|0644, st_size=8574, ...}) = 0
09:01:57.186794 open("/usr/share/perl5/Net/DNS/SEC.pm", O_RDONLY) = 9
09:01:57.186846 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233adb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.186893 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.186954 read(9, "#\n# $Id: SEC.pm 850 2010-03-12 13:14:33Z olaf $\n#\n\nuse strict;\n\n\n\npackage Net::DNS::SEC;\nuse Net::DNS;\nuse bytes;\nuse Carp;\nuse strict;\nuse Exporter;\nuse vars qw($SVNVERSION $VERSION $HAS_NSEC3 $HAS_DLV @EXPORT_OK @ISA);\n@ISA=qw(Exporter);\n$VERSION = '0.16';\n\n$HAS_DLV=1;     # Signals availability of DLV to Net::DNS::RR\n$HAS_NSEC3=1;   # Signals availability of NSEC3 to Net::DNS::RR\n\n\n$SVNVERSION = (qw$LastChangedRevision: 850 $)[1];\n\n\n@EXPORT_OK= qw (\n              key_difference\n              verify_selfsig\n               );\n\n\n=head1 NAME\n\nNet::DNS::SEC - DNSSEC extensions to Net::DNS\n\n=head1 SYNOPSIS\n\nC<use Net::DNS;>\n\nThe Net::DNS::SEC module implements a few class methods used by the\nother modules in this suite and a few functions that can be exported.\n\n\n=head1 DESCRIPTION\n\nThe Net::DSN::SEC suite provides the resource records that are needed\nfor DNSSEC (RFC 4033, 4034 and 4035). In addition the DLV RR, a clone\nof the DS RR is supported (RFC 4431)\n\nIt also provides support for SIG0. That later is useful for dynamic\nupdates using key-pairs.\n\nRSA and DSA crypto routines are supported.\n\nFor details see L<Net::DNS::RR::RRSIG>, L<Net::DNS::RR::DNSKEY>,\nL<Net::DNS::RR::NSEC>, L<Net::DNS::RR:DS>, L<Net::DNS::RR::DLV>, and\nsee L<Net::DNS::RR::SIG> and L<Net::DNS::RR::KEY> for the use with\nSIG0.\n\nNet::DNS contains all needed hooks to load the Net::DNS::SEC\nextensions when they are available.\n\nSee L<Net::DNS> for general help.\n\n=head1 Utility function\n\nUse the following construct if you want to use thos function in your code.\n\n   use Net::DNS::SEC qw( key_difference );\n\n\n=head2 key_difference\n\n    $result=key_differnece(\\@a,\\@b,\\@result);\n\n\nFills @result with all keys in the array \"@a\" that are not in the\narray \"@b\".\n\nReturns 0 on success or an error message on failure.\n\n\n=cut\n\n\n\nsub key_difference {\n    my $a=shift;\n    my $b=shift;\n    my $r=shift;\n\n    my %b_index;\n    foreach my $b_key (@$b){\n\treturn \"Second array contains something different than a \".\n\t    \"Net::DNS::RR::DNSKEY objects (\".ref($b_key).\")\" if\n\t    ref($b_key) ne \"Net::DNS::RR::DNSKEY\";\n\t    \n\t$b_index{$b_key->name.\"+\".$b_key->algorithm.\"+\".$b_key->keytag}++;\n    }\n    foreach my $a_key (@$a){\n\treturn \"First array contains something different than a \".\n\t    \"Net::DNS::RR::DNSKEY objects (\".ref($a_key).\")\" if\n\t    ref($a_key) ne \"Net::DNS::RR::DNSKEY\";\n\n\tpush @$r,$a_key  unless \n\t    defined ($b_index{$a_key->name.\"+\".$a_key->algorithm.\"+\".$a_key->keytag});\n    }\n    return (0);\n}\n\n\n=head1 Class methods\n\nThese functions are inherited by relevant Net::DNS::RR classes. They\nare not exported.\n\n=head2 algorithm\n\n    $value=Net::DNS::SEC->algorithm(\"RSASHA1\");\n    $value=$self->algorithm(\"RSASHA1\");\n    $value=$self->algorithm(5);\n\n    $algorithm=$self->algorithm();\n    $memonic=$self->algorithm(\"mnemonic\");\n\n\nThe algorithm method is used to set or read the value of the algorithm\nfield in Net::DNS::RR::DNSKEY and Net::DNS::RR::RRSIG.\n\nIf supplied with an argument it will set the algorithm accordingly, except\nwhen the argument equals the string \"mnemonic\" the method will return the\nmnemonic of the algorithm.\n\nCan also be called as a class method to do Mnemonic to Value conversion.\n\n=head2 digtype\n\n    $value=$self->digtype(\"SHA1\");\n    $value=$self->digtype(1);\n\n    $algorithm=$self->digtype();\n    $memonic=$self->digtype(\"mnemonic\");\n\n\nThe algorithm method is used to set or read the value of the digest or\nhash algorithm field in Net::DNS::RR::DS and Net::DNS::RR::NSEC3\nobjects.\n\nIf supplied with an argument it will set the digetstype/hash algorithm\naccordingly, except when the argument equals the string \"mnemonic\" the\nmethod will return the mnemonic of the digetstype/hash algorithm.\n\nCan also be called as a class method to do Mnemonic to Value\nconversion, note however that it will then use the \"Delegation Signer\n(DS) Resource Record (RR) Type Digest Algorithms\" and not the \"DNSSEC\nNSEC3 Hash Algorithms\" IANA registry. If you want to specifically get\naccess to the NSEC3  digest types then use a construct like:\n\n bless $self, Net::DNS::RR::NSEC3;\n $self->digtype(\"SHA1\");\n\n\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\n \n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::RR::KEY>, L<Net::DNS::RR::SIG>,\nL<Net::DNS::RR::DNSKEY>, L<Net::DNS::RR::RRSIG>,\nL<Net::DNS::RR::NSEC>, L<Net::DNS::RR::DS>, L<Net::DNS::SEC::Private>.\n\nRFC4033, 4034 and 4035.\n\n=cut\n\n\n\n\n\n\n sub algorithm {\n    my $self=shift;\n    my $argument=shift;\n\n   # classmethod is true if called as class method.\n    my $classmethod=0;\n    $classmethod=1 unless  ref ($self);\n \n    my %algbyname = (\n\t\"RSAMD5\"              => 1,\n\t\"DH\"                  => 2,           # Not implemented\n\t\"DSA\"                 => 3,\n\t\"ECC\"                 => 4,           # Not implemented\n\t\"RSASHA1\"             => 5,\n\t\"DSA-NSEC3-SHA1\"      => 6,\n\t\"RSA-NSEC3-SHA1\"      => 7,\n\t\"RSASHA256\"           => 8,\n\t\"RSASHA512\"           => 10,\n\t\"INDIRECT\"            => 252,         # Not implemented\n\t\"PRIVATEDNS\"          => 253,         # Not implemented\n\t\"PRIVATEOID\"          => 254,         # Not implemented\n\t);      \n    my %algbyval = reverse %algbyname;\n\n    # If the argument is undefined...\n    \n    if (!defined $argument){\n\treturn if $classmethod;\n\treturn $self->{\"algorithm\"};\n    }\n\n    # Argument has some value...\n    $argument =~ s/\\s//g; # Remove strings to be kind\n    $argument =~ s!RSA/!RSA!;  # Be kind for those who use RSA/SHA1\n    if ($argument =~ /^\\d+$/ ){    #Numeric argument.\n\n\tif ($classmethod){\n\t    return $argument ;\n\t}else{\n\t    return $self->{\"algorithm\"}=$argument ;\n\t}\n    }else{  # argument is not numeric\n\tif ($classmethod){\n\t    # This will return undefined if the argument does not exist\n\t    return $algbyname{uc($argument)};\n\t    \n\t}else{ # Not a class method..\n\t    if (lc($argument) eq \"mnemonic\"){\n\t\treturn $algbyval{$self->{\"algorithm\"}};\n\t    }else{\n\t\t# This will return undefined if the argument does not exist\n\t\treturn $self->{\"algorithm\"}=$algbyname{uc($argument)};\n\t    }\t    \n\t}\n\n\t\n    }\t\n    die \"algorithm method should never end here\";\n\n\t\n}\n\n\n\n\n\n\n\nsub digtype {\n    _digtype(@_);\n}\n\nsub _digtype {\n    my $self=shift;\n    my $argument=shift;\n    # classmethod is true if called as class method.\n    my $classmethod=0;\n    $classmethod=1 unless  ref ($self);\n\n    my %digestbyname= (\n\t\t\t\"SHA1\"\t\t   => 1,\t\t\n\t\t\t\"SHA256\"\t   => 2,\t\t\n\t\t\t);      \n\n    \n    if (! $classmethod && defined ($self->{'digestbyname'}) ){\n\t%digestbyname= %{$self->{\"digestbyname\"}};\n    }\n\n\n    my %digestbyval = reverse %digestbyname;\n    \n    # If the argument is undefined...\n    \n    if (!defined $argument){\n\treturn if $classmethod;\n\treturn $self->{\"digest\"};\n    }\n\n    # Argument has some value...\n    $argument =~ s/\\s//g; # Remove strings to be kind\n\n    if ($argument =~ /^\\d+$/ ){    #Numeric argument.\n\tcarp \"$argument does not map to a valid digest\" unless \n\t    exists $digestbyval{$argument};\n\tif ($classmethod){\n\t    return $argument ;\n\t}else{\n\t    return $self->{\"digest\"}=$argument ;\n\t}\n    }else{  # argument is not numeric\n\tif ($classmethod){\n\t    carp \"$argument does not map to a valid digest\" unless\n\t\texists $digestbyname{uc($argument)};\n\t    return $digestbyname{uc($", 8192) = 8192
09:01:57.187664 brk(0x109a000)          = 0x109a000
09:01:57.187913 read(9, "argument)};\n\t    \n\t}else{ # Not a class method..\n\t    if (lc($argument) eq \"mnemonic\"){\n\t\treturn $digestbyval{$self->{\"digest\"}};\n\t    }else{\n\t\tcarp \"$argument does not map to a valid digest\" unless\n\t\t    exists $digestbyname{uc($argument)};\n\t\treturn $self->{\"digest\"}=$digestbyname{uc($argument)};\n\t    }\t    \n\t}\n\n\t\n    }\t\n    die \"digest method should never end here\";\n\n\t\n}\n\n\n\n\n\n\n", 8192) = 382
09:01:57.188030 read(9, "", 8192)       = 0
09:01:57.188079 close(9)                = 0
09:01:57.188159 stat("modules/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188210 stat("modules/Net/DNS/Resolver.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.188260 stat("modules/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188309 stat("modules/Net/DNS/Resolver.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.188358 stat("/etc/perl/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188407 stat("/etc/perl/Net/DNS/Resolver.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.188457 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188507 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.188558 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188608 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.188659 stat("/usr/lib/perl5/Net/DNS/Resolver.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.188711 stat("/usr/lib/perl5/Net/DNS/Resolver.pm", {st_mode=S_IFREG|0644, st_size=20529, ...}) = 0
09:01:57.188770 open("/usr/lib/perl5/Net/DNS/Resolver.pm", O_RDONLY) = 9
09:01:57.188823 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.188869 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.188928 read(9, "package Net::DNS::Resolver;\n#\n# $Id: Resolver.pm 830 2009-12-23 16:31:13Z olaf $\n#\n\nuse strict;\nuse vars qw($VERSION @ISA);\n\n$VERSION = (qw$LastChangedRevision: 830 $)[1];\n\nBEGIN {\n\tif ($^O eq 'MSWin32') {\n\t\trequire Net::DNS::Resolver::Win32;\n\t\t@ISA = qw(Net::DNS::Resolver::Win32);\n\t} elsif ($^O eq 'cygwin') {\n\t\trequire Net::DNS::Resolver::Win32;\n\t\t@ISA = qw(Net::DNS::Resolver::Win32);\n\t} else {   \n\t\trequire Net::DNS::Resolver::UNIX;\n\t\t@ISA = qw(Net::DNS::Resolver::UNIX);\n\t}\n}\n\n__PACKAGE__->init();\n\n1;\n\n__END__\n\n=head1 NAME\n\nNet::DNS::Resolver - DNS resolver class\n\n=head1 SYNOPSIS\n\n  use Net::DNS;\n  \n  my $res = Net::DNS::Resolver->new;\n  \n  # Perform a lookup, using the searchlist if appropriate.\n  my $answer = $res->search('example.com');\n  \n  # Perform a lookup, without the searchlist\n  my $answer = $res->query('example.com', 'MX');\n  \n  # Perform a lookup, without pre or post-processing\n  my $answer = $res->send('example.com', 'MX', 'CH');\n  \n  # Send a prebuilt packet\n  my $packet = Net::DNS::Packet->new(...);\n  my $answer = $res->send($packet);\n  \n=head1 DESCRIPTION\n\nInstances of the C<Net::DNS::Resolver> class represent resolver objects.\nA program can have multiple resolver objects, each maintaining its\nown state information such as the nameservers to be queried, whether\nrecursion is desired, etc.\n\n=head1 METHODS\n\n=head2 new\n\n  # Use the system defaults\n  my $res = Net::DNS::Resolver->new;\n  \n  # Use my own configuration file\n  my $res = Net::DNS::Resolver->new(config_file => '/my/dns.conf');\n  \n  # Set options in the constructor\n  my $res = Net::DNS::Resolver->new(\n  \tnameservers => [qw(10.1.1.128 10.1.2.128)],\n  \trecurse     => 0,\n  \tdebug       => 1,\n  );\n\nReturns a resolver object.  If given no arguments, C<new()> returns an\nobject configured to your system's defaults.  On UNIX systems the \ndefaults are read from the following files, in the order indicated:\n\n    /etc/resolv.conf\n    $HOME/.resolv.conf\n    ./.resolv.conf\n\nThe following keywords are recognized in resolver configuration files:\n\n=over 4\n\n=item domain\n\nThe default domain.\n\n=item search\n\nA space-separated list of domains to put in the search list.\n\n=item nameserver\n\nA space-separated list of nameservers to query.\n\n=back\n\nFiles except for F</etc/resolv.conf> must be owned by the effective\nuserid running the program or they won't be read.  In addition, several\nenvironment variables can also contain configuration information; see\nL</ENVIRONMENT>.\n\nOn Windows systems, an attempt is made to determine the system defaults\nusing the registry.  This is still a work in progress; systems with many\ndynamically configured network interfaces may confuse Net::DNS.\n\nYou can include a configuration file of your own when creating a\nresolver object:\n\n # Use my own configuration file \n my $res = Net::DNS::Resolver->new(config_file => '/my/dns.conf');\n\nThis is supported on both UNIX and Windows.  Values pulled from a custom\nconfiguration file override the the system's defaults, but can still be\noverridden by the other arguments to new().\n\nExplicit arguments to new override both the system's defaults and the\nvalues of the custom configuration file, if any.  The following\narguments to new() are supported:\n\n=over 4\n\n=item nameservers\n\nAn array reference of nameservers to query.  \n\n=item searchlist\n\nAn array reference of domains.\n\n=item recurse\n\n=item debug\n\n=item domain\n\n=item port\n\n=item srcaddr\n\n=item srcport\n\n=item tcp_timeout\n\n=item udp_timeout\n\n=item retrans\n\n=item retry\n\n=item usevc\n\n=item stayopen\n\n=item igntc\n\n=item defnames\n\n=item dnsrch\n\n=item persistent_tcp\n\n=item persistent_udp\n\n=item dnssec\n\n=back\n\nFor more information on any of these options, please consult the method\nof the same name.\n\n=head2 search\n\n    $packet = $res->search('mailhost');\n    $packet = $res->search('mailhost.example.com');\n    $packet = $res->search('192.168.1.1');\n    $packet = $res->search('example.com', 'MX');\n    $packet = $res->search('user.passwd.example.com', 'TXT', 'HS');\n\nPerforms a DNS query for the given name, applying the searchlist\nif appropriate.  The search algorithm is as follows:\n\n=over 4\n\n=item 1.\n\nIf the name contains at least one dot, try it as is.\n\n=item 2.\n\nIf the name doesn't end in a dot then append each item in\nthe search list to the name.  This is only done if B<dnsrch>\nis true.\n\n=item 3.\n\nIf the name doesn't contain any dots, try it as is.\n\n=back\n\nThe record type and class can be omitted; they default to A and\nIN.  If the name looks like an IP address (4 dot-separated numbers),\nthen an appropriate PTR query will be performed.\n\nReturns a \"Net::DNS::Packet\" object, or \"undef\" if no answers were\nfound.  If you need to examine the response packet whether it contains\nany answers or not, use the send() method instead.\n\n=head2 query\n\n    $packet = $res->query('mailhost');\n    $packet = $res->query('mailhost.example.com');\n    $packet = $res->query('192.168.1.1');\n    $packet = $res->query('example.com', 'MX');\n    $packet = $res->query('user.passwd.example.com', 'TXT', 'HS');\n\nPerforms a DNS query for the given name; the search list is not\napplied.  If the name doesn't contain any dots and B<defnames>\nis true then the default domain will be appended.\n\nThe record type and class can be omitted; they default to A and\nIN.  If the name looks like an IP address (IPv4 or IPv6),\nthen an appropriate PTR query will be performed.\n\nReturns a \"Net::DNS::Packet\" object, or \"undef\" if no answers were\nfound.  If you need to examine the response packet whether it contains\nany answers or not, use the send() method instead.\n\n=head2 send\n\n    $packet = $res->send($packet_object);\n    $packet = $res->send('mailhost.example.com');\n    $packet = $res->send('example.com', 'MX');\n    $packet = $res->send('user.passwd.example.com', 'TXT', 'HS');\n\nPerforms a DNS query for the given name.  Neither the searchlist\nnor the default domain will be appended.  \n\nThe argument list can be either a C<Net::DNS::Packet> object or a list\nof strings.  The record type and class can be omitted; they default to\nA and IN.  If the name looks like an IP address (Ipv4 or IPv6),\nthen an appropriate PTR query will be performed.\n\nReturns a C<Net::DNS::Packet> object whether there were any answers or not.\nUse C<< $packet->header->ancount >> or C<< $packet->answer >> to find out\nif there were any records in the answer section.  Returns C<undef> if there\nwas an error.\n\n=head2 axfr\n\n    @zone = $res->axfr;\n    @zone = $res->axfr('example.com');\n    @zone = $res->axfr('passwd.example.com', 'HS');\n\nPerforms a zone transfer from the first nameserver listed in C<nameservers>.\nIf the zone is omitted, it defaults to the first zone listed in the resolver's\nsearch list.  If the class is omitted, it defaults to IN.\n\nReturns a list of C<Net::DNS::RR> objects, or C<undef> if the zone\ntransfer failed.\n\nThe redundant SOA record that terminates the zone transfer is not\nreturned to the caller.\n\nSee also L</axfr_start> and L</axfr_next>.\n\nHere's an example that uses a timeout:\n\n    $res->tcp_timeout(10);\n    my @zone = $res->axfr('example.com');\n\n    if (@zone) {\n        foreach my $rr (@zone) {\n            $rr->print;\n        }\n    } else {\n        print 'Zone transfer failed: ', $res->errorstring, \"\\n\";\n    }\n\n=head2 axfr_start\n\n    $res->axfr_start;\n    $res->axfr_start('example.com');\n    $res->axfr_start('example.com', 'HS');\n\nStarts a zone transfer from the first nameserver listed in C<nameservers>.\nIf the zone is omitted, it defaults to the first zone listed in the resolver's\nsearch list.  If the class is omitted, it defaults to IN.\n\nB<IMPORTANT>:\n\nThis method currently returns the C<IO::Socket::INET> object that will\nbe used for reading, or C<undef> on error.  DO NOT DEPEND ON C<axfr_start()>\nreturning a socket object.  THIS MIGHT CHANGE in future releases.\n\nUse C<axfr_next> to read the zone records one at a time.\n\n=head2 axfr_next\n\n    $res->axfr_start('example.com');\n\n    while (my $rr = $res->axfr_next) {\n\t    $rr->print;\n    }\n\nReads records from a zone transfer one at a time.\n\nReturns C<undef> at the end of the zone transfer.  The redundant\nSOA record that terminates the zone transfer is not returned.\n\nSee also L</axfr>.\n\n=head2 nameservers\n\n  ", 8192) = 8192
09:01:57.189438 stat("modules/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189491 stat("modules/Net/DNS/Resolver/UNIX.pm", 0x7ffe1233a9f0) = -1 ENOENT (No such file or directory)
09:01:57.189542 stat("modules/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189591 stat("modules/Net/DNS/Resolver/UNIX.pm", 0x7ffe1233a9f0) = -1 ENOENT (No such file or directory)
09:01:57.189641 stat("/etc/perl/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189695 stat("/etc/perl/Net/DNS/Resolver/UNIX.pm", 0x7ffe1233a9f0) = -1 ENOENT (No such file or directory)
09:01:57.189745 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189796 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver/UNIX.pm", 0x7ffe1233a9f0) = -1 ENOENT (No such file or directory)
09:01:57.189847 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189897 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver/UNIX.pm", 0x7ffe1233a9f0) = -1 ENOENT (No such file or directory)
09:01:57.189947 stat("/usr/lib/perl5/Net/DNS/Resolver/UNIX.pmc", 0x7ffe1233aaa0) = -1 ENOENT (No such file or directory)
09:01:57.189998 stat("/usr/lib/perl5/Net/DNS/Resolver/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1600, ...}) = 0
09:01:57.190072 open("/usr/lib/perl5/Net/DNS/Resolver/UNIX.pm", O_RDONLY) = 10
09:01:57.190127 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a780) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.190174 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.190233 read(10, "package Net::DNS::Resolver::UNIX;\n#\n# $Id: UNIX.pm 482 2005-09-02 13:34:33Z olaf $\n#\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\nuse Net::DNS::Resolver::Base ();\n\n@ISA     = qw(Net::DNS::Resolver::Base);\n$VERSION = (qw$LastChangedRevision: 482 $)[1];\n\nmy $resolv_conf = '/etc/resolv.conf';\nmy $dotfile     = '.resolv.conf';\n\nmy @config_path;\npush(@config_path, $ENV{'HOME'}) if exists $ENV{'HOME'};\npush(@config_path, '.');\n\nsub init {\n\tmy ($class) = @_;\n\t\n\t$class->read_config_file($resolv_conf) if -f $resolv_conf && -r _; \n\t\n\tforeach my $dir (@config_path) {\n\t\tmy $file = \"$dir/$dotfile\";\n\t\t$class->read_config_file($file) if -f $file && -r _ && -o _;\n\t}\n\t\n\t$class->read_env;\n\t\n\tmy $defaults = $class->defaults;\n\t\n\tif (!$defaults->{'domain'} && @{$defaults->{'searchlist'}}) {\n\t\t$defaults->{'domain'} = $defaults->{'searchlist'}[0];\n\t} elsif (!@{$defaults->{'searchlist'}} && $defaults->{'domain'}) {\n\t\t$defaults->{'searchlist'} = [ $defaults->{'domain'} ];\n\t}\n}\n\t\n1;\n__END__\n\n\n=head1 NAME\n\nNet::DNS::Resolver::UNIX - UNIX Resolver Class\n\n=head1 SYNOPSIS\n\n use Net::DNS::Resolver;\n\n=head1 DESCRIPTION\n\nThis class implements the UNIX specific portions of C<Net::DNS::Resolver>.\n\nNo user serviceable parts inside, see L<Net::DNS::Resolver|Net::DNS::Resolver>\nfor all your resolving needs.\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>\n\n=cut\n", 8192) = 1600
09:01:57.190409 stat("modules/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190461 stat("modules/Net/DNS/Resolver/Base.pm", 0x7ffe1233a3c0) = -1 ENOENT (No such file or directory)
09:01:57.190512 stat("modules/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190561 stat("modules/Net/DNS/Resolver/Base.pm", 0x7ffe1233a3c0) = -1 ENOENT (No such file or directory)
09:01:57.190611 stat("/etc/perl/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190660 stat("/etc/perl/Net/DNS/Resolver/Base.pm", 0x7ffe1233a3c0) = -1 ENOENT (No such file or directory)
09:01:57.190716 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190768 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Resolver/Base.pm", 0x7ffe1233a3c0) = -1 ENOENT (No such file or directory)
09:01:57.190819 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190869 stat("/usr/local/share/perl/5.14.2/Net/DNS/Resolver/Base.pm", 0x7ffe1233a3c0) = -1 ENOENT (No such file or directory)
09:01:57.190921 stat("/usr/lib/perl5/Net/DNS/Resolver/Base.pmc", 0x7ffe1233a470) = -1 ENOENT (No such file or directory)
09:01:57.190971 stat("/usr/lib/perl5/Net/DNS/Resolver/Base.pm", {st_mode=S_IFREG|0644, st_size=39889, ...}) = 0
09:01:57.191029 open("/usr/lib/perl5/Net/DNS/Resolver/Base.pm", O_RDONLY) = 11
09:01:57.191083 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a150) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.191129 lseek(11, 0, SEEK_CUR)  = 0
09:01:57.191188 read(11, "package Net::DNS::Resolver::Base;\n#\n# $Id: Base.pm 830 2009-12-23 16:31:13Z olaf $\n#\n\nuse strict;\n\nBEGIN { \n    eval { require bytes; }\n}\n\nuse vars qw(\n\t    $VERSION\n\t    $has_inet6\n\t    $AUTOLOAD\n);\n\nuse Carp;\nuse Config ();\nuse Socket;\nuse IO::Socket;\nuse IO::Select;\n\nuse Net::DNS;\nuse Net::DNS::Packet;\n\n$VERSION = (qw$LastChangedRevision: 830 $)[1];\n\n\n#\n#  A few implementation notes wrt IPv6 support.\n#\n#  In general we try to be gracious to those stacks that do not have ipv6 support.\n#  We test that by means of the availability of Socket6 and IO::Socket::INET6\n#\n\n\n#  We have chosen to not use mapped IPv4 addresses, there seem to be\n#  issues with this; as a result we have to use sockets for both\n#  family types.  To be able to deal with persistent sockets and\n#  sockets of both family types we use an array that is indexed by the\n#  socketfamily type to store the socket handlers. I think this could\n#  be done more efficiently.\n\n \n#  inet_pton is not available on WIN32, so we only use the getaddrinfo\n#  call to translate IP addresses to socketaddress\n\n\n \n#  Set the $force_inet4_only variable inside the BEGIN block to force\n#  not to use the IPv6 stuff. You can use this for compatibility\n#  test. We do not see a need to do this from the calling code.\n\n \n# Olaf Kolkman, RIPE NCC, December 2003.\n \n \nBEGIN {\n    if ( \n\t eval {require IO::Socket::INET6; IO::Socket::INET6->VERSION(\"2.00\");}\n\t ) {\n \t$has_inet6=1;\n    }else{\n \t$has_inet6=0;\n    }\n }\n\t    \n \n \n \n \n  \n#\n# Set up a closure to be our class data.\n#\n{\n\tmy %defaults = (\n\t\tnameservers\t   => ['127.0.0.1'],\n\t\tport\t\t   => 53,\n\t\tsrcaddr        => '0.0.0.0',\n\t\tsrcport        => 0,\n\t\tdomain\t       => '',\n\t\tsearchlist\t   => [],\n\t\tretrans\t       => 5,\n\t\tretry\t\t   => 4,\n\t\tusevc\t\t   => 0,\n\t\tstayopen       => 0,\n\t\tigntc          => 0,\n\t\trecurse        => 1,\n\t\tdefnames       => 1,\n\t\tdnsrch         => 1,\n\t\tdebug          => 0,\n\t\terrorstring\t   => 'unknown error or no error',\n\t\ttsig_rr        => undef,\n\t\tanswerfrom     => '',\n\t\tquerytime      => undef,\n\t\ttcp_timeout    => 120,\n\t\tudp_timeout    => undef,\n\t\taxfr_sel       => undef,\n\t\taxfr_rr        => [],\n\t\taxfr_soa_count => 0,\n\t\tpersistent_tcp => 0,\n\t\tpersistent_udp => 0,\n\t\tdnssec         => 0,\n\t\tudppacketsize  => 0,  # The actual default is lower bound by Net::DNS::PACKETSZ\n\t        cdflag         => 0,  # this is only used when {dnssec} == 1\n\t        adflag         => 1,  # this is only used when {dnssec} == 1\n\t\tforce_v4       => 0,  # force_v4 is only relevant when we have\n                                      # v6 support available\n\t\tignqrid        => 0,  # normally packets with non-matching ID \n                                      # or with the qr bit of are thrown away\n\t\t\t              # in 'ignqrid' these packets are \n\t\t\t              # are accepted.\n\t\t\t              # USE WITH CARE, YOU ARE VULNARABLE TO\n\t\t\t              # SPOOFING IF SET.\n\t\t\t              # This is may be a temporary feature\n\t);\n\t\n\t# If we're running under a SOCKSified Perl, use TCP instead of UDP\n\t# and keep the sockets open.\n\tif ($Config::Config{'usesocks'}) {\n\t\t$defaults{'usevc'} = 1;\n\t\t$defaults{'persistent_tcp'} = 1;\n\t}\n\t\n\tsub defaults { \\%defaults }\n}\n\n# These are the attributes that we let the user specify in the new().\n# We also deprecate access to these with AUTOLOAD (some may be useful).\nmy %public_attr = map { $_ => 1 } qw(\n\tnameservers\n\tport\n\tsrcaddr\n\tsrcport\n\tdomain\n\tsearchlist\n\tretrans\n\tretry\n\tusevc\n\tstayopen\n\tigntc\n\trecurse\n\tdefnames\n\tdnsrch\n\tdebug\n\ttcp_timeout\n\tudp_timeout\n\tpersistent_tcp\n\tpersistent_udp\n\tdnssec\n\tignqrid\n);\n\n\nsub new {\n\tmy $class = shift;\n\tmy $self = bless({ %{$class->defaults} }, $class);\n\n\t$self->_process_args(@_) if @_ and @_ % 2 == 0;\n\treturn $self;\n}\n\n\n\nsub _process_args {\n\tmy ($self, %args) = @_;\n\t\n\tif ($args{'config_file'}) {\n\t\t$self->read_config_file($args{'config_file'});\n\t}\n\t\n\tforeach my $attr (keys %args) {\n\t\tnext unless $public_attr{$attr};\n\n\t\tif ($attr eq 'nameservers' || $attr eq 'searchlist') {\n\n\t\t\tdie \"Net::DNS::Resolver->new(): $attr must be an arrayref\\n\" unless\n\t\t\t  defined($args{$attr}) &&  UNIVERSAL::isa($args{$attr}, 'ARRAY');\n\n\t\t}\n\t\t\n\t\tif ($attr eq 'nameservers') {\n\t\t\t$self->nameservers(@{$args{$attr}});\n\t\t} else {\n\t\t\t$self->{$attr} = $args{$attr};\n\t\t}\n\t}\n\n\n}\n\t\t\t\n\t\t\t\n\t\t\t\n\n\n#\n# Some people have reported that Net::DNS dies because AUTOLOAD picks up\n# calls to DESTROY.\n#\nsub DESTROY {}\n\n\nsub read_env {\n\tmy ($invocant) = @_;\n\tmy $config     = ref $invocant ? $invocant : $invocant->defaults;\n\t\t\n\t$config->{'nameservers'} = [ $ENV{'RES_NAMESERVERS'} =~ m/(\\S+)/g ]\n\t\tif exists $ENV{'RES_NAMESERVERS'};\n\n\t$config->{'searchlist'}  = [ split(' ', $ENV{'RES_SEARCHLIST'})  ]\n\t\tif exists $ENV{'RES_SEARCHLIST'};\n\t\n\t$config->{'domain'} = $ENV{'LOCALDOMAIN'}\n\t\tif exists $ENV{'LOCALDOMAIN'};\n\n\tif (exists $ENV{'RES_OPTIONS'}) {\n\t\tforeach ($ENV{'RES_OPTIONS'} =~ m/(\\S+)/g) {\n\t\t\tmy ($name, $val) = split(m/:/);\n\t\t\t$val = 1 unless defined $val;\n\t\t\t$config->{$name} = $val if exists $config->{$name};\n\t\t}\n\t}\n}\n\n#\n# $class->read_config_file($filename) or $self->read_config_file($file)\n#\nsub read_config_file {\n\tmy ($invocant, $file) = @_;\n\tmy $config            = ref $invocant ? $invocant : $invocant->defaults;\n\n\t\n\tmy @ns;\n\tmy @searchlist;\n\t\n\tlocal *FILE;\n\n\topen(FILE, \"< $file\") or croak \"Could not open $file: $!\";\n\tlocal $/ = \"\\n\";\n\tlocal $_;\n\t\n\twhile (<FILE>) {\n \t\ts/\\s*[;#].*//;\n\t\t\n\t\t# Skip ahead unless there's non-whitespace characters \n\t\tnext unless m/\\S/;\n\n\t\tSWITCH: {\n\t\t\t/^\\s*domain\\s+(\\S+)/ && do {\n\t\t\t\t$config->{'domain'} = $1;\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\n\t\t\t/^\\s*search\\s+(.*)/ && do {\n\t\t\t\tpush(@searchlist, split(' ', $1));\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\n\t\t\t/^\\s*nameserver\\s+(.*)/ && do {\n\t\t\t\tforeach my $ns (split(' ', $1)) {\n\t\t\t\t\t$ns = '0.0.0.0' if $ns eq '0';\n#\t\t\t\t\tnext if $ns =~ m/:/;  # skip IPv6 nameservers\n\t\t\t\t\tpush @ns, $ns;\n\t\t\t\t}\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t    }\n\t\t  }\n\t\tclose FILE || croak \"Could not close $file: $!\";\n\t\t\n\t\t$config->{'nameservers'} = [ @ns ]         if @ns;\n\t\t$config->{'searchlist'}  = [ @searchlist ] if @searchlist;\n\t    }\n \n\n\n\nsub print { print $_[0]->string }\n\nsub string {\n\tmy $self = shift;\n\n\tmy $timeout = defined $self->{'tcp_timeout'} ? $self->{'tcp_timeout'} : 'indefinite';\n\tmy $hasINET6line= $has_inet6 ?\" (IPv6 Transport is available)\":\" (IPv6 Transport is not available)\";\n\tmy $ignqrid=$self->{'ignqrid'} ? \"\\n;; ACCEPTING ALL PACKETS (IGNQRID)\":\"\";\n\treturn <<END;\n;; RESOLVER state:\n;;  domain       = $self->{domain}\n;;  searchlist   = @{$self->{searchlist}}\n;;  nameservers  = @{$self->{nameservers}}\n;;  port         = $self->{port}\n;;  srcport      = $self->{srcport}\n;;  srcaddr      = $self->{srcaddr}\n;;  tcp_timeout  = $timeout\n;;  retrans  = $self->{retrans}  retry    = $self->{retry}\n;;  usevc    = $self->{usevc}  stayopen = $self->{stayopen}    igntc = $self->{igntc}\n;;  defnames = $self->{defnames}  dnsrch   = $self->{dnsrch}\n;;  recurse  = $self->{recurse}  debug    = $self->{debug}\n;;  force_v4 = $self->{force_v4} $hasINET6line $ignqrid\nEND\n\n}\n\n\nsub searchlist {\n\tmy $self = shift;\n\t$self->{'searchlist'} = [ @_ ] if @_;\n\treturn @{$self->{'searchlist'}};\n}\n\nsub nameservers {\n    my $self   = shift;\n\n    if (@_) {\n\tmy @a;\n\tforeach my $ns (@_) {\n\t    next unless defined($ns);\n\t    if ( _ip_is_ipv4($ns) ) {\n\t\tpush @a, ($ns eq '0') ? '0.0.0.0' : $ns;\n\n\t    } elsif ( _ip_is_ipv6($ns) ) {\n\t\tpush @a, ($ns eq '0') ? '::0' : $ns;\n\n\t} else  {\n\n\t\tmy $defres = Net::DNS::Resolver->new ();\n\t\t$defres->{\"debug\"}=$self->{\"debug\"};\n\n\t\t\n\n\t\tmy @names;\n\t\t\n\t\tif ($ns !~ /\\./) {\n\t\t    if (defined $defres->searchlist) {\n\t\t\t@names = map { $ns . '.' . $_ }\n\t\t\t$defres->searchlist;\n\t\t    } elsif (defined $defres->domain) {\n\t\t\t@names = ($ns . '.' . $defres->domain);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    @names = ($ns);\n\t\t}\n\t\t\n\t\tmy $packet = $defres->search($ns);\n\t\t$self->errorstring($defres->errorstring);\n\t\tif (defined($packet)) {\n\t\t    push @a, cname_addr([@names], $packet);\n\t\t}\n\t    }\n\t}\n\t\n\n\t$self->{'nameservers'} = [ @a ];\n    }\n    my @returnval;\n    foreach my $ns (@{$self->{'nameservers'}}){\n\tnext if _ip_is_ipv6($ns) && (! $has_inet6 || $self->force_v4() );\n\tpush @returnval, $ns;\n    }\n    \n    return @returnval;\n}\n\nsub nameserver { &nameservers }\n\ns", 8192) = 8192
09:01:57.192110 brk(0x10bb000)          = 0x10bb000
09:01:57.192454 stat("modules/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.192506 stat("modules/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.192556 stat("modules/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.192604 stat("modules/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.192653 stat("/etc/perl/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.192703 stat("/etc/perl/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.192752 stat("/usr/local/lib/perl/5.14.2/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.192803 stat("/usr/local/lib/perl/5.14.2/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.192853 stat("/usr/local/share/perl/5.14.2/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.192907 stat("/usr/local/share/perl/5.14.2/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.192958 stat("/usr/lib/perl5/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.193009 stat("/usr/lib/perl5/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.193060 stat("/usr/share/perl5/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.193110 stat("/usr/share/perl5/IO/Select.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.193166 stat("/usr/lib/perl/5.14/IO/Select.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.193219 stat("/usr/lib/perl/5.14/IO/Select.pm", {st_mode=S_IFREG|0644, st_size=4256, ...}) = 0
09:01:57.193280 open("/usr/lib/perl/5.14/IO/Select.pm", O_RDONLY) = 12
09:01:57.193333 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339b20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.193380 lseek(12, 0, SEEK_CUR)  = 0
09:01:57.193441 read(12, "# IO::Select.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Select;\n\nuse     strict;\nuse warnings::register;\nuse     vars qw($VERSION @ISA);\nrequire Exporter;\n\n$VERSION = \"1.20\";\n\n@ISA = qw(Exporter); # This is only so we can do version checking\n\nsub VEC_BITS () {0}\nsub FD_COUNT () {1}\nsub FIRST_FD () {2}\n\nsub new\n{\n my $self = shift;\n my $type = ref($self) || $self;\n\n my $vec = bless [undef,0], $type;\n\n $vec->add(@_)\n    if @_;\n\n $vec;\n}\n\nsub add\n{\n shift->_update('add', @_);\n}\n\nsub remove\n{\n shift->_update('remove', @_);\n}\n\nsub exists\n{\n my $vec = shift;\n my $fno = $vec->_fileno(shift);\n return undef unless defined $fno;\n $vec->[$fno + FIRST_FD];\n}\n\nsub _fileno\n{\n my($self, $f) = @_;\n return unless defined $f;\n $f = $f->[0] if ref($f) eq 'ARRAY';\n ($f =~ /^\\d+$/) ? $f : fileno($f);\n}\n\nsub _update\n{\n my $vec = shift;\n my $add = shift eq 'add';\n\n my $bits = $vec->[VEC_BITS];\n $bits = '' unless defined $bits;\n\n my $count = 0;\n my $f;\n foreach $f (@_)\n  {\n   my $fn = $vec->_fileno($f);\n   if ($add) {\n     next unless defined $fn;\n     my $i = $fn + FIRST_FD;\n     if (defined $vec->[$i]) {\n\t $vec->[$i] = $f;  # if array rest might be different, so we update\n\t next;\n     }\n     $vec->[FD_COUNT]++;\n     vec($bits, $fn, 1) = 1;\n     $vec->[$i] = $f;\n   } else {      # remove\n     if ( ! defined $fn ) { # remove if fileno undef'd\n         defined($_) && $_ == $f and do { $vec->[FD_COUNT]--; $_ = undef; }\n           for @{$vec}[FIRST_FD .. $#$vec];\n         next;\n     }\n     my $i = $fn + FIRST_FD;\n     next unless defined $vec->[$i];\n     $vec->[FD_COUNT]--;\n     vec($bits, $fn, 1) = 0;\n     $vec->[$i] = undef;\n   }\n   $count++;\n  }\n $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;\n $count;\n}\n\nsub can_read\n{\n my $vec = shift;\n my $timeout = shift;\n my $r = $vec->[VEC_BITS];\n\n defined($r) && (select($r,undef,undef,$timeout) > 0)\n    ? handles($vec, $r)\n    : ();\n}\n\nsub can_write\n{\n my $vec = shift;\n my $timeout = shift;\n my $w = $vec->[VEC_BITS];\n\n defined($w) && (select(undef,$w,undef,$timeout) > 0)\n    ? handles($vec, $w)\n    : ();\n}\n\nsub has_exception\n{\n my $vec = shift;\n my $timeout = shift;\n my $e = $vec->[VEC_BITS];\n\n defined($e) && (select(undef,undef,$e,$timeout) > 0)\n    ? handles($vec, $e)\n    : ();\n}\n\nsub has_error\n{\n warnings::warn(\"Call to deprecated method 'has_error', use 'has_exception'\")\n\tif warnings::enabled();\n goto &has_exception;\n}\n\nsub count\n{\n my $vec = shift;\n $vec->[FD_COUNT];\n}\n\nsub bits\n{\n my $vec = shift;\n $vec->[VEC_BITS];\n}\n\nsub as_string  # for debugging\n{\n my $vec = shift;\n my $str = ref($vec) . \": \";\n my $bits = $vec->bits;\n my $count = $vec->count;\n $str .= defined($bits) ? unpack(\"b*\", $bits) : \"undef\";\n $str .= \" $count\";\n my @handles = @$vec;\n splice(@handles, 0, FIRST_FD);\n for (@handles) {\n     $str .= \" \" . (defined($_) ? \"$_\" : \"-\");\n }\n $str;\n}\n\nsub _max\n{\n my($a,$b,$c) = @_;\n $a > $b\n    ? $a > $c\n        ? $a\n        : $c\n    : $b > $c\n        ? $b\n        : $c;\n}\n\nsub select\n{\n shift\n   if defined $_[0] && !ref($_[0]);\n\n my($r,$w,$e,$t) = @_;\n my @result = ();\n\n my $rb = defined $r ? $r->[VEC_BITS] : undef;\n my $wb = defined $w ? $w->[VEC_BITS] : undef;\n my $eb = defined $e ? $e->[VEC_BITS] : undef;\n\n if(select($rb,$wb,$eb,$t) > 0)\n  {\n   my @r = ();\n   my @w = ();\n   my @e = ();\n   my $i = _max(defined $r ? scalar(@$r)-1 : 0,\n                defined $w ? scalar(@$w)-1 : 0,\n                defined $e ? scalar(@$e)-1 : 0);\n\n   for( ; $i >= FIRST_FD ; $i--)\n    {\n     my $j = $i - FIRST_FD;\n     push(@r, $r->[$i])\n        if defined $rb && defined $r->[$i] && vec($rb, $j, 1);\n     push(@w, $w->[$i])\n        if defined $wb && defined $w->[$i] && vec($wb, $j, 1);\n     push(@e, $e->[$i])\n        if defined $eb && defined $e->[$i] && vec($eb, $j, 1);\n    }\n\n   @result = (\\@r, \\@w, \\@e);\n  }\n @result;\n}\n\nsub handles\n{\n my $vec = shift;\n my $bits = shift;\n my @h = ();\n my $i;\n my $max = scalar(@$vec) - 1;\n\n for ($i = FIRST_FD; $i <= $max; $i++)\n  {\n   next unless defined $vec->[$i];\n   push(@h, $vec->[$i])\n      if !defined($bits) || vec($bits, $i - FIRST_FD, 1);\n  }\n \n @h;\n}\n\n1;\n__END__\n\n", 8192) = 4256
09:01:57.194357 brk(0x10dc000)          = 0x10dc000
09:01:57.194465 lseek(12, 4255, SEEK_SET) = 4255
09:01:57.194512 lseek(12, 0, SEEK_CUR)  = 4255
09:01:57.194557 close(12)               = 0
09:01:57.194673 stat("modules/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.194726 stat("modules/Net/DNS/Packet.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.194777 stat("modules/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.194827 stat("modules/Net/DNS/Packet.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.194877 stat("/etc/perl/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.194926 stat("/etc/perl/Net/DNS/Packet.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.194976 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.195027 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Packet.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.195078 stat("/usr/local/share/perl/5.14.2/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.195128 stat("/usr/local/share/perl/5.14.2/Net/DNS/Packet.pm", 0x7ffe12339d90) = -1 ENOENT (No such file or directory)
09:01:57.195179 stat("/usr/lib/perl5/Net/DNS/Packet.pmc", 0x7ffe12339e40) = -1 ENOENT (No such file or directory)
09:01:57.195229 stat("/usr/lib/perl5/Net/DNS/Packet.pm", {st_mode=S_IFREG|0644, st_size=20470, ...}) = 0
09:01:57.195288 open("/usr/lib/perl5/Net/DNS/Packet.pm", O_RDONLY) = 12
09:01:57.195340 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339b20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.195387 lseek(12, 0, SEEK_CUR)  = 0
09:01:57.195441 read(12, "package Net::DNS::Packet;\n#\n# $Id: Packet.pm 837 2009-12-30 10:23:25Z olaf $\n#\nuse strict;\n\nBEGIN { \n    eval { require bytes; }\n}\n\nuse vars qw(@ISA @EXPORT_OK $VERSION $AUTOLOAD);\n\nuse Carp;\nuse Net::DNS ;\nuse Net::DNS::Question;\nuse Net::DNS::RR;\nuse Data::Dumper;\n\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT_OK = qw(dn_expand);\n\n\n$VERSION = (qw$LastChangedRevision: 837 $)[1];\n\n\n\n=head1 NAME\n\nNet::DNS::Packet - DNS packet object class\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::Packet;>\n\n=head1 DESCRIPTION\n\nA C<Net::DNS::Packet> object represents a DNS packet.\n\n=head1 METHODS\n\n=head2 new\n\n    $packet = Net::DNS::Packet->new(\"example.com\");\n    $packet = Net::DNS::Packet->new(\"example.com\", \"MX\", \"IN\");\n\n    $packet = Net::DNS::Packet->new(\\$data);\n    $packet = Net::DNS::Packet->new(\\$data, 1);  # set debugging\n\n    ($packet, $err) = Net::DNS::Packet->new(\\$data);\n\n    $packet = Net::DNS::Packet->new();\n\nIf passed a domain, type, and class, C<new> creates a packet\nobject appropriate for making a DNS query for the requested\ninformation.  The type and class can be omitted; they default\nto A and IN.\n\nIf passed a reference to a scalar containing DNS packet data,\nC<new> creates a packet object from that data.  A second argument\ncan be passed to turn on debugging output for packet parsing.\n\nIf called in array context, returns a packet object and an\nerror string.  The error string will only be defined if the\npacket object is undefined (i.e., couldn't be created).\n\nReturns B<undef> if unable to create a packet object (e.g., if\nthe packet data is truncated).\n\nIf called with an empty argument list, C<new> creates an empty packet.\n\n=cut\n\nsub new {\n\tmy $class = shift;\n\tmy ($data) = @_;\n\treturn $class->parse(@_) if ref $data;\n\n\tmy %self = (\theader\t\t=> Net::DNS::Header->new,\n\t\t\tquestion\t=> [],\n\t\t\tanswer\t\t=> [],\n\t\t\tauthority\t=> [],\n\t\t\tadditional\t=> []\t);\n\n\tpush @{$self{question}}, Net::DNS::Question->new(@_) if @_;\n\n\tbless \\%self, $class;\n}\n\n\n\nsub parse {\n\tmy $class = shift;\n\tmy $data  = shift;\n\tmy $debug = shift || 0;\n\n\tmy %self = (\tquestion\t=> [],\n\t\t\tanswer\t\t=> [],\n\t\t\tauthority\t=> [],\n\t\t\tadditional\t=> [],\n\t\t\tanswersize\t=> length $$data,\n\t\t\tbuffer\t\t=> $data\t);\n\n\tmy $self = eval {\n\t\t# Parse header section\n\t\tmy ($header, $offset) = Net::DNS::Header->parse($data);\n\t\t$self{header} = $header;\n\n\t\t# Parse question/zone section\n\t\tfor ( 1 .. $header->qdcount ) {\n\t\t\tmy $qd;\n\t\t\t($qd, $offset) = Net::DNS::Question->parse($data, $offset);\n\t\t\tpush(@{$self{question}}, $qd);\n\t\t}\n\t\t\t\n\t\t# Retain offset for on-demand parse of remaining data\n\t\t$self{offset} = $offset;\n\n\t\tbless \\%self, $class;\n\t};\n\n\t($self || die $@)->print if $debug;\n\n\treturn wantarray ? ($self, $@) : $self;\n}\n\n\n\n=head2 data\n\n    $data = $packet->data;\n\nReturns the packet data in binary format, suitable for sending to\na nameserver.\n\n=cut\n\nsub data {\n\tmy $self = shift;\n\tmy $data = '';\n\tmy $header = $self->{header};\n\n\t# Default question for empty packet\n\t$self->push('question', Net::DNS::Question->new('','ANY','ANY'))\n\t\t\t\t\t\tunless @{$self->{question}};\n\n\t#----------------------------------------------------------------------\n\t# Set record counts in packet header\n\t#----------------------------------------------------------------------\n\t$header->qdcount( scalar @{$self->{question}} );\n\t$header->ancount( scalar @{$self->{answer}} );\n\t$header->nscount( scalar @{$self->{authority}} );\n\t$header->arcount( scalar @{$self->{additional}} );\n\n\t#----------------------------------------------------------------------\n\t# Get the data for each section in the packet\n\t#----------------------------------------------------------------------\n\t$self->{compnames} = {};\n\tforeach my $component ( $header,\n\t\t\t\t@{$self->{question}},\n\t\t\t\t@{$self->{answer}},\n\t\t\t\t@{$self->{authority}},\n\t\t\t\t@{$self->{additional}}\t) {\n\t\t$data .= $component->data($self, length $data);\n\t}\n\n\treturn $data;\n}\n\n\n=head2 header\n\n    $header = $packet->header;\n\nReturns a C<Net::DNS::Header> object representing the header section\nof the packet.\n\n=cut\n\nsub header {\n\treturn shift->{header};\n}\n\n=head2 question, zone\n\n    @question = $packet->question;\n\nReturns a list of C<Net::DNS::Question> objects representing the\nquestion section of the packet.\n\nIn dynamic update packets, this section is known as C<zone> and\nspecifies the zone to be updated.\n\n=cut\n\nsub question {\n\treturn @{shift->{question}};\n}\n\nsub zone { &question }\n\n=head2 answer, pre, prerequisite\n\n    @answer = $packet->answer;\n\nReturns a list of C<Net::DNS::RR> objects representing the answer\nsection of the packet.\n\nIn dynamic update packets, this section is known as C<pre> or\nC<prerequisite> and specifies the RRs or RRsets which must or\nmust not preexist.\n\n=cut\n\nsub answer {\n\tmy @rr = eval { &_answer };\n\tcarp \"$@ caught\" if $@;\n\treturn @rr;\n}\n\nsub _answer {\n\tmy ($self) = @_;\n\n\tmy @rr = @{$self->{answer}};\n\treturn @rr if @rr;\t\t\t\t# return if already parsed\n\n\tmy $data = $self->{buffer};\t\t\t# parse answer data\n\tmy $offset = $self->{offset} || return;\n\tundef $self->{offset};\n\tmy $ancount = $self->{header}->ancount;\n\tmy $rr;\n\twhile ( $ancount-- ) {\n\t\t($rr, $offset) = Net::DNS::RR->parse($data, $offset);\n\t\tpush(@rr, $rr);\n\t}\n\t$self->{offset} = $offset;\t\t\t# index next section\n\t@{$self->{answer}} = @rr;\n}\n\nsub pre\t\t{ &answer }\nsub prerequisite { &answer }\n\n=head2 authority, update\n\n    @authority = $packet->authority;\n\nReturns a list of C<Net::DNS::RR> objects representing the authority\nsection of the packet.\n\nIn dynamic update packets, this section is known as C<update> and\nspecifies the RRs or RRsets to be added or deleted.\n\n=cut\n\nsub authority {\n\tmy @rr = eval { &_authority };\n\tcarp \"$@ caught\" if $@;\n\treturn @rr;\n}\n\nsub _authority {\n\tmy ($self) = @_;\n\n\tmy @rr = @{$self->{authority}};\n\treturn @rr if @rr;\t\t\t\t# return if already parsed\n\n\t&_answer unless @{$self->{answer}};\t\t# parse answer data\n\n\tmy $data = $self->{buffer};\t\t\t# parse authority data\n\tmy $offset = $self->{offset} || return;\n\tundef $self->{offset};\n\tmy $nscount = $self->{header}->nscount;\n\tmy $rr;\n\twhile ( $nscount-- ) {\n\t\t($rr, $offset) = Net::DNS::RR->parse($data, $offset);\n\t\tpush(@rr, $rr);\n\t}\n\t$self->{offset} = $offset;\t\t\t# index next section\n\t@{$self->{authority}} = @rr;\n}\n\nsub update { &authority }\n\n=head2 additional\n\n    @additional = $packet->additional;\n\nReturns a list of C<Net::DNS::RR> objects representing the additional\nsection of the packet.\n\n=cut\n\nsub additional {\n\tmy @rr = eval { &_additional };\n\tcarp \"$@ caught\" if $@;\n\treturn @rr;\n}\n\nsub _additional {\n\tmy ($self) = @_;\n\n\tmy @rr = @{$self->{additional}};\n\treturn @rr if @rr;\t\t\t\t# return if already parsed\n\n\t&_authority unless @{$self->{authority}};\t# parse authority data\n\n\tmy $data = $self->{buffer};\t\t\t# parse additional data\n\tundef $self->{buffer};\t\t\t\t# discard raw data after use\n\tmy $offset = $self->{offset} || return;\n\tundef $self->{offset};\n\tmy $arcount = $self->{header}->arcount;\n\tmy $rr;\n\twhile ( $arcount-- ) {\n\t\t($rr, $offset) = Net::DNS::RR->parse($data, $offset);\n\t\tpush(@rr, $rr);\n\t}\n\t@{$self->{additional}} = @rr;\n}\n\n\n=head2 print\n\n    $packet->print;\n\nPrints the packet data on the standard output in an ASCII format\nsimilar to that used in DNS zone files.\n\n=cut\n\nsub print {\tprint &string; }\n\n=head2 string\n\n    print $packet->string;\n\nReturns a string representation of the packet.\n\n=cut\n\nsub string {\n\tmy $self = shift;\n\n\tmy $header = $self->{header};\n\tmy $update = $header->opcode eq 'UPDATE';\n\n\tmy $server = $self->{answerfrom};\n\tmy $string = $server ? \";; Answer received from $server ($self->{answersize} bytes)\\n\" : \"\";\n\n\t$string .= \";; HEADER SECTION\\n\".$header->string;\n\n\tmy $question = $update ? 'ZONE' : 'QUESTION';\n\tmy @question = map{$_->string} $self->question;\n\tmy $qdcount = @question;\n\tmy $qds = $qdcount != 1 ? 's' : '';\n\t$string .= join \"\\n;; \", \"\\n;; $question SECTION ($qdcount record$qds)\", @question;\n\n\tmy $answer = $update ? 'PREREQUISITE' : 'ANSWER';\n\tmy @answer = map{$_->string} $self->answer;\n\tmy $ancount = @answer;\n\tmy $ans = $ancount != 1 ? 's' : '';\n\t$string .= join \"\\n\", \"\\n\\n;; $answer SECTION ($ancount record$ans)\", @answer;\n\n\tmy $authority = $update ? 'UPDATE' : 'AUTHORITY';\n\tmy @authority = map{$_->string} $self->authority;\n\tmy $nscount = @authority;\n\tmy $nss = $ns", 8192) = 8192
09:01:57.195975 stat("modules/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196028 stat("modules/Net/DNS/Question.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.196078 stat("modules/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196127 stat("modules/Net/DNS/Question.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.196177 stat("/etc/perl/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196226 stat("/etc/perl/Net/DNS/Question.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.196276 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196327 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Question.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.196378 stat("/usr/local/share/perl/5.14.2/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196428 stat("/usr/local/share/perl/5.14.2/Net/DNS/Question.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.196478 stat("/usr/lib/perl5/Net/DNS/Question.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.196535 stat("/usr/lib/perl5/Net/DNS/Question.pm", {st_mode=S_IFREG|0644, st_size=6451, ...}) = 0
09:01:57.196595 open("/usr/lib/perl5/Net/DNS/Question.pm", O_RDONLY) = 13
09:01:57.196648 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123394f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.196694 lseek(13, 0, SEEK_CUR)  = 0
09:01:57.196754 read(13, "package Net::DNS::Question;\n#\n# $Id: Question.pm 836 2009-12-30 09:41:53Z olaf $\n#\nuse strict;\nBEGIN { \n    eval { require bytes; }\n} \n\nuse vars qw($VERSION $AUTOLOAD);\n\nuse Carp;\nuse Net::DNS;\n\n$VERSION = (qw$LastChangedRevision: 800$)[1];\n\n=head1 NAME\n\nNet::DNS::Question - DNS question class\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::Question>\n\n=head1 DESCRIPTION\n\nA C<Net::DNS::Question> object represents a record in the\nquestion section of a DNS packet.\n\n=head1 METHODS\n\n=head2 new\n\n    $question = Net::DNS::Question->new(\"example.com\", \"MX\", \"IN\");\n\nCreates a question object from the domain, type, and class passed\nas arguments.\n\nRFC4291 and RFC4632 IP address/prefix notation is supported for\nqueries in in-addr.arpa and ip6.arpa subdomains.\n\n=cut\n\nsub new {\n\tmy $self   = bless {}, shift;\n\tmy $qname  = shift;\n\tmy $qtype  = uc (shift || '');\n\tmy $qclass = uc (shift || '');\n\n\t$qname = '' unless defined $qname;\t# || ''; is NOT same!\n\t$qname =~ s/\\.+$//o;\t\t\t# strip gratuitous trailing dot\n\n\t# tolerate (possibly unknown) type and class in zone file order\n\tunless ( exists $Net::DNS::classesbyname{$qclass} ) {\n\t\t( $qtype, $qclass ) = ( $qclass, $qtype )\n\t\t\t\tif exists $Net::DNS::classesbyname{$qtype};\n\t\t( $qtype, $qclass ) = ( $qclass, $qtype ) if $qtype =~ /CLASS/;\n\t}\n\tunless ( exists $Net::DNS::typesbyname{$qtype} ) {\n\t\t( $qtype, $qclass ) = ( $qclass, $qtype )\n\t\t\t\tif exists $Net::DNS::typesbyname{$qclass};\n\t\t( $qtype, $qclass ) = ( $qclass, $qtype ) if $qclass =~ /TYPE/;\n\t}\n\n\t# if argument is an IP address, do appropriate reverse lookup\n\tmy $reverse = _dns_addr($qname) if $qname =~ m/:|\\d$/o;\n\tif ( $reverse ) {\n\t\t$qname = $reverse;\n\t\t$qtype ||= 'PTR';\n\t}\n\n\t$self->{qname}  = $qname;\n\t$self->{qtype}  = ( $qtype || 'A' );\n\t$self->{qclass} = ( $qclass || 'IN' );\n\n\treturn $self;\n}\n\n\nsub _dns_addr {\n\tmy $arg = shift;\t# name or IP address\n\n\t# IP address must contain address characters only\n\treturn undef if $arg =~ m#[^a-fA-F0-9:./]#o;\n\n\t# if arg looks like IPv4 address then map to in-addr.arpa space\n\tif ( $arg =~ m#(^|:.*:)((^|\\d+\\.)+\\d+)(/(\\d+))?$#o ) {\n\t\tmy @parse = split /\\./, $2;\n\t\tmy $prefx = $5 || @parse<<3;\n\t\tmy $last = $prefx > 24 ? 3 : ($prefx-1)>>3;\n\t\treturn join '.', reverse( (@parse,(0)x3)[0 .. $last] ), 'in-addr.arpa';\n\t}\n\n\t# if arg looks like IPv6 address then map to ip6.arpa space\n\tif ( $arg =~ m#^((\\w*:)+)(\\w*)(/(\\d+))?$#o ) {\n\t\tmy @parse = split /:/, (reverse \"0${1}0${3}\"), 9;\n\t\tmy @xpand = map{/./ ? $_ : ('0')x(9-@parse)} @parse;\t# expand ::\n\t\tmy $prefx = $5 || @xpand<<4;\t\t# implicit length if unspecified\n\t\tmy $hex = pack 'A4'x8, map{$_.'000'} ('0')x(8-@xpand), @xpand;\n\t\tmy $len = $prefx > 124 ? 32 : ($prefx+3)>>2;\n\t\treturn join '.', split(//, substr($hex,-$len) ), 'ip6.arpa';\n\t}\n\n\treturn undef;\n}\n\n\n=head2 parse\n\n    ($question, $offset) = Net::DNS::Question->parse(\\$data, $offset);\n\nParses a question section record at the specified location within a DNS packet.\nThe first argument is a reference to the packet data.\nThe second argument is the offset within the packet where the question record begins.\n\nReturns a Net::DNS::Question object and the offset of the next location in the packet.\n\nParsing is aborted if the question object cannot be created (e.g., corrupt or insufficient data).\n\n=cut\n\nuse constant PACKED_LENGTH => length pack 'n2', (0)x2;\n\nsub parse {\n\tmy ($class, $data, $offset) = @_;\n\n\tmy ($qname, $index) = Net::DNS::Packet::dn_expand($data, $offset);\n\tdie 'Exception: corrupt or incomplete data' unless $index;\n\n\tmy $next = $index + PACKED_LENGTH;\n\tdie 'Exception: incomplete data' if length $$data < $next;\n\tmy ($qtype, $qclass) = unpack(\"\\@$index n2\", $$data);\n\n\tmy $self = {\tqname\t=> $qname,\n\t\t\tqtype\t=> Net::DNS::typesbyval($qtype),\n\t\t\tqclass\t=> Net::DNS::classesbyval($qclass)\n\t\t\t};\n\n\tbless $self, $class;\n\n\treturn wantarray ? ($self, $next) : $self;\n}\n\n\n#\n# Some people have reported that Net::DNS dies because AUTOLOAD picks up\n# calls to DESTROY.\n#\nsub DESTROY {}\n\n=head2 qname, zname\n\n    print \"qname = \", $question->qname, \"\\n\";\n    print \"zname = \", $question->zname, \"\\n\";\n\nReturns the domain name.  In dynamic update packets, this field is\nknown as C<zname> and refers to the zone name.\n\n=head2 qtype, ztype\n\n    print \"qtype = \", $question->qtype, \"\\n\";\n    print \"ztype = \", $question->ztype, \"\\n\";\n\nReturns the record type.  In dymamic update packets, this field is\nknown as C<ztype> and refers to the zone type (must be SOA).\n\n=head2 qclass, zclass\n\n    print \"qclass = \", $question->qclass, \"\\n\";\n    print \"zclass = \", $question->zclass, \"\\n\";\n\nReturns the record class.  In dynamic update packets, this field is\nknown as C<zclass> and refers to the zone's class.\n\n=cut\n\nsub zname  { &qname;  }\nsub ztype  { &qtype;  }\nsub zclass { &qclass; }\n\n\nsub AUTOLOAD {\n\tmy $self = shift;\n\n\tmy $name = $AUTOLOAD;\n\t$name =~ s/.*://o;\n\n\tcroak \"$AUTOLOAD: no such method\" unless exists $self->{$name};\n\n\treturn $self->{$name} unless @_;\n\n\tmy $value = shift;\n\t$value =~ s/\\.+$//o if defined $value;\t# strip gratuitous trailing dot\n\t$self->{$name} = $value;\n}\n\n=head2 print\n\n    $question->print;\n\nPrints the question record on the standard output.\n\n=cut\n\nsub print {\tprint &string, \"\\n\"; }\n\n=head2 string\n\n    print $qr->string, \"\\n\";\n\nReturns a string representation of the question record.\n\n=cut\n\nsub string {\n\tmy $self = shift;\n\treturn \"$self->{qname}.\\t$self->{qclass}\\t$self->{qtype}\";\n}\n\n=head2 data\n\n    $qdata = $question->data($packet, $offset);\n\nReturns the question record in binary format suitable for inclusion\nin a DNS packet.\n\nArguments are a C<Net::DNS::Packet> object and the offset within\nthat packet's data where the C<Net::DNS::Question> record is to\nbe stored.  This information is necessary for using compressed\ndomain names.\n\n=cut\n\nsub data {\n\tmy ($self, $packet, $offset) = @_;\n\n\tmy $data = $packet->dn_comp($self->{qname}, $offset);\n\n\t$data .= pack('n2',\tNet::DNS::typesbyname(uc $self->{qtype}),\n\t\t\t\tNet::DNS::classesbyname(uc $self->{qclass})\n\t\t\t\t);\n\treturn $data;\n}\n\n\n1;\n__END__\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nPortions Copyright (c) 2003,2006-2009 Dick Franks.\n\nAll rights reserved.\n\nThis program is free software; you may redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Update>, L<Net::DNS::Header>, L<Net::DNS::RR>,\nRFC 1035 Section 4.1.2\n\n=cut\n\n", 8192) = 6451
09:01:57.197755 lseek(13, 5981, SEEK_SET) = 5981
09:01:57.197803 lseek(13, 0, SEEK_CUR)  = 5981
09:01:57.197848 close(13)               = 0
09:01:57.197921 stat("modules/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.197971 stat("modules/Net/DNS/RR.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.198020 stat("modules/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.198088 stat("modules/Net/DNS/RR.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.198139 stat("/etc/perl/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.198189 stat("/etc/perl/Net/DNS/RR.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.198238 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.198295 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.198346 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.198397 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR.pm", 0x7ffe12339760) = -1 ENOENT (No such file or directory)
09:01:57.198447 stat("/usr/lib/perl5/Net/DNS/RR.pmc", 0x7ffe12339810) = -1 ENOENT (No such file or directory)
09:01:57.198497 stat("/usr/lib/perl5/Net/DNS/RR.pm", {st_mode=S_IFREG|0644, st_size=25950, ...}) = 0
09:01:57.198557 open("/usr/lib/perl5/Net/DNS/RR.pm", O_RDONLY) = 13
09:01:57.198610 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123394f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.198656 lseek(13, 0, SEEK_CUR)  = 0
09:01:57.198711 read(13, "package Net::DNS::RR;\n#\n# $Id: RR.pm 828 2009-12-23 15:03:29Z olaf $\n#\nuse strict;\n\nBEGIN { \n    eval { require bytes; }\n} \n\n\nuse vars qw($VERSION $AUTOLOAD %rrsortfunct );\nuse Carp;\nuse Net::DNS qw (wire2presentation name2labels stripdot);\nuse Net::DNS::RR::Unknown;\n\n\n$VERSION = (qw$LastChangedRevision: 828 $)[1];\n\n=head1 NAME\n\nNet::DNS::RR - DNS Resource Record class\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR>\n\n=head1 DESCRIPTION\n\nC<Net::DNS::RR> is the base class for DNS Resource Record (RR) objects.\nSee also the manual pages for each RR type.\n\n=head1 METHODS\n\nB<WARNING!!!>  Don't assume the RR objects you receive from a query\nare of a particular type -- always check an object's type before calling\nany of its methods.  If you call an unknown method, you'll get a nasty\nwarning message and C<Net::DNS::RR> will return C<undef> to the caller.\n\n=cut\n\n# %RR needs to be available within the scope of the BEGIN block.\n# $RR_REGEX is a global just to be on the safe side.  \n# %_LOADED is used internally for autoloading the RR subclasses.\nuse vars qw(%RR %_LOADED $RR_REGEX);\n\nBEGIN {\n\n\t%RR = map { $_ => 1 } qw(\n\t\tA\n\t\tAAAA\n\t\tAFSDB\n\t\tCNAME\n\t\tCERT\n\t\tDHCID\n\t\tDNAME\n\t\tEID\n\t\tHINFO\n\t\tISDN\n\t\tKX\n\t\tLOC\n\t\tMB\n\t\tMG\n\t\tMINFO\n\t\tMR\n\t\tMX\n\t\tNAPTR\n\t\tNIMLOC\n\t\tNS\n\t\tNSAP\n\t\tNULL\n\t\tPTR\n\t\tPX\n\t\tRP\n\t\tRT\n\t\tSOA\n\t\tSRV\n\t\tTKEY\n\t\tTSIG\n\t\tTXT\n\t\tX25\n\t\tOPT\n\t\tAPL\n\t\tSSHFP\n\t\tHIP\n\t\tSPF\n\t\tIPSECKEY\n\n\t);\n\n\t#  Only load DNSSEC if available\n\n\teval { \t    \n\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t    require Net::DNS::RR::SIG; \n\t};\n\n\tunless ($@) {\n\t\t$RR{'SIG'} = 1;\n\t\teval { \t    \n\t\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t    require Net::DNS::RR::NXT; \n\t\t};\n\t\t\n\t\tunless ($@) {\n\t\t    $RR{'NXT'}\t= 1;\n\t\t} else {\n\t\t    die $@;\n\t\t}\n\t\t\n\t\teval { \n\t\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t    require Net::DNS::RR::KEY; \n\t\t};\n\t\t\n\t\tunless ($@) {\n\t\t    $RR{'KEY'} = 1;\n\t\t} else {\n\t\t    die $@;\n\t\t}\n\n\t \teval { \n\t\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t    require Net::DNS::RR::DS; \n\t\t};\n\n\t \tunless ($@) {\n\t\t    $RR{'DS'} = 1;\n\n\t\t} else {\n\t\t    die $@;\n\t\t}\n\n\t \teval { \n\t\t    local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t    require Net::DNS::RR::RRSIG; \n\t\t};\n\n\t \tunless ($@) {\n\t\t    $RR{'RRSIG'} = 1;\n\t\t    # If RRSIG is available so should the other DNSSEC types\n\t\t    eval {\t\t    \n\t\t\tlocal $SIG{'__DIE__'} = 'DEFAULT';\n\t\t\trequire Net::DNS::RR::NSEC; \n\t\t    };\n\t\t    unless ($@) {\n\t\t      $RR{'NSEC'} = 1;\n\t\t    } else {\n\t\t    die $@;\n\t\t  }\n\t\t    eval { \n\t\t\tlocal $SIG{'__DIE__'} = 'DEFAULT';\n\t\t\trequire Net::DNS::RR::DNSKEY; \n\t\t    };\n\n\t\t    unless ($@) {\n\t\t      $RR{'DNSKEY'} = 1;\n\t\t    } else {\n\t\t      die $@;\n\t\t    }\n\t\t} \n\n\t \teval { \n\t\t  local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t  require Net::DNS::RR::DLV; \n\t\t};\n\n\t\tunless ($@) {\n\t\t  $RR{'DLV'} =1;\n\t\t} else {\n\t\t  # Die only if we are dealing with a version for which DLV is \n\t\t  # available \n\t\t  die $@ if defined ($Net::DNS::SEC::HAS_DLV) ;\n\n\t\t}\n\n\t \teval { \n\t\t  local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t  require Net::DNS::RR::NSEC3; \n\t\t};\n\n\t\tunless ($@) {\n\t\t  $RR{'NSEC3'} =1;\n\t\t} else {\n\t\t  # Die only if we are dealing with a version for which NSEC3 is\t\t  # available \n\t\t  die $@ if defined ($Net::DNS::SEC::HAS_NSEC3);\n\t\t}\n\t\t\n\t\t\n\t \teval { \n\t\t  local $SIG{'__DIE__'} = 'DEFAULT';\n\t\t  require Net::DNS::RR::NSEC3PARAM; \n\t\t};\n\n\t\tunless ($@) {\n\t\t  $RR{'NSEC3PARAM'} =1;\n\t\t} else {\n\t\t  # Die only if we are dealing with a version for which NSEC3 is \n\t\t  # available \n\n\t\t  die $@ if defined($Net::DNS::SEC::SVNVERSION) &&  $Net::DNS::SEC::SVNVERSION > 619;   # In the code since. (for users of the SVN trunk)\n\t\t}\n\n\n\n    }\n}\n\nsub build_regex {\n\tmy $classes = join('|', keys %Net::DNS::classesbyname, 'CLASS\\\\d+');\n\n\t# Longest ones go first, so the regex engine will match AAAA before A.\n\tmy $types   = join('|', sort { length $b <=> length $a } keys %Net::DNS::typesbyname);\n\n\t$types .= '|TYPE\\\\d+';\n\t\t\t\t\n\t$RR_REGEX   = \" ^ \n\t\t\t\t\t\\\\s*\n    \t            (\\\\S+) # name anything non-space will do \n    \t            \\\\s*                \n    \t            (\\\\d+)?           \n    \t            \\\\s*\n    \t            ($classes)?\n    \t            \\\\s*\n    \t            ($types)?\n    \t            \\\\s*\n    \t            (.*)\n    \t            \\$\";\n\n#\tprint STDERR \"Regex: $RR_REGEX\\n\";\n}\n\n\n=head2 new (from string)\n\n $a     = Net::DNS::RR->new(\"foo.example.com. 86400 A 10.1.2.3\");\n $mx    = Net::DNS::RR->new(\"example.com. 7200 MX 10 mailhost.example.com.\");\n $cname = Net::DNS::RR->new(\"www.example.com 300 IN CNAME www1.example.com\");\n $txt   = Net::DNS::RR->new('baz.example.com 3600 HS TXT \"text record\"');\n\nReturns a C<Net::DNS::RR> object of the appropriate type and\ninitialized from the string passed by the user.  The format of the\nstring is that used in zone files, and is compatible with the string\nreturned by C<< Net::DNS::RR->string >>.\n\nThe name and RR type are required; all other information is optional.\nIf omitted, the TTL defaults to 0 and the RR class defaults to IN.\nOmitting the optional fields is useful for creating the empty RDATA\nsections required for certain dynamic update operations.  See the\nC<Net::DNS::Update> manual page for additional examples.\n\nAll names must be fully qualified.  The trailing dot (.) is optional.\n\n=head2 new (from hash)\n\n $rr = Net::DNS::RR->new(\n\t name    => \"foo.example.com\",\n\t ttl     => 86400,\n\t class   => \"IN\",\n\t type    => \"A\",\n\t address => \"10.1.2.3\",\n );\n \n $rr = Net::DNS::RR->new(\n\t name => \"foo.example.com\",\n\t type => \"A\",\n );\n\nReturns an RR object of the appropriate type, or a C<Net::DNS::RR>\nobject if the type isn't implemented.  See the manual pages for\neach RR type to see what fields the type requires.\n\nThe C<Name> and C<Type> fields are required; all others are optional.\nIf omitted, C<TTL> defaults to 0 and C<Class> defaults to IN.  Omitting\nthe optional fields is useful for creating the empty RDATA sections\nrequired for certain dynamic update operations.\n\nThe fields are case-insensitive, but starting each with uppercase\nis recommended.\n\n=cut\n\n\n\nsub new {\n\treturn new_from_string(@_) if @_ == 2;\n\treturn new_from_string(@_) if @_ == 3;\n\treturn new_from_hash(@_);\n}\n\n\nsub new_from_data {\n\tmy $class = shift;\n\tmy ($name, $rrtype, $rrclass, $ttl, $rdlength, $data, $offset) = @_;\n\n\tmy $self = {\tname\t\t=> $name,\n\t\t\ttype\t\t=> $rrtype,\n\t\t\tclass\t\t=> $rrclass,\n\t\t\tttl\t\t=> $ttl,\n\t\t\trdlength\t=> $rdlength,\n\t\t\trdata\t\t=> substr($$data, $offset, $rdlength)\n\t\t\t};\n\n\tif ($RR{$rrtype}) {\n\t\tmy $subclass = $class->_get_subclass($rrtype);\n\t\treturn $subclass->new($self, $data, $offset);\n\t} else {\n\t\treturn Net::DNS::RR::Unknown->new($self, $data, $offset);\n\t}\n\n}\n\nsub new_from_string {\n\tmy ($class, $rrstring, $update_type) = @_;\n\n\tbuild_regex() unless $RR_REGEX;\n\n\t# strip out comments\n\t# Comments start with a semi collon and run till end of line.\n\t# However if the semi colon is escaped or inside a character string then we should keep it\n\t# see e.g. rt.cpan 49035\n\tmy $loopdetection=length($rrstring);\n\tmy $cleanstring;\n\twhile ($rrstring) {\n\n\t\tif ($rrstring=~s/^([^\\\\;'\"]*)//o){       # Anything not special in this context.\n\t\t\t$cleanstring.=$1;\n\t\t}\n\t\tif ($rrstring=~s/^(\\\\.)//o){             # Escaped special character\n\t\t\t$cleanstring.=$1;\n\t\t}\n\t\t\n\t\tif ($rrstring=~s/^((['\"]).*(?<!\\\\)\\2)//o){ # Anything within a matching string block. (non escaped terminator)\n\t\t\t$cleanstring.=$1;\n\n\t\t\t# Next: Anything within a non matched string upto\n\t\t\t# the first encountered comment (but first we\n\t\t\t# want to make sure we captured all the nested\n\t\t\t# blocks hence elsif\n\t\t}elsif ($rrstring=~s/^((['\"]).*((?<!\\\\);)?)//o){\n\t\t\t$cleanstring.=$1;\n\t\t}\n\t\t\n\t\t$rrstring=~s/^(;.*\\n)//o;  # comment till newline\n\t\t$rrstring=~s/^(;.*$)//o;   # comment till end of string\n\t\t#print STDERR \".\";\n\n\t\tconfess \"Failed stripping:loop will not terminate. Please report this info: \". $cleanstring .\"---\". $rrstring.\"\\n\" \n\t\t  if ($loopdetection==length($rrstring));\n\t\t$loopdetection=length($rrstring);\n\n\n\t}\n\t  \n\t\n\t\n\n\t($cleanstring =~ m/$RR_REGEX/xso) || \n\t\tconfess qq|Internal Error: \"$rrstring\" did not match RR pat.\\nPlease report this to the author!\\n|;\n\n\tmy $name    = $1;\n\tmy $ttl     = $2 || 0;\n\tmy $rrclass = $3 || '';\n\n\n\tmy $rrtype  = $4 || '';\n\tmy $rdata   = $5 || '';\n\n\t$rdata =~ s/\\s+$//o if $rdata;\n\n\t$name  = stripdot($name)  if $name;\n\n\n\n\t# RFC3597 tweaks\n", 8192) = 8192
09:01:57.199114 brk(0x10fd000)          = 0x10fd000
09:01:57.199302 stat("modules/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199354 stat("modules/Net/DNS/RR/Unknown.pm", 0x7ffe12339130) = -1 ENOENT (No such file or directory)
09:01:57.199405 stat("modules/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199454 stat("modules/Net/DNS/RR/Unknown.pm", 0x7ffe12339130) = -1 ENOENT (No such file or directory)
09:01:57.199503 stat("/etc/perl/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199553 stat("/etc/perl/Net/DNS/RR/Unknown.pm", 0x7ffe12339130) = -1 ENOENT (No such file or directory)
09:01:57.199603 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199654 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/Unknown.pm", 0x7ffe12339130) = -1 ENOENT (No such file or directory)
09:01:57.199705 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199756 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/Unknown.pm", 0x7ffe12339130) = -1 ENOENT (No such file or directory)
09:01:57.199806 stat("/usr/lib/perl5/Net/DNS/RR/Unknown.pmc", 0x7ffe123391e0) = -1 ENOENT (No such file or directory)
09:01:57.199863 stat("/usr/lib/perl5/Net/DNS/RR/Unknown.pm", {st_mode=S_IFREG|0644, st_size=1449, ...}) = 0
09:01:57.199922 open("/usr/lib/perl5/Net/DNS/RR/Unknown.pm", O_RDONLY) = 14
09:01:57.199975 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338ec0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.200022 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.200081 read(14, "package Net::DNS::RR::Unknown;\n#\n# $Id: Unknown.pm 388 2005-06-22 10:06:05Z olaf $\n#\nuse strict;\nBEGIN { \n    eval { require bytes; }\n} \nuse vars qw(@ISA $VERSION);\n\n@ISA     = qw(Net::DNS::RR);\n$VERSION = (qw$LastChangedRevision: 388 $)[1];\n\nsub new {\n\tmy ($class, $self, $data, $offset) = @_;\n\t\n\tmy $length = $self->{'rdlength'};\n\t\n\tif ($length > 0) {\n\t\t$self->{'rdata'}    = substr($$data, $offset,$length);\n\t\t$self->{'rdatastr'} = \"\\\\# $length \" . unpack('H*',  $self->{'rdata'});\n\t}\n\t\n\treturn bless $self, $class;\n}\n\n\nsub rdatastr {\n\tmy $self = shift;\n\t\n\tif (exists $self->{'rdatastr'}) {\n\t\treturn $self->{'rdatastr'};\n\t} else {\n\t\tif (exists $self->{\"rdata\"}){\n\t\t\tmy $data= $self->{'rdata'};\n\t\t\t\n\t\t\treturn  \"\\\\# \". length($data) . \"  \" . unpack('H*',  $data);\n\t\t}\n\t}\n\t\n\treturn \"#NO DATA\";\n}\n\n\n# sub rr_rdata is inherited from RR.pm. Note that $self->{'rdata'}\n# should always be defined\n\n\n\n1;\n__END__\n\n=head1 NAME\n\nNet::DNS::RR::Unknown - Unknown RR record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR>;\n\n=head1 DESCRIPTION\n\nClass for dealing with unknown RR types (RFC3597)\n\n=head1 METHODS\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nPortions Copyright (c) 2003  Olaf M. Kolkman, RIPE NCC.\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<Net::DNS>, L<Net::DNS::RR>, RFC 3597\n\n=cut\n", 8192) = 1449
09:01:57.200349 lseek(14, 906, SEEK_SET) = 906
09:01:57.200397 lseek(14, 0, SEEK_CUR)  = 906
09:01:57.200442 close(14)               = 0
09:01:57.200794 stat("modules/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.200846 stat("modules/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.200896 stat("modules/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.200945 stat("modules/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.200994 stat("/etc/perl/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.201043 stat("/etc/perl/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.201093 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.201147 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.201199 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.201249 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.201300 stat("/usr/lib/perl5/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.201350 stat("/usr/lib/perl5/Net/DNS/RR/SIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.201401 stat("/usr/share/perl5/Net/DNS/RR/SIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.201453 stat("/usr/share/perl5/Net/DNS/RR/SIG.pm", {st_mode=S_IFREG|0644, st_size=35809, ...}) = 0
09:01:57.201512 open("/usr/share/perl5/Net/DNS/RR/SIG.pm", O_RDONLY) = 14
09:01:57.201565 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.201612 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.201679 read(14, "# perldoc SIG.pm for documentation.\n# Specs: RFC 2535 section 4\n# $Id: SIG.pm 777 2008-12-30 17:18:54Z olaf $\n\npackage Net::DNS::RR::SIG;\n\nuse vars qw(@ISA $VERSION @EXPORT );\n\nuse Net::DNS;\nuse Carp;\nuse bytes;\nuse Crypt::OpenSSL::DSA;\nuse Crypt::OpenSSL::RSA;\nuse Crypt::OpenSSL::Bignum;\nuse Net::DNS::SEC::Private;\n\nuse File::Basename;\nuse MIME::Base64;\nuse Math::BigInt;\nuse Time::Local;\nuse Digest::SHA qw (sha1);\n\n\n\n\n\n\n#\n# Most of the cryptovariables should be interpred as unsigne\n#\n#\n\n\nrequire Exporter;\n\n$VERSION = do { my @r=(q$Revision: 777 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n@ISA = qw (\n\t   Exporter\n\t Net::DNS::RR\n\t   );\n\n@EXPORT = qw (\n\t      );\n\n\nuse strict;\nmy $debug=0;\nmy $crypt_open_ssl=1;\nmy $__DeprecationWarningVerifyShown=0;\nmy $__DeprecationWarningCreateShown=0;\n\n\n\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n\n    if ($self->{\"rdlength\"} > 0) {\n\t#RFC2535 section 4.1\n\tmy $offsettoalg=$offset+2;\n\tmy $offsettolabels=$offset+3;\n\tmy $offsettoorgttl=$offset+4;\n\tmy $offsettosigexp=$offset+8;\n\tmy $offsettosiginc=$offset+12;\n\tmy $offsettokeytag=$offset+16;\n\tmy $offsettosignm=$offset+18;\n\n\t$self->{\"typecovered\"}= _type2string(unpack(\"n\",substr($$data,$offset,2)));\n\t$self->{\"algorithm\"}=unpack(\"C\",substr($$data,$offsettoalg,1));\n\t$self->{\"labels\"}=lc(unpack(\"C\",substr($$data,$offsettolabels,1)));\n\t$self->{\"orgttl\"}=unpack(\"N\",substr($$data,$offsettoorgttl,4));\n\tmy @expt=gmtime(unpack(\"N\",substr($$data,$offsettosigexp,4)));\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $expt[5]+1900 ,$expt[4]+1 , \n\t\t\t\t\t   $expt[3] ,$expt[2] , $expt[1]  , \n\t\t\t\t\t   $expt[0]);\n\tmy @inct=gmtime(unpack(\"N\",substr($$data,$offsettosiginc,4)));\n\t$self->{\"siginception\"}=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t     $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t     $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t     $inct[0]);\n\t$self->{\"keytag\"}=unpack(\"n\",substr($$data,$offsettokeytag,2));\n\tmy($signame,$sigoffset) = Net::DNS::Packet::dn_expand\n\t    ($data, $offsettosignm);\n\t$self->{\"signame\"}=lc($signame) ;\n\tmy($sigmaterial)=substr($$data,$sigoffset,\n\t\t\t\t($self->{\"rdlength\"}-$sigoffset+$offset));\n\t$self->{\"sigbin\"}=$sigmaterial;\n\t$self->{\"sig\"}= encode_base64($sigmaterial);\n\t$self->{\"vrfyerrstr\"}=\"\";\n\t\n    }\n    return bless $self, $class;\n}\n\n\n\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    if ($string) {\n\t$string =~ tr/()//d;\n\t$string =~ s/;.*$//mg;\n\t$string =~ s/\\n//mg;\n\tmy ($typecovered, $algoritm,\n\t    $labels, $orgttl, $sigexpiration,\n\t    $siginception, $keytag,$signame,$sig) = \n\t\t$string =~ \n\t\t    /^\\s*(\\S+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)\\s+(.*)/;\n\tcroak (\" Invallid SIG RR, check your fomat \") if !$keytag;\n\t$sig =~ s/\\s*//g;\n\t$self->{\"typecovered\"}=uc($typecovered);\n\t$self->{\"algorithm\"}= $algoritm;\n\t$self->{\"labels\"}= lc($labels);\n\t$self->{\"orgttl\"}= $orgttl;\n\t_checktimeformat($sigexpiration);\n\t_checktimeformat($siginception);\n\t$self->{\"sigexpiration\"}=  $sigexpiration;\n\t$self->{\"siginception\"}= $siginception;\n\t$self->{\"keytag\"}= $keytag;\n\t$self->{\"signame\"}= Net::DNS::stripdot(lc($signame));\n\t$self->{\"sig\"}= $sig;\n\t$self->{\"sigbin\"}= decode_base64($sig);\n\t$self->{\"vrfyerrstr\"}=\"\";\n    }\n    return bless $self, $class;\n}\n\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\tif (exists $self->{\"typecovered\"}) {\n\t    $rdatastr  = $self->{typecovered};\n\t    $rdatastr .= \"  \"  . \"$self->{algorithm}\";\n\t    $rdatastr .= \"  \"  . \"$self->{labels}\";\n\t    $rdatastr .= \"  \"  . \"$self->{orgttl}\";\n\t    $rdatastr .= \"  \"  . \"$self->{sigexpiration}\";\n\t    $rdatastr .= \" (\\n\\t\\t\\t\"  . \"$self->{siginception}\";\n\t    $rdatastr .= \" \"  . \"$self->{keytag}\";\n\t    $rdatastr .= \"  \"  . \"$self->{signame}\";\n\t    # do some nice formatting\n\t    my $sigstring=$self->{sig};\n\t    $sigstring =~ s/\\n//g;\n\t    $sigstring =~ s/(\\S{45})/$1\\n\\t\\t\\t/g;\n\t    $rdatastr .=  \"\\n\\t\\t\\t\".$sigstring;\n\t    $rdatastr .= \" )\";\n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\n\nsub rr_rdata_without_sigbin {\n    my ($self) = shift;\n    my $rdata = \"\";\n\n    if (exists $self->{\"typecovered\"}) {\n\t$rdata  = pack(\"n\",_string2type($self->{typecovered}));\n\t$rdata .= pack(\"C\",$self->{algorithm});\n\t$rdata .= pack(\"C\",$self->{\"labels\"});\n\t$rdata .= pack(\"N\",$self->{\"orgttl\"});\n\t$self->{\"sigexpiration\"} =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/;\n\t$rdata .= pack(\"N\",timegm ($6, $5, $4, $3, $2-1, $1-1900));\n\n\t$self->{\"siginception\"} =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/;\n\t$rdata .= pack(\"N\",timegm ($6, $5, $4, $3, $2-1, $1-1900));\n\t$rdata .= pack(\"n\",$self->{\"keytag\"});\n\t# Since we will need canonical and expanded names while checking \n\t# we do not use the packet->dn_comp here but use RFC1035 p10.\n\t{   my @dname= split /\\./,lc($self->{\"signame\"});\n\t    for (my $i=0;$i<@dname;$i++){\n\t\t$rdata .= pack (\"C\",length $dname[$i] );\n\t\t$rdata .= $dname[$i] ;\n\n\t    }\n\t    $rdata .= pack (\"C\",\"0\");\n\t}\n    }\n    return $rdata;\n\n}\n\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n    my $rdata = \"\";\n    if (exists $self->{\"typecovered\"}) {\n\t$rdata=$self->rr_rdata_without_sigbin;\n\n\tif ($self->{\"sig\"} ne \"NOTYETCALCULATED\") {\n            $self->{\"sigbin\"}= decode_base64($self->{\"sig\"}) unless defined $self->{\"sigbin\"} ;\n            $rdata .= $self->{\"sigbin\"};\n\t}else{\n            #do sigzero calculation based on current packet content...\n\t    \n\t    die \"Signature not known for a not SIG0 type of signature\" if ($self->{\"typecovered\"} ne \"TYPE000\");\n\t    die \"Private key not known for SIG0\" if (! exists $self->{\"private_key\"});\n\t    \n\n\t    my $rr=$packet->pop(\"additional\");\n\t    die \"SIG0 should be the last RR in the packet\" if ($rr->type ne \"SIG\");\n\t    die \"Unexpected error during creation of SIG0. \" if ($rr ne $self);\n\t    print \"Processing SIG0 signature\\n\" if $debug;\n\n\t    my $data;\n\t    # Compress the data and make sure we will not go into deep\n\t    # recursion \n\t    if ($self->{\"rr_rdata_recursion\"}==0){\t    \n\t\t$self->{\"rr_rdata_recursion\"}=1;\t    \n\n\t\t$data=$packet->data;\n\n\t\tmy $sigdata=$self->_CreateSigData($data);\n\t\tmy $signature;\n\n\t\tif ($self->{\"algorithm\"} == 1 ||\n\t\t    $self->{\"algorithm\"} == 5)\n\t\t{  #RSA\n\n\n\t\t  my $rsa_priv=$self->{\"private_key\"};\n\t\t    eval {\n\t\t\t$rsa_priv->use_pkcs1_oaep_padding;\n\t\t\tif ($self->{\"algorithm\"} == 1) {\n\t\t\t    $rsa_priv->use_md5_hash;\n\t\t\t} else {\n\t\t\t    $rsa_priv->use_sha1_hash;\n\t\t\t}\n\n\t\t    };\n\t\t    die \"Error loading RSA private key \" . $@ if $@;\n\n\t\t    eval {\n\t\t\t$signature = $rsa_priv->sign($sigdata);\n\t\t    };\n\t\t    die \"RSA Signature generation failed \".$@ if $@;\n\n\t\t    print \"\\n SIGNED\" if $debug ;\n\t\t    \n\t\t}elsif ($self->{\"algorithm\"} == 3){  #DSA\n\n\n\t\t    my $private_dsa = $self->{\"private_key\"};\n\n\n\t\t    # If $sigzero then we want to sign data if given\n\t\t    # in the argument. If the argument is empty we\n\t\t    # sign when the packet put on the wire.\n\n\t\t    if (my $sig_obj= $private_dsa->do_sign(sha1($sigdata)))\n\t\t    {\n\t\t\t\n\t\t\tprint \"\\n SIGNED\" if $debug ;\n\t\t\t# See RFC 2536 for the content of the DSA SIG rdata \n\t\t\tmy $T_parameter= (length($private_dsa->get_g)-64)/8;\n\t\t\t$signature=pack(\"C\",$T_parameter);\n\t\t\tmy $sig_r_param=$sig_obj->get_r;\n\t\t\tmy $sig_s_param=$sig_obj->get_s;\n\t\t\t# both the R and S paramater in the RDATA need to be\n\t\t\t# 20 octets\n\t\t\twhile (length($sig_r_param)<20){\t\n\t\t\t    $sig_r_param=pack(\"x\").$sig_r_param ;\n\t\t\t}\n\t\t\twhile (length($sig_s_param)<20) {\t\n\t\t\t    $sig_s_param=pack(\"x\").$sig_s_param ;\n\t\t\t}\n\n\n\t\t\t$signature.=$sig_r_param.$sig_s_param;\n\n\n\t\t\t\n\n\t\t    }else\n\t\t    {  \n\t\t\tconfess \"creation of DSA Signature failed \" ;\n\t\t    }\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t$self->{\"sigbin\"}=$signature;\n\t\t$self->{\"sig\"}= encode_base64($signature);\n\t\t$rdata .= $self->{\"sigbin\"};\n\t    }\n\t    $packet->push(\"additional\", $self);\n\t}\n    }\n    return $rdata;\n    \n}\n\nsub create {\n    my ($class,  $datarrset, $priv_key, %args) = @_;\n\n    # This method returns a sigrr with the signature over the\n    # datatrrset (an array of RRs) made with the private key stored in\n    # the $key_file.\n\n    my $self;\n    $self->{\"sigerrstr\"}=\"---- Unknown Error Condition ------\";\n    my $Private;\n\n\n    if (UNIVERSAL::isa($priv_key,\"Net::DNS::SEC::Private\")){\n\t$Private=$priv_key;\n    }else{\n\t$Private=Net::DNS::S", 8192) = 8192
09:01:57.202250 stat("modules/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202304 stat("modules/Crypt/OpenSSL/DSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.202354 stat("modules/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202409 stat("modules/Crypt/OpenSSL/DSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.202459 stat("/etc/perl/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202509 stat("/etc/perl/Crypt/OpenSSL/DSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.202559 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202611 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/DSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.202662 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202713 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/DSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.202764 stat("/usr/lib/perl5/Crypt/OpenSSL/DSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.202816 stat("/usr/lib/perl5/Crypt/OpenSSL/DSA.pm", {st_mode=S_IFREG|0644, st_size=5077, ...}) = 0
09:01:57.202875 open("/usr/lib/perl5/Crypt/OpenSSL/DSA.pm", O_RDONLY) = 15
09:01:57.202928 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.202975 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.203036 read(15, "package Crypt::OpenSSL::DSA;\n\nuse strict;\nuse warnings;\n\nrequire DynaLoader;\n\nuse vars qw(@ISA $VERSION);\n@ISA = qw(DynaLoader);\n$VERSION = '0.13';\n\nbootstrap Crypt::OpenSSL::DSA $VERSION;\n\nsub read_pub_key_str {\n  my ($class, $key_str) = @_;\n  $class->_load_key(0, $key_str);\n}\n\nsub read_priv_key_str {\n  my ($class, $key_str) = @_;\n  $class->_load_key(1, $key_str);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nCrypt::OpenSSL::DSA - Digital Signature Algorithm using OpenSSL\n\n=head1 SYNOPSIS\n\n  use Crypt::OpenSSL::DSA;\n\n  # generate keys and write out to PEM files\n  my $dsa = Crypt::OpenSSL::DSA->generate_parameters( 512 );\n  $dsa->generate_key;\n  $dsa->write_pub_key( $filename );\n  $dsa->write_priv_key( $filename );\n\n  # using keys from PEM files\n  my $dsa_priv = Crypt::OpenSSL::DSA->read_priv_key( $filename );\n  my $sig      = $dsa_priv->sign($message);\n  my $dsa_pub  = Crypt::OpenSSL::DSA->read_pub_key( $filename );\n  my $valid    = $dsa_pub->verify($message, $sig);\n\n  # using keys from PEM strings\n  my $dsa_priv = Crypt::OpenSSL::DSA->read_priv_key_str( $key_string );\n  my $sig      = $dsa_priv->sign($message);\n  my $dsa_pub  = Crypt::OpenSSL::DSA->read_pub_key_str( $key_string );\n  my $valid    = $dsa_pub->verify($message, $sig);\n\n=head1 DESCRIPTION\n\nCrypt::OpenSSL::DSA implements the DSA\n(Digital Signature Algorithm) signature verification system.\n\nIt is a thin XS wrapper to the DSA functions contained in the \nOpenSSL crypto library, located at http://www.openssl.org\n\n=head1 CLASS METHODS\n\n=over 4\n\n=item $dsa = Crypt::OpenSSL::DSA->generate_parameters( $bits, $seed );\n\nReturns a new DSA object and generates the p, q and g\nparameters necessary to generate keys.\n\nbits is the length of the prime to be generated; the DSS allows a maximum of 1024 bits.\n\n=item $dsa = Crypt::OpenSSL::DSA->read_params( $filename );\n\nReads in a parameter PEM file and returns a new DSA object with the p, q and g\nparameters necessary to generate keys.\n\n=item $dsa = Crypt::OpenSSL::DSA->read_pub_key( $filename );\n\nReads in a public key PEM file and returns a new DSA object that can be used\nto verify DSA signatures.\n\n=item $dsa = Crypt::OpenSSL::DSA->read_priv_key( $filename );\n\nReads in a private key PEM file and returns a new DSA object that can be used\nto sign messages.\n\n=item $dsa = Crypt::OpenSSL::DSA->read_pub_key_str( $key_string );\n\nReads in a public key PEM string and returns a new DSA object that can be used\nto verify DSA signatures.\nThe string should include the -----BEGIN...----- and -----END...----- lines.\n\n=item $dsa = Crypt::OpenSSL::DSA->read_priv_key_str( $key_string );\n\nReads in a private key PEM string and returns a new DSA object that can be used\nto sign messages.\nThe string should include the -----BEGIN...----- and -----END...----- lines.\n\n=back\n\n=head1 OBJECT METHODS\n\n=over 4\n\n=item $dsa->generate_key;\n\nGenerates private and public keys, assuming that $dsa is the return\nvalue of generate_parameters.\n\n=item $sig = $dsa->sign( $message );\n\nSigns $message, returning the signature.  Note that $meesage cannot exceed\n20 characters in length.\n\n$dsa is the signer's private key.\n\n=item $sig_obj = $dsa->do_sign( $message );\n\nSimilar to C<sign>, but returns a L<Crypt::OpenSSL::DSA::Signature> object.\n\n=item $valid = $dsa->verify( $message, $sig );\n\nVerifies that the $sig signature for $message is valid.\n\n$dsa is the signer's public key.\n\nNote it croaks if the underlying library call returns error (-1).\n\n=item $valid = $dsa->do_verify( $message, $sig_obj );\n\nSimilar to C<verify>, but uses a L<Crypt::OpenSSL::DSA::Signature> object.\n\nNote it croaks if the underlying library call returns error (-1).\n\n=item $dsa->write_params( $filename );\n\nWrites the parameters into a PEM file.\n\n=item $dsa->write_pub_key( $filename );\n\nWrites the public key into a PEM file.\n\n=item $dsa->write_priv_key( $filename );\n\nWrites the private key into a PEM file.\n\n=item $p = $dsa->get_p, $dsa->set_p($p)\n\nGets/sets the prime number in binary format.\n\n=item $q = $dsa->get_q, $dsa->set_q($q)\n\nGets/sets the subprime number (q | p-1) in binary format.\n\n=item $g = $dsa->get_g, $dsa->set_g($g)\n\nGets/sets the generator of subgroup in binary format.\n\n=item $pub_key = $dsa->get_pub_key, $dsa->set_pub_key($pub_key)\n\nGets/sets the public key (y = g^x) in binary format.\n\n=item $priv_key = $dsa->get_priv_key, $dsa->set_priv_key($priv_key)\n\nGets/sets the private key in binary format.\n\n=back\n\n=head1 NOTES\n\nL<Crpyt::DSA> is a more mature Perl DSA module, but can be difficult to\ninstall, because of the L<Math::Pari> requirement.\n\nComments, suggestions, and patches welcome.\n\n=head1 AUTHOR\n\nT.J. Mather, E<lt>tjmather@maxmind.comE<gt>\n\n=head1 COPYRIGHT\n\nCopyright (c) 2002 T.J. Mather.  Crypt::OpenSSL::DSA is free software;\nyou may redistribute it and/or modify it under the same terms as Perl itself. \n\nPaid support is available from directly from the author of this package.\nPlease see L<http://www.maxmind.com/app/opensourceservices> for more details.\n\n=head1 SEE ALSO\n\nL<Crypt::OpenSSL::DSA::Signature>\n\nL<Crypt::DSA>, L<Crypt::OpenSSL::RSA>\n\nL<Net::DNS::SEC>\n\n=cut\n", 8192) = 5077
09:01:57.203413 lseek(15, 382, SEEK_SET) = 382
09:01:57.203460 lseek(15, 0, SEEK_CUR)  = 382
09:01:57.203504 close(15)               = 0
09:01:57.203579 stat("modules/auto/Crypt/OpenSSL/DSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.203633 stat("modules/auto/Crypt/OpenSSL/DSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.203685 stat("/etc/perl/auto/Crypt/OpenSSL/DSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.203737 stat("/usr/local/lib/perl/5.14.2/auto/Crypt/OpenSSL/DSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.203791 stat("/usr/local/share/perl/5.14.2/auto/Crypt/OpenSSL/DSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.203850 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/DSA", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.203913 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/DSA/DSA.so", {st_mode=S_IFREG|0644, st_size=39152, ...}) = 0
09:01:57.203994 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/DSA/DSA.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.204067 open("/usr/lib/perl5/auto/Crypt/OpenSSL/DSA/DSA.so", O_RDONLY) = 15
09:01:57.204121 read(15, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\"\0\0\0\0\0\0@\0\0\0\0\0\0\0p\222\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\206\0\0\0\0\0\0\f\206\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\10\215\0\0\0\0\0\0\10\215 \0\0\0\0\0\10\215 \0\0\0\0\0\230\4\0\0\0\0\0\0\250\4\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0000\215\0\0\0\0\0\0000\215 \0\0\0\0\0000\215 \0\0\0\0\0\240\1\0\0\0\0\0\0\240\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\350}\0\0\0\0\0\0\350}\0\0\0\0\0\0\350}\0\0\0\0\0\0\24\1\0\0\0\0\0\0\24\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\10\215\0\0\0\0\0\0\10\215 \0\0\0\0\0\10\215 \0\0\0\0\0\370\2\0\0\0\0\0\0\370\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\235\212\20_\362\257\362G\324\256\16\223R\322\344\2505\361v\7\0\0\0\0C\0\0\0]\0\0\0F\0\0\0000\0\0\0G\0\0\0006\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0+\0\0\0,\0\0\0\0\0\0\0W\0\0\0\0\0\0\0!\0\0\0P\0\0\0\0\0\0\0T\0\0\0002\0\0\0\37\0\0\0\22\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\27\0\0\0X\0\0\0Q\0\0\0<\0\0\0\\\0\0\0\0\0\0\0O\0\0\0L\0\0\0\36\0\0\0E\0\0\0S\0\0\0\24\0\0\0\0\0\0\0\v\0\0\0\33\0\0\0>\0\0\0H\0\0\0?\0\0\0U\0\0\0\34\0\0\0\0\0\0\0'\0\0\0\0\0\0\0M\0\0\0C\0\0\0@\0\0\0\20\0\0\0K\0\0\0001\0\0\0A\0\0\0009\0\0\0&\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\10\0\0\0.\0\0\0/\0\0\0003\0\0\0\31\0\0\0D\0\0\0\"\0\0\0-\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0Y\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.204260 fstat(15, {st_mode=S_IFREG|0644, st_size=39152, ...}) = 0
09:01:57.204317 mmap(NULL, 2134448, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 15, 0) = 0x7f74333ed000
09:01:57.204366 mprotect(0x7f74333f6000, 2093056, PROT_NONE) = 0
09:01:57.204414 mmap(0x7f74335f5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 15, 0x8000) = 0x7f74335f5000
09:01:57.204472 close(15)               = 0
09:01:57.204538 mprotect(0x7f74335f5000, 4096, PROT_READ) = 0
09:01:57.204637 brk(0x111e000)          = 0x111e000
09:01:57.204760 stat("modules/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.204811 stat("modules/Crypt/OpenSSL/RSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.204861 stat("modules/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.204909 stat("modules/Crypt/OpenSSL/RSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.204959 stat("/etc/perl/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.205009 stat("/etc/perl/Crypt/OpenSSL/RSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.205060 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.205111 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/RSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.205166 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.205217 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/RSA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.205268 stat("/usr/lib/perl5/Crypt/OpenSSL/RSA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.205320 stat("/usr/lib/perl5/Crypt/OpenSSL/RSA.pm", {st_mode=S_IFREG|0644, st_size=8427, ...}) = 0
09:01:57.205378 open("/usr/lib/perl5/Crypt/OpenSSL/RSA.pm", O_RDONLY) = 15
09:01:57.205432 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.205478 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.205537 read(15, "package Crypt::OpenSSL::RSA;\n\nuse strict;\nuse Carp;\n\nuse vars qw ($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);\n\nrequire DynaLoader;\nuse AutoLoader 'AUTOLOAD';\n\n@ISA = qw(DynaLoader);\n\n$VERSION = '0.28';\n\nbootstrap Crypt::OpenSSL::RSA $VERSION;\n\nBEGIN { eval { require Crypt::OpenSSL::Bignum; }; }\n\n1;\n\n__END__\n\n=head1 NAME\n\nCrypt::OpenSSL::RSA - RSA encoding and decoding, using the openSSL libraries\n\n=head1 SYNOPSIS\n\n  use Crypt::OpenSSL::Random;\n  use Crypt::OpenSSL::RSA;\n\n  # not necessary if we have /dev/random:\n  Crypt::OpenSSL::Random::random_seed($good_entropy);\n  Crypt::OpenSSL::RSA->import_random_seed();\n  $rsa_pub = Crypt::OpenSSL::RSA->new_public_key($key_string);\n  $rsa_pub->use_sslv23_padding(); # use_pkcs1_oaep_padding is the default\n  $ciphertext = $rsa->encrypt($plaintext);\n\n  $rsa_priv = Crypt::OpenSSL::RSA->new_private_key($key_string);\n  $plaintext = $rsa->encrypt($ciphertext);\n\n  $rsa = Crypt::OpenSSL::RSA->generate_key(1024); # or\n  $rsa = Crypt::OpenSSL::RSA->generate_key(1024, $prime);\n\n  print \"private key is:\\n\", $rsa->get_private_key_string();\n  print \"public key (in PKCS1 format) is:\\n\",\n        $rsa->get_public_key_string();\n  print \"public key (in X509 format) is:\\n\",\n        $rsa->get_public_key_x509_string();\n\n  $rsa_priv->use_md5_hash(); # use_sha1_hash is the default\n  $signature = $rsa_priv->sign($plaintext);\n  print \"Signed correctly\\n\" if ($rsa->verify($plaintext, $signature));\n\n=head1 DESCRIPTION\n\nCrypt::OpenSSL::RSA provides the ability to RSA encrypt strings which are\nsomewhat shorter than the block size of a key.  It also allows for decryption,\nsignatures and signature verification.\n\nI<NOTE>: Many of the methods in this package can croak, so use eval, or\nError.pm's try/catch mechanism to capture errors.  Also, while some\nmethods from earlier versions of this package return true on success,\nthis (never documented) behavior is no longer the case.\n\n=head1 Class Methods\n\n=over\n\n=item new_public_key\n\nCreate a new Crypt::OpenSSL::RSA object by loading a public key in\nfrom a string containing Base64/DER-encoding of either the PKCS1 or\nX.509 representation of the key.  The string should include the\n-----BEGIN...----- and -----END...----- lines.\n\nThe padding is set to PKCS1_OAEP, but can be changed with the\nuse_xxx_padding methods\n\n=cut\n\nsub new_public_key\n{\n    my ($proto, $p_key_string) = @_;\n    if ($p_key_string =~ /^-----BEGIN RSA PUBLIC KEY-----/)\n    {\n        return $proto->_new_public_key_pkcs1($p_key_string);\n    }\n    elsif ($p_key_string =~ /^-----BEGIN PUBLIC KEY-----/)\n    {\n        return $proto->_new_public_key_x509($p_key_string);\n    }\n    else\n    {\n        croak \"unrecognized key format\";\n    }\n}\n\n=item new_private_key\n\nCreate a new Crypt::OpenSSL::RSA object by loading a private key in\nfrom an string containing the Base64/DER encoding of the PKCS1\nrepresentation of the key.  The string should include the\n-----BEGIN...----- and -----END...----- lines.  The padding is set to\nPKCS1_OAEP, but can be changed with use_xxx_padding.\n\n=item generate_key\n\nCreate a new Crypt::OpenSSL::RSA object by constructing a\nprivate/public key pair.  The first (mandetory) argument is the key\nsize, while the second optional argument specifies the public exponent\n(the default public exponent is 65537).  The padding is set to\nPKCS1_OAEP, but can be changed with use_xxx_padding methods.\n\n=item new_key_from_parameters\n\nGiven Crypt::OpenSSL::Bignum objects for n, e, and optionally d, p,\nand q, where p and q are the prime factors of n, e is the public\nexponent and d is the private exponent, create a new\nCrypt::OpenSSL::RSA object using these values.  If p and q are\nprovided and d is undef, d is computed.  Note that while p and q are\nnot necessary for a private key, their presence will speed up\ncomputation.\n\n=cut\n\nsub new_key_from_parameters\n{\n    my($proto, $n, $e, $d, $p, $q) = @_;\n    return $proto->_new_key_from_parameters\n        (map { $_ ? $_->pointer_copy() : 0 } $n, $e, $d, $p, $q);\n}\n\n=item import_random_seed\n\nImport a random seed from Crypt::OpenSSL::Random, since the OpenSSL\nlibraries won't allow sharing of random structures across perl XS\nmodules.\n\n=cut\n\nsub import_random_seed\n{\n    until (_random_status())\n    {\n        _random_seed(Crypt::OpenSSL::Random::random_bytes(20));\n    }\n}\n\n=back\n\n=head1 Instance Methods\n\n=over\n\n=item DESTROY\n\nClean up after ourselves.  In particular, erase and free the memory\noccupied by the RSA key structure.\n\n=item get_public_key_string\n\nReturn the Base64/DER-encoded PKCS1 representation of the public\nkey.  This string has\nheader and footer lines:\n\n  -----BEGIN RSA PUBLIC KEY------\n  -----END RSA PUBLIC KEY------\n\n=item get_public_key_x509_string\n\nReturn the Base64/DER-encoded representation of the \"subject\npublic key\", suitable for use in X509 certificates.  This string has\nheader and footer lines:\n\n  -----BEGIN PUBLIC KEY------\n  -----END PUBLIC KEY------\n\nand is the format that is produced by running C<openssl rsa -pubout>.\n\n=item get_private_key_string\n\nReturn the DER-encoded PKCS1 representation of the private key.\n\n=item encrypt\n\nEncrypt a binary \"string\" using the public (portion of the) key.\n\n=item decrypt\n\nDecrypt a binary \"string\".  Croaks if the key is public only.\n\n=item private_encrypt\n\nEncrypt a binary \"string\" using the private key.  Croaks if the key is\npublic only.\n\n=item public_decrypt\n\nDecrypt a binary \"string\" using the public (portion of the) key.\n\n=item sign\n\nSign a string using the secret (portion of the) key.\n\n=item verify\n\nCheck the signature on a text.\n\n=item use_no_padding\n\nUse raw RSA encryption. This mode should only be used to implement\ncryptographically sound padding modes in the application code.\nEncrypting user data directly with RSA is insecure.\n\n=item use_pkcs1_padding\n\nUse PKCS #1 v1.5 padding. This currently is the most widely used mode\nof padding.\n\n=item use_pkcs1_oaep_padding\n\nUse EME-OAEP padding as defined in PKCS #1 v2.0 with SHA-1, MGF1 and\nan empty encoding parameter. This mode of padding is recommended for\nall new applications.  It is the default mode used by\nCrypt::OpenSSL::RSA.\n\n=item use_sslv23_padding\n\nUse PKCS #1 v1.5 padding with an SSL-specific modification that\ndenotes that the server is SSL3 capable.\n\n=item use_md5_hash\n\nUse the RFC 1321 MD5 hashing algorithm by Ron Rivest when signing and\nverifying messages.\n\n=item use_sha1_hash\n\nUse the RFC 3174 Secure Hashing Algorithm (FIPS 180-1) when signing\nand verifying messages. This is the default.\n\n=item use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash\n\nThese FIPS 180-2 hash algorithms, for use when signing and verifying\nmessages, are only available with newer openssl versions (>= 0.9.8).\n\n=item use_ripemd160_hash\n\nDobbertin, Bosselaers and Preneel's RIPEMD hashing algorithm when\nsigning and verifying messages.\n\n=item size\n\nReturns the size, in bytes, of the key.  All encrypted text will be of\nthis size, and depending on the padding mode used, the length of\nthe text to be encrypted should be:\n\n=over\n\n=item pkcs1_oaep_padding\n\nat most 42 bytes less than this size.\n\n=item pkcs1_padding or sslv23_padding\n\nat most 11 bytes less than this size.\n\n=item no_padding\n\nexactly this size.\n\n=back\n\n=item check_key\n\nThis function validates the RSA key, returning a true value if the key\nis valid, and a false value otherwise.  Croaks if the key is public only.\n\n=item get_key_parameters\n\nReturn Crypt::OpenSSL::Bignum objects representing the values of n, e,\nd, p, q, d mod (p-1), d mod (q-1), and 1/q mod p, where p and q are\nthe prime factors of n, e is the public exponent and d is the private\nexponent.  Some of these values may return as undef; only n and e will\nbe defined for a public key.  The Crypt::OpenSSL::Bignum module must\nbe installed for this to work.\n\n=item is_private\n\nReturn true if this is a private key, and false if it is private only.\n\n=cut\n\nsub get_key_parameters\n{\n    return map { $_ ? Crypt::OpenSSL::Bignum->bless_pointer($_) : undef }\n        shift->_get_key_parameters();\n}\n\n=back\n\n=head1 BUGS\n\nThere is a small memory leak when generating new keys of more than 512 bits.\n\n=head1 AUTHOR\n\nIan Robertson, iroberts@cpan.org.  For support, please email\nperl-openssl-us", 8192) = 8192
09:01:57.206073 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA/autosplit.ix", {st_mode=S_IFREG|0644, st_size=230, ...}) = 0
09:01:57.206141 open("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA/autosplit.ix", O_RDONLY) = 16
09:01:57.206206 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123382b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.206253 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.206315 read(16, "# Index created by AutoSplit for blib/lib/Crypt/OpenSSL/RSA.pm\n#    (file acts as timestamp)\npackage Crypt::OpenSSL::RSA;\nsub new_public_key \n;\nsub new_key_from_parameters \n;\nsub import_random_seed \n;\nsub get_key_parameters \n;\n1;\n", 8192) = 230
09:01:57.206406 read(16, "", 8192)      = 0
09:01:57.206453 close(16)               = 0
09:01:57.206541 stat("modules/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.206592 stat("modules/Crypt/OpenSSL/Bignum.pm", 0x7ffe12338570) = -1 ENOENT (No such file or directory)
09:01:57.206641 stat("modules/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.206690 stat("modules/Crypt/OpenSSL/Bignum.pm", 0x7ffe12338570) = -1 ENOENT (No such file or directory)
09:01:57.206739 stat("/etc/perl/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.206788 stat("/etc/perl/Crypt/OpenSSL/Bignum.pm", 0x7ffe12338570) = -1 ENOENT (No such file or directory)
09:01:57.206838 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.206888 stat("/usr/local/lib/perl/5.14.2/Crypt/OpenSSL/Bignum.pm", 0x7ffe12338570) = -1 ENOENT (No such file or directory)
09:01:57.206938 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.206988 stat("/usr/local/share/perl/5.14.2/Crypt/OpenSSL/Bignum.pm", 0x7ffe12338570) = -1 ENOENT (No such file or directory)
09:01:57.207038 stat("/usr/lib/perl5/Crypt/OpenSSL/Bignum.pmc", 0x7ffe12338620) = -1 ENOENT (No such file or directory)
09:01:57.207089 stat("/usr/lib/perl5/Crypt/OpenSSL/Bignum.pm", {st_mode=S_IFREG|0644, st_size=6475, ...}) = 0
09:01:57.207149 open("/usr/lib/perl5/Crypt/OpenSSL/Bignum.pm", O_RDONLY) = 16
09:01:57.207201 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338300) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.207247 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.207300 read(16, "package Crypt::OpenSSL::Bignum;\n\nuse 5.005;\nuse strict;\nuse Carp;\n\nuse vars qw( $VERSION @ISA );\n\nrequire DynaLoader;\n\n@ISA = qw(DynaLoader);\n\n$VERSION = '0.04';\n\nbootstrap Crypt::OpenSSL::Bignum $VERSION;\n\nsub DESTROY\n{\n    shift->_free_BN();\n}\n\nsub bless_pointer\n{\n    my( $proto, $p_pointer ) = @_;\n    return bless( \\$p_pointer, $proto );\n}\n\nsub equals\n{\n    my( $self, $a ) = @_;\n    return ! $self->cmp( $a );\n}\n\n\n1;\n__END__\n\n=head1 NAME\n\nCrypt::OpenSSL::Bignum - OpenSSL's multiprecision integer arithmetic\n\n=head1 SYNOPSIS\n\n  use Crypt::OpenSSL::Bignum;\n\n  my $bn = Crypt::OpenSSL::Bignum->new_from_decimal( \"1000\" );\n  # or\n  my $bn = Crypt::OpenSSL::Bignum->new_from_word( 1000 );\n  # or\n  my $bn = Crypt::OpenSSL::Bignum->new_from_hex(\"0x3e8\");\n  # or\n  my $bn = Crypt::OpenSSL::Bignum->new_from_bin(pack( \"C*\", 3, 232 ))\n\n  use Crypt::OpenSSL::Bignum::CTX;\n\n  sub print_factorial\n  {\n    my( $n ) = @_;\n    my $fac = Crypt::OpenSSL::Bignum->one();\n    my $ctx = Crypt::OpenSSL::Bignum::CTX->new();\n    foreach my $i (1 .. $n)\n    {\n      $fac->mul( Crypt::OpenSSL::Bignum->new_from_word( $i ), $ctx, $fac );\n    }\n    print \"$n factorial is \", $fac->to_decimal(), \"\\n\";\n  }\n\n=head1 DESCRIPTION\n\nCrypt::OpenSSL::Bignum provides access to OpenSSL multiprecision\ninteger arithmetic libraries.  Presently, many though not all of the\narithmetic operations that OpenSSL provides are exposed to perl.  In\naddition, this module can be used to provide access to bignum values\nproduced by other OpenSSL modules, such as key parameters from\nCrypt::OpenSSL::RSA.\n\nI<NOTE>: Many of the methods in this package can croak, so use eval, or\nError.pm's try/catch mechanism to capture errors.\n\n=head1 Class Methods\n\n=over\n\n=item new_from_word\n\nCreate a new Crypt::OpenSSL::Bignum object whose value will be the\nword given.  Note that numbers represneted by objects created using\nthis method are necessarily between 0 and 2^32 - 1.\n\n=item new_from_decimal\n\nCreate a new Crypt::OpenSSL::Bignum object whose value is specified by\nthe given decimal representation.\n\n=item new_from_hex\n\nCreate a new Crypt::OpenSSL::Bignum object whose value is specified by\nthe given hexidecimal representation.\n\n=item new_from_bin\n\nCreate a new Crypt::OpenSSL::Bignum object whose value is specified by\nthe given packed binary string.  Note that objects created using this\nmethod are necessarily nonnegative.\n\n=item zero\n\nReturns a new Crypt::OpenSSL::Bignum object representing 0\n\n=item one\n\nReturns a new Crypt::OpenSSL::Bignum object representing 1\n\n=item bless_pointer\n\nGiven a pointer to a OpenSSL BIGNUM object in memory, construct and\nreturn Crypt::OpenSSL::Bignum object around this.  Note that the\nunderlying BIGNUM object will be destroyed (via BN_clear_free(3ssl))\nwhen the returned Crypt::OpenSSL::Bignum object is no longer\nreferenced, so the pointer passed to this method should only be\nreferenced via the returned perl object after calling bless_pointer.\n\nThis method is intended only for use by XSUB writers writing code that\ninterfaces with OpenSSL library methods, and who wish to be able to\nreturn a BIGNUM structure to perl as a Crypt::OpenSSL::Bignum object.\n\n=back\n\n=head1 Instance Methods\n\n=over\n\n=item to_decimal\n\nReturn a decimal string representation of this object.\n\n=item to_hex\n\nReturn a hexidecimal string representation of this object.\n\n=item to_bin\n\nReturn a packed binary string representation of this object.  Note\nthat sign is ignored, so that to bin called on a\nCrypt::OpenSSL::Bignum object representing a negative number returns\nthe same value as it would called on an object representing that\nnumber's absolute value.\n\n=item get_word\n\nReturn a scalar integer representation of this object, if it can be\nrepresented as an unsigned long.\n\n=item is_zero\n\nReturns true of this object represents 0.\n\n=item is_one\n\nReturns true of this object represents 1.\n\n=item is_odd\n\nReturns true of this object represents an odd number.\n\n=item copy\n\nReturns a copy of this object.\n\n=item add\n\nThis method returns the sum of this object and the first argument.  If\nonly one argument is passed, a new Crypt::OpenSSL::Bignum object is\ncreated for the return value; otherwise, the value of second argument\nis set to the result and returned.\n\n=item sub\n\nThis method returns the difference of this object and the first\nargument.  If only one argument is passed, a new\nCrypt::OpenSSL::Bignum object is created for the return value;\notherwise, the value of second argument is set to the result and\nreturned.\n\n=item mul\n\nThis method returns the product of this object and the first argument,\nusing the second argument, a Crypt::OpenSSL::Bignum::CTX object, as a\nscratchpad.  If only two arguments are passed, a new\nCrypt::OpenSSL::Bignum object is created for the return value;\notherwise, the value of third argument is set to the result and\nreturned.\n\n=item div\n\nThis method returns a list consisting of quotient and the remainder\nobtained by dividing this object by the first argument, using the\nsecond argument, a Crypt::OpenSSL::Bignum::CTX object, as a\nscratchpad.  If only two arguments are passed, new\nCrypt::OpenSSL::Bignum objects is created for both return values.  If\na third argument is passed, otherwise, the value of third argument is\nset to the quotient.  If a fourth argument is passed, the value of the\nfourth argument is set to the remainder.\n\n=item exp\n\nThis method returns the product of this object exponeniated by the\nfirst argument, using the second argument, a\nCrypt::OpenSSL::Bignum::CTX object, as a scratchpad.\n\n=item mod_exp\n\nThis method returns the product of this object exponeniated by the\nfirst argument, modulo the second argument, using the third argument, a\nCrypt::OpenSSL::Bignum::CTX object, as a scratchpad.\n\n=item pointer_copy\n\nThis method is intended only for use by XSUB writers wanting to have\naccess to the underlying BIGNUM structure referenced by a\nCrypt::OpenSSL::Bignum perl object so that they can pass them to other\nroutines in the OpenSSL library.  It returns a perl scalar whose IV\ncan be cast to a BIGNUM* value.  This can then be passed to an XSUB\nwhich can work with the BIGNUM directly.  Note that the BIGNUM object\npointed to will be a copy of the BIGNUM object wrapped by the\ninstance; it is thus the responsiblity of the client to free space\nallocated by this BIGNUM object if and when it is done with it. See\nalso bless_pointer.\n\n=back\n\n=head1 AUTHOR\n\nIan Robertson, iroberts@cpan.org\n\n=head1 SEE ALSO\n\nL<perl>, L<bn(3ssl)>\n\n=cut\n", 8192) = 6475
09:01:57.207807 lseek(16, 431, SEEK_SET) = 431
09:01:57.207859 lseek(16, 0, SEEK_CUR)  = 431
09:01:57.207905 close(16)               = 0
09:01:57.207991 stat("modules/auto/Crypt/OpenSSL/Bignum", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.208046 stat("modules/auto/Crypt/OpenSSL/Bignum", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.208098 stat("/etc/perl/auto/Crypt/OpenSSL/Bignum", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.208150 stat("/usr/local/lib/perl/5.14.2/auto/Crypt/OpenSSL/Bignum", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.208204 stat("/usr/local/share/perl/5.14.2/auto/Crypt/OpenSSL/Bignum", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.208257 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/Bignum", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.208317 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/Bignum/Bignum.so", {st_mode=S_IFREG|0644, st_size=39208, ...}) = 0
09:01:57.208396 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/Bignum/Bignum.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.208467 open("/usr/lib/perl5/auto/Crypt/OpenSSL/Bignum/Bignum.so", O_RDONLY) = 16
09:01:57.208521 read(16, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20%\0\0\0\0\0\0@\0\0\0\0\0\0\0\250\222\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\201\0\0\0\0\0\0\\\201\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\320\214\0\0\0\0\0\0\320\214 \0\0\0\0\0\320\214 \0\0\0\0\0\370\4\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\350\214\0\0\0\0\0\0\350\214 \0\0\0\0\0\350\214 \0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\310w\0\0\0\0\0\0\310w\0\0\0\0\0\0\310w\0\0\0\0\0\0\34\1\0\0\0\0\0\0\34\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\320\214\0\0\0\0\0\0\320\214 \0\0\0\0\0\320\214 \0\0\0\0\0000\3\0\0\0\0\0\0000\3\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\315\f{\203\336\213\n\6\2371\2642\327\20\212\307g\274\0272\0\0\0\0a\0\0\0c\0\0\0^\0\0\0C\0\0\0\33\0\0\0Y\0\0\0\0\0\0\0004\0\0\0F\0\0\0S\0\0\0N\0\0\0\30\0\0\0.\0\0\0\0\0\0\0003\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\24\0\0\0\0\0\0\0\\\0\0\0@\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\0\0X\0\0\0002\0\0\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0:\0\0\0M\0\0\0\0\0\0\0a\0\0\0\0\0\0\0<\0\0\0\0\0\0\0\17\0\0\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\0\0\0\"\0\0\0;\0\0\0\0\0\0\0?\0\0\0U\0\0\0P\0\0\0T\0\0\0\0\0\0\0B\0\0\0A\0\0\0 \0\0\0\5\0\0\0+\0\0\0009\0\0\0\r\0\0\0\0\0\0\0000\0\0\0`\0\0\0006\0\0\0Z\0\0\0/\0\0\0\0\0\0\0\0\0\0\0I\0\0\0J\0\0\0\0\0\0\0005\0\0\0\4\0\0\0\22\0\0\0G\0\0\0\32\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.208655 fstat(16, {st_mode=S_IFREG|0644, st_size=39208, ...}) = 0
09:01:57.208711 mmap(NULL, 2134480, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 16, 0) = 0x7f74331e3000
09:01:57.208760 mprotect(0x7f74331ec000, 2093056, PROT_NONE) = 0
09:01:57.208810 mmap(0x7f74333eb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 16, 0x8000) = 0x7f74333eb000
09:01:57.208873 close(16)               = 0
09:01:57.208940 mprotect(0x7f74333eb000, 4096, PROT_READ) = 0
09:01:57.209088 lseek(15, 310, SEEK_SET) = 310
09:01:57.209137 lseek(15, 0, SEEK_CUR)  = 310
09:01:57.209182 close(15)               = 0
09:01:57.209251 stat("modules/auto/Crypt/OpenSSL/RSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.209305 stat("modules/auto/Crypt/OpenSSL/RSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.209356 stat("/etc/perl/auto/Crypt/OpenSSL/RSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.209408 stat("/usr/local/lib/perl/5.14.2/auto/Crypt/OpenSSL/RSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.209461 stat("/usr/local/share/perl/5.14.2/auto/Crypt/OpenSSL/RSA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.209514 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.209573 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA/RSA.so", {st_mode=S_IFREG|0644, st_size=38272, ...}) = 0
09:01:57.209654 stat("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA/RSA.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.209725 open("/usr/lib/perl5/auto/Crypt/OpenSSL/RSA/RSA.so", O_RDONLY) = 15
09:01:57.209778 read(15, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300,\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\217\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\244\210\0\0\0\0\0\0\244\210\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\250\210\0\0\0\0\0\0\250\210 \0\0\0\0\0\250\210 \0\0\0\0\0\210\5\0\0\0\0\0\0\230\5\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320\210\0\0\0\0\0\0\320\210 \0\0\0\0\0\320\210 \0\0\0\0\0\240\1\0\0\0\0\0\0\240\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\310|\0\0\0\0\0\0\310|\0\0\0\0\0\0\310|\0\0\0\0\0\0d\1\0\0\0\0\0\0d\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\236\212\354F\221\2726\224\27\322\230\350J(\310\376\35\334@k\0\0\0\0a\0\0\0{\0\0\0\0\0\0\0\0\0\0\0u\0\0\0v\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\36\0\0\0y\0\0\0\34\0\0\0;\0\0\0\0\0\0\0.\0\0\0002\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\0\0\0-\0\0\0n\0\0\0\23\0\0\0\0\0\0\0:\0\0\0\27\0\0\0h\0\0\0?\0\0\0W\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\10\0\0\0H\0\0\0<\0\0\0L\0\0\0x\0\0\0a\0\0\0K\0\0\0#\0\0\0\"\0\0\0F\0\0\0+\0\0\0Z\0\0\0\0\0\0\0005\0\0\0*\0\0\0I\0\0\0\0\0\0\0\0\0\0\0%\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0w\0\0\0&\0\0\0D\0\0\0T\0\0\0E\0\0\0!\0\0\0U\0\0\0>\0\0\0p\0\0\0\0\0\0\0007\0\0\0z\0\0\0$\0\0\0m\0\0\0P\0\0\0\0\0\0\0\0\0\0\0A\0\0\0e\0\0\0\30\0\0\0008\0\0\0 \0\0\0009\0\0\0\0\0\0\0O\0\0\0\0\0\0\0000\0\0\0G\0\0\0\0\0\0\0\26\0\0\0\0\0\0\0006\0\0\0\0\0\0\0g\0\0\0\0\0\0\0C\0\0\0\0\0\0\0N\0\0\0J\0\0\0\20\0\0\0", 832) = 832
09:01:57.209911 fstat(15, {st_mode=S_IFREG|0644, st_size=38272, ...}) = 0
09:01:57.209983 mmap(NULL, 2133568, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 15, 0) = 0x7f7432fda000
09:01:57.210040 mprotect(0x7f7432fe3000, 2093056, PROT_NONE) = 0
09:01:57.210095 mmap(0x7f74331e2000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 15, 0x8000) = 0x7f74331e2000
09:01:57.210150 close(15)               = 0
09:01:57.210337 stat("modules/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210389 stat("modules/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210440 stat("modules/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210489 stat("modules/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210539 stat("/etc/perl/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210589 stat("/etc/perl/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210646 stat("/usr/local/lib/perl/5.14.2/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210698 stat("/usr/local/lib/perl/5.14.2/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210750 stat("/usr/local/share/perl/5.14.2/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210800 stat("/usr/local/share/perl/5.14.2/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210851 stat("/usr/lib/perl5/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.210902 stat("/usr/lib/perl5/Net/DNS/SEC/Private.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.210953 stat("/usr/share/perl5/Net/DNS/SEC/Private.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.211005 stat("/usr/share/perl5/Net/DNS/SEC/Private.pm", {st_mode=S_IFREG|0644, st_size=14088, ...}) = 0
09:01:57.211064 open("/usr/share/perl5/Net/DNS/SEC/Private.pm", O_RDONLY) = 15
09:01:57.211118 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.211164 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.211224 read(15, "package Net::DNS::SEC::Private;\n\nuse vars qw(@ISA $VERSION @EXPORT );\n\nuse Net::DNS;\nuse Carp;\n\nuse bytes;\n\nuse Crypt::OpenSSL::DSA;\nuse Crypt::OpenSSL::RSA;\nuse Crypt::OpenSSL::Bignum;\n\nuse File::Basename;\nuse MIME::Base64;\nuse Math::BigInt;\nuse Time::Local;\n\n\nrequire Exporter;\n\n$VERSION = do { my @r=(q$Revision: 816 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class,  $key_file) = @_;\n    my $self={};\n    my    ($Modulus,$PublicExponent,$PrivateExponent,$Prime1,\n\t   $Prime2,$Exponent1,$Exponent2,$Coefficient,\n\t   $prime_p,$subprime_q,$base_g,$private_val_x,$public_val_y);\n    \n\n    bless ($self,$class);\n    my $keyname=basename($key_file);\n    print \"\\nKeyname:\\t \". $keyname .\"\\n\" if $ debug;\n\n    #Format something like: /Kbla.foo.+001+60114.private'\n    # assuming proper file name.\n    # We determine the algorithm from the filename.\n    if ($keyname =~ /K(.*)\\.\\+(\\d{3})\\+(\\d*)\\.private/){\n\t$self->{\"signame\"}=$1.\".\";\n\t$self->{\"algorithm\"}= 0 + $2; #  Force non-string \n\t$self->{\"keytag\"}=$3;\n    }else{\n\tcroak \"$keyname does not seem to be a valid private key\\n\";\n    }\n\n\n\n    open (KEYFH, \"<$key_file\" ) || croak \"Cannot open keyfile: $key_file\";\n    \n    \n    while (<KEYFH>) {\n\tif (/Private-key-format: (v\\d*\\.\\d*)/) {\n\t    if ($1 ne \"v1.2\") {\n\t\tcroak \"Private Key Format not regognized\";\n\t    }\n\t}elsif\t    (/^Algorithm:\\s*(\\d*)/) {\n\t    if ($1 != 1 && $1 != 3 && $1 != 5 && $1 !=6 && $1 != 7 && $1 != 8 && $1 != 10 ) {\n\t\tcroak \"Key $key_file algorithm is not RSA or DSA (those are the only implemented algorithms) \";\n\t    }\n\t    \n\t} elsif (/^Modulus:\\s*(\\S+)/) {\t\t\t\t#RSA \n\t  $Modulus=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^PublicExponent:\\s*(\\S+)/) {\n\n\t  $PublicExponent=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^PrivateExponent:\\s*(\\S+)/) {\n\t    $PrivateExponent=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^Prime1:\\s*(\\S+)/) {\n\t    $Prime1=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^Prime2:\\s*(\\S+)/) {\n\t    $Prime2=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^Exponent1:\\s*(\\S+)/) {\n\t    $Exponent1=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^Exponent2:\\s*(\\S+)/) {\n\t    $Exponent2=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\t} elsif (/^Coefficient:\\s*(\\S+)/) {\n\t    $Coefficient=Crypt::OpenSSL::Bignum->new_from_bin(decode_base64($1));\n\n\t} elsif (/^Prime\\(p\\):\\s*(\\S+)/) {\t\t\t\t#DSA\n\t    $prime_p=decode_base64($1);\n\t} elsif (/^Subprime\\(q\\):\\s*(\\S+)/) {\n\t    $subprime_q=decode_base64($1);\n\t} elsif (/^Base\\(g\\):\\s*(\\S+)/) {\n\t    $base_g=decode_base64($1);\n\t} elsif (/^Private_value\\(x\\):\\s*(\\S+)/) {\n\t    $private_val_x=decode_base64($1);\n\t} elsif (/^Public_value\\(y\\):\\s*(\\S+)/) { \n\t    $public_val_y=decode_base64($1);\n\t}\n    }\n    close(KEYFH);\n\n    if ($self->{\"algorithm\"} == 1\n     || $self->{\"algorithm\"} == 5\n     || $self->{\"algorithm\"} == 7\n     || $self->{\"algorithm\"} == 8\n     || $self->{\"algorithm\"} == 10) {  #RSA\n      $self->{'privatekey'}=Crypt::OpenSSL::RSA-> \n\t  new_key_from_parameters(\n\t      $Modulus,\n\t      $PublicExponent,\n\t      $PrivateExponent,\n\t      $Prime1,\n\t      $Prime2,\n\t      $Exponent1,\n\t      $Exponent2,\n\t      $Coefficient,\n\t);\n\n      # Trying to determine the keytag\n\n      my $keytag_from_data1=$self->dump_rsa_keytag(256,1);\n      my $keytag_from_data2=$self->dump_rsa_keytag(257,1);\n      if (($self->{\"keytag\"} != $keytag_from_data1) &&\n\t  ($self->{\"keytag\"} != $keytag_from_data2)){\n\t  warn \"NB: filename seems to have the wrong keytag.\\n\".\n\t      \"Depending on DNSKEY RR flags set for this key the keytag should be\\n\".\n\t      $keytag_from_data1. \" or \".  $keytag_from_data2. \" instead of \".$self->{\"keytag\"}.\"\\n\";\n\t  return(0);\n      }\n      \n    }elsif ($self->{\"algorithm\"} == 3\n\t|| $self->{\"algorithm\"} == 6 ){  #DSA\n\tmy $private_dsa = Crypt::OpenSSL::DSA->new();\n\t$private_dsa->set_p($prime_p);\n\t$private_dsa->set_q($subprime_q);\n\t$private_dsa->set_g($base_g);\n\t$private_dsa->set_priv_key($private_val_x);\n\t$private_dsa->set_pub_key($public_val_y);\n\t$self->{\"privatekey\"}=$private_dsa;\n    }\n    return $self;\n\n}\n\n\n\n\nsub algorithm {\n    my $self=shift;\n    return $self->{'algorithm'};\n}\n\n\nsub privatekey {\n    my $self=shift;\n    return $self->{'privatekey'};\n}\n\n\nsub keytag {\n    my $self=shift;\n    return $self->{'keytag'};\n}\n\n\n\nsub signame {\n    my $self=shift;\n    return $self->{'signame'};\n}\n\n\n# Little helper function to put a BigInt into a binary (unsigned,\n#network order )\n\n#sub bi2bin {\n#    my($p, $l) = @_;\n#    $l ||= 0;\n#    my $base = Math::BigInt->new(\"+256\");\n#    my $res = '';\n#    {\n#        my $r = $p % $base;\n#        my $d = ($p-$r) / $base;\n#        $res = chr($r) . $res;\n#        if ($d >= $base) {\n#            $p = $d;\n#            redo;\n#        }\n#        elsif ($d != 0) {\n#            $res = chr($d) . $res;\n#        }\n#    }\n#    $res = \"\\0\" x ($l-length($res)) . $res\n#        if length($res) < $l;\n#    $res;\n#}\n\n\n\nsub new_rsa_priv {\n    my ($class,  $keyblob,$signame,$flags) = @_;\n    my $self={};\n    bless ($self,$class);\n    $self->{\"signame\"}=$signame;\n    $self->{\"algorithm\"}=5;\n    $self->{\"flags\"}=$flags;\n    $self->{'privatekey'}=Crypt::OpenSSL::RSA->  \n\tnew_private_key($keyblob);\n\n    $self->{\"keytag\"}=$self->dump_rsa_keytag();\n    return $self;\n}\n\nsub  dump_rsa_priv {\n    my $self=shift;\n\n    my ( $Modulus,$PublicExponent, $PrivateExponent, $Prime1, $Prime2, $Exponent1,\n\t $Exponent2,$Coefficient )=$self->{\"privatekey\"}->get_key_parameters;\n    my $string=\"Private-key-format: v1.2\\n\";\n    $string .= \"Algorithm: 5 (RSASHA1)\\n\";\n    \n    if (defined $Modulus \n\t&& defined $PublicExponent \n\t&& defined $PrivateExponent \n\t&& defined $Prime1 \n\t&& defined $Prime2 \n\t&& defined $Exponent1 \n\t&& defined $Exponent2 \n\t&& $Coefficient ){\n\t$string .= \"Modulus: \". encode_base64($Modulus->to_bin,\"\").\"\\n\" ;\n\t$string .= \"PublicExponent: \". encode_base64($PublicExponent->to_bin,\"\").\"\\n\" ;\n\t$string .= \"PrivateExponent: \". encode_base64($PrivateExponent->to_bin,\"\").\"\\n\"; \n\t$string .= \"Prime1: \". encode_base64($Prime1->to_bin,\"\").\"\\n\" ;\n\t$string .= \"Prime2: \". encode_base64($Prime2->to_bin,\"\").\"\\n\" ;\n\t$string .= \"Exponent1: \". encode_base64($Exponent1->to_bin,\"\").\"\\n\" ;\n\t$string .= \"Exponent2: \". encode_base64($Exponent2->to_bin,\"\").\"\\n\" ;\n\t$string .= \"Coefficient: \". encode_base64($Coefficient->to_bin,\"\").\"\\n\" ;\n    }\n    else  {\n\t$string= \"\";\n    };\n    return $string;\n}\n\n\nsub  dump_rsa_pub {\n    my $self=shift;\n    my ( $Modulus,$PublicExponent, $PrivateExponent, $Prime1, $Prime2, $Exponent1,\n\t $Exponent2,$Coefficient )=$self->{\"privatekey\"}->get_key_parameters;\n    \n    return \"\" unless (defined  $Modulus && defined $PublicExponent);\n    my $explength;\n    my $pubexp=$PublicExponent->to_bin;\n    if (length($pubexp)>255){\n\t$explength=pack(\"C\",0).pack(\"n\",length($pubexp));\n    }else{\n\t$explength=pack(\"C\",length($pubexp));\n    }\n\n    return encode_base64($explength.$pubexp.$Modulus->to_bin, \"\");\n}\n\n\nsub dump_rsa_keytag{\n    my $self=shift;\n    my $flags;\n    if (defined $self->{\"flags\"}){\n\t$flags=$self->{\"flags\"}\n    }else{\n\t$flags=shift;\n    }\n    return()  unless defined $flags;\n\n    # This will set flag if empty before, note the undocumented\n    # feature that a non-zero second argument to this function will\n    # _not_ set the flag.\n    $self->{\"flags\"}=$flags unless shift; \n    my $alg=$self->{\"algorithm\"};\n    return () unless ($alg ==1 || $alg ==5 || $alg == 7 || $alg ==8 || $alg ==10);\n    my $key=$self->dump_rsa_pub;\n    return ()  unless $key;\n    my $tmprr=Net::DNS::RR->new(\"tmp  IN DNSKEY $flags 3 $alg  $key\");\n    return $tmprr->keytag;\n}\n\nsub dump_rsa_private_der {\n    my $self=shift;\n    return $self->{\"privatekey\"}->get_private_key_string;\n\n    }\n\n\n\n\nsub generate_rsa {\n    my ($class) =shift;\n    my $name=shift;\n    my $flags=shift;\n    my $size=shift;\n    $size=1024 if !defined ($size);\n    my $good_entropy=shift;\n    my $self={};\n    bless ($self,$class);\n\n    $self->{\"signame\"}=$name;  \n    $self->{\"algorithm\"}= 5; #  Force non-string \n    if (defined($good_entropy)){\n\tCrypt::OpenSSL::Random::random_seed($good_entropy);\n\t", 8192) = 8192
09:01:57.211782 stat("modules/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.211838 stat("modules/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.211890 stat("modules/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.211938 stat("modules/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.211988 stat("/etc/perl/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212037 stat("/etc/perl/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.212087 stat("/usr/local/lib/perl/5.14.2/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212138 stat("/usr/local/lib/perl/5.14.2/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.212189 stat("/usr/local/share/perl/5.14.2/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212241 stat("/usr/local/share/perl/5.14.2/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.212291 stat("/usr/lib/perl5/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212340 stat("/usr/lib/perl5/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.212390 stat("/usr/share/perl5/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212442 stat("/usr/share/perl5/MIME/Base64.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.212493 stat("/usr/lib/perl/5.14/MIME/Base64.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.212547 stat("/usr/lib/perl/5.14/MIME/Base64.pm", {st_mode=S_IFREG|0644, st_size=5450, ...}) = 0
09:01:57.212606 open("/usr/lib/perl/5.14/MIME/Base64.pm", O_RDONLY) = 16
09:01:57.212660 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123382b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.212706 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.212769 read(16, "package MIME::Base64;\n\nuse strict;\nuse vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(encode_base64 decode_base64);\n@EXPORT_OK = qw(encode_base64url decode_base64url encoded_base64_length decoded_base64_length);\n\n$VERSION = '3.13';\n\nrequire XSLoader;\nXSLoader::load('MIME::Base64', $VERSION);\n\n*encode = \\&encode_base64;\n*decode = \\&decode_base64;\n\nsub encode_base64url {\n    my $e = encode_base64(shift, \"\");\n    $e =~ s/=+\\z//;\n    $e =~ tr[+/][-_];\n    return $e;\n}\n\nsub decode_base64url {\n    my $s = shift;\n    $s =~ tr[-_][+/];\n    $s .= '=' while length($s) % 4;\n    return decode_base64($s);\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nMIME::Base64 - Encoding and decoding of base64 strings\n\n=head1 SYNOPSIS\n\n use MIME::Base64;\n\n $encoded = encode_base64('Aladdin:open sesame');\n $decoded = decode_base64($encoded);\n\n=head1 DESCRIPTION\n\nThis module provides functions to encode and decode strings into and from the\nbase64 encoding specified in RFC 2045 - I<MIME (Multipurpose Internet\nMail Extensions)>. The base64 encoding is designed to represent\narbitrary sequences of octets in a form that need not be humanly\nreadable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used,\nenabling 6 bits to be represented per printable character.\n\nThe following primary functions are provided:\n\n=over 4\n\n=item encode_base64( $bytes )\n\n=item encode_base64( $bytes, $eol );\n\nEncode data by calling the encode_base64() function.  The first\nargument is the byte string to encode.  The second argument is the\nline-ending sequence to use.  It is optional and defaults to \"\\n\".  The\nreturned encoded string is broken into lines of no more than 76\ncharacters each and it will end with $eol unless it is empty.  Pass an\nempty string as second argument if you do not want the encoded string\nto be broken into lines.\n\nThe function will croak with \"Wide character in subroutine entry\" if $bytes\ncontains characters with code above 255.  The base64 encoding is only defined\nfor single-byte characters.  Use the Encode module to select the byte encoding\nyou want.\n\n=item decode_base64( $str )\n\nDecode a base64 string by calling the decode_base64() function.  This\nfunction takes a single argument which is the string to decode and\nreturns the decoded data.\n\nAny character not part of the 65-character base64 subset is\nsilently ignored.  Characters occurring after a '=' padding character\nare never decoded.\n\n=back\n\nIf you prefer not to import these routines into your namespace, you can\ncall them as:\n\n    use MIME::Base64 ();\n    $encoded = MIME::Base64::encode($decoded);\n    $decoded = MIME::Base64::decode($encoded);\n\nAdditional functions not exported by default:\n\n=over 4\n\n=item encode_base64url( $bytes )\n\n=item decode_base64url( $str )\n\nEncode and decode according to the base64 scheme for \"URL applications\" [1].\nThis is a variant of the base64 encoding which does not use padding, does not\nbreak the string into multiple lines and use the characters \"-\" and \"_\" instead\nof \"+\" and \"/\" to avoid using reserved URL characters.\n\n=item encoded_base64_length( $bytes )\n\n=item encoded_base64_length( $bytes, $eol )\n\nReturns the length that the encoded string would have without actually\nencoding it.  This will return the same value as C<< length(encode_base64($bytes)) >>,\nbut should be more efficient.\n\n=item decoded_base64_length( $str )\n\nReturns the length that the decoded string would have without actually\ndecoding it.  This will return the same value as C<< length(decode_base64($str)) >>,\nbut should be more efficient.\n\n=back\n\n=head1 EXAMPLES\n\nIf you want to encode a large file, you should encode it in chunks\nthat are a multiple of 57 bytes.  This ensures that the base64 lines\nline up and that you do not end up with padding in the middle. 57\nbytes of data fills one complete base64 line (76 == 57*4/3):\n\n   use MIME::Base64 qw(encode_base64);\n\n   open(FILE, \"/var/log/wtmp\") or die \"$!\";\n   while (read(FILE, $buf, 60*57)) {\n       print encode_base64($buf);\n   }\n\nor if you know you have enough memory\n\n   use MIME::Base64 qw(encode_base64);\n   local($/) = undef;  # slurp\n   print encode_base64(<STDIN>);\n\nThe same approach as a command line:\n\n   perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' <file\n\nDecoding does not need slurp mode if every line contains a multiple\nof four base64 chars:\n\n   perl -MMIME::Base64 -ne 'print decode_base64($_)' <file\n\nPerl v5.8 and better allow extended Unicode characters in strings.\nSuch strings cannot be encoded directly, as the base64\nencoding is only defined for single-byte characters.  The solution is\nto use the Encode module to select the byte encoding you want.  For\nexample:\n\n    use MIME::Base64 qw(encode_base64);\n    use Encode qw(encode);\n\n    $encoded = encode_base64(encode(\"UTF-8\", \"\\x{FFFF}\\n\"));\n    print $encoded;\n\n=head1 COPYRIGHT\n\nCopyright 1995-1999, 2001-2004, 2010 Gisle Aas.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\nDistantly based on LWP::Base64 written by Martijn Koster\n<m.koster@nexor.co.uk> and Joerg Reichelt <j.reichelt@nexor.co.uk> and\ncode posted to comp.lang.perl <3pd2lp$6gf@wsinti07.win.tue.nl> by Hans\nMulder <hansm@wsinti07.win.tue.nl>\n\nThe XS implementation uses code from metamail.  Copyright 1991 Bell\nCommunications Research, Inc. (Bellcore)\n\n=head1 SEE ALSO\n\nL<MIME::QuotedPrint>\n\n[1] L<http://en.wikipedia.org/wiki/Base64#URL_applications>\n\n=cut\n", 8192) = 5450
09:01:57.213230 lseek(16, 664, SEEK_SET) = 664
09:01:57.213278 lseek(16, 0, SEEK_CUR)  = 664
09:01:57.213323 close(16)               = 0
09:01:57.213410 stat("/usr/lib/perl/5.14/auto/MIME/Base64/Base64.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.213469 stat("/usr/lib/perl/5.14/auto/MIME/Base64/Base64.so", {st_mode=S_IFREG|0644, st_size=14448, ...}) = 0
09:01:57.213529 stat("/usr/lib/perl/5.14/auto/MIME/Base64/Base64.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.213592 open("/usr/lib/perl/5.14/auto/MIME/Base64/Base64.so", O_RDONLY) = 16
09:01:57.213648 read(16, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\20\0\0\0\0\0\0@\0\0\0\0\0\0\0\2601\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264*\0\0\0\0\0\0\264*\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\240-\0\0\0\0\0\0\240- \0\0\0\0\0\240- \0\0\0\0\0\30\3\0\0\0\0\0\0 \3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\270-\0\0\0\0\0\0\270- \0\0\0\0\0\270- \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0@(\0\0\0\0\0\0@(\0\0\0\0\0\0@(\0\0\0\0\0\0L\0\0\0\0\0\0\0L\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\240-\0\0\0\0\0\0\240- \0\0\0\0\0\240- \0\0\0\0\0`\2\0\0\0\0\0\0`\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\32\361\372\273\230\3\356\24H\323\312\r\20\23B\7\243K\34\247\0\0\0\0%\0\0\0)\0\0\0\0\0\0\0\30\0\0\0\22\0\0\0\0\0\0\0\t\0\0\0\32\0\0\0(\0\0\0\"\0\0\0\16\0\0\0\23\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\27\0\0\0\n\0\0\0\36\0\0\0$\0\0\0\34\0\0\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0\7\0\0\0\0\0\0\0\33\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0\35\0\0\0 \0\0\0\0\0\0\0\24\0\0\0&\0\0\0\17\0\0\0\f\0\0\0\10\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\21\0\0\0\26\0\0\0\0\0\0\0\2\0\0\0\v\0\0\0\5\0\0\0\3\0\0\0\35\0\0\0\2\0\0\0\7\0\0\0", 832) = 832
09:01:57.213785 fstat(16, {st_mode=S_IFREG|0644, st_size=14448, ...}) = 0
09:01:57.213842 mmap(NULL, 2109632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 16, 0) = 0x7f7432dd6000
09:01:57.213890 mprotect(0x7f7432dd9000, 2093056, PROT_NONE) = 0
09:01:57.213939 mmap(0x7f7432fd8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 16, 0x2000) = 0x7f7432fd8000
09:01:57.214001 close(16)               = 0
09:01:57.214070 mprotect(0x7f7432fd8000, 4096, PROT_READ) = 0
09:01:57.214202 stat("modules/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214255 stat("modules/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214305 stat("modules/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214355 stat("modules/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214405 stat("/etc/perl/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214458 stat("/etc/perl/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214508 stat("/usr/local/lib/perl/5.14.2/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214560 stat("/usr/local/lib/perl/5.14.2/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214611 stat("/usr/local/share/perl/5.14.2/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214662 stat("/usr/local/share/perl/5.14.2/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214713 stat("/usr/lib/perl5/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214764 stat("/usr/lib/perl5/Math/BigInt.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.214814 stat("/usr/share/perl5/Math/BigInt.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.214866 stat("/usr/share/perl5/Math/BigInt.pm", {st_mode=S_IFREG|0644, st_size=158428, ...}) = 0
09:01:57.214924 open("/usr/share/perl5/Math/BigInt.pm", O_RDONLY) = 16
09:01:57.214977 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123382b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.215023 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.215082 read(16, "package Math::BigInt;\n\n#\n# \"Mike had an infinite amount to do and a negative amount of time in which\n# to do it.\" - Before and After\n#\n\n# The following hash values are used:\n#   value: unsigned int with actual value (as a Math::BigInt::Calc or similar)\n#   sign : +,-,NaN,+inf,-inf\n#   _a   : accuracy\n#   _p   : precision\n#   _f   : flags, used by MBF to flag parts of a float as untouchable\n\n# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since\n# underlying lib might change the reference!\n\nmy $class = \"Math::BigInt\";\nuse 5.006002;\n\n$VERSION = '1.997';\n\n@ISA = qw(Exporter);\n@EXPORT_OK = qw(objectify bgcd blcm); \n\n# _trap_inf and _trap_nan are internal and should never be accessed from the\n# outside\nuse vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode \n\t    $upgrade $downgrade $_trap_nan $_trap_inf/;\nuse strict;\n\n# Inside overload, the first arg is always an object. If the original code had\n# it reversed (like $x = 2 * $y), then the third parameter is true.\n# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes\n# no difference, but in some cases it does.\n\n# For overloaded ops with only one argument we simple use $_[0]->copy() to\n# preserve the argument.\n\n# Thus inheritance of overload operators becomes possible and transparent for\n# our subclasses without the need to repeat the entire overload section there.\n\nuse overload\n'='     =>      sub { $_[0]->copy(); },\n\n# some shortcuts for speed (assumes that reversed order of arguments is routed\n# to normal '+' and we thus can always modify first arg. If this is changed,\n# this breaks and must be adjusted.)\n'+='\t=>\tsub { $_[0]->badd($_[1]); },\n'-='\t=>\tsub { $_[0]->bsub($_[1]); },\n'*='\t=>\tsub { $_[0]->bmul($_[1]); },\n'/='\t=>\tsub { scalar $_[0]->bdiv($_[1]); },\n'%='\t=>\tsub { $_[0]->bmod($_[1]); },\n'^='\t=>\tsub { $_[0]->bxor($_[1]); },\n'&='\t=>\tsub { $_[0]->band($_[1]); },\n'|='\t=>\tsub { $_[0]->bior($_[1]); },\n\n'**='\t=>\tsub { $_[0]->bpow($_[1]); },\n'<<='\t=>\tsub { $_[0]->blsft($_[1]); },\n'>>='\t=>\tsub { $_[0]->brsft($_[1]); },\n\n# not supported by Perl yet\n'..'\t=>\t\\&_pointpoint,\n\n'<=>'\t=>\tsub { my $rc = $_[2] ?\n                      ref($_[0])->bcmp($_[1],$_[0]) : \n                      $_[0]->bcmp($_[1]); \n\t\t      $rc = 1 unless defined $rc;\n\t\t      $rc <=> 0;\n\t\t},\n# we need '>=' to get things like \"1 >= NaN\" right:\n'>='\t=>\tsub { my $rc = $_[2] ?\n                      ref($_[0])->bcmp($_[1],$_[0]) : \n                      $_[0]->bcmp($_[1]);\n\t\t      # if there was a NaN involved, return false\n\t\t      return '' unless defined $rc;\n\t\t      $rc >= 0;\n\t\t},\n'cmp'\t=>\tsub {\n         $_[2] ? \n               \"$_[1]\" cmp $_[0]->bstr() :\n               $_[0]->bstr() cmp \"$_[1]\" },\n\n'cos'\t=>\tsub { $_[0]->copy->bcos(); }, \n'sin'\t=>\tsub { $_[0]->copy->bsin(); }, \n'atan2'\t=>\tsub { $_[2] ?\n\t\t\tref($_[0])->new($_[1])->batan2($_[0]) :\n\t\t\t$_[0]->copy()->batan2($_[1]) },\n\n# are not yet overloadable\n#'hex'\t=>\tsub { print \"hex\"; $_[0]; }, \n#'oct'\t=>\tsub { print \"oct\"; $_[0]; }, \n\n# log(N) is log(N, e), where e is Euler's number\n'log'\t=>\tsub { $_[0]->copy()->blog($_[1], undef); }, \n'exp'\t=>\tsub { $_[0]->copy()->bexp($_[1]); }, \n'int'\t=>\tsub { $_[0]->copy(); }, \n'neg'\t=>\tsub { $_[0]->copy()->bneg(); }, \n'abs'\t=>\tsub { $_[0]->copy()->babs(); },\n'sqrt'  =>\tsub { $_[0]->copy()->bsqrt(); },\n'~'\t=>\tsub { $_[0]->copy()->bnot(); },\n\n# for subtract it's a bit tricky to not modify b: b-a => -a+b\n'-'\t=>\tsub { my $c = $_[0]->copy; $_[2] ?\n\t\t\t$c->bneg()->badd( $_[1]) :\n\t\t\t$c->bsub( $_[1]) },\n'+'\t=>\tsub { $_[0]->copy()->badd($_[1]); },\n'*'\t=>\tsub { $_[0]->copy()->bmul($_[1]); },\n\n'/'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);\n  }, \n'%'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);\n  }, \n'**'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);\n  }, \n'<<'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);\n  }, \n'>>'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);\n  }, \n'&'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);\n  }, \n'|'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);\n  }, \n'^'\t=>\tsub { \n   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);\n  }, \n\n# can modify arg of ++ and --, so avoid a copy() for speed, but don't\n# use $_[0]->bone(), it would modify $_[0] to be 1!\n'++'\t=>\tsub { $_[0]->binc() },\n'--'\t=>\tsub { $_[0]->bdec() },\n\n# if overloaded, O(1) instead of O(N) and twice as fast for small numbers\n'bool'  =>\tsub {\n  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/\n  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;\t\t    :-(\n  my $t = undef;\n  $t = 1 if !$_[0]->is_zero();\n  $t;\n  },\n\n# the original qw() does not work with the TIESCALAR below, why?\n# Order of arguments unsignificant\n'\"\"' => sub { $_[0]->bstr(); },\n'0+' => sub { $_[0]->numify(); }\n;\n\n##############################################################################\n# global constants, flags and accessory\n\n# These vars are public, but their direct usage is not recommended, use the\n# accessor methods instead\n\n$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'\n$accuracy   = undef;\n$precision  = undef;\n$div_scale  = 40;\n\n$upgrade = undef;\t\t\t# default is no upgrade\n$downgrade = undef;\t\t\t# default is no downgrade\n\n# These are internally, and not to be used from the outside at all\n\n$_trap_nan = 0;\t\t\t\t# are NaNs ok? set w/ config()\n$_trap_inf = 0;\t\t\t\t# are infs ok? set w/ config()\nmy $nan = 'NaN'; \t\t\t# constants for easier life\n\nmy $CALC = 'Math::BigInt::Calc';\t# module to do the low level math\n\t\t\t\t\t# default is Calc.pm\nmy $IMPORT = 0;\t\t\t\t# was import() called yet?\n\t\t\t\t\t# used to make require work\nmy %WARN;\t\t\t\t# warn only once for low-level libs\nmy %CAN;\t\t\t\t# cache for $CALC->can(...)\nmy %CALLBACKS;\t\t\t\t# callbacks to notify on lib loads\nmy $EMU_LIB = 'Math/BigInt/CalcEmu.pm';\t# emulate low-level math\n\n##############################################################################\n# the old code had $rnd_mode, so we need to support it, too\n\n$rnd_mode   = 'even';\nsub TIESCALAR  { my ($class) = @_; bless \\$round_mode, $class; }\nsub FETCH      { return $round_mode; }\nsub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }\n\nBEGIN\n  { \n  # tie to enable $rnd_mode to work transparently\n  tie $rnd_mode, 'Math::BigInt'; \n\n  # set up some handy alias names\n  *as_int = \\&as_number;\n  *is_pos = \\&is_positive;\n  *is_neg = \\&is_negative;\n  }\n\n############################################################################## \n\nsub round_mode\n  {\n  no strict 'refs';\n  # make Class->round_mode() work\n  my $self = shift;\n  my $class = ref($self) || $self || __PACKAGE__;\n  if (defined $_[0])\n    {\n    my $m = shift;\n    if ($m !~ /^(even|odd|\\+inf|\\-inf|zero|trunc|common)$/)\n      {\n      require Carp; Carp::croak (\"Unknown round mode '$m'\");\n      }\n    return ${\"${class}::round_mode\"} = $m;\n    }\n  ${\"${class}::round_mode\"};\n  }\n\nsub upgrade\n  {\n  no strict 'refs';\n  # make Class->upgrade() work\n  my $self = shift;\n  my $class = ref($self) || $self || __PACKAGE__;\n  # need to set new value?\n  if (@_ > 0)\n    {\n    return ${\"${class}::upgrade\"} = $_[0];\n    }\n  ${\"${class}::upgrade\"};\n  }\n\nsub downgrade\n  {\n  no strict 'refs';\n  # make Class->downgrade() work\n  my $self = shift;\n  my $class = ref($self) || $self || __PACKAGE__;\n  # need to set new value?\n  if (@_ > 0)\n    {\n    return ${\"${class}::downgrade\"} = $_[0];\n    }\n  ${\"${class}::downgrade\"};\n  }\n\nsub div_scale\n  {\n  no strict 'refs';\n  # make Class->div_scale() work\n  my $self = shift;\n  my $class = ref($self) || $self || __PACKAGE__;\n  if (defined $_[0])\n    {\n    if ($_[0] < 0)\n      {\n      require Carp; Carp::croak ('div_scale must be greater than zero');\n      }\n    ${\"${class}::div_scale\"} = $_[0];\n    }\n  ${\"${class}::div_scale\"};\n  }\n\nsub accuracy\n  {\n  # $x->accuracy($a);\t\tref($x)\t$a\n  # $x->accuracy();\t\tref($x)\n  # Class->accuracy();\t\tclass\n  # Class->accuracy($a);\tclass $a\n\n  my $x = shift;\n  my $class = ref($x) ||", 8192) = 8192
09:01:57.215652 brk(0x113f000)          = 0x113f000
09:01:57.216291 stat("modules/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216346 stat("modules/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216396 stat("modules/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216445 stat("modules/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216494 stat("/etc/perl/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216545 stat("/etc/perl/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216596 stat("/usr/local/lib/perl/5.14.2/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216648 stat("/usr/local/lib/perl/5.14.2/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216700 stat("/usr/local/share/perl/5.14.2/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216752 stat("/usr/local/share/perl/5.14.2/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216803 stat("/usr/lib/perl5/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216853 stat("/usr/lib/perl5/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.216903 stat("/usr/share/perl5/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.216953 stat("/usr/share/perl5/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.217003 stat("/usr/lib/perl/5.14/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.217060 stat("/usr/lib/perl/5.14/overload.pm", 0x7ffe12337ef0) = -1 ENOENT (No such file or directory)
09:01:57.217112 stat("/usr/share/perl/5.14/overload.pmc", 0x7ffe12337fa0) = -1 ENOENT (No such file or directory)
09:01:57.217167 stat("/usr/share/perl/5.14/overload.pm", {st_mode=S_IFREG|0644, st_size=4612, ...}) = 0
09:01:57.217228 open("/usr/share/perl/5.14/overload.pm", O_RDONLY) = 17
09:01:57.217281 ioctl(17, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12337c80) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.217327 lseek(17, 0, SEEK_CUR)  = 0
09:01:57.217385 brk(0x1161000)          = 0x1161000
09:01:57.217439 read(17, "package overload;\n\nour $VERSION = '1.13';\n\nsub nil {}\n\nsub OVERLOAD {\n  $package = shift;\n  my %arg = @_;\n  my ($sub, $fb);\n  $ {$package . \"::OVERLOAD\"}{dummy}++; # Register with magic by touching.\n  $fb = ${$package . \"::()\"}; # preserve old fallback value RT#68196\n  *{$package . \"::()\"} = \\&nil; # Make it findable via fetchmethod.\n  for (keys %arg) {\n    if ($_ eq 'fallback') {\n      $fb = $arg{$_};\n    } else {\n      $sub = $arg{$_};\n      if (not ref $sub and $sub !~ /::/) {\n\t$ {$package . \"::(\" . $_} = $sub;\n\t$sub = \\&nil;\n      }\n      #print STDERR \"Setting `$ {'package'}::\\cO$_' to \\\\&`$sub'.\\n\";\n      *{$package . \"::(\" . $_} = \\&{ $sub };\n    }\n  }\n  ${$package . \"::()\"} = $fb; # Make it findable too (fallback only).\n}\n\nsub import {\n  $package = (caller())[0];\n  # *{$package . \"::OVERLOAD\"} = \\&OVERLOAD;\n  shift;\n  $package->overload::OVERLOAD(@_);\n}\n\nsub unimport {\n  $package = (caller())[0];\n  ${$package . \"::OVERLOAD\"}{dummy}++; # Upgrade the table\n  shift;\n  for (@_) {\n    if ($_ eq 'fallback') {\n      undef $ {$package . \"::()\"};\n    } else {\n      delete $ {$package . \"::\"}{\"(\" . $_};\n    }\n  }\n}\n\nsub Overloaded {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  $package->can('()');\n}\n\nsub ov_method {\n  my $globref = shift;\n  return undef unless $globref;\n  my $sub = \\&{*$globref};\n  require Scalar::Util;\n  return $sub\n    if Scalar::Util::refaddr($sub) != Scalar::Util::refaddr(\\&nil);\n  return shift->can($ {*$globref});\n}\n\nsub OverloadedStringify {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  #$package->can('(\"\"')\n  ov_method mycan($package, '(\"\"'), $package\n    or ov_method mycan($package, '(0+'), $package\n    or ov_method mycan($package, '(bool'), $package\n    or ov_method mycan($package, '(nomethod'), $package;\n}\n\nsub Method {\n  my $package = shift;\n  if(ref $package) {\n    local $@;\n    local $!;\n    require Scalar::Util;\n    $package = Scalar::Util::blessed($package);\n    return undef if !defined $package;\n  }\n  #my $meth = $package->can('(' . shift);\n  ov_method mycan($package, '(' . shift), $package;\n  #return $meth if $meth ne \\&nil;\n  #return $ {*{$meth}};\n}\n\nsub AddrRef {\n  my $package = ref $_[0];\n  return \"$_[0]\" unless $package;\n\n  local $@;\n  local $!;\n  require Scalar::Util;\n  my $class = Scalar::Util::blessed($_[0]);\n  my $class_prefix = defined($class) ? \"$class=\" : \"\";\n  my $type = Scalar::Util::reftype($_[0]);\n  my $addr = Scalar::Util::refaddr($_[0]);\n  return sprintf(\"%s%s(0x%x)\", $class_prefix, $type, $addr);\n}\n\n*StrVal = *AddrRef;\n\nsub mycan {\t\t\t\t# Real can would leave stubs.\n  my ($package, $meth) = @_;\n\n  local $@;\n  local $!;\n  require mro;\n\n  my $mro = mro::get_linear_isa($package);\n  foreach my $p (@$mro) {\n    my $fqmeth = $p . q{::} . $meth;\n    return \\*{$fqmeth} if defined &{$fqmeth};\n  }\n\n  return undef;\n}\n\n%constants = (\n\t      'integer'\t  =>  0x1000, # HINT_NEW_INTEGER\n\t      'float'\t  =>  0x2000, # HINT_NEW_FLOAT\n\t      'binary'\t  =>  0x4000, # HINT_NEW_BINARY\n\t      'q'\t  =>  0x8000, # HINT_NEW_STRING\n\t      'qr'\t  => 0x10000, # HINT_NEW_RE\n\t     );\n\n%ops = ( with_assign\t  => \"+ - * / % ** << >> x .\",\n\t assign\t\t  => \"+= -= *= /= %= **= <<= >>= x= .=\",\n\t num_comparison\t  => \"< <= >  >= == !=\",\n\t '3way_comparison'=> \"<=> cmp\",\n\t str_comparison\t  => \"lt le gt ge eq ne\",\n\t binary\t\t  => '& &= | |= ^ ^=',\n\t unary\t\t  => \"neg ! ~\",\n\t mutators\t  => '++ --',\n\t func\t\t  => \"atan2 cos sin exp abs log sqrt int\",\n\t conversion\t  => 'bool \"\" 0+ qr',\n\t iterators\t  => '<>',\n         filetest         => \"-X\",\n\t dereferencing\t  => '${} @{} %{} &{} *{}',\n\t matching\t  => '~~',\n\t special\t  => 'nomethod fallback =');\n\nuse warnings::register;\nsub constant {\n  # Arguments: what, sub\n  while (@_) {\n    if (@_ == 1) {\n        warnings::warnif (\"Odd number of arguments for overload::constant\");\n        last;\n    }\n    elsif (!exists $constants {$_ [0]}) {\n        warnings::warnif (\"`$_[0]' is not an overloadable type\");\n    }\n    elsif (!ref $_ [1] || \"$_[1]\" !~ /(^|=)CODE\\(0x[0-9a-f]+\\)$/) {\n        # Can't use C<ref $_[1] eq \"CODE\"> above as code references can be\n        # blessed, and C<ref> would return the package the ref is blessed into.\n        if (warnings::enabled) {\n            $_ [1] = \"undef\" unless defined $_ [1];\n            warnings::warn (\"`$_[1]' is not a code reference\");\n        }\n    }\n    else {\n        $^H{$_[0]} = $_[1];\n        $^H |= $constants{$_[0]};\n    }\n    shift, shift;\n  }\n}\n\nsub remove_constant {\n  # Arguments: what, sub\n  while (@_) {\n    delete $^H{$_[0]};\n    $^H &= ~ $constants{$_[0]};\n    shift, shift;\n  }\n}\n\n1;\n\n__END__\n\n", 8192) = 4612
09:01:57.218327 lseek(17, 4611, SEEK_SET) = 4611
09:01:57.218378 lseek(17, 0, SEEK_CUR)  = 4611
09:01:57.218423 close(17)               = 0
09:01:57.218880 brk(0x1182000)          = 0x1182000
09:01:57.219002 read(16, " $x || __PACKAGE__;\n\n  no strict 'refs';\n  # need to set new value?\n  if (@_ > 0)\n    {\n    my $a = shift;\n    # convert objects to scalars to avoid deep recursion. If object doesn't\n    # have numify(), then hopefully it will have overloading for int() and\n    # boolean test without wandering into a deep recursion path...\n    $a = $a->numify() if ref($a) && $a->can('numify');\n\n    if (defined $a)\n      {\n      # also croak on non-numerical\n      if (!$a || $a <= 0)\n        {\n        require Carp;\n\tCarp::croak ('Argument to accuracy must be greater than zero');\n        }\n      if (int($a) != $a)\n        {\n        require Carp;\n\tCarp::croak ('Argument to accuracy must be an integer');\n        }\n      }\n    if (ref($x))\n      {\n      # $object->accuracy() or fallback to global\n      $x->bround($a) if $a;\t\t# not for undef, 0\n      $x->{_a} = $a;\t\t\t# set/overwrite, even if not rounded\n      delete $x->{_p};\t\t\t# clear P\n      $a = ${\"${class}::accuracy\"} unless defined $a;   # proper return value\n      }\n    else\n      {\n      ${\"${class}::accuracy\"} = $a;\t# set global A\n      ${\"${class}::precision\"} = undef;\t# clear global P\n      }\n    return $a;\t\t\t\t# shortcut\n    }\n\n  my $a;\n  # $object->accuracy() or fallback to global\n  $a = $x->{_a} if ref($x);\n  # but don't return global undef, when $x's accuracy is 0!\n  $a = ${\"${class}::accuracy\"} if !defined $a;\n  $a;\n  }\n\nsub precision\n  {\n  # $x->precision($p);\t\tref($x)\t$p\n  # $x->precision();\t\tref($x)\n  # Class->precision();\t\tclass\n  # Class->precision($p);\tclass $p\n\n  my $x = shift;\n  my $class = ref($x) || $x || __PACKAGE__;\n\n  no strict 'refs';\n  if (@_ > 0)\n    {\n    my $p = shift;\n    # convert objects to scalars to avoid deep recursion. If object doesn't\n    # have numify(), then hopefully it will have overloading for int() and\n    # boolean test without wandering into a deep recursion path...\n    $p = $p->numify() if ref($p) && $p->can('numify');\n    if ((defined $p) && (int($p) != $p))\n      {\n      require Carp; Carp::croak ('Argument to precision must be an integer');\n      }\n    if (ref($x))\n      {\n      # $object->precision() or fallback to global\n      $x->bfround($p) if $p;\t\t# not for undef, 0\n      $x->{_p} = $p;\t\t\t# set/overwrite, even if not rounded\n      delete $x->{_a};\t\t\t# clear A\n      $p = ${\"${class}::precision\"} unless defined $p;  # proper return value\n      }\n    else\n      {\n      ${\"${class}::precision\"} = $p;\t# set global P\n      ${\"${class}::accuracy\"} = undef;\t# clear global A\n      }\n    return $p;\t\t\t\t# shortcut\n    }\n\n  my $p;\n  # $object->precision() or fallback to global\n  $p = $x->{_p} if ref($x);\n  # but don't return global undef, when $x's precision is 0!\n  $p = ${\"${class}::precision\"} if !defined $p;\n  $p;\n  }\n\nsub config\n  {\n  # return (or set) configuration data as hash ref\n  my $class = shift || 'Math::BigInt';\n\n  no strict 'refs';\n  if (@_ > 1 || (@_ == 1 && (ref($_[0]) eq 'HASH')))\n    {\n    # try to set given options as arguments from hash\n\n    my $args = $_[0];\n    if (ref($args) ne 'HASH')\n      {\n      $args = { @_ };\n      }\n    # these values can be \"set\"\n    my $set_args = {};\n    foreach my $key (\n     qw/trap_inf trap_nan\n        upgrade downgrade precision accuracy round_mode div_scale/\n     )\n      {\n      $set_args->{$key} = $args->{$key} if exists $args->{$key};\n      delete $args->{$key};\n      }\n    if (keys %$args > 0)\n      {\n      require Carp;\n      Carp::croak (\"Illegal key(s) '\",\n       join(\"','\",keys %$args),\"' passed to $class\\->config()\");\n      }\n    foreach my $key (keys %$set_args)\n      {\n      if ($key =~ /^trap_(inf|nan)\\z/)\n        {\n        ${\"${class}::_trap_$1\"} = ($set_args->{\"trap_$1\"} ? 1 : 0);\n        next;\n        }\n      # use a call instead of just setting the $variable to check argument\n      $class->$key($set_args->{$key});\n      }\n    }\n\n  # now return actual configuration\n\n  my $cfg = {\n    lib => $CALC,\n    lib_version => ${\"${CALC}::VERSION\"},\n    class => $class,\n    trap_nan => ${\"${class}::_trap_nan\"},\n    trap_inf => ${\"${class}::_trap_inf\"},\n    version => ${\"${class}::VERSION\"},\n    };\n  foreach my $key (qw/\n     upgrade downgrade precision accuracy round_mode div_scale\n     /)\n    {\n    $cfg->{$key} = ${\"${class}::$key\"};\n    };\n  if (@_ == 1 && (ref($_[0]) ne 'HASH'))\n    {\n    # calls of the style config('lib') return just this value\n    return $cfg->{$_[0]};\n    }\n  $cfg;\n  }\n\nsub _scale_a\n  { \n  # select accuracy parameter based on precedence,\n  # used by bround() and bfround(), may return undef for scale (means no op)\n  my ($x,$scale,$mode) = @_;\n\n  $scale = $x->{_a} unless defined $scale;\n\n  no strict 'refs';\n  my $class = ref($x);\n\n  $scale = ${ $class . '::accuracy' } unless defined $scale;\n  $mode = ${ $class . '::round_mode' } unless defined $mode;\n\n  if (defined $scale)\n    {\n    $scale = $scale->can('numify') ? $scale->numify() : \"$scale\" if ref($scale);\n    $scale = int($scale);\n    }\n\n  ($scale,$mode);\n  }\n\nsub _scale_p\n  { \n  # select precision parameter based on precedence,\n  # used by bround() and bfround(), may return undef for scale (means no op)\n  my ($x,$scale,$mode) = @_;\n  \n  $scale = $x->{_p} unless defined $scale;\n\n  no strict 'refs';\n  my $class = ref($x);\n\n  $scale = ${ $class . '::precision' } unless defined $scale;\n  $mode = ${ $class . '::round_mode' } unless defined $mode;\n\n  if (defined $scale)\n    {\n    $scale = $scale->can('numify') ? $scale->numify() : \"$scale\" if ref($scale);\n    $scale = int($scale);\n    }\n\n  ($scale,$mode);\n  }\n\n##############################################################################\n# constructors\n\nsub copy\n  {\n  # if two arguments, the first one is the class to \"swallow\" subclasses\n  if (@_ > 1)\n    {\n    my  $self = bless {\n\tsign => $_[1]->{sign}, \n\tvalue => $CALC->_copy($_[1]->{value}),\n    }, $_[0] if @_ > 1;\n\n    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};\n    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};\n    return $self;\n    }\n\n  my $self = bless {\n\tsign => $_[0]->{sign}, \n\tvalue => $CALC->_copy($_[0]->{value}),\n\t}, ref($_[0]);\n\n  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};\n  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};\n  $self;\n  }\n\nsub new \n  {\n  # create a new BigInt object from a string or another BigInt object. \n  # see hash keys documented at top\n\n  # the argument could be an object, so avoid ||, && etc on it, this would\n  # cause costly overloaded code to be called. The only allowed ops are\n  # ref() and defined.\n\n  my ($class,$wanted,$a,$p,$r) = @_;\n \n  # avoid numify-calls by not using || on $wanted!\n  return $class->bzero($a,$p) if !defined $wanted;\t# default to 0\n  return $class->copy($wanted,$a,$p,$r)\n   if ref($wanted) && $wanted->isa($class);\t\t# MBI or subclass\n\n  $class->import() if $IMPORT == 0;\t\t# make require work\n  \n  my $self = bless {}, $class;\n\n  # shortcut for \"normal\" numbers\n  if ((!ref $wanted) && ($wanted =~ /^([+-]?)[1-9][0-9]*\\z/))\n    {\n    $self->{sign} = $1 || '+';\n\n    if ($wanted =~ /^[+-]/)\n     {\n      # remove sign without touching wanted to make it work with constants\n      my $t = $wanted; $t =~ s/^[+-]//;\n      $self->{value} = $CALC->_new($t);\n      }\n    else\n      {\n      $self->{value} = $CALC->_new($wanted);\n      }\n    no strict 'refs';\n    if ( (defined $a) || (defined $p) \n        || (defined ${\"${class}::precision\"})\n        || (defined ${\"${class}::accuracy\"}) \n       )\n      {\n      $self->round($a,$p,$r) unless (@_ == 4 && !defined $a && !defined $p);\n      }\n    return $self;\n    }\n\n  # handle '+inf', '-inf' first\n  if ($wanted =~ /^[+-]?inf\\z/)\n    {\n    $self->{sign} = $wanted;\t\t# set a default sign for bstr()\n    return $self->binf($wanted);\n    }\n  # split str in m mantissa, e exponent, i integer, f fraction, v value, s sign\n  my ($mis,$miv,$mfv,$es,$ev) = _split($wanted);\n  if (!ref $mis)\n    {\n    if ($_trap_nan)\n      {\n      require Carp; Carp::croak(\"$wanted is not a number in $class\");\n      }\n    $self->{value} = $CALC->_zero();\n    $self->{sign} = $nan;\n    return $self;\n    }\n  if (!ref $miv)\n    {\n    # _from_hex or _from_bin\n    $self->{value} = $mis->{value};\n    $self->{sign} = $mis->{sign};\n    return $self;\t# throw away $mis\n    }\n  # m", 8192) = 8192
09:01:57.220233 brk(0x11a3000)          = 0x11a3000
09:01:57.220340 read(16, "ake integer from mantissa by adjusting exp, then convert to bigint\n  $self->{sign} = $$mis;\t\t\t# store sign\n  $self->{value} = $CALC->_zero();\t\t# for all the NaN cases\n  my $e = int(\"$$es$$ev\");\t\t\t# exponent (avoid recursion)\n  if ($e > 0)\n    {\n    my $diff = $e - CORE::length($$mfv);\n    if ($diff < 0)\t\t\t\t# Not integer\n      {\n      if ($_trap_nan)\n        {\n        require Carp; Carp::croak(\"$wanted not an integer in $class\");\n        }\n      #print \"NOI 1\\n\";\n      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;\n      $self->{sign} = $nan;\n      }\n    else\t\t\t\t\t# diff >= 0\n      {\n      # adjust fraction and add it to value\n      #print \"diff > 0 $$miv\\n\";\n      $$miv = $$miv . ($$mfv . '0' x $diff);\n      }\n    }\n  else\n    {\n    if ($$mfv ne '')\t\t\t\t# e <= 0\n      {\n      # fraction and negative/zero E => NOI\n      if ($_trap_nan)\n        {\n        require Carp; Carp::croak(\"$wanted not an integer in $class\");\n        }\n      #print \"NOI 2 \\$\\$mfv '$$mfv'\\n\";\n      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;\n      $self->{sign} = $nan;\n      }\n    elsif ($e < 0)\n      {\n      # xE-y, and empty mfv\n      #print \"xE-y\\n\";\n      $e = abs($e);\n      if ($$miv !~ s/0{$e}$//)\t\t# can strip so many zero's?\n        {\n        if ($_trap_nan)\n          {\n          require Carp; Carp::croak(\"$wanted not an integer in $class\");\n          }\n        #print \"NOI 3\\n\";\n        return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;\n        $self->{sign} = $nan;\n        }\n      }\n    }\n  $self->{sign} = '+' if $$miv eq '0';\t\t\t# normalize -0 => +0\n  $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;\n  # if any of the globals is set, use them to round and store them inside $self\n  # do not round for new($x,undef,undef) since that is used by MBF to signal\n  # no rounding\n  $self->round($a,$p,$r) unless @_ == 4 && !defined $a && !defined $p;\n  $self;\n  }\n\nsub bnan\n  {\n  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'\n  my $self = shift;\n  $self = $class if !defined $self;\n  if (!ref($self))\n    {\n    my $c = $self; $self = {}; bless $self, $c;\n    }\n  no strict 'refs';\n  if (${\"${class}::_trap_nan\"})\n    {\n    require Carp;\n    Carp::croak (\"Tried to set $self to NaN in $class\\::bnan()\");\n    }\n  $self->import() if $IMPORT == 0;\t\t# make require work\n  return if $self->modify('bnan');\n  if ($self->can('_bnan'))\n    {\n    # use subclass to initialize\n    $self->_bnan();\n    }\n  else\n    {\n    # otherwise do our own thing\n    $self->{value} = $CALC->_zero();\n    }\n  $self->{sign} = $nan;\n  delete $self->{_a}; delete $self->{_p};\t# rounding NaN is silly\n  $self;\n  }\n\nsub binf\n  {\n  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'\n  # the sign is either '+', or if given, used from there\n  my $self = shift;\n  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;\n  $self = $class if !defined $self;\n  if (!ref($self))\n    {\n    my $c = $self; $self = {}; bless $self, $c;\n    }\n  no strict 'refs';\n  if (${\"${class}::_trap_inf\"})\n    {\n    require Carp;\n    Carp::croak (\"Tried to set $self to +-inf in $class\\::binf()\");\n    }\n  $self->import() if $IMPORT == 0;\t\t# make require work\n  return if $self->modify('binf');\n  if ($self->can('_binf'))\n    {\n    # use subclass to initialize\n    $self->_binf();\n    }\n  else\n    {\n    # otherwise do our own thing\n    $self->{value} = $CALC->_zero();\n    }\n  $sign = $sign . 'inf' if $sign !~ /inf$/;\t# - => -inf\n  $self->{sign} = $sign;\n  ($self->{_a},$self->{_p}) = @_;\t\t# take over requested rounding\n  $self;\n  }\n\nsub bzero\n  {\n  # create a bigint '+0', if given a BigInt, set it to 0\n  my $self = shift;\n  $self = __PACKAGE__ if !defined $self;\n \n  if (!ref($self))\n    {\n    my $c = $self; $self = {}; bless $self, $c;\n    }\n  $self->import() if $IMPORT == 0;\t\t# make require work\n  return if $self->modify('bzero');\n  \n  if ($self->can('_bzero'))\n    {\n    # use subclass to initialize\n    $self->_bzero();\n    }\n  else\n    {\n    # otherwise do our own thing\n    $self->{value} = $CALC->_zero();\n    }\n  $self->{sign} = '+';\n  if (@_ > 0)\n    {\n    if (@_ > 3)\n      {\n      # call like: $x->bzero($a,$p,$r,$y);\n      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);\n      }\n    else\n      {\n      $self->{_a} = $_[0]\n       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));\n      $self->{_p} = $_[1]\n       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));\n      }\n    }\n  $self;\n  }\n\nsub bone\n  {\n  # create a bigint '+1' (or -1 if given sign '-'),\n  # if given a BigInt, set it to +1 or -1, respectively\n  my $self = shift;\n  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';\n  $self = $class if !defined $self;\n\n  if (!ref($self))\n    {\n    my $c = $self; $self = {}; bless $self, $c;\n    }\n  $self->import() if $IMPORT == 0;\t\t# make require work\n  return if $self->modify('bone');\n\n  if ($self->can('_bone'))\n    {\n    # use subclass to initialize\n    $self->_bone();\n    }\n  else\n    {\n    # otherwise do our own thing\n    $self->{value} = $CALC->_one();\n    }\n  $self->{sign} = $sign;\n  if (@_ > 0)\n    {\n    if (@_ > 3)\n      {\n      # call like: $x->bone($sign,$a,$p,$r,$y);\n      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);\n      }\n    else\n      {\n      # call like: $x->bone($sign,$a,$p,$r);\n      $self->{_a} = $_[0]\n       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));\n      $self->{_p} = $_[1]\n       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));\n      }\n    }\n  $self;\n  }\n\n##############################################################################\n# string conversion\n\nsub bsstr\n  {\n  # (ref to BFLOAT or num_str ) return num_str\n  # Convert number from internal format to scientific string format.\n  # internal format is always normalized (no leading zeros, \"-0E0\" => \"+0E0\")\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); \n\n  if ($x->{sign} !~ /^[+-]$/)\n    {\n    return $x->{sign} unless $x->{sign} eq '+inf';\t# -inf, NaN\n    return 'inf';\t\t\t\t\t# +inf\n    }\n  my ($m,$e) = $x->parts();\n  #$m->bstr() . 'e+' . $e->bstr(); \t# e can only be positive in BigInt\n  # 'e+' because E can only be positive in BigInt\n  $m->bstr() . 'e+' . $CALC->_str($e->{value}); \n  }\n\nsub bstr \n  {\n  # make a string from bigint object\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); \n\n  if ($x->{sign} !~ /^[+-]$/)\n    {\n    return $x->{sign} unless $x->{sign} eq '+inf';\t# -inf, NaN\n    return 'inf';\t\t\t\t\t# +inf\n    }\n  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';\n  $es.$CALC->_str($x->{value});\n  }\n\nsub numify \n  {\n  # Make a \"normal\" scalar from a BigInt object\n  my $x = shift; $x = $class->new($x) unless ref $x;\n\n  return $x->bstr() if $x->{sign} !~ /^[+-]$/;\n  my $num = $CALC->_num($x->{value});\n  return -$num if $x->{sign} eq '-';\n  $num;\n  }\n\n##############################################################################\n# public stuff (usually prefixed with \"b\")\n\nsub sign\n  {\n  # return the sign of the number: +/-/-inf/+inf/NaN\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); \n  \n  $x->{sign};\n  }\n\nsub _find_round_parameters\n  {\n  # After any operation or when calling round(), the result is rounded by\n  # regarding the A & P from arguments, local parameters, or globals.\n\n  # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!\n\n  # This procedure finds the round parameters, but it is for speed reasons\n  # duplicated in round. Otherwise, it is tested by the testsuite and used\n  # by fdiv().\n \n  # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P\n  # were requested/defined (locally or globally or both)\n  \n  my ($self,$a,$p,$r,@args) = @_;\n  # $a accuracy, if given by caller\n  # $p precision, if given by caller\n  # $r round_mode, if given by caller\n  # @args all 'other' arguments (0 for unary, 1 for binary ops)\n\n  my $c = ref($self);\t\t\t\t# find out class of argument(s)\n  no strict 'refs';\n\n  # convert to normal scalar for speed and correctness in inner parts\n  $a = $a->can('numify') ? $a->numify() : \"$a\" if defined $a && ref($a);\n  $p = $p", 8192) = 8192
09:01:57.221527 brk(0x11c4000)          = 0x11c4000
09:01:57.221651 read(16, "->can('numify') ? $p->numify() : \"$p\" if defined $p && ref($p);\n\n  # now pick $a or $p, but only if we have got \"arguments\"\n  if (!defined $a)\n    {\n    foreach ($self,@args)\n      {\n      # take the defined one, or if both defined, the one that is smaller\n      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);\n      }\n    }\n  if (!defined $p)\n    {\n    # even if $a is defined, take $p, to signal error for both defined\n    foreach ($self,@args)\n      {\n      # take the defined one, or if both defined, the one that is bigger\n      # -2 > -3, and 3 > 2\n      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);\n      }\n    }\n  # if still none defined, use globals (#2)\n  $a = ${\"$c\\::accuracy\"} unless defined $a;\n  $p = ${\"$c\\::precision\"} unless defined $p;\n\n  # A == 0 is useless, so undef it to signal no rounding\n  $a = undef if defined $a && $a == 0;\n \n  # no rounding today? \n  return ($self) unless defined $a || defined $p;\t\t# early out\n\n  # set A and set P is an fatal error\n  return ($self->bnan()) if defined $a && defined $p;\t\t# error\n\n  $r = ${\"$c\\::round_mode\"} unless defined $r;\n  if ($r !~ /^(even|odd|\\+inf|\\-inf|zero|trunc|common)$/)\n    {\n    require Carp; Carp::croak (\"Unknown round mode '$r'\");\n    }\n\n  $a = int($a) if defined $a;\n  $p = int($p) if defined $p;\n\n  ($self,$a,$p,$r);\n  }\n\nsub round\n  {\n  # Round $self according to given parameters, or given second argument's\n  # parameters or global defaults \n\n  # for speed reasons, _find_round_parameters is embedded here:\n\n  my ($self,$a,$p,$r,@args) = @_;\n  # $a accuracy, if given by caller\n  # $p precision, if given by caller\n  # $r round_mode, if given by caller\n  # @args all 'other' arguments (0 for unary, 1 for binary ops)\n\n  my $c = ref($self);\t\t\t\t# find out class of argument(s)\n  no strict 'refs';\n\n  # now pick $a or $p, but only if we have got \"arguments\"\n  if (!defined $a)\n    {\n    foreach ($self,@args)\n      {\n      # take the defined one, or if both defined, the one that is smaller\n      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);\n      }\n    }\n  if (!defined $p)\n    {\n    # even if $a is defined, take $p, to signal error for both defined\n    foreach ($self,@args)\n      {\n      # take the defined one, or if both defined, the one that is bigger\n      # -2 > -3, and 3 > 2\n      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);\n      }\n    }\n  # if still none defined, use globals (#2)\n  $a = ${\"$c\\::accuracy\"} unless defined $a;\n  $p = ${\"$c\\::precision\"} unless defined $p;\n \n  # A == 0 is useless, so undef it to signal no rounding\n  $a = undef if defined $a && $a == 0;\n  \n  # no rounding today? \n  return $self unless defined $a || defined $p;\t\t# early out\n\n  # set A and set P is an fatal error\n  return $self->bnan() if defined $a && defined $p;\n\n  $r = ${\"$c\\::round_mode\"} unless defined $r;\n  if ($r !~ /^(even|odd|\\+inf|\\-inf|zero|trunc|common)$/)\n    {\n    require Carp; Carp::croak (\"Unknown round mode '$r'\");\n    }\n\n  # now round, by calling either fround or ffround:\n  if (defined $a)\n    {\n    $self->bround(int($a),$r) if !defined $self->{_a} || $self->{_a} >= $a;\n    }\n  else # both can't be undefined due to early out\n    {\n    $self->bfround(int($p),$r) if !defined $self->{_p} || $self->{_p} <= $p;\n    }\n  # bround() or bfround() already called bnorm() if nec.\n  $self;\n  }\n\nsub bnorm\n  { \n  # (numstr or BINT) return BINT\n  # Normalize number -- no-op here\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n  $x;\n  }\n\nsub babs \n  {\n  # (BINT or num_str) return BINT\n  # make number absolute, or return absolute BINT from string\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  return $x if $x->modify('babs');\n  # post-normalized abs for internal use (does nothing for NaN)\n  $x->{sign} =~ s/^-/+/;\n  $x;\n  }\n\nsub bsgn {\n    # Signum function.\n\n    my $self = shift;\n\n    return $self if $self->modify('bsgn');\n\n    return $self -> bone(\"+\") if $self -> is_pos();\n    return $self -> bone(\"-\") if $self -> is_neg();\n    return $self;               # zero or NaN\n}\n\nsub bneg \n  { \n  # (BINT or num_str) return BINT\n  # negate number or make a negated number from string\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n  \n  return $x if $x->modify('bneg');\n\n  # for +0 dont negate (to have always normalized +0). Does nothing for 'NaN'\n  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));\n  $x;\n  }\n\nsub bcmp \n  {\n  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)\n  # (BINT or num_str, BINT or num_str) return cond_code\n  \n  # set up parameters\n  my ($self,$x,$y) = (ref($_[0]),@_);\n\n  # objectify is costly, so avoid it \n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y) = objectify(2,@_);\n    }\n\n  return $upgrade->bcmp($x,$y) if defined $upgrade &&\n    ((!$x->isa($self)) || (!$y->isa($self)));\n\n  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))\n    {\n    # handle +-inf and NaN\n    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));\n    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;\n    return +1 if $x->{sign} eq '+inf';\n    return -1 if $x->{sign} eq '-inf';\n    return -1 if $y->{sign} eq '+inf';\n    return +1;\n    }\n  # check sign for speed first\n  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';\t# does also 0 <=> -y\n  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0 \n\n  # have same sign, so compare absolute values. Don't make tests for zero here\n  # because it's actually slower than testin in Calc (especially w/ Pari et al)\n\n  # post-normalized compare for internal use (honors signs)\n  if ($x->{sign} eq '+') \n    {\n    # $x and $y both > 0\n    return $CALC->_acmp($x->{value},$y->{value});\n    }\n\n  # $x && $y both < 0\n  $CALC->_acmp($y->{value},$x->{value});\t# swaped acmp (lib returns 0,1,-1)\n  }\n\nsub bacmp \n  {\n  # Compares 2 values, ignoring their signs. \n  # Returns one of undef, <0, =0, >0. (suitable for sort)\n  # (BINT, BINT) return cond_code\n  \n  # set up parameters\n  my ($self,$x,$y) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it \n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y) = objectify(2,@_);\n    }\n\n  return $upgrade->bacmp($x,$y) if defined $upgrade &&\n    ((!$x->isa($self)) || (!$y->isa($self)));\n\n  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))\n    {\n    # handle +-inf and NaN\n    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));\n    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;\n    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;\n    return -1;\n    }\n  $CALC->_acmp($x->{value},$y->{value});\t# lib does only 0,1,-1\n  }\n\nsub badd \n  {\n  # add second arg (BINT or string) to first (BINT) (modifies first)\n  # return result as BINT\n\n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it \n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('badd');\n  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@r) if defined $upgrade &&\n    ((!$x->isa($self)) || (!$y->isa($self)));\n\n  $r[3] = $y;\t\t\t\t# no push!\n  # inf and NaN handling\n  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))\n    {\n    # NaN first\n    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));\n    # inf handling\n    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))\n      {\n      # +inf++inf or -inf+-inf => same, rest is NaN\n      return $x if $x->{sign} eq $y->{sign};\n      return $x->bnan();\n      }\n    # +-inf + something => +inf\n    # something +-inf => +-inf\n    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;\n    return $x;\n    }\n    \n  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); \t\t# get signs\n\n  if ($sx eq $sy)  \n    {\n    $x->{value} = $CALC->_add($x->{value},$y->{value});\t# same sign, abs add\n    }\n  else \n    {\n    my $a = $CALC->_acmp ($y->{value},$x->{value});\t# absolute compare\n    if ($a > 0)                           \n      {\n      $x->{valu", 8192) = 8192
09:01:57.222802 brk(0x11e5000)          = 0x11e5000
09:01:57.222959 read(16, "e} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap\n      $x->{sign} = $sy;\n      } \n    elsif ($a == 0)\n      {\n      # speedup, if equal, set result to 0\n      $x->{value} = $CALC->_zero();\n      $x->{sign} = '+';\n      }\n    else # a < 0\n      {\n      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub\n      }\n    }\n  $x->round(@r);\n  }\n\nsub bsub \n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # subtract second arg from first, modify first\n  \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bsub');\n\n  return $upgrade->new($x)->bsub($upgrade->new($y),@r) if defined $upgrade &&\n   ((!$x->isa($self)) || (!$y->isa($self)));\n\n  return $x->round(@r) if $y->is_zero();\n\n  # To correctly handle the lone special case $x->bsub($x), we note the sign\n  # of $x, then flip the sign from $y, and if the sign of $x did change, too,\n  # then we caught the special case:\n  my $xsign = $x->{sign};\n  $y->{sign} =~ tr/+\\-/-+/; \t# does nothing for NaN\n  if ($xsign ne $x->{sign})\n    {\n    # special case of $x->bsub($x) results in 0\n    return $x->bzero(@r) if $xsign =~ /^[+-]$/;\n    return $x->bnan();          # NaN, -inf, +inf\n    }\n  $x->badd($y,@r); \t\t# badd does not leave internal zeros\n  $y->{sign} =~ tr/+\\-/-+/; \t# refix $y (does nothing for NaN)\n  $x;\t\t\t\t# already rounded by badd() or no round nec.\n  }\n\nsub binc\n  {\n  # increment arg by one\n  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);\n  return $x if $x->modify('binc');\n\n  if ($x->{sign} eq '+')\n    {\n    $x->{value} = $CALC->_inc($x->{value});\n    return $x->round($a,$p,$r);\n    }\n  elsif ($x->{sign} eq '-')\n    {\n    $x->{value} = $CALC->_dec($x->{value});\n    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0\n    return $x->round($a,$p,$r);\n    }\n  # inf, nan handling etc\n  $x->badd($self->bone(),$a,$p,$r);\t\t# badd does round\n  }\n\nsub bdec\n  {\n  # decrement arg by one\n  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);\n  return $x if $x->modify('bdec');\n  \n  if ($x->{sign} eq '-')\n    {\n    # x already < 0\n    $x->{value} = $CALC->_inc($x->{value});\n    } \n  else\n    {\n    return $x->badd($self->bone('-'),@r) unless $x->{sign} eq '+'; \t# inf or NaN\n    # >= 0\n    if ($CALC->_is_zero($x->{value}))\n      {\n      # == 0\n      $x->{value} = $CALC->_one(); $x->{sign} = '-';\t\t# 0 => -1\n      }\n    else\n      {\n      # > 0\n      $x->{value} = $CALC->_dec($x->{value});\n      }\n    }\n  $x->round(@r);\n  }\n\nsub blog\n  {\n  # calculate $x = $a ** $base + $b and return $a (e.g. the log() to base\n  # $base of $x)\n\n  # set up parameters\n  my ($self,$x,$base,@r) = (undef,@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$base,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('blog');\n\n  $base = $self->new($base) if defined $base && !ref $base;\n\n  # inf, -inf, NaN, <0 => NaN\n  return $x->bnan()\n   if $x->{sign} ne '+' || (defined $base && $base->{sign} ne '+');\n\n  return $upgrade->blog($upgrade->new($x),$base,@r) if \n    defined $upgrade;\n\n  # fix for bug #24969:\n  # the default base is e (Euler's number) which is not an integer\n  if (!defined $base)\n    {\n    require Math::BigFloat;\n    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();\n    # modify $x in place\n    $x->{value} = $u->{value};\n    $x->{sign} = $u->{sign};\n    return $x;\n    }\n  \n  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});\n  return $x->bnan() unless defined $rc;\t\t# not possible to take log?\n  $x->{value} = $rc;\n  $x->round(@r);\n  }\n\nsub bnok\n  {\n  # Calculate n over k (binomial coefficient or \"choose\" function) as integer.\n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bnok');\n  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';\n  return $x->binf() if $x->{sign} eq '+inf';\n\n  # k > n or k < 0 => 0\n  my $cmp = $x->bacmp($y);\n  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;\n  # k == n => 1\n  return $x->bone(@r) if $cmp == 0;\n\n  if ($CALC->can('_nok'))\n    {\n    $x->{value} = $CALC->_nok($x->{value},$y->{value});\n    }\n  else\n    {\n    # ( 7 )       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7\n    # ( - ) = --------- =  --------------- = --------- = 5 * - * -\n    # ( 3 )   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3\n\n    if (!$y->is_zero())\n      {\n      my $z = $x - $y;\n      $z->binc();\n      my $r = $z->copy(); $z->binc();\n      my $d = $self->new(2);\n      while ($z->bacmp($x) <= 0)\t\t# f <= x ?\n        {\n        $r->bmul($z); $r->bdiv($d);\n        $z->binc(); $d->binc();\n        }\n      $x->{value} = $r->{value}; $x->{sign} = '+';\n      }\n    else { $x->bone(); }\n    }\n  $x->round(@r);\n  }\n\nsub bexp\n  {\n  # Calculate e ** $x (Euler's number to the power of X), truncated to\n  # an integer value.\n  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);\n  return $x if $x->modify('bexp');\n\n  # inf, -inf, NaN, <0 => NaN\n  return $x->bnan() if $x->{sign} eq 'NaN';\n  return $x->bone() if $x->is_zero();\n  return $x if $x->{sign} eq '+inf';\n  return $x->bzero() if $x->{sign} eq '-inf';\n\n  my $u;\n  {\n    # run through Math::BigFloat unless told otherwise\n    require Math::BigFloat unless defined $upgrade;\n    local $upgrade = 'Math::BigFloat' unless defined $upgrade;\n    # calculate result, truncate it to integer\n    $u = $upgrade->bexp($upgrade->new($x),@r);\n  }\n\n  if (!defined $upgrade)\n    {\n    $u = $u->as_int();\n    # modify $x in place\n    $x->{value} = $u->{value};\n    $x->round(@r);\n    }\n  else { $x = $u; }\n  }\n\nsub blcm\n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # does not modify arguments, but returns new object\n  # Lowest Common Multiple\n\n  my $y = shift; my ($x);\n  if (ref($y))\n    {\n    $x = $y->copy();\n    }\n  else\n    {\n    $x = $class->new($y);\n    }\n  my $self = ref($x);\n  while (@_) \n    {\n    my $y = shift; $y = $self->new($y) if !ref ($y);\n    $x = __lcm($x,$y);\n    } \n  $x;\n  }\n\nsub bgcd \n  { \n  # (BINT or num_str, BINT or num_str) return BINT\n  # does not modify arguments, but returns new object\n  # GCD -- Euclid's algorithm, variant C (Knuth Vol 3, pg 341 ff)\n\n  my $y = shift;\n  $y = $class->new($y) if !ref($y);\n  my $self = ref($y);\n  my $x = $y->copy()->babs();\t\t\t# keep arguments\n  return $x->bnan() if $x->{sign} !~ /^[+-]$/;\t# x NaN?\n\n  while (@_)\n    {\n    $y = shift; $y = $self->new($y) if !ref($y);\n    return $x->bnan() if $y->{sign} !~ /^[+-]$/;\t# y NaN?\n    $x->{value} = $CALC->_gcd($x->{value},$y->{value});\n    last if $CALC->_is_one($x->{value});\n    }\n  $x;\n  }\n\nsub bnot \n  {\n  # (num_str or BINT) return BINT\n  # represent ~x as twos-complement number\n  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster\n  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n \n  return $x if $x->modify('bnot');\n  $x->binc()->bneg();\t\t\t# binc already does round\n  }\n\n##############################################################################\n# is_foo test routines\n# we don't need $self, so undef instead of ref($_[0]) make it slightly faster\n\nsub is_zero\n  {\n  # return true if arg (BINT or num_str) is zero (array '+', '0')\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n  \n  return 0 if $x->{sign} !~ /^\\+$/;\t\t\t# -, NaN & +-inf aren't\n  $CALC->_is_zero($x->{value});\n  }\n\nsub is_nan\n  {\n  # return true if arg (BINT or num_str) is NaN\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  $x->{sign} eq $nan ? 1 : 0;\n  }\n\nsub is_inf\n  {\n  # return true if arg (BINT or num_str) is +-inf\n  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  if (defined $sign)\n    {\n    $sign = '[+-]inf' if $sign eq '';\t# +- doesn't matter, only that's inf\n    $sign = \"[$1]inf\" if $sign =~ /^([+-])(inf)?$/;\t# extract '+' or '-'\n    return $x->{sign} =~ /^$sign$/ ? 1", 8192) = 8192
09:01:57.224027 brk(0x1206000)          = 0x1206000
09:01:57.224333 read(16, " : 0;\n    }\n  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;\t\t# only +-inf is infinity\n  }\n\nsub is_one\n  {\n  # return true if arg (BINT or num_str) is +1, or -1 if sign is given\n  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n    \n  $sign = '+' if !defined $sign || $sign ne '-';\n \n  return 0 if $x->{sign} ne $sign; \t# -1 != +1, NaN, +-inf aren't either\n  $CALC->_is_one($x->{value});\n  }\n\nsub is_odd\n  {\n  # return true when arg (BINT or num_str) is odd, false for even\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  return 0 if $x->{sign} !~ /^[+-]$/;\t\t\t# NaN & +-inf aren't\n  $CALC->_is_odd($x->{value});\n  }\n\nsub is_even\n  {\n  # return true when arg (BINT or num_str) is even, false for odd\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  return 0 if $x->{sign} !~ /^[+-]$/;\t\t\t# NaN & +-inf aren't\n  $CALC->_is_even($x->{value});\n  }\n\nsub is_positive\n  {\n  # return true when arg (BINT or num_str) is positive (> 0)\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  return 1 if $x->{sign} eq '+inf';\t\t\t# +inf is positive\n\n  # 0+ is neither positive nor negative\n  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;\n  }\n\nsub is_negative\n  {\n  # return true when arg (BINT or num_str) is negative (< 0)\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n  \n  $x->{sign} =~ /^-/ ? 1 : 0; \t\t# -inf is negative, but NaN is not\n  }\n\nsub is_int\n  {\n  # return true when arg (BINT or num_str) is an integer\n  # always true for BigInt, but different for BigFloats\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n  \n  $x->{sign} =~ /^[+-]$/ ? 1 : 0;\t\t# inf/-inf/NaN aren't\n  }\n\n###############################################################################\n\nsub bmul \n  { \n  # multiply the first number by the second number\n  # (BINT or num_str, BINT or num_str) return BINT\n\n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bmul');\n\n  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));\n\n  # inf handling\n  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))\n    {\n    return $x->bnan() if $x->is_zero() || $y->is_zero();\n    # result will always be +-inf:\n    # +inf * +/+inf => +inf, -inf * -/-inf => +inf\n    # +inf * -/-inf => -inf, -inf * +/+inf => -inf\n    return $x->binf() if ($x->{sign} =~ /^\\+/ && $y->{sign} =~ /^\\+/); \n    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); \n    return $x->binf('-');\n    }\n\n  return $upgrade->bmul($x,$upgrade->new($y),@r)\n   if defined $upgrade && !$y->isa($self);\n  \n  $r[3] = $y;\t\t\t\t# no push here\n\n  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +\n\n  $x->{value} = $CALC->_mul($x->{value},$y->{value});\t# do actual math\n  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); \t# no -0\n\n  $x->round(@r);\n  }\n\nsub bmuladd\n  { \n  # multiply two numbers and then add the third to the result\n  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT\n\n  # set up parameters\n  my ($self,$x,$y,$z,@r) = objectify(3,@_);\n\n  return $x if $x->modify('bmuladd');\n\n  return $x->bnan() if  ($x->{sign} eq $nan) ||\n\t\t\t($y->{sign} eq $nan) ||\n\t\t\t($z->{sign} eq $nan);\n\n  # inf handling of x and y\n  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))\n    {\n    return $x->bnan() if $x->is_zero() || $y->is_zero();\n    # result will always be +-inf:\n    # +inf * +/+inf => +inf, -inf * -/-inf => +inf\n    # +inf * -/-inf => -inf, -inf * +/+inf => -inf\n    return $x->binf() if ($x->{sign} =~ /^\\+/ && $y->{sign} =~ /^\\+/); \n    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); \n    return $x->binf('-');\n    }\n  # inf handling x*y and z\n  if (($z->{sign} =~ /^[+-]inf$/))\n    {\n    # something +-inf => +-inf\n    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;\n    }\n\n  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@r)\n   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));\n \n  # TODO: what if $y and $z have A or P set?\n  $r[3] = $z;\t\t\t\t# no push here\n\n  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +\n\n  $x->{value} = $CALC->_mul($x->{value},$y->{value});\t# do actual math\n  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); \t# no -0\n\n  my ($sx, $sz) = ( $x->{sign}, $z->{sign} ); \t\t# get signs\n\n  if ($sx eq $sz)  \n    {\n    $x->{value} = $CALC->_add($x->{value},$z->{value});\t# same sign, abs add\n    }\n  else \n    {\n    my $a = $CALC->_acmp ($z->{value},$x->{value});\t# absolute compare\n    if ($a > 0)                           \n      {\n      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap\n      $x->{sign} = $sz;\n      } \n    elsif ($a == 0)\n      {\n      # speedup, if equal, set result to 0\n      $x->{value} = $CALC->_zero();\n      $x->{sign} = '+';\n      }\n    else # a < 0\n      {\n      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub\n      }\n    }\n  $x->round(@r);\n  }\n\nsub _div_inf\n  {\n  # helper function that handles +-inf cases for bdiv()/bmod() to reuse code\n  my ($self,$x,$y) = @_;\n\n  # NaN if x == NaN or y == NaN or x==y==0\n  return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan()\n   if (($x->is_nan() || $y->is_nan())   ||\n       ($x->is_zero() && $y->is_zero()));\n \n  # +-inf / +-inf == NaN, remainder also NaN\n  if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))\n    {\n    return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan();\n    }\n  # x / +-inf => 0, remainder x (works even if x == 0)\n  if ($y->{sign} =~ /^[+-]inf$/)\n    {\n    my $t = $x->copy();\t\t# bzero clobbers up $x\n    return wantarray ? ($x->bzero(),$t) : $x->bzero()\n    }\n  \n  # 5 / 0 => +inf, -6 / 0 => -inf\n  # +inf / 0 = inf, inf,  and -inf / 0 => -inf, -inf \n  # exception:   -8 / 0 has remainder -8, not 8\n  # exception: -inf / 0 has remainder -inf, not inf\n  if ($y->is_zero())\n    {\n    # +-inf / 0 => special case for -inf\n    return wantarray ?  ($x,$x->copy()) : $x if $x->is_inf();\n    if (!$x->is_zero() && !$x->is_inf())\n      {\n      my $t = $x->copy();\t\t# binf clobbers up $x\n      return wantarray ?\n       ($x->binf($x->{sign}),$t) : $x->binf($x->{sign})\n      }\n    }\n  \n  # last case: +-inf / ordinary number\n  my $sign = '+inf';\n  $sign = '-inf' if substr($x->{sign},0,1) ne $y->{sign};\n  $x->{sign} = $sign;\n  return wantarray ? ($x,$self->bzero()) : $x;\n  }\n\nsub bdiv \n  {\n  # (dividend: BINT or num_str, divisor: BINT or num_str) return \n  # (BINT,BINT) (quo,rem) or BINT (only rem)\n  \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it \n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    } \n\n  return $x if $x->modify('bdiv');\n\n  return $self->_div_inf($x,$y)\n   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());\n\n  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@r)\n   if defined $upgrade;\n   \n  $r[3] = $y;\t\t\t\t\t# no push!\n\n  # calc new sign and in case $y == +/- 1, return $x\n  my $xsign = $x->{sign};\t\t\t\t# keep\n  $x->{sign} = ($x->{sign} ne $y->{sign} ? '-' : '+'); \n\n  if (wantarray)\n    {\n    my $rem = $self->bzero(); \n    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});\n    $x->{sign} = '+' if $CALC->_is_zero($x->{value});\n    $rem->{_a} = $x->{_a};\n    $rem->{_p} = $x->{_p};\n    $x->round(@r);\n    if (! $CALC->_is_zero($rem->{value}))\n      {\n      $rem->{sign} = $y->{sign};\n      $rem = $y->copy()->bsub($rem) if $xsign ne $y->{sign}; # one of them '-'\n      }\n    else\n      {\n      $rem->{sign} = '+';\t\t\t# dont leave -0\n      }\n    $rem->round(@r);\n    return ($x,$rem);\n    }\n\n  $x->{value} = $CALC->_div($x->{value},$y->{value});\n  $x->{sign} = '+' if $CALC->_is_zero($x->{value});\n\n  $x->round(@r);\n  }\n\n###############################################################################\n# modulus functions\n\nsub bmod \n  {\n  # modulus (or remainder)\n  # (BINT or num_str, BINT or num_str) return BINT\n  \n  # set up parameters\n  my ($self,$x,$y,@r)", 8192) = 8192
09:01:57.225243 brk(0x1227000)          = 0x1227000
09:01:57.225728 read(16, " = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bmod');\n  $r[3] = $y;\t\t\t\t\t# no push!\n  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero())\n    {\n    my ($d,$r) = $self->_div_inf($x,$y);\n    $x->{sign} = $r->{sign};\n    $x->{value} = $r->{value};\n    return $x->round(@r);\n    }\n\n  # calc new sign and in case $y == +/- 1, return $x\n  $x->{value} = $CALC->_mod($x->{value},$y->{value});\n  if (!$CALC->_is_zero($x->{value}))\n    {\n    $x->{value} = $CALC->_sub($y->{value},$x->{value},1) \t# $y-$x\n      if ($x->{sign} ne $y->{sign});\n    $x->{sign} = $y->{sign};\n    }\n   else\n    {\n    $x->{sign} = '+';\t\t\t\t# dont leave -0\n    }\n  $x->round(@r);\n  }\n\nsub bmodinv\n  {\n  # Return modular multiplicative inverse: z is the modular inverse of x (mod\n  # y) if and only if x*z (mod y) = 1 (mod y). If the modulus y is larger than\n  # one, x and z are relative primes (i.e., their greatest common divisor is\n  # one).\n  #\n  # If no modular multiplicative inverse exists, NaN is returned.\n\n  # set up parameters\n  my ($self,$x,$y,@r) = (undef,@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bmodinv');\n\n  # Return NaN if one or both arguments is +inf, -inf, or nan.\n\n  return $x->bnan() if ($y->{sign} !~ /^[+-]$/ ||\n                        $x->{sign} !~ /^[+-]$/);\n\n  # Return NaN if $y is zero; 1 % 0 makes no sense.\n\n  return $x->bnan() if $y->is_zero();\n\n  # Return 0 in the trivial case. $x % 1 or $x % -1 is zero for all finite\n  # integers $x.\n\n  return $x->bzero() if ($y->is_one() ||\n                         $y->is_one('-'));\n\n  # Return NaN if $x = 0, or $x modulo $y is zero. The only valid case when\n  # $x = 0 is when $y = 1 or $y = -1, but that was covered above.\n  #\n  # Note that computing $x modulo $y here affects the value we'll feed to\n  # $CALC->_modinv() below when $x and $y have opposite signs. E.g., if $x =\n  # 5 and $y = 7, those two values are fed to _modinv(), but if $x = -5 and\n  # $y = 7, the values fed to _modinv() are $x = 2 (= -5 % 7) and $y = 7.\n  # The value if $x is affected only when $x and $y have opposite signs.\n\n  $x->bmod($y);\n  return $x->bnan() if $x->is_zero();\n\n  # Compute the modular multiplicative inverse of the absolute values. We'll\n  # correct for the signs of $x and $y later. Return NaN if no GCD is found.\n\n  ($x->{value}, $x->{sign}) = $CALC->_modinv($x->{value}, $y->{value});\n  return $x->bnan() if !defined $x->{value};\n\n  # Library inconsistency workaround: _modinv() in Math::BigInt::GMP versions\n  # <= 1.32 return undef rather than a \"+\" for the sign.\n\n  $x->{sign} = '+' unless defined $x->{sign};\n\n  # When one or both arguments are negative, we have the following\n  # relations.  If x and y are positive:\n  #\n  #   modinv(-x, -y) = -modinv(x, y)\n  #   modinv(-x,  y) = y - modinv(x, y)  = -modinv(x, y) (mod y)\n  #   modinv( x, -y) = modinv(x, y) - y  =  modinv(x, y) (mod -y)\n\n  # We must swap the sign of the result if the original $x is negative.\n  # However, we must compensate for ignoring the signs when computing the\n  # inverse modulo. The net effect is that we must swap the sign of the\n  # result if $y is negative.\n\n  $x -> bneg() if $y->{sign} eq '-';\n\n  # Compute $x modulo $y again after correcting the sign.\n\n  $x -> bmod($y) if $x->{sign} ne $y->{sign};\n\n  return $x;\n  }\n\nsub bmodpow\n  {\n  # Modular exponentiation. Raises a very large number to a very large exponent\n  # in a given very large modulus quickly, thanks to binary exponentiation.\n  # Supports negative exponents.\n  my ($self,$num,$exp,$mod,@r) = objectify(3,@_);\n\n  return $num if $num->modify('bmodpow');\n\n  # When the exponent 'e' is negative, use the following relation, which is\n  # based on finding the multiplicative inverse 'd' of 'b' modulo 'm':\n  #\n  #    b^(-e) (mod m) = d^e (mod m) where b*d = 1 (mod m)\n\n  $num->bmodinv($mod) if ($exp->{sign} eq '-');\n\n  # Check for valid input. All operands must be finite, and the modulus must be\n  # non-zero.\n\n  return $num->bnan() if ($num->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf\n                          $exp->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf\n                          $mod->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf\n                          $mod->is_zero());\n\n  # Compute 'a (mod m)', ignoring the signs on 'a' and 'm'. If the resulting\n  # value is zero, the output is also zero, regardless of the signs on 'a' and\n  # 'm'.\n\n  my $value = $CALC->_modpow($num->{value}, $exp->{value}, $mod->{value});\n  my $sign  = '+';\n\n  # If the resulting value is non-zero, we have four special cases, depending\n  # on the signs on 'a' and 'm'.\n\n  unless ($CALC->_is_zero($value)) {\n\n      # There is a negative sign on 'a' (= $num**$exp) only if the number we\n      # are exponentiating ($num) is negative and the exponent ($exp) is odd.\n\n      if ($num->{sign} eq '-' && $exp->is_odd()) {\n\n          # When both the number 'a' and the modulus 'm' have a negative sign,\n          # use this relation:\n          #\n          #    -a (mod -m) = -(a (mod m))\n\n          if ($mod->{sign} eq '-') {\n              $sign = '-';\n          }\n\n          # When only the number 'a' has a negative sign, use this relation:\n          #\n          #    -a (mod m) = m - (a (mod m))\n\n          else {\n              # Use copy of $mod since _sub() modifies the first argument.\n              my $mod = $CALC->_copy($mod->{value});\n              $value = $CALC->_sub($mod, $value);\n              $sign  = '+';\n          }\n\n      } else {\n\n          # When only the modulus 'm' has a negative sign, use this relation:\n          #\n          #    a (mod -m) = (a (mod m)) - m\n          #               = -(m - (a (mod m)))\n\n          if ($mod->{sign} eq '-') {\n              # Use copy of $mod since _sub() modifies the first argument.\n              my $mod = $CALC->_copy($mod->{value});\n              $value = $CALC->_sub($mod, $value);\n              $sign  = '-';\n          }\n\n          # When neither the number 'a' nor the modulus 'm' have a negative\n          # sign, directly return the already computed value.\n          #\n          #    (a (mod m))\n\n      }\n\n  }\n\n  $num->{value} = $value;\n  $num->{sign}  = $sign;\n\n  return $num;\n  }\n\n###############################################################################\n\nsub bfac\n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # compute factorial number from $x, modify $x in place\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';\t# inf => inf\n  return $x->bnan() if $x->{sign} ne '+';\t\t\t# NaN, <0 etc => NaN\n\n  $x->{value} = $CALC->_fac($x->{value});\n  $x->round(@r);\n  }\n \nsub bpow \n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233\n  # modifies first argument\n\n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bpow');\n\n  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;\n\n  # inf handling\n  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))\n    {\n    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))\n      {\n      # +-inf ** +-inf\n      return $x->bnan();\n      }\n    # +-inf ** Y\n    if ($x->{sign} =~ /^[+-]inf/)\n      {\n      # +inf ** 0 => NaN\n      return $x->bnan() if $y->is_zero();\n      # -inf ** -1 => 1/inf => 0\n      return $x->bzero() if $y->is_one('-') && $x->is_negative();\n\n      # +inf ** Y => inf\n      return $x if $x->{sign} eq '+inf';\n\n      # -inf ** Y => -inf if Y is odd\n      return $x if $y->is_odd();\n      return $x->babs();\n      }\n    # X ** +-inf\n\n    # 1 ** +inf => 1\n    return $x if $x->is_one();\n    \n    # 0 ** inf => 0\n    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;\n\n    # 0 ** -inf => inf\n    return $x->binf() if $x->is_zero();\n\n    # -1 ** ", 8192) = 8192
09:01:57.226465 brk(0x1248000)          = 0x1248000
09:01:57.226795 read(16, "-inf => NaN\n    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;\n\n    # -X ** -inf => 0\n    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;\n\n    # -1 ** inf => NaN\n    return $x->bnan() if $x->{sign} eq '-';\n\n    # X ** inf => inf\n    return $x->binf() if $y->{sign} =~ /^[+]/;\n    # X ** -inf => 0\n    return $x->bzero();\n    }\n\n  return $upgrade->bpow($upgrade->new($x),$y,@r)\n   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');\n\n  $r[3] = $y;\t\t\t\t\t# no push!\n\n  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu\n\n  my $new_sign = '+';\n  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+'); \n\n  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf \n  return $x->binf() \n    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});\n  # 1 ** -y => 1 / (1 ** |y|)\n  # so do test for negative $y after above's clause\n  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});\n\n  $x->{value} = $CALC->_pow($x->{value},$y->{value});\n  $x->{sign} = $new_sign;\n  $x->{sign} = '+' if $CALC->_is_zero($y->{value});\n  $x->round(@r);\n  }\n\nsub blsft \n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # compute x << y, base n, y >= 0\n \n  # set up parameters\n  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,$n,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('blsft');\n  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);\n  return $x->round(@r) if $y->is_zero();\n\n  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';\n\n  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);\n  $x->round(@r);\n  }\n\nsub brsft \n  {\n  # (BINT or num_str, BINT or num_str) return BINT\n  # compute x >> y, base n, y >= 0\n  \n  # set up parameters\n  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,$n,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('brsft');\n  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);\n  return $x->round(@r) if $y->is_zero();\n  return $x->bzero(@r) if $x->is_zero();\t\t# 0 => 0\n\n  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';\n\n   # this only works for negative numbers when shifting in base 2\n  if (($x->{sign} eq '-') && ($n == 2))\n    {\n    return $x->round(@r) if $x->is_one('-');\t# -1 => -1\n    if (!$y->is_one())\n      {\n      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al\n      # but perhaps there is a better emulation for two's complement shift...\n      # if $y != 1, we must simulate it by doing:\n      # convert to bin, flip all bits, shift, and be done\n      $x->binc();\t\t\t# -3 => -2\n      my $bin = $x->as_bin();\n      $bin =~ s/^-0b//;\t\t\t# strip '-0b' prefix\n      $bin =~ tr/10/01/;\t\t# flip bits\n      # now shift\n      if ($y >= CORE::length($bin))\n        {\n\t$bin = '0'; \t\t\t# shifting to far right creates -1\n\t\t\t\t\t# 0, because later increment makes \n\t\t\t\t\t# that 1, attached '-' makes it '-1'\n\t\t\t\t\t# because -1 >> x == -1 !\n        } \n      else\n\t{\n\t$bin =~ s/.{$y}$//;\t\t# cut off at the right side\n        $bin = '1' . $bin;\t\t# extend left side by one dummy '1'\n        $bin =~ tr/10/01/;\t\t# flip bits back\n\t}\n      my $res = $self->new('0b'.$bin);\t# add prefix and convert back\n      $res->binc();\t\t\t# remember to increment\n      $x->{value} = $res->{value};\t# take over value\n      return $x->round(@r);\t\t# we are done now, magic, isn't?\n      }\n    # x < 0, n == 2, y == 1\n    $x->bdec();\t\t\t\t# n == 2, but $y == 1: this fixes it\n    }\n\n  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);\n  $x->round(@r);\n  }\n\nsub band \n  {\n  #(BINT or num_str, BINT or num_str) return BINT\n  # compute x & y\n \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n  \n  return $x if $x->modify('band');\n\n  $r[3] = $y;\t\t\t\t# no push!\n\n  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);\n\n  my $sx = $x->{sign} eq '+' ? 1 : -1;\n  my $sy = $y->{sign} eq '+' ? 1 : -1;\n  \n  if ($sx == 1 && $sy == 1)\n    {\n    $x->{value} = $CALC->_and($x->{value},$y->{value});\n    return $x->round(@r);\n    }\n  \n  if ($CAN{signed_and})\n    {\n    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);\n    return $x->round(@r);\n    }\n \n  require $EMU_LIB;\n  __emu_band($self,$x,$y,$sx,$sy,@r);\n  }\n\nsub bior \n  {\n  #(BINT or num_str, BINT or num_str) return BINT\n  # compute x | y\n  \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bior');\n  $r[3] = $y;\t\t\t\t# no push!\n\n  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);\n\n  my $sx = $x->{sign} eq '+' ? 1 : -1;\n  my $sy = $y->{sign} eq '+' ? 1 : -1;\n\n  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()\n  \n  # don't use lib for negative values\n  if ($sx == 1 && $sy == 1)\n    {\n    $x->{value} = $CALC->_or($x->{value},$y->{value});\n    return $x->round(@r);\n    }\n\n  # if lib can do negative values, let it handle this\n  if ($CAN{signed_or})\n    {\n    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);\n    return $x->round(@r);\n    }\n\n  require $EMU_LIB;\n  __emu_bior($self,$x,$y,$sx,$sy,@r);\n  }\n\nsub bxor \n  {\n  #(BINT or num_str, BINT or num_str) return BINT\n  # compute x ^ y\n  \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$x,$y,@r) = objectify(2,@_);\n    }\n\n  return $x if $x->modify('bxor');\n  $r[3] = $y;\t\t\t\t# no push!\n\n  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);\n  \n  my $sx = $x->{sign} eq '+' ? 1 : -1;\n  my $sy = $y->{sign} eq '+' ? 1 : -1;\n\n  # don't use lib for negative values\n  if ($sx == 1 && $sy == 1)\n    {\n    $x->{value} = $CALC->_xor($x->{value},$y->{value});\n    return $x->round(@r);\n    }\n  \n  # if lib can do negative values, let it handle this\n  if ($CAN{signed_xor})\n    {\n    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);\n    return $x->round(@r);\n    }\n\n  require $EMU_LIB;\n  __emu_bxor($self,$x,$y,$sx,$sy,@r);\n  }\n\nsub length\n  {\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  my $e = $CALC->_len($x->{value}); \n  wantarray ? ($e,0) : $e;\n  }\n\nsub digit\n  {\n  # return the nth decimal digit, negative values count backward, 0 is right\n  my ($self,$x,$n) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  $n = $n->numify() if ref($n);\n  $CALC->_digit($x->{value},$n||0);\n  }\n\nsub _trailing_zeros\n  {\n  # return the amount of trailing zeros in $x (as scalar)\n  my $x = shift;\n  $x = $class->new($x) unless ref $x;\n\n  return 0 if $x->{sign} !~ /^[+-]$/;\t# NaN, inf, -inf etc\n\n  $CALC->_zeros($x->{value});\t\t# must handle odd values, 0 etc\n  }\n\nsub bsqrt\n  {\n  # calculate square root of $x\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  return $x if $x->modify('bsqrt');\n\n  return $x->bnan() if $x->{sign} !~ /^\\+/;\t# -x or -inf or NaN => NaN\n  return $x if $x->{sign} eq '+inf';\t\t# sqrt(+inf) == inf\n\n  return $upgrade->bsqrt($x,@r) if defined $upgrade;\n\n  $x->{value} = $CALC->_sqrt($x->{value});\n  $x->round(@r);\n  }\n\nsub broot\n  {\n  # calculate $y'th root of $x\n \n  # set up parameters\n  my ($self,$x,$y,@r) = (ref($_[0]),@_);\n\n  $y = $self->new(2) unless defined $y;\n\n  # objectify is costly, so avoid it\n  if ((!ref($x)) || (ref($x) ne ref($y)))\n    {\n    ($self,$x,$y,@r) = objectify(2,$self || $class,@_);\n    }\n\n  return $x if $x->modify('broot');\n\n  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0\n  return $x->bnan() if $x->{sign} !~ /^\\+/ || $y->is_zero() ||\n         $y->{sign} !~ /^\\+$/;\n\n  return $x->round(@r)\n    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();\n\n  return $upgrade->new($x)->broo", 8192) = 8192
09:01:57.227673 brk(0x1269000)          = 0x1269000
09:01:57.228267 read(16, "t($upgrade->new($y),@r) if defined $upgrade;\n\n  $x->{value} = $CALC->_root($x->{value},$y->{value});\n  $x->round(@r);\n  }\n\nsub exponent\n  {\n  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)\n  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);\n \n  if ($x->{sign} !~ /^[+-]$/)\n    {\n    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf\n    return $self->new($s);\n    }\n  return $self->bone() if $x->is_zero();\n\n  # 12300 => 2 trailing zeros => exponent is 2\n  $self->new( $CALC->_zeros($x->{value}) );\n  }\n\nsub mantissa\n  {\n  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)\n  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);\n\n  if ($x->{sign} !~ /^[+-]$/)\n    {\n    # for NaN, +inf, -inf: keep the sign\n    return $self->new($x->{sign});\n    }\n  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};\n\n  # that's a bit inefficient:\n  my $zeros = $CALC->_zeros($m->{value});\n  $m->brsft($zeros,10) if $zeros != 0;\n  $m;\n  }\n\nsub parts\n  {\n  # return a copy of both the exponent and the mantissa\n  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);\n\n  ($x->mantissa(),$x->exponent());\n  }\n   \n##############################################################################\n# rounding functions\n\nsub bfround\n  {\n  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'\n  # $n == 0 || $n == 1 => round to integer\n  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;\n\n  my ($scale,$mode) = $x->_scale_p(@_);\n\n  return $x if !defined $scale || $x->modify('bfround');\t# no-op\n\n  # no-op for BigInts if $n <= 0\n  $x->bround( $x->length()-$scale, $mode) if $scale > 0;\n\n  delete $x->{_a};\t# delete to save memory\n  $x->{_p} = $scale;\t# store new _p\n  $x;\n  }\n\nsub _scan_for_nonzero\n  {\n  # internal, used by bround() to scan for non-zeros after a '5'\n  my ($x,$pad,$xs,$len) = @_;\n \n  return 0 if $len == 1;\t\t# \"5\" is trailed by invisible zeros\n  my $follow = $pad - 1;\n  return 0 if $follow > $len || $follow < 1;\n\n  # use the string form to check whether only '0's follow or not\n  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;\n  }\n\nsub fround\n  {\n  # Exists to make life easier for switch between MBF and MBI (should we\n  # autoload fxxx() like MBF does for bxxx()?)\n  my $x = shift; $x = $class->new($x) unless ref $x;\n  $x->bround(@_);\n  }\n\nsub bround\n  {\n  # accuracy: +$n preserve $n digits from left,\n  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)\n  # no-op for $n == 0\n  # and overwrite the rest with 0's, return normalized number\n  # do not return $x->bnorm(), but $x\n\n  my $x = shift; $x = $class->new($x) unless ref $x;\n  my ($scale,$mode) = $x->_scale_a(@_);\n  return $x if !defined $scale || $x->modify('bround');\t# no-op\n  \n  if ($x->is_zero() || $scale == 0)\n    {\n    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2\n    return $x;\n    }\n  return $x if $x->{sign} !~ /^[+-]$/;\t\t# inf, NaN\n\n  # we have fewer digits than we want to scale to\n  my $len = $x->length();\n  # convert $scale to a scalar in case it is an object (put's a limit on the\n  # number length, but this would already limited by memory constraints), makes\n  # it faster\n  $scale = $scale->numify() if ref ($scale);\n\n  # scale < 0, but > -len (not >=!)\n  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))\n    {\n    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2\n    return $x; \n    }\n   \n  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6\n  my ($pad,$digit_round,$digit_after);\n  $pad = $len - $scale;\n  $pad = abs($scale-1) if $scale < 0;\n\n  # do not use digit(), it is very costly for binary => decimal\n  # getting the entire string is also costly, but we need to do it only once\n  my $xs = $CALC->_str($x->{value});\n  my $pl = -$pad-1;\n\n  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4\n  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3\n  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;\n  $pl++; $pl ++ if $pad >= $len;\n  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;\n\n  # in case of 01234 we round down, for 6789 up, and only in case 5 we look\n  # closer at the remaining digits of the original $x, remember decision\n  my $round_up = 1;\t\t\t\t\t# default round up\n  $round_up -- if\n    ($mode eq 'trunc')\t\t\t\t||\t# trunc by round down\n    ($digit_after =~ /[01234]/)\t\t\t|| \t# round down anyway,\n\t\t\t\t\t\t\t# 6789 => round up\n    ($digit_after eq '5')\t\t\t&&\t# not 5000...0000\n    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)\t\t&&\n    (\n     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||\n     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||\n     ($mode eq '+inf') && ($x->{sign} eq '-')   ||\n     ($mode eq '-inf') && ($x->{sign} eq '+')   ||\n     ($mode eq 'zero')\t\t# round down if zero, sign adjusted below\n    );\n  my $put_back = 0;\t\t\t\t\t# not yet modified\n\t\n  if (($pad > 0) && ($pad <= $len))\n    {\n    substr($xs,-$pad,$pad) = '0' x $pad;\t\t# replace with '00...'\n    $put_back = 1;\t\t\t\t\t# need to put back\n    }\n  elsif ($pad > $len)\n    {\n    $x->bzero();\t\t\t\t\t# round to '0'\n    }\n\n  if ($round_up)\t\t\t\t\t# what gave test above?\n    {\n    $put_back = 1;\t\t\t\t\t# need to put back\n    $pad = $len, $xs = '0' x $pad if $scale < 0;\t# tlr: whack 0.51=>1.0\t\n\n    # we modify directly the string variant instead of creating a number and\n    # adding it, since that is faster (we already have the string)\n    my $c = 0; $pad ++;\t\t\t\t# for $pad == $len case\n    while ($pad <= $len)\n      {\n      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';\n      substr($xs,-$pad,1) = $c; $pad++;\n      last if $c != 0;\t\t\t\t# no overflow => early out\n      }\n    $xs = '1'.$xs if $c == 0;\n\n    }\n  $x->{value} = $CALC->_new($xs) if $put_back == 1;\t# put back, if needed\n\n  $x->{_a} = $scale if $scale >= 0;\n  if ($scale < 0)\n    {\n    $x->{_a} = $len+$scale;\n    $x->{_a} = 0 if $scale < -$len;\n    }\n  $x;\n  }\n\nsub bfloor\n  {\n  # return integer less or equal then number; no-op since it's already integer\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  $x->round(@r);\n  }\n\nsub bceil\n  {\n  # return integer greater or equal then number; no-op since it's already int\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  $x->round(@r);\n  }\n\nsub as_number\n  {\n  # An object might be asked to return itself as bigint on certain overloaded\n  # operations. This does exactly this, so that sub classes can simple inherit\n  # it or override with their own integer conversion routine.\n  $_[0]->copy();\n  }\n\nsub as_hex\n  {\n  # return as hex string, with prefixed 0x\n  my $x = shift; $x = $class->new($x) if !ref($x);\n\n  return $x->bstr() if $x->{sign} !~ /^[+-]$/;\t# inf, nan etc\n\n  my $s = '';\n  $s = $x->{sign} if $x->{sign} eq '-';\n  $s . $CALC->_as_hex($x->{value});\n  }\n\nsub as_bin\n  {\n  # return as binary string, with prefixed 0b\n  my $x = shift; $x = $class->new($x) if !ref($x);\n\n  return $x->bstr() if $x->{sign} !~ /^[+-]$/;\t# inf, nan etc\n\n  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';\n  return $s . $CALC->_as_bin($x->{value});\n  }\n\nsub as_oct\n  {\n  # return as octal string, with prefixed 0\n  my $x = shift; $x = $class->new($x) if !ref($x);\n\n  return $x->bstr() if $x->{sign} !~ /^[+-]$/;\t# inf, nan etc\n\n  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';\n  return $s . $CALC->_as_oct($x->{value});\n  }\n\n##############################################################################\n# private stuff (internal use only)\n\nsub objectify {\n    # Convert strings and \"foreign objects\" to the objects we want.\n\n    # The first argument, $count, is the number of following arguments that\n    # objectify() looks at and converts to objects. The first is a classname.\n    # If the given count is 0, all arguments will be used.\n\n    # After the count is read, objectify obtains the name of the class to which\n    # the following arguments are converted. If the second argument is a\n    # reference, use the reference type as the class name. Otherwise, if it is\n    # a string that looks like a class name, use that. Otherwise, use $class.\n\n    # Caller:                        Gives us:\n", 8192) = 8192
09:01:57.228940 brk(0x128a000)          = 0x128a000
09:01:57.229481 read(16, "    #\n    # $x->badd(1);                => ref x, scalar y\n    # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y\n    # Class->badd(Class->(1),2);  => classname x (scalar), ref x, scalar y\n    # Math::BigInt::badd(1,2);    => scalar x, scalar y\n\n    # A shortcut for the common case $x->unary_op():\n\n    return (ref($_[1]), $_[1]) if (@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);\n\n    # Check the context.\n\n    unless (wantarray) {\n        require Carp;\n        Carp::croak (\"${class}::objectify() needs list context\");\n    }\n\n    # Get the number of arguments to objectify.\n\n    my $count = shift;\n    $count ||= @_;\n\n    # Initialize the output array.\n\n    my @a = @_;\n\n    # If the first argument is a reference, use that reference type as our\n    # class name. Otherwise, if the first argument looks like a class name,\n    # then use that as our class name. Otherwise, use the default class name.\n\n    {\n        if (ref($a[0])) {               # reference?\n            unshift @a, ref($a[0]);\n            last;\n        }\n        if ($a[0] =~ /^[A-Z].*::/) {    # string with class name?\n            last;\n        }\n        unshift @a, $class;             # default class name\n    }\n\n    no strict 'refs';\n\n    # What we upgrade to, if anything.\n\n    my $up = ${\"$a[0]::upgrade\"};\n\n    # Disable downgrading, because Math::BigFloat -> foo('1.0','2.0') needs\n    # floats.\n\n    my $down;\n    if (defined ${\"$a[0]::downgrade\"}) {\n        $down = ${\"$a[0]::downgrade\"};\n        ${\"$a[0]::downgrade\"} = undef;\n    }\n\n    for my $i (1 .. $count) {\n        my $ref = ref $a[$i];\n\n        # If it is an object of the right class, all is fine.\n\n        if ($ref eq $a[0]) {\n            next;\n        }\n\n        # Don't do anything with undefs.\n\n        unless (defined($a[$i])) {\n            next;\n        }\n\n        # Perl scalars are fed to the appropriate constructor.\n\n        unless ($ref) {\n            $a[$i] = $a[0] -> new($a[$i]);\n            next;\n        }\n\n        # Upgrading is OK, so skip further tests if the argument is upgraded.\n\n        if (defined $up && $ref eq $up) {\n            next;\n        }\n\n        # If we want a Math::BigInt, see if the object can become one.\n        # Support the old misnomer as_number().\n\n        if ($a[0] eq 'Math::BigInt') {\n            if ($a[$i] -> can('as_int')) {\n                $a[$i] = $a[$i] -> as_int();\n                next;\n            }\n            if ($a[$i] -> can('as_number')) {\n                $a[$i] = $a[$i] -> as_number();\n                next;\n            }\n        }\n\n        # If we want a Math::BigFloat, see if the object can become one.\n\n        if ($a[0] eq 'Math::BigFloat') {\n            if ($a[$i] -> can('as_float')) {\n                $a[$i] = $a[$i] -> as_float();\n                next;\n            }\n        }\n\n        # Last resort.\n\n        $a[$i] = $a[0] -> new($a[$i]);\n    }\n\n    # Reset the downgrading.\n\n    ${\"$a[0]::downgrade\"} = $down;\n\n    return @a;\n}\n\nsub _register_callback\n  {\n  my ($class,$callback) = @_;\n\n  if (ref($callback) ne 'CODE')\n    { \n    require Carp;\n    Carp::croak (\"$callback is not a coderef\");\n    }\n  $CALLBACKS{$class} = $callback;\n  }\n\nsub import \n  {\n  my $self = shift;\n\n  $IMPORT++;\t\t\t\t# remember we did import()\n  my @a; my $l = scalar @_;\n  my $warn_or_die = 0;\t\t\t# 0 - no warn, 1 - warn, 2 - die\n  for ( my $i = 0; $i < $l ; $i++ )\n    {\n    if ($_[$i] eq ':constant')\n      {\n      # this causes overlord er load to step in\n      overload::constant \n\tinteger => sub { $self->new(shift) },\n      \tbinary => sub { $self->new(shift) };\n      }\n    elsif ($_[$i] eq 'upgrade')\n      {\n      # this causes upgrading\n      $upgrade = $_[$i+1];\t\t# or undef to disable\n      $i++;\n      }\n    elsif ($_[$i] =~ /^(lib|try|only)\\z/)\n      {\n      # this causes a different low lib to take care...\n      $CALC = $_[$i+1] || '';\n      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)\n      $warn_or_die = 1 if $_[$i] eq 'lib';\n      $warn_or_die = 2 if $_[$i] eq 'only';\n      $i++;\n      }\n    else\n      {\n      push @a, $_[$i];\n      }\n    }\n  # any non :constant stuff is handled by our parent, Exporter\n  if (@a > 0)\n    {\n    require Exporter;\n \n    $self->SUPER::import(@a);\t\t\t# need it for subclasses\n    $self->export_to_level(1,$self,@a);\t\t# need it for MBF\n    }\n\n  # try to load core math lib\n  my @c = split /\\s*,\\s*/,$CALC;\n  foreach (@c)\n    {\n    $_ =~ tr/a-zA-Z0-9://cd;\t\t\t# limit to sane characters\n    }\n  push @c, \\'Calc'\t\t\t\t# if all fail, try these\n    if $warn_or_die < 2;\t\t\t# but not for \"only\"\n  $CALC = '';\t\t\t\t\t# signal error\n  foreach my $l (@c)\n    {\n    # fallback libraries are \"marked\" as \\'string', extract string if nec.\n    my $lib = $l; $lib = $$l if ref($l);\n\n    next if ($lib || '') eq '';\n    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;\n    $lib =~ s/\\.pm$//;\n    if ($] < 5.006)\n      {\n      # Perl < 5.6.0 dies with \"out of memory!\" when eval(\"\") and ':constant' is\n      # used in the same script, or eval(\"\") inside import().\n      my @parts = split /::/, $lib;             # Math::BigInt => Math BigInt\n      my $file = pop @parts; $file .= '.pm';    # BigInt => BigInt.pm\n      require File::Spec;\n      $file = File::Spec->catfile (@parts, $file);\n      eval { require \"$file\"; $lib->import( @c ); }\n      }\n    else\n      {\n      eval \"use $lib qw/@c/;\";\n      }\n    if ($@ eq '')\n      {\n      my $ok = 1;\n      # loaded it ok, see if the api_version() is high enough\n      if ($lib->can('api_version') && $lib->api_version() >= 1.0)\n\t{\n\t$ok = 0;\n\t# api_version matches, check if it really provides anything we need\n        for my $method (qw/\n\t\tone two ten\n\t\tstr num\n\t\tadd mul div sub dec inc\n\t\tacmp len digit is_one is_zero is_even is_odd\n\t\tis_two is_ten\n\t\tzeros new copy check\n\t\tfrom_hex from_oct from_bin as_hex as_bin as_oct\n\t\trsft lsft xor and or\n\t\tmod sqrt root fac pow modinv modpow log_int gcd\n\t /)\n          {\n\t  if (!$lib->can(\"_$method\"))\n\t    {\n\t    if (($WARN{$lib}||0) < 2)\n\t      {\n\t      require Carp;\n\t      Carp::carp (\"$lib is missing method '_$method'\");\n\t      $WARN{$lib} = 1;\t\t# still warn about the lib\n\t      }\n            $ok++; last; \n\t    }\n          }\n\t}\n      if ($ok == 0)\n\t{\n\t$CALC = $lib;\n\tif ($warn_or_die > 0 && ref($l))\n\t  {\n\t  require Carp;\n\t  my $msg = \"Math::BigInt: couldn't load specified math lib(s), fallback to $lib\";\n          Carp::carp ($msg) if $warn_or_die == 1;\n          Carp::croak ($msg) if $warn_or_die == 2;\n\t  }\n        last;\t\t\t# found a usable one, break\n\t}\n      else\n\t{\n\tif (($WARN{$lib}||0) < 2)\n\t  {\n\t  my $ver = eval \"\\$$lib\\::VERSION\" || 'unknown';\n\t  require Carp;\n\t  Carp::carp (\"Cannot load outdated $lib v$ver, please upgrade\");\n\t  $WARN{$lib} = 2;\t\t# never warn again\n\t  }\n        }\n      }\n    }\n  if ($CALC eq '')\n    {\n    require Carp;\n    if ($warn_or_die == 2)\n      {\n      Carp::croak (\"Couldn't load specified math lib(s) and fallback disallowed\");\n      }\n    else\n      {\n      Carp::croak (\"Couldn't load any math lib(s), not even fallback to Calc.pm\");\n      }\n    }\n\n  # notify callbacks\n  foreach my $class (keys %CALLBACKS)\n    {\n    &{$CALLBACKS{$class}}($CALC);\n    }\n\n  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib\n  # functions\n\n  %CAN = ();\n  for my $method (qw/ signed_and signed_or signed_xor /)\n    {\n    $CAN{$method} = $CALC->can(\"_$method\") ? 1 : 0;\n    }\n\n  # import done\n  }\n\nsub from_hex {\n    # Create a bigint from a hexadecimal string.\n\n    my ($self, $str) = @_;\n\n    if ($str =~ s/\n                     ^\n                     ( [+-]? )\n                     (0?x)?\n                     (\n                         [0-9a-fA-F]*\n                         ( _ [0-9a-fA-F]+ )*\n                     )\n                     $\n                 //x)\n    {\n        # Get a \"clean\" version of the string, i.e., non-emtpy and with no\n        # underscores or invalid characters.\n\n        my $sign = $1;\n        my $chrs = $3;\n        $chrs =~ tr/_//d;\n        $chrs = '0' unless CORE::length $chrs;\n\n        # Initialize output.\n\n        my $x = Math::BigInt->bzero();\n\n        # The library method requires a prefix.\n\n        $x->{value} = $CAL", 8192) = 8192
09:01:57.230207 brk(0x12ab000)          = 0x12ab000
09:01:57.230711 read(16, "C->_from_hex('0x' . $chrs);\n\n        # Place the sign.\n\n        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {\n            $x->{sign} = '-';\n        }\n\n        return $x;\n    }\n\n    # CORE::hex() parses as much as it can, and ignores any trailing garbage.\n    # For backwards compatibility, we return NaN.\n\n    return $self->bnan();\n}\n\nsub from_oct {\n    # Create a bigint from an octal string.\n\n    my ($self, $str) = @_;\n\n    if ($str =~ s/\n                     ^\n                     ( [+-]? )\n                     (\n                         [0-7]*\n                         ( _ [0-7]+ )*\n                     )\n                     $\n                 //x)\n    {\n        # Get a \"clean\" version of the string, i.e., non-emtpy and with no\n        # underscores or invalid characters.\n\n        my $sign = $1;\n        my $chrs = $2;\n        $chrs =~ tr/_//d;\n        $chrs = '0' unless CORE::length $chrs;\n\n        # Initialize output.\n\n        my $x = Math::BigInt->bzero();\n\n        # The library method requires a prefix.\n\n        $x->{value} = $CALC->_from_oct('0' . $chrs);\n\n        # Place the sign.\n\n        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {\n            $x->{sign} = '-';\n        }\n\n        return $x;\n    }\n\n    # CORE::oct() parses as much as it can, and ignores any trailing garbage.\n    # For backwards compatibility, we return NaN.\n\n    return $self->bnan();\n}\n\nsub from_bin {\n    # Create a bigint from a binary string.\n\n    my ($self, $str) = @_;\n\n    if ($str =~ s/\n                     ^\n                     ( [+-]? )\n                     (0?b)?\n                     (\n                         [01]*\n                         ( _ [01]+ )*\n                     )\n                     $\n                 //x)\n    {\n        # Get a \"clean\" version of the string, i.e., non-emtpy and with no\n        # underscores or invalid characters.\n\n        my $sign = $1;\n        my $chrs = $3;\n        $chrs =~ tr/_//d;\n        $chrs = '0' unless CORE::length $chrs;\n\n        # Initialize output.\n\n        my $x = Math::BigInt->bzero();\n\n        # The library method requires a prefix.\n\n        $x->{value} = $CALC->_from_bin('0b' . $chrs);\n\n        # Place the sign.\n\n        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {\n            $x->{sign} = '-';\n        }\n\n        return $x;\n    }\n\n    # For consistency with from_hex() and from_oct(), we return NaN when the\n    # input is invalid.\n\n    return $self->bnan();\n}\n\nsub _split\n  {\n  # input: num_str; output: undef for invalid or\n  # (\\$mantissa_sign,\\$mantissa_value,\\$mantissa_fraction,\\$exp_sign,\\$exp_value)\n  # Internal, take apart a string and return the pieces.\n  # Strip leading/trailing whitespace, leading zeros, underscore and reject\n  # invalid input.\n  my $x = shift;\n\n  # strip white space at front, also extraneous leading zeros\n  $x =~ s/^\\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'\n  $x =~ s/^\\s+//;                       # but this will\n  $x =~ s/\\s+$//g;                      # strip white space at end\n\n  # shortcut, if nothing to split, return early\n  if ($x =~ /^[+-]?[0-9]+\\z/)\n    {\n    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';\n    return (\\$sign, \\$x, \\'', \\'', \\0);\n    }\n\n  # invalid starting char?\n  return if $x !~ /^[+-]?(\\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;\n\n  return Math::BigInt->from_hex($x) if $x =~ /^[+-]?0x/;        # hex string\n  return Math::BigInt->from_bin($x) if $x =~ /^[+-]?0b/;        # binary string\n\n  # strip underscores between digits\n  $x =~ s/([0-9])_([0-9])/$1$2/g;\n  $x =~ s/([0-9])_([0-9])/$1$2/g;\t\t# do twice for 1_2_3\n\n  # some possible inputs: \n  # 2.1234 # 0.12        # 1 \t      # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2 \n  # .2 \t   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999\t\n\n  my ($m,$e,$last) = split /[Ee]/,$x;\n  return if defined $last;\t\t# last defined => 1e2E3 or others\n  $e = '0' if !defined $e || $e eq \"\";\n\n  # sign,value for exponent,mantint,mantfrac\n  my ($es,$ev,$mis,$miv,$mfv);\n  # valid exponent?\n  if ($e =~ /^([+-]?)0*([0-9]+)$/)\t# strip leading zeros\n    {\n    $es = $1; $ev = $2;\n    # valid mantissa?\n    return if $m eq '.' || $m eq '';\n    my ($mi,$mf,$lastf) = split /\\./,$m;\n    return if defined $lastf;\t\t# lastf defined => 1.2.3 or others\n    $mi = '0' if !defined $mi;\n    $mi .= '0' if $mi =~ /^[\\-\\+]?$/;\n    $mf = '0' if !defined $mf || $mf eq '';\n    if ($mi =~ /^([+-]?)0*([0-9]+)$/)\t\t# strip leading zeros\n      {\n      $mis = $1||'+'; $miv = $2;\n      return unless ($mf =~ /^([0-9]*?)0*$/);\t# strip trailing zeros\n      $mfv = $1;\n      # handle the 0e999 case here\n      $ev = 0 if $miv eq '0' && $mfv eq '';\n      return (\\$mis,\\$miv,\\$mfv,\\$es,\\$ev);\n      }\n    }\n  return; # NaN, not a number\n  }\n\n##############################################################################\n# internal calculation routines (others are in Math::BigInt::Calc etc)\n\nsub __lcm \n  { \n  # (BINT or num_str, BINT or num_str) return BINT\n  # does modify first argument\n  # LCM\n \n  my ($x,$ty) = @_;\n  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);\n  my $method = ref($x) . '::bgcd';\n  no strict 'refs';\n  $x * $ty / &$method($x,$ty);\n  }\n\n###############################################################################\n# trigonometric functions\n\nsub bpi\n  {\n  # Calculate PI to N digits. Unless upgrading is in effect, returns the\n  # result truncated to an integer, that is, always returns '3'.\n  my ($self,$n) = @_;\n  if (@_ == 1)\n    {\n    # called like Math::BigInt::bpi(10);\n    $n = $self; $self = $class;\n    }\n  $self = ref($self) if ref($self);\n\n  return $upgrade->new($n) if defined $upgrade;\n\n  # hard-wired to \"3\"\n  $self->new(3);\n  }\n\nsub bcos\n  {\n  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the\n  # result truncated to an integer.\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  return $x if $x->modify('bcos');\n\n  return $x->bnan() if $x->{sign} !~ /^[+-]\\z/;\t# -inf +inf or NaN => NaN\n\n  return $upgrade->new($x)->bcos(@r) if defined $upgrade;\n\n  require Math::BigFloat;\n  # calculate the result and truncate it to integer\n  my $t = Math::BigFloat->new($x)->bcos(@r)->as_int();\n\n  $x->bone() if $t->is_one();\n  $x->bzero() if $t->is_zero();\n  $x->round(@r);\n  }\n\nsub bsin\n  {\n  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the\n  # result truncated to an integer.\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  return $x if $x->modify('bsin');\n\n  return $x->bnan() if $x->{sign} !~ /^[+-]\\z/;\t# -inf +inf or NaN => NaN\n\n  return $upgrade->new($x)->bsin(@r) if defined $upgrade;\n\n  require Math::BigFloat;\n  # calculate the result and truncate it to integer\n  my $t = Math::BigFloat->new($x)->bsin(@r)->as_int();\n\n  $x->bone() if $t->is_one();\n  $x->bzero() if $t->is_zero();\n  $x->round(@r);\n  }\n\nsub batan2\n  { \n  # calculate arcus tangens of ($y/$x)\n \n  # set up parameters\n  my ($self,$y,$x,@r) = (ref($_[0]),@_);\n  # objectify is costly, so avoid it\n  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))\n    {\n    ($self,$y,$x,@r) = objectify(2,@_);\n    }\n\n  return $y if $y->modify('batan2');\n\n  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);\n\n  # Y    X\n  # != 0 -inf result is +- pi\n  if ($x->is_inf() || $y->is_inf())\n    {\n    # upgrade to BigFloat etc.\n    return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;\n    if ($y->is_inf())\n      {\n      if ($x->{sign} eq '-inf')\n        {\n        # calculate 3 pi/4 => 2.3.. => 2\n        $y->bone( substr($y->{sign},0,1) );\n        $y->bmul($self->new(2));\n        }\n      elsif ($x->{sign} eq '+inf')\n        {\n        # calculate pi/4 => 0.7 => 0\n        $y->bzero();\n        }\n      else\n        {\n        # calculate pi/2 => 1.5 => 1\n        $y->bone( substr($y->{sign},0,1) );\n        }\n      }\n    else\n      {\n      if ($x->{sign} eq '+inf')\n        {\n        # calculate pi/4 => 0.7 => 0\n        $y->bzero();\n        }\n      else\n        {\n        # PI => 3.1415.. => 3\n        $y->bone( substr($y->{sign},0,1) );\n        $y->bmul($self->new(3));\n        }\n      }\n    return $y;\n    }\n\n  return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrad", 8192) = 8192
09:01:57.231535 brk(0x12cc000)          = 0x12cc000
09:01:57.232032 read(16, "e;\n\n  require Math::BigFloat;\n  my $r = Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@r)->as_int();\n\n  $x->{value} = $r->{value};\n  $x->{sign} = $r->{sign};\n\n  $x;\n  }\n\nsub batan\n  {\n  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the\n  # result truncated to an integer.\n  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);\n\n  return $x if $x->modify('batan');\n\n  return $x->bnan() if $x->{sign} !~ /^[+-]\\z/;\t# -inf +inf or NaN => NaN\n\n  return $upgrade->new($x)->batan(@r) if defined $upgrade;\n\n  # calculate the result and truncate it to integer\n  my $t = Math::BigFloat->new($x)->batan(@r);\n\n  $x->{value} = $CALC->_new( $x->as_int()->bstr() );\n  $x->round(@r);\n  }\n\n###############################################################################\n# this method returns 0 if the object can be modified, or 1 if not.\n# We use a fast constant sub() here, to avoid costly calls. Subclasses\n# may override it with special code (f.i. Math::BigInt::Constant does so)\n\nsub modify () { 0; }\n\n1;\n__END__\n\n=pod\n\n=head1 NAME\n\nMath::BigInt - Arbitrary size integer/float math package\n\n=head1 SYNOPSIS\n\n  use Math::BigInt;\n\n  # or make it faster with huge numbers: install (optional)\n  # Math::BigInt::GMP and always use (it will fall back to\n  # pure Perl if the GMP library is not installed):\n  # (See also the L<MATH LIBRARY> section!)\n\n  # will warn if Math::BigInt::GMP cannot be found\n  use Math::BigInt lib => 'GMP';\n\n  # to suppress the warning use this:\n  # use Math::BigInt try => 'GMP';\n\n  # dies if GMP cannot be loaded:\n  # use Math::BigInt only => 'GMP';\n\n  my $str = '1234567890';\n  my @values = (64,74,18);\n  my $n = 1; my $sign = '-';\n\n  # Number creation\t\n  my $x = Math::BigInt->new($str);\t# defaults to 0\n  my $y = $x->copy();\t\t\t# make a true copy\n  my $nan  = Math::BigInt->bnan(); \t# create a NotANumber\n  my $zero = Math::BigInt->bzero();\t# create a +0\n  my $inf = Math::BigInt->binf();\t# create a +inf\n  my $inf = Math::BigInt->binf('-');\t# create a -inf\n  my $one = Math::BigInt->bone();\t# create a +1\n  my $mone = Math::BigInt->bone('-');\t# create a -1\n\n  my $pi = Math::BigInt->bpi();\t\t# returns '3'\n\t\t\t\t\t# see Math::BigFloat::bpi()\n\n  $h = Math::BigInt->new('0x123');\t# from hexadecimal\n  $b = Math::BigInt->new('0b101');\t# from binary\n  $o = Math::BigInt->from_oct('0101');\t# from octal\n\n  # Testing (don't modify their arguments)\n  # (return true if the condition is met, otherwise false)\n\n  $x->is_zero();\t# if $x is +0\n  $x->is_nan();\t\t# if $x is NaN\n  $x->is_one();\t\t# if $x is +1\n  $x->is_one('-');\t# if $x is -1\n  $x->is_odd();\t\t# if $x is odd\n  $x->is_even();\t# if $x is even\n  $x->is_pos();\t\t# if $x > 0\n  $x->is_neg();\t\t# if $x < 0\n  $x->is_inf($sign);\t# if $x is +inf, or -inf (sign is default '+')\n  $x->is_int();\t\t# if $x is an integer (not a float)\n\n  # comparing and digit/sign extraction\n  $x->bcmp($y);\t\t# compare numbers (undef,<0,=0,>0)\n  $x->bacmp($y);\t# compare absolutely (undef,<0,=0,>0)\n  $x->sign();\t\t# return the sign, either +,- or NaN\n  $x->digit($n);\t# return the nth digit, counting from right\n  $x->digit(-$n);\t# return the nth digit, counting from left\n\n  # The following all modify their first argument. If you want to pre-\n  # serve $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for\n  # why this is necessary when mixing $a = $b assignments with non-over-\n  # loaded math.\n\n  $x->bzero();\t\t# set $x to 0\n  $x->bnan();\t\t# set $x to NaN\n  $x->bone();\t\t# set $x to +1\n  $x->bone('-');\t# set $x to -1\n  $x->binf();\t\t# set $x to inf\n  $x->binf('-');\t# set $x to -inf\n\n  $x->bneg();\t\t# negation\n  $x->babs();\t\t# absolute value\n  $x->bsgn();\t\t# sign function (-1, 0, 1, or NaN)\n  $x->bnorm();\t\t# normalize (no-op in BigInt)\n  $x->bnot();\t\t# two's complement (bit wise not)\n  $x->binc();\t\t# increment $x by 1\n  $x->bdec();\t\t# decrement $x by 1\n\n  $x->badd($y);\t\t# addition (add $y to $x)\n  $x->bsub($y);\t\t# subtraction (subtract $y from $x)\n  $x->bmul($y);\t\t# multiplication (multiply $x by $y)\n  $x->bdiv($y);\t\t# divide, set $x to quotient\n\t\t\t# return (quo,rem) or quo if scalar\n\n  $x->bmuladd($y,$z);\t# $x = $x * $y + $z\n\n  $x->bmod($y);\t\t   # modulus (x % y)\n  $x->bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)\n  $x->bmodinv($mod);       # modular multiplicative inverse\n  $x->bpow($y);\t\t   # power of arguments (x ** y)\n  $x->blsft($y);\t   # left shift in base 2\n  $x->brsft($y);\t   # right shift in base 2\n\t\t\t   # returns (quo,rem) or quo if in sca-\n\t\t\t   # lar context\n  $x->blsft($y,$n);\t   # left shift by $y places in base $n\n  $x->brsft($y,$n);\t   # right shift by $y places in base $n\n\t\t\t   # returns (quo,rem) or quo if in sca-\n\t\t\t   # lar context\n\n  $x->band($y);\t\t   # bitwise and\n  $x->bior($y);\t\t   # bitwise inclusive or\n  $x->bxor($y);\t\t   # bitwise exclusive or\n  $x->bnot();\t\t   # bitwise not (two's complement)\n\n  $x->bsqrt();\t\t   # calculate square-root\n  $x->broot($y);\t   # $y'th root of $x (e.g. $y == 3 => cubic root)\n  $x->bfac();\t\t   # factorial of $x (1*2*3*4*..$x)\n\n  $x->bnok($y);\t\t   # x over y (binomial coefficient n over k)\n\n  $x->blog();\t\t   # logarithm of $x to base e (Euler's number)\n  $x->blog($base);\t   # logarithm of $x to base $base (f.i. 2)\n  $x->bexp();\t\t   # calculate e ** $x where e is Euler's number\n\n  $x->round($A,$P,$mode);  # round to accuracy or precision using\n\t\t\t   # mode $mode\n  $x->bround($n);\t   # accuracy: preserve $n digits\n  $x->bfround($n);\t   # $n > 0: round $nth digits,\n\t\t\t   # $n < 0: round to the $nth digit after the\n\t\t\t   # dot, no-op for BigInts\n\n  # The following do not modify their arguments in BigInt (are no-ops),\n  # but do so in BigFloat:\n\n  $x->bfloor();\t\t   # return integer less or equal than $x\n  $x->bceil();\t\t   # return integer greater or equal than $x\n\n  # The following do not modify their arguments:\n\n  # greatest common divisor (no OO style)\n  my $gcd = Math::BigInt::bgcd(@values);\n  # lowest common multiple (no OO style)\n  my $lcm = Math::BigInt::blcm(@values);\n\n  $x->length();\t\t   # return number of digits in number\n  ($xl,$f) = $x->length(); # length of number and length of fraction\n\t\t\t   # part, latter is always 0 digits long\n\t\t\t   # for BigInts\n\n  $x->exponent();\t  # return exponent as BigInt\n  $x->mantissa();\t  # return (signed) mantissa as BigInt\n  $x->parts();\t\t  # return (mantissa,exponent) as BigInt\n  $x->copy();\t\t  # make a true copy of $x (unlike $y = $x;)\n  $x->as_int();\t\t  # return as BigInt (in BigInt: same as copy())\n  $x->numify();\t\t  # return as scalar (might overflow!)\n\n  # conversion to string (do not modify their argument)\n  $x->bstr();\t      # normalized string (e.g. '3')\n  $x->bsstr();\t      # norm. string in scientific notation (e.g. '3E0')\n  $x->as_hex();\t      # as signed hexadecimal string with prefixed 0x\n  $x->as_bin();\t      # as signed binary string with prefixed 0b\n  $x->as_oct();\t      # as signed octal string with prefixed 0\n\n\n  # precision and accuracy (see section about rounding for more)\n  $x->precision();\t # return P of $x (or global, if P of $x undef)\n  $x->precision($n);\t # set P of $x to $n\n  $x->accuracy();\t # return A of $x (or global, if A of $x undef)\n  $x->accuracy($n);\t # set A $x to $n\n\n  # Global methods\n  Math::BigInt->precision();   # get/set global P for all BigInt objects\n  Math::BigInt->accuracy();    # get/set global A for all BigInt objects\n  Math::BigInt->round_mode();  # get/set global round mode, one of\n\t\t\t       # 'even', 'odd', '+inf', '-inf', 'zero',\n\t\t\t       # 'trunc' or 'common'\n  Math::BigInt->config();      # return hash containing configuration\n\n=head1 DESCRIPTION\n\nAll operators (including basic math operations) are overloaded if you\ndeclare your big integers as\n\n  $i = new Math::BigInt '123_456_789_123_456_789';\n\nOperations with overloaded operators preserve the arguments which is\nexactly what you expect.\n\n=over 2\n\n=item Input\n\nInput values to these routines may be any string, that looks like a number\nand results in an integer, including hexadecimal and binary numbers.\n\nScalars holding numbers may also be passed, but note that non-integer numbers\nmay already have lost precision due to the conversion to float. Quote\nyour input if you want BigInt to see al", 8192) = 8192
09:01:57.232945 lseek(16, 91169, SEEK_SET) = 91169
09:01:57.233003 lseek(16, 0, SEEK_CUR)  = 91169
09:01:57.233057 close(16)               = 0
09:01:57.233212 stat("modules/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233278 stat("modules/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233340 stat("modules/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233399 stat("modules/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233459 stat("/etc/perl/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233518 stat("/etc/perl/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233578 stat("/usr/local/lib/perl/5.14.2/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233640 stat("/usr/local/lib/perl/5.14.2/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233707 stat("/usr/local/share/perl/5.14.2/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233771 stat("/usr/local/share/perl/5.14.2/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233836 stat("/usr/lib/perl5/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.233907 stat("/usr/lib/perl5/Math/BigInt/Calc.pm", 0x7ffe12337f00) = -1 ENOENT (No such file or directory)
09:01:57.233970 stat("/usr/share/perl5/Math/BigInt/Calc.pmc", 0x7ffe12337fb0) = -1 ENOENT (No such file or directory)
09:01:57.234039 stat("/usr/share/perl5/Math/BigInt/Calc.pm", {st_mode=S_IFREG|0644, st_size=79629, ...}) = 0
09:01:57.234118 open("/usr/share/perl5/Math/BigInt/Calc.pm", O_RDONLY) = 16
09:01:57.234182 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12337c90) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.234239 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.234308 read(16, "package Math::BigInt::Calc;\n\nuse 5.006002;\nuse strict;\n# use warnings;\t# dont use warnings for older Perls\n\nour $VERSION = '1.997';\n\n# Package to store unsigned big integers in decimal and do math with them\n\n# Internally the numbers are stored in an array with at least 1 element, no\n# leading zero parts (except the first) and in base 1eX where X is determined\n# automatically at loading time to be the maximum possible value\n\n# todo:\n# - fully remove funky $# stuff in div() (maybe - that code scares me...)\n\n# USE_MUL: due to problems on certain os (os390, posix-bc) \"* 1e-5\" is used\n# instead of \"/ 1e5\" at some places, (marked with USE_MUL). Other platforms\n# BS2000, some Crays need USE_DIV instead.\n# The BEGIN block is used to determine which of the two variants gives the\n# correct result.\n\n# Beware of things like:\n# $i = $i * $y + $car; $car = int($i / $BASE); $i = $i % $BASE;\n# This works on x86, but fails on ARM (SA1100, iPAQ) due to whoknows what\n# reasons. So, use this instead (slower, but correct):\n# $i = $i * $y + $car; $car = int($i / $BASE); $i -= $BASE * $car;\n\n##############################################################################\n# global constants, flags and accessory\n\n# announce that we are compatible with MBI v1.83 and up\nsub api_version () { 2; }\n \n# constants for easier life\nmy ($BASE,$BASE_LEN,$RBASE,$MAX_VAL);\nmy ($AND_BITS,$XOR_BITS,$OR_BITS);\nmy ($AND_MASK,$XOR_MASK,$OR_MASK);\n\nsub _base_len \n  {\n  # Set/get the BASE_LEN and assorted other, connected values.\n  # Used only by the testsuite, the set variant is used only by the BEGIN\n  # block below:\n  shift;\n\n  my ($b, $int) = @_;\n  if (defined $b)\n    {\n    # avoid redefinitions\n    undef &_mul;\n    undef &_div;\n\n    if ($] >= 5.008 && $int && $b > 7)\n      {\n      $BASE_LEN = $b;\n      *_mul = \\&_mul_use_div_64;\n      *_div = \\&_div_use_div_64;\n      $BASE = int(\"1e\".$BASE_LEN);\n      $MAX_VAL = $BASE-1;\n      return $BASE_LEN unless wantarray;\n      return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL,);\n      }\n\n    # find whether we can use mul or div in mul()/div()\n    $BASE_LEN = $b+1;\n    my $caught = 0;\n    while (--$BASE_LEN > 5)\n      {\n      $BASE = int(\"1e\".$BASE_LEN);\n      $RBASE = abs('1e-'.$BASE_LEN);\t\t\t# see USE_MUL\n      $caught = 0;\n      $caught += 1 if (int($BASE * $RBASE) != 1);\t# should be 1\n      $caught += 2 if (int($BASE / $BASE) != 1);\t# should be 1\n      last if $caught != 3;\n      }\n    $BASE = int(\"1e\".$BASE_LEN);\n    $RBASE = abs('1e-'.$BASE_LEN);\t\t\t# see USE_MUL\n    $MAX_VAL = $BASE-1;\n   \n    # ($caught & 1) != 0 => cannot use MUL\n    # ($caught & 2) != 0 => cannot use DIV\n    if ($caught == 2)\t\t\t\t# 2\n      {\n      # must USE_MUL since we cannot use DIV\n      *_mul = \\&_mul_use_mul;\n      *_div = \\&_div_use_mul;\n      }\n    else\t\t\t\t\t# 0 or 1\n      {\n      # can USE_DIV instead\n      *_mul = \\&_mul_use_div;\n      *_div = \\&_div_use_div;\n      }\n    }\n  return $BASE_LEN unless wantarray;\n  return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL);\n  }\n\nsub _new\n  {\n  # (ref to string) return ref to num_array\n  # Convert a number from string format (without sign) to internal base\n  # 1ex format. Assumes normalized value as input.\n  my $il = length($_[1])-1;\n\n  # < BASE_LEN due len-1 above\n  return [ int($_[1]) ] if $il < $BASE_LEN;\t# shortcut for short numbers\n\n  # this leaves '00000' instead of int 0 and will be corrected after any op\n  [ reverse(unpack(\"a\" . ($il % $BASE_LEN+1) \n    . (\"a$BASE_LEN\" x ($il / $BASE_LEN)), $_[1])) ];\n  }                                                                             \n\nBEGIN\n  {\n  # from Daniel Pfeiffer: determine largest group of digits that is precisely\n  # multipliable with itself plus carry\n  # Test now changed to expect the proper pattern, not a result off by 1 or 2\n  my ($e, $num) = 3;\t# lowest value we will use is 3+1-1 = 3\n  do \n    {\n    $num = ('9' x ++$e) + 0;\n    $num *= $num + 1.0;\n    } while (\"$num\" =~ /9{$e}0{$e}/);\t# must be a certain pattern\n  $e--; \t\t\t\t# last test failed, so retract one step\n  # the limits below brush the problems with the test above under the rug:\n  # the test should be able to find the proper $e automatically\n  $e = 5 if $^O =~ /^uts/;\t# UTS get's some special treatment\n  $e = 5 if $^O =~ /^unicos/;\t# unicos is also problematic (6 seems to work\n\t\t\t\t# there, but we play safe)\n\n  my $int = 0;\n  if ($e > 7)\n    {\n    use integer;\n    my $e1 = 7;\n    $num = 7;\n    do \n      {\n      $num = ('9' x ++$e1) + 0;\n      $num *= $num + 1;\n      } while (\"$num\" =~ /9{$e1}0{$e1}/);\t# must be a certain pattern\n    $e1--; \t\t\t\t\t# last test failed, so retract one step\n    if ($e1 > 7)\n      { \n      $int = 1; $e = $e1; \n      }\n    }\n \n  __PACKAGE__->_base_len($e,$int);\t# set and store\n\n  use integer;\n  # find out how many bits _and, _or and _xor can take (old default = 16)\n  # I don't think anybody has yet 128 bit scalars, so let's play safe.\n  local $^W = 0;\t# don't warn about 'nonportable number'\n  $AND_BITS = 15; $XOR_BITS = 15; $OR_BITS = 15;\n\n  # find max bits, we will not go higher than numberofbits that fit into $BASE\n  # to make _and etc simpler (and faster for smaller, slower for large numbers)\n  my $max = 16;\n  while (2 ** $max < $BASE) { $max++; }\n  {\n    no integer;\n    $max = 16 if $] < 5.006;\t# older Perls might not take >16 too well\n  }\n  my ($x,$y,$z);\n  do {\n    $AND_BITS++;\n    $x = CORE::oct('0b' . '1' x $AND_BITS); $y = $x & $x;\n    $z = (2 ** $AND_BITS) - 1;\n    } while ($AND_BITS < $max && $x == $z && $y == $x);\n  $AND_BITS --;\t\t\t\t\t\t# retreat one step\n  do {\n    $XOR_BITS++;\n    $x = CORE::oct('0b' . '1' x $XOR_BITS); $y = $x ^ 0;\n    $z = (2 ** $XOR_BITS) - 1;\n    } while ($XOR_BITS < $max && $x == $z && $y == $x);\n  $XOR_BITS --;\t\t\t\t\t\t# retreat one step\n  do {\n    $OR_BITS++;\n    $x = CORE::oct('0b' . '1' x $OR_BITS); $y = $x | $x;\n    $z = (2 ** $OR_BITS) - 1;\n    } while ($OR_BITS < $max && $x == $z && $y == $x);\n  $OR_BITS --;\t\t\t\t\t\t# retreat one step\n  \n  $AND_MASK = __PACKAGE__->_new( ( 2 ** $AND_BITS ));\n  $XOR_MASK = __PACKAGE__->_new( ( 2 ** $XOR_BITS ));\n  $OR_MASK = __PACKAGE__->_new( ( 2 ** $OR_BITS ));\n\n  # We can compute the approximate length no faster than the real length:\n  *_alen = \\&_len;\n  }\n\n###############################################################################\n\nsub _zero\n  {\n  # create a zero\n  [ 0 ];\n  }\n\nsub _one\n  {\n  # create a one\n  [ 1 ];\n  }\n\nsub _two\n  {\n  # create a two (used internally for shifting)\n  [ 2 ];\n  }\n\nsub _ten\n  {\n  # create a 10 (used internally for shifting)\n  [ 10 ];\n  }\n\nsub _1ex\n  {\n  # create a 1Ex\n  my $rem = $_[1] % $BASE_LEN;\t\t# remainder\n  my $parts = $_[1] / $BASE_LEN;\t# parts\n\n  # 000000, 000000, 100 \n  [ (0) x $parts, '1' . ('0' x $rem) ];\n  }\n\nsub _copy\n  {\n  # make a true copy\n  [ @{$_[1]} ];\n  }\n\n# catch and throw away\nsub import { }\n\n##############################################################################\n# convert back to string and number\n\nsub _str\n  {\n  # (ref to BINT) return num_str\n  # Convert number from internal base 100000 format to string format.\n  # internal format is always normalized (no leading zeros, \"-0\" => \"+0\")\n  my $ar = $_[1];\n\n  my $l = scalar @$ar;\t\t\t\t# number of parts\n  if ($l < 1)\t\t\t\t\t# should not happen\n    {\n    require Carp;\n    Carp::croak(\"$_[1] has no elements\");\n    }\n\n  my $ret = \"\";\n  # handle first one different to strip leading zeros from it (there are no\n  # leading zero parts in internal representation)\n  $l --; $ret .= int($ar->[$l]); $l--;\n  # Interestingly, the pre-padd method uses more time\n  # the old grep variant takes longer (14 vs. 10 sec)\n  my $z = '0' x ($BASE_LEN-1);                            \n  while ($l >= 0)\n    {\n    $ret .= substr($z.$ar->[$l],-$BASE_LEN); # fastest way I could think of\n    $l--;\n    }\n  $ret;\n  }                                                                             \n\nsub _num\n  {\n    # Make a Perl scalar number (int/float) from a BigInt object.\n    my $x = $_[1];\n\n    return 0 + $x->[0] if scalar @$x == 1;      # below $BASE\n\n    # Start with the most significant element and work towards the least\n    # significant element. Avoid multiplying \"inf\" (wh", 8192) = 8192
09:01:57.235340 stat("modules/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.235407 stat("modules/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.235468 stat("modules/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.235527 stat("modules/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.235586 stat("/etc/perl/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.235646 stat("/etc/perl/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.235706 stat("/usr/local/lib/perl/5.14.2/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.235767 stat("/usr/local/lib/perl/5.14.2/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.235865 stat("/usr/local/share/perl/5.14.2/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.235935 stat("/usr/local/share/perl/5.14.2/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.235989 stat("/usr/lib/perl5/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.236040 stat("/usr/lib/perl5/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.236090 stat("/usr/share/perl5/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.236140 stat("/usr/share/perl5/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.236191 stat("/usr/lib/perl/5.14/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.236242 stat("/usr/lib/perl/5.14/integer.pm", 0x7ffe123378d0) = -1 ENOENT (No such file or directory)
09:01:57.236293 stat("/usr/share/perl/5.14/integer.pmc", 0x7ffe12337980) = -1 ENOENT (No such file or directory)
09:01:57.236344 stat("/usr/share/perl/5.14/integer.pm", {st_mode=S_IFREG|0644, st_size=172, ...}) = 0
09:01:57.236403 open("/usr/share/perl/5.14/integer.pm", O_RDONLY) = 17
09:01:57.236457 ioctl(17, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12337660) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.236504 lseek(17, 0, SEEK_CUR)  = 0
09:01:57.236556 brk(0x12ed000)          = 0x12ed000
09:01:57.236617 read(17, "package integer;\n\nour $VERSION = '1.00';\n\n$integer::hint_bits = 0x1;\n\nsub import {\n    $^H |= $integer::hint_bits;\n}\n\nsub unimport {\n    $^H &= ~$integer::hint_bits;\n}\n\n1;\n", 8192) = 172
09:01:57.236720 read(17, "", 8192)      = 0
09:01:57.236769 close(17)               = 0
09:01:57.237281 read(16, "ich happens if the number\n    # overflows) with \"0\" (if there are zero elements in $x) since this gives\n    # \"nan\" which propagates to the output.\n\n    my $num = 0;\n    for (my $i = $#$x ; $i >= 0 ; --$i) {\n        $num *= $BASE;\n        $num += $x -> [$i];\n    }\n    return $num;\n  }\n\n##############################################################################\n# actual math code\n\nsub _add\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # routine to add two base 1eX numbers\n  # stolen from Knuth Vol 2 Algorithm A pg 231\n  # there are separate routines to add and sub as per Knuth pg 233\n  # This routine modifies array x, but not y.\n \n  my ($c,$x,$y) = @_;\n\n  return $x if (@$y == 1) && $y->[0] == 0;\t\t# $x + 0 => $x\n  if ((@$x == 1) && $x->[0] == 0)\t\t\t# 0 + $y => $y->copy\n    {\n    # twice as slow as $x = [ @$y ], but nec. to retain $x as ref :(\n    @$x = @$y; return $x;\t\t\n    }\n \n  # for each in Y, add Y to X and carry. If after that, something is left in\n  # X, foreach in X add carry to X and then return X, carry\n  # Trades one \"$j++\" for having to shift arrays\n  my $i; my $car = 0; my $j = 0;\n  for $i (@$y)\n    {\n    $x->[$j] -= $BASE if $car = (($x->[$j] += $i + $car) >= $BASE) ? 1 : 0;\n    $j++;\n    }\n  while ($car != 0)\n    {\n    $x->[$j] -= $BASE if $car = (($x->[$j] += $car) >= $BASE) ? 1 : 0; $j++;\n    }\n  $x;\n  }                                                                             \n\nsub _inc\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # Add 1 to $x, modify $x in place\n  my ($c,$x) = @_;\n\n  for my $i (@$x)\n    {\n    return $x if (($i += 1) < $BASE);\t\t# early out\n    $i = 0;\t\t\t\t\t# overflow, next\n    }\n  push @$x,1 if (($x->[-1] || 0) == 0);\t\t# last overflowed, so extend\n  $x;\n  }                                                                             \n\nsub _dec\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # Sub 1 from $x, modify $x in place\n  my ($c,$x) = @_;\n\n  my $MAX = $BASE-1;\t\t\t\t# since MAX_VAL based on BASE\n  for my $i (@$x)\n    {\n    last if (($i -= 1) >= 0);\t\t\t# early out\n    $i = $MAX;\t\t\t\t\t# underflow, next\n    }\n  pop @$x if $x->[-1] == 0 && @$x > 1;\t\t# last underflowed (but leave 0)\n  $x;\n  }                                                                             \n\nsub _sub\n  {\n  # (ref to int_num_array, ref to int_num_array, swap)\n  # subtract base 1eX numbers -- stolen from Knuth Vol 2 pg 232, $x > $y\n  # subtract Y from X by modifying x in place\n  my ($c,$sx,$sy,$s) = @_;\n \n  my $car = 0; my $i; my $j = 0;\n  if (!$s)\n    {\n    for $i (@$sx)\n      {\n      last unless defined $sy->[$j] || $car;\n      $i += $BASE if $car = (($i -= ($sy->[$j] || 0) + $car) < 0); $j++;\n      }\n    # might leave leading zeros, so fix that\n    return __strip_zeros($sx);\n    }\n  for $i (@$sx)\n    {\n    # we can't do an early out if $x is < than $y, since we\n    # need to copy the high chunks from $y. Found by Bob Mathews.\n    #last unless defined $sy->[$j] || $car;\n    $sy->[$j] += $BASE\n     if $car = (($sy->[$j] = $i-($sy->[$j]||0) - $car) < 0);\n    $j++;\n    }\n  # might leave leading zeros, so fix that\n  __strip_zeros($sy);\n  }                                                                             \n\nsub _mul_use_mul\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # multiply two numbers in internal representation\n  # modifies first arg, second need not be different from first\n  my ($c,$xv,$yv) = @_;\n\n  if (@$yv == 1)\n    {\n    # shortcut for two very short numbers (improved by Nathan Zook)\n    # works also if xv and yv are the same reference, and handles also $x == 0\n    if (@$xv == 1)\n      {\n      if (($xv->[0] *= $yv->[0]) >= $BASE)\n         {\n         $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $BASE;\n         };\n      return $xv;\n      }\n    # $x * 0 => 0\n    if ($yv->[0] == 0)\n      {\n      @$xv = (0);\n      return $xv;\n      }\n    # multiply a large number a by a single element one, so speed up\n    my $y = $yv->[0]; my $car = 0;\n    foreach my $i (@$xv)\n      {\n      $i = $i * $y + $car; $car = int($i * $RBASE); $i -= $car * $BASE;\n      }\n    push @$xv, $car if $car != 0;\n    return $xv;\n    }\n  # shortcut for result $x == 0 => result = 0\n  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); \n\n  # since multiplying $x with $x fails, make copy in this case\n  $yv = [@$xv] if $xv == $yv;\t# same references?\n\n  my @prod = (); my ($prod,$car,$cty,$xi,$yi);\n\n  for $xi (@$xv)\n    {\n    $car = 0; $cty = 0;\n\n    # slow variant\n#    for $yi (@$yv)\n#      {\n#      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;\n#      $prod[$cty++] =\n#       $prod - ($car = int($prod * RBASE)) * $BASE;  # see USE_MUL\n#      }\n#    $prod[$cty] += $car if $car; # need really to check for 0?\n#    $xi = shift @prod;\n\n    # faster variant\n    # looping through this if $xi == 0 is silly - so optimize it away!\n    $xi = (shift @prod || 0), next if $xi == 0;\n    for $yi (@$yv)\n      {\n      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;\n##     this is actually a tad slower\n##        $prod = $prod[$cty]; $prod += ($car + $xi * $yi);\t# no ||0 here\n      $prod[$cty++] =\n       $prod - ($car = int($prod * $RBASE)) * $BASE;  # see USE_MUL\n      }\n    $prod[$cty] += $car if $car; # need really to check for 0?\n    $xi = shift @prod || 0;\t# || 0 makes v5.005_3 happy\n    }\n  push @$xv, @prod;\n  # can't have leading zeros\n#  __strip_zeros($xv);\n  $xv;\n  }                                                                             \n\nsub _mul_use_div_64\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # multiply two numbers in internal representation\n  # modifies first arg, second need not be different from first\n  # works for 64 bit integer with \"use integer\"\n  my ($c,$xv,$yv) = @_;\n\n  use integer;\n  if (@$yv == 1)\n    {\n    # shortcut for two small numbers, also handles $x == 0\n    if (@$xv == 1)\n      {\n      # shortcut for two very short numbers (improved by Nathan Zook)\n      # works also if xv and yv are the same reference, and handles also $x == 0\n      if (($xv->[0] *= $yv->[0]) >= $BASE)\n          {\n          $xv->[0] =\n              $xv->[0] - ($xv->[1] = $xv->[0] / $BASE) * $BASE;\n          };\n      return $xv;\n      }\n    # $x * 0 => 0\n    if ($yv->[0] == 0)\n      {\n      @$xv = (0);\n      return $xv;\n      }\n    # multiply a large number a by a single element one, so speed up\n    my $y = $yv->[0]; my $car = 0;\n    foreach my $i (@$xv)\n      {\n      #$i = $i * $y + $car; $car = $i / $BASE; $i -= $car * $BASE;\n      $i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;\n      }\n    push @$xv, $car if $car != 0;\n    return $xv;\n    }\n  # shortcut for result $x == 0 => result = 0\n  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); \n\n  # since multiplying $x with $x fails, make copy in this case\n  $yv = [@$xv] if $xv == $yv;\t# same references?\n\n  my @prod = (); my ($prod,$car,$cty,$xi,$yi);\n  for $xi (@$xv)\n    {\n    $car = 0; $cty = 0;\n    # looping through this if $xi == 0 is silly - so optimize it away!\n    $xi = (shift @prod || 0), next if $xi == 0;\n    for $yi (@$yv)\n      {\n      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;\n      $prod[$cty++] = $prod - ($car = $prod / $BASE) * $BASE;\n      }\n    $prod[$cty] += $car if $car; # need really to check for 0?\n    $xi = shift @prod || 0;\t# || 0 makes v5.005_3 happy\n    }\n  push @$xv, @prod;\n  $xv;\n  }                                                                             \n\nsub _mul_use_div\n  {\n  # (ref to int_num_array, ref to int_num_array)\n  # multiply two numbers in internal representation\n  # modifies first arg, second need not be different from first\n  my ($c,$xv,$yv) = @_;\n\n  if (@$yv == 1)\n    {\n    # shortcut for two small numbers, also handles $x == 0\n    if (@$xv == 1)\n      {\n      # shortcut for two very short numbers (improved by Nathan Zook)\n      # works also if xv and yv are the same reference, and handles also $x == 0\n      if (($xv->[0] *= $yv->[0]) >= $BASE)\n          {\n          $xv->[0] =\n              $xv->[0] - ($xv->[1] = int($xv->[0] / $BASE)) * $BASE;\n          };\n      return $xv;\n      }\n    # $x * 0 => 0\n    if ($yv->[0] == 0)\n      {\n      @$xv = (0);\n      return $xv;\n      }\n    # multiply a large number ", 8192) = 8192
09:01:57.238058 brk(0x130e000)          = 0x130e000
09:01:57.238317 read(16, "a by a single element one, so speed up\n    my $y = $yv->[0]; my $car = 0;\n    foreach my $i (@$xv)\n      {\n      $i = $i * $y + $car; $car = int($i / $BASE); $i -= $car * $BASE;\n      # This (together with use integer;) does not work on 32-bit Perls\n      #$i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;\n      }\n    push @$xv, $car if $car != 0;\n    return $xv;\n    }\n  # shortcut for result $x == 0 => result = 0\n  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); \n\n  # since multiplying $x with $x fails, make copy in this case\n  $yv = [@$xv] if $xv == $yv;\t# same references?\n\n  my @prod = (); my ($prod,$car,$cty,$xi,$yi);\n  for $xi (@$xv)\n    {\n    $car = 0; $cty = 0;\n    # looping through this if $xi == 0 is silly - so optimize it away!\n    $xi = (shift @prod || 0), next if $xi == 0;\n    for $yi (@$yv)\n      {\n      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;\n      $prod[$cty++] = $prod - ($car = int($prod / $BASE)) * $BASE;\n      }\n    $prod[$cty] += $car if $car; # need really to check for 0?\n    $xi = shift @prod || 0;\t# || 0 makes v5.005_3 happy\n    }\n  push @$xv, @prod;\n  # can't have leading zeros\n#  __strip_zeros($xv);\n  $xv;\n  }                                                                             \n\nsub _div_use_mul\n  {\n  # ref to array, ref to array, modify first array and return remainder if \n  # in list context\n\n  # see comments in _div_use_div() for more explanations\n\n  my ($c,$x,$yorg) = @_;\n  \n  # the general div algorithm here is about O(N*N) and thus quite slow, so\n  # we first check for some special cases and use shortcuts to handle them.\n\n  # This works, because we store the numbers in a chunked format where each\n  # element contains 5..7 digits (depending on system).\n\n  # if both numbers have only one element:\n  if (@$x == 1 && @$yorg == 1)\n    {\n    # shortcut, $yorg and $x are two small numbers\n    if (wantarray)\n      {\n      my $r = [ $x->[0] % $yorg->[0] ];\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return ($x,$r); \n      }\n    else\n      {\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return $x; \n      }\n    }\n\n  # if x has more than one, but y has only one element:\n  if (@$yorg == 1)\n    {\n    my $rem;\n    $rem = _mod($c,[ @$x ],$yorg) if wantarray;\n\n    # shortcut, $y is < $BASE\n    my $j = scalar @$x; my $r = 0; \n    my $y = $yorg->[0]; my $b;\n    while ($j-- > 0)\n      {\n      $b = $r * $BASE + $x->[$j];\n      $x->[$j] = int($b/$y);\n      $r = $b % $y;\n      }\n    pop @$x if @$x > 1 && $x->[-1] == 0;\t# splice up a leading zero \n    return ($x,$rem) if wantarray;\n    return $x;\n    }\n\n  # now x and y have more than one element\n\n  # check whether y has more elements than x, if yet, the result will be 0\n  if (@$yorg > @$x)\n    {\n    my $rem;\n    $rem = [@$x] if wantarray;                  # make copy\n    splice (@$x,1);                             # keep ref to original array\n    $x->[0] = 0;                                # set to 0\n    return ($x,$rem) if wantarray;              # including remainder?\n    return $x;\t\t\t\t\t# only x, which is [0] now\n    }\n  # check whether the numbers have the same number of elements, in that case\n  # the result will fit into one element and can be computed efficiently\n  if (@$yorg == @$x)\n    {\n    my $rem;\n    # if $yorg has more digits than $x (it's leading element is longer than\n    # the one from $x), the result will also be 0:\n    if (length(int($yorg->[-1])) > length(int($x->[-1])))\n      {\n      $rem = [@$x] if wantarray;\t\t# make copy\n      splice (@$x,1);\t\t\t\t# keep ref to org array\n      $x->[0] = 0;\t\t\t\t# set to 0\n      return ($x,$rem) if wantarray;\t\t# including remainder?\n      return $x;\n      }\n    # now calculate $x / $yorg\n    if (length(int($yorg->[-1])) == length(int($x->[-1])))\n      {\n      # same length, so make full compare\n\n      my $a = 0; my $j = scalar @$x - 1;\n      # manual way (abort if unequal, good for early ne)\n      while ($j >= 0)\n        {\n        last if ($a = $x->[$j] - $yorg->[$j]); $j--;\n        }\n      # $a contains the result of the compare between X and Y\n      # a < 0: x < y, a == 0: x == y, a > 0: x > y\n      if ($a <= 0)\n        {\n        $rem = [ 0 ];                   # a = 0 => x == y => rem 0\n        $rem = [@$x] if $a != 0;        # a < 0 => x < y => rem = x\n        splice(@$x,1);                  # keep single element\n        $x->[0] = 0;                    # if $a < 0\n        $x->[0] = 1 if $a == 0;         # $x == $y\n        return ($x,$rem) if wantarray;\n        return $x;\n        }\n      # $x >= $y, so proceed normally\n      }\n    }\n\n  # all other cases:\n\n  my $y = [ @$yorg ];\t\t\t\t# always make copy to preserve\n\n  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);\n\n  $car = $bar = $prd = 0;\n  if (($dd = int($BASE/($y->[-1]+1))) != 1) \n    {\n    for $xi (@$x) \n      {\n      $xi = $xi * $dd + $car;\n      $xi -= ($car = int($xi * $RBASE)) * $BASE;\t# see USE_MUL\n      }\n    push(@$x, $car); $car = 0;\n    for $yi (@$y) \n      {\n      $yi = $yi * $dd + $car;\n      $yi -= ($car = int($yi * $RBASE)) * $BASE;\t# see USE_MUL\n      }\n    }\n  else \n    {\n    push(@$x, 0);\n    }\n  @q = (); ($v2,$v1) = @$y[-2,-1];\n  $v2 = 0 unless $v2;\n  while ($#$x > $#$y) \n    {\n    ($u2,$u1,$u0) = @$x[-3..-1];\n    $u2 = 0 unless $u2;\n    #warn \"oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l \",scalar @$y,\"\\n\"\n    # if $v1 == 0;\n    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));\n    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);\n    if ($q)\n      {\n      ($car, $bar) = (0,0);\n      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n        {\n        $prd = $q * $y->[$yi] + $car;\n        $prd -= ($car = int($prd * $RBASE)) * $BASE;\t# see USE_MUL\n\t$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));\n\t}\n      if ($x->[-1] < $car + $bar) \n        {\n        $car = 0; --$q;\n\tfor ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n          {\n\t  $x->[$xi] -= $BASE\n\t   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));\n\t  }\n\t}   \n      }\n    pop(@$x);\n    unshift(@q, $q);\n    }\n  if (wantarray) \n    {\n    @d = ();\n    if ($dd != 1)  \n      {\n      $car = 0; \n      for $xi (reverse @$x) \n        {\n        $prd = $car * $BASE + $xi;\n        $car = $prd - ($tmp = int($prd / $dd)) * $dd; # see USE_MUL\n        unshift(@d, $tmp);\n        }\n      }\n    else \n      {\n      @d = @$x;\n      }\n    @$x = @q;\n    my $d = \\@d; \n    __strip_zeros($x);\n    __strip_zeros($d);\n    return ($x,$d);\n    }\n  @$x = @q;\n  __strip_zeros($x);\n  $x;\n  }\n\nsub _div_use_div_64\n  {\n  # ref to array, ref to array, modify first array and return remainder if \n  # in list context\n  # This version works on 64 bit integers\n  my ($c,$x,$yorg) = @_;\n\n  use integer;\n  # the general div algorithm here is about O(N*N) and thus quite slow, so\n  # we first check for some special cases and use shortcuts to handle them.\n\n  # This works, because we store the numbers in a chunked format where each\n  # element contains 5..7 digits (depending on system).\n\n  # if both numbers have only one element:\n  if (@$x == 1 && @$yorg == 1)\n    {\n    # shortcut, $yorg and $x are two small numbers\n    if (wantarray)\n      {\n      my $r = [ $x->[0] % $yorg->[0] ];\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return ($x,$r); \n      }\n    else\n      {\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return $x; \n      }\n    }\n  # if x has more than one, but y has only one element:\n  if (@$yorg == 1)\n    {\n    my $rem;\n    $rem = _mod($c,[ @$x ],$yorg) if wantarray;\n\n    # shortcut, $y is < $BASE\n    my $j = scalar @$x; my $r = 0; \n    my $y = $yorg->[0]; my $b;\n    while ($j-- > 0)\n      {\n      $b = $r * $BASE + $x->[$j];\n      $x->[$j] = int($b/$y);\n      $r = $b % $y;\n      }\n    pop @$x if @$x > 1 && $x->[-1] == 0;\t# splice up a leading zero \n    return ($x,$rem) if wantarray;\n    return $x;\n    }\n  # now x and y have more than one element\n\n  # check whether y has more elements than x, if yet, the result will be 0\n  if (@$yorg > @$x)\n    {\n    my $rem;\n    $rem = [@$x] if wantarray;\t\t\t# make copy\n    splice (@$x,1);\t\t\t\t# keep ref to original array\n    $x->[0] = 0;\t\t\t\t# set to 0\n    return ($x,$rem) if wantarray;\t\t# including remainder?", 8192) = 8192
09:01:57.239227 brk(0x132f000)          = 0x132f000
09:01:57.239439 read(16, "\n    return $x;\t\t\t\t\t# only x, which is [0] now\n    }\n  # check whether the numbers have the same number of elements, in that case\n  # the result will fit into one element and can be computed efficiently\n  if (@$yorg == @$x)\n    {\n    my $rem;\n    # if $yorg has more digits than $x (it's leading element is longer than\n    # the one from $x), the result will also be 0:\n    if (length(int($yorg->[-1])) > length(int($x->[-1])))\n      {\n      $rem = [@$x] if wantarray;\t\t# make copy\n      splice (@$x,1);\t\t\t\t# keep ref to org array\n      $x->[0] = 0;\t\t\t\t# set to 0\n      return ($x,$rem) if wantarray;\t\t# including remainder?\n      return $x;\n      }\n    # now calculate $x / $yorg\n\n    if (length(int($yorg->[-1])) == length(int($x->[-1])))\n      {\n      # same length, so make full compare\n\n      my $a = 0; my $j = scalar @$x - 1;\n      # manual way (abort if unequal, good for early ne)\n      while ($j >= 0)\n        {\n        last if ($a = $x->[$j] - $yorg->[$j]); $j--;\n        }\n      # $a contains the result of the compare between X and Y\n      # a < 0: x < y, a == 0: x == y, a > 0: x > y\n      if ($a <= 0)\n        {\n        $rem = [ 0 ];\t\t\t# a = 0 => x == y => rem 0\n        $rem = [@$x] if $a != 0;\t# a < 0 => x < y => rem = x\n        splice(@$x,1);\t\t\t# keep single element\n        $x->[0] = 0;\t\t\t# if $a < 0\n        $x->[0] = 1 if $a == 0; \t# $x == $y\n        return ($x,$rem) if wantarray;\t# including remainder?\n        return $x;\n        }\n      # $x >= $y, so proceed normally\n\n      }\n    }\n\n  # all other cases:\n\n  my $y = [ @$yorg ];\t\t\t\t# always make copy to preserve\n \n  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);\n\n  $car = $bar = $prd = 0;\n  if (($dd = int($BASE/($y->[-1]+1))) != 1) \n    {\n    for $xi (@$x) \n      {\n      $xi = $xi * $dd + $car;\n      $xi -= ($car = int($xi / $BASE)) * $BASE;\n      }\n    push(@$x, $car); $car = 0;\n    for $yi (@$y) \n      {\n      $yi = $yi * $dd + $car;\n      $yi -= ($car = int($yi / $BASE)) * $BASE;\n      }\n    }\n  else \n    {\n    push(@$x, 0);\n    }\n\n  # @q will accumulate the final result, $q contains the current computed\n  # part of the final result\n\n  @q = (); ($v2,$v1) = @$y[-2,-1];\n  $v2 = 0 unless $v2;\n  while ($#$x > $#$y) \n    {\n    ($u2,$u1,$u0) = @$x[-3..-1];\n    $u2 = 0 unless $u2;\n    #warn \"oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l \",scalar @$y,\"\\n\"\n    # if $v1 == 0;\n    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));\n    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);\n    if ($q)\n      {\n      ($car, $bar) = (0,0);\n      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n        {\n        $prd = $q * $y->[$yi] + $car;\n        $prd -= ($car = int($prd / $BASE)) * $BASE;\n\t$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));\n\t}\n      if ($x->[-1] < $car + $bar) \n        {\n        $car = 0; --$q;\n\tfor ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n          {\n\t  $x->[$xi] -= $BASE\n\t   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));\n\t  }\n\t}   \n      }\n    pop(@$x); unshift(@q, $q);\n    }\n  if (wantarray) \n    {\n    @d = ();\n    if ($dd != 1)  \n      {\n      $car = 0; \n      for $xi (reverse @$x) \n        {\n        $prd = $car * $BASE + $xi;\n        $car = $prd - ($tmp = int($prd / $dd)) * $dd;\n        unshift(@d, $tmp);\n        }\n      }\n    else \n      {\n      @d = @$x;\n      }\n    @$x = @q;\n    my $d = \\@d; \n    __strip_zeros($x);\n    __strip_zeros($d);\n    return ($x,$d);\n    }\n  @$x = @q;\n  __strip_zeros($x);\n  $x;\n  }\n\nsub _div_use_div\n  {\n  # ref to array, ref to array, modify first array and return remainder if \n  # in list context\n  my ($c,$x,$yorg) = @_;\n\n  # the general div algorithm here is about O(N*N) and thus quite slow, so\n  # we first check for some special cases and use shortcuts to handle them.\n\n  # This works, because we store the numbers in a chunked format where each\n  # element contains 5..7 digits (depending on system).\n\n  # if both numbers have only one element:\n  if (@$x == 1 && @$yorg == 1)\n    {\n    # shortcut, $yorg and $x are two small numbers\n    if (wantarray)\n      {\n      my $r = [ $x->[0] % $yorg->[0] ];\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return ($x,$r); \n      }\n    else\n      {\n      $x->[0] = int($x->[0] / $yorg->[0]);\n      return $x; \n      }\n    }\n  # if x has more than one, but y has only one element:\n  if (@$yorg == 1)\n    {\n    my $rem;\n    $rem = _mod($c,[ @$x ],$yorg) if wantarray;\n\n    # shortcut, $y is < $BASE\n    my $j = scalar @$x; my $r = 0; \n    my $y = $yorg->[0]; my $b;\n    while ($j-- > 0)\n      {\n      $b = $r * $BASE + $x->[$j];\n      $x->[$j] = int($b/$y);\n      $r = $b % $y;\n      }\n    pop @$x if @$x > 1 && $x->[-1] == 0;\t# splice up a leading zero \n    return ($x,$rem) if wantarray;\n    return $x;\n    }\n  # now x and y have more than one element\n\n  # check whether y has more elements than x, if yet, the result will be 0\n  if (@$yorg > @$x)\n    {\n    my $rem;\n    $rem = [@$x] if wantarray;\t\t\t# make copy\n    splice (@$x,1);\t\t\t\t# keep ref to original array\n    $x->[0] = 0;\t\t\t\t# set to 0\n    return ($x,$rem) if wantarray;\t\t# including remainder?\n    return $x;\t\t\t\t\t# only x, which is [0] now\n    }\n  # check whether the numbers have the same number of elements, in that case\n  # the result will fit into one element and can be computed efficiently\n  if (@$yorg == @$x)\n    {\n    my $rem;\n    # if $yorg has more digits than $x (it's leading element is longer than\n    # the one from $x), the result will also be 0:\n    if (length(int($yorg->[-1])) > length(int($x->[-1])))\n      {\n      $rem = [@$x] if wantarray;\t\t# make copy\n      splice (@$x,1);\t\t\t\t# keep ref to org array\n      $x->[0] = 0;\t\t\t\t# set to 0\n      return ($x,$rem) if wantarray;\t\t# including remainder?\n      return $x;\n      }\n    # now calculate $x / $yorg\n\n    if (length(int($yorg->[-1])) == length(int($x->[-1])))\n      {\n      # same length, so make full compare\n\n      my $a = 0; my $j = scalar @$x - 1;\n      # manual way (abort if unequal, good for early ne)\n      while ($j >= 0)\n        {\n        last if ($a = $x->[$j] - $yorg->[$j]); $j--;\n        }\n      # $a contains the result of the compare between X and Y\n      # a < 0: x < y, a == 0: x == y, a > 0: x > y\n      if ($a <= 0)\n        {\n        $rem = [ 0 ];\t\t\t# a = 0 => x == y => rem 0\n        $rem = [@$x] if $a != 0;\t# a < 0 => x < y => rem = x\n        splice(@$x,1);\t\t\t# keep single element\n        $x->[0] = 0;\t\t\t# if $a < 0\n        $x->[0] = 1 if $a == 0; \t# $x == $y\n        return ($x,$rem) if wantarray;\t# including remainder?\n        return $x;\n        }\n      # $x >= $y, so proceed normally\n\n      }\n    }\n\n  # all other cases:\n\n  my $y = [ @$yorg ];\t\t\t\t# always make copy to preserve\n \n  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);\n\n  $car = $bar = $prd = 0;\n  if (($dd = int($BASE/($y->[-1]+1))) != 1) \n    {\n    for $xi (@$x) \n      {\n      $xi = $xi * $dd + $car;\n      $xi -= ($car = int($xi / $BASE)) * $BASE;\n      }\n    push(@$x, $car); $car = 0;\n    for $yi (@$y) \n      {\n      $yi = $yi * $dd + $car;\n      $yi -= ($car = int($yi / $BASE)) * $BASE;\n      }\n    }\n  else \n    {\n    push(@$x, 0);\n    }\n\n  # @q will accumulate the final result, $q contains the current computed\n  # part of the final result\n\n  @q = (); ($v2,$v1) = @$y[-2,-1];\n  $v2 = 0 unless $v2;\n  while ($#$x > $#$y) \n    {\n    ($u2,$u1,$u0) = @$x[-3..-1];\n    $u2 = 0 unless $u2;\n    #warn \"oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l \",scalar @$y,\"\\n\"\n    # if $v1 == 0;\n    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));\n    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);\n    if ($q)\n      {\n      ($car, $bar) = (0,0);\n      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n        {\n        $prd = $q * $y->[$yi] + $car;\n        $prd -= ($car = int($prd / $BASE)) * $BASE;\n\t$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));\n\t}\n      if ($x->[-1] < $car + $bar) \n        {\n        $car = 0; --$q;\n\tfor ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) \n          {\n\t  $x->[$xi] -= $BASE\n\t   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));\n\t  }\n\t}   \n      }\n    pop(@$x); unshift(@q, $q);\n    }\n  ", 8192) = 8192
09:01:57.240411 brk(0x1350000)          = 0x1350000
09:01:57.240593 read(16, "if (wantarray) \n    {\n    @d = ();\n    if ($dd != 1)  \n      {\n      $car = 0; \n      for $xi (reverse @$x) \n        {\n        $prd = $car * $BASE + $xi;\n        $car = $prd - ($tmp = int($prd / $dd)) * $dd;\n        unshift(@d, $tmp);\n        }\n      }\n    else \n      {\n      @d = @$x;\n      }\n    @$x = @q;\n    my $d = \\@d; \n    __strip_zeros($x);\n    __strip_zeros($d);\n    return ($x,$d);\n    }\n  @$x = @q;\n  __strip_zeros($x);\n  $x;\n  }\n\n##############################################################################\n# testing\n\nsub _acmp\n  {\n  # internal absolute post-normalized compare (ignore signs)\n  # ref to array, ref to array, return <0, 0, >0\n  # arrays must have at least one entry; this is not checked for\n  my ($c,$cx,$cy) = @_;\n \n  # shortcut for short numbers \n  return (($cx->[0] <=> $cy->[0]) <=> 0) \n   if scalar @$cx == scalar @$cy && scalar @$cx == 1;\n\n  # fast comp based on number of array elements (aka pseudo-length)\n  my $lxy = (scalar @$cx - scalar @$cy)\n  # or length of first element if same number of elements (aka difference 0)\n    ||\n  # need int() here because sometimes the last element is '00018' vs '18'\n   (length(int($cx->[-1])) - length(int($cy->[-1])));\n  return -1 if $lxy < 0;\t\t\t\t# already differs, ret\n  return 1 if $lxy > 0;\t\t\t\t\t# ditto\n\n  # manual way (abort if unequal, good for early ne)\n  my $a; my $j = scalar @$cx;\n  while (--$j >= 0)\n    {\n    last if ($a = $cx->[$j] - $cy->[$j]);\n    }\n  $a <=> 0;\n  }\n\nsub _len\n  {\n  # compute number of digits in base 10\n\n  # int() because add/sub sometimes leaves strings (like '00005') instead of\n  # '5' in this place, thus causing length() to report wrong length\n  my $cx = $_[1];\n\n  (@$cx-1)*$BASE_LEN+length(int($cx->[-1]));\n  }\n\nsub _digit\n  {\n  # Return the nth digit. Zero is rightmost, so _digit(123,0) gives 3.\n  # Negative values count from the left, so _digit(123, -1) gives 1.\n  my ($c,$x,$n) = @_;\n\n  my $len = _len('',$x);\n\n  $n += $len if $n < 0;                 # -1 last, -2 second-to-last\n  return \"0\" if $n < 0 || $n >= $len;   # return 0 for digits out of range\n\n  my $elem = int($n / $BASE_LEN);       # which array element\n  my $digit = $n % $BASE_LEN;           # which digit in this element\n  substr(\"$x->[$elem]\", -$digit-1, 1);\n  }\n\nsub _zeros\n  {\n  # return amount of trailing zeros in decimal\n  # check each array elem in _m for having 0 at end as long as elem == 0\n  # Upon finding a elem != 0, stop\n  my $x = $_[1];\n\n  return 0 if scalar @$x == 1 && $x->[0] == 0;\n\n  my $zeros = 0; my $elem;\n  foreach my $e (@$x)\n    {\n    if ($e != 0)\n      {\n      $elem = \"$e\";\t\t\t\t# preserve x\n      $elem =~ s/.*?(0*$)/$1/;\t\t\t# strip anything not zero\n      $zeros *= $BASE_LEN;\t\t\t# elems * 5\n      $zeros += length($elem);\t\t\t# count trailing zeros\n      last;\t\t\t\t\t# early out\n      }\n    $zeros ++;\t\t\t\t\t# real else branch: 50% slower!\n    }\n  $zeros;\n  }\n\n##############################################################################\n# _is_* routines\n\nsub _is_zero\n  {\n  # return true if arg is zero \n  (((scalar @{$_[1]} == 1) && ($_[1]->[0] == 0))) <=> 0;\n  }\n\nsub _is_even\n  {\n  # return true if arg is even\n  (!($_[1]->[0] & 1)) <=> 0; \n  }\n\nsub _is_odd\n  {\n  # return true if arg is odd\n  (($_[1]->[0] & 1)) <=> 0;\n  }\n\nsub _is_one\n  {\n  # return true if arg is one\n  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 1) <=> 0; \n  }\n\nsub _is_two\n  {\n  # return true if arg is two \n  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 2) <=> 0; \n  }\n\nsub _is_ten\n  {\n  # return true if arg is ten \n  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 10) <=> 0; \n  }\n\nsub __strip_zeros\n  {\n  # internal normalization function that strips leading zeros from the array\n  # args: ref to array\n  my $s = shift;\n \n  my $cnt = scalar @$s; # get count of parts\n  my $i = $cnt-1;\n  push @$s,0 if $i < 0;\t\t# div might return empty results, so fix it\n\n  return $s if @$s == 1;\t\t# early out\n\n  #print \"strip: cnt $cnt i $i\\n\";\n  # '0', '3', '4', '0', '0',\n  #  0    1    2    3    4\n  # cnt = 5, i = 4\n  # i = 4\n  # i = 3\n  # => fcnt = cnt - i (5-2 => 3, cnt => 5-1 = 4, throw away from 4th pos)\n  # >= 1: skip first part (this can be zero)\n  while ($i > 0) { last if $s->[$i] != 0; $i--; }\n  $i++; splice @$s,$i if ($i < $cnt); # $i cant be 0\n  $s;                                                                    \n  }                                                                             \n\n###############################################################################\n# check routine to test internal state for corruptions\n\nsub _check\n  {\n  # used by the test suite\n  my $x = $_[1];\n\n  return \"$x is not a reference\" if !ref($x);\n\n  # are all parts are valid?\n  my $i = 0; my $j = scalar @$x; my ($e,$try);\n  while ($i < $j)\n    {\n    $e = $x->[$i]; $e = 'undef' unless defined $e;\n    $try = '=~ /^[\\+]?[0-9]+\\$/; '.\"($x, $e)\";\n    last if $e !~ /^[+]?[0-9]+$/;\n    $try = '=~ /^[\\+]?[0-9]+\\$/; '.\"($x, $e) (stringify)\";\n    last if \"$e\" !~ /^[+]?[0-9]+$/;\n    $try = '=~ /^[\\+]?[0-9]+\\$/; '.\"($x, $e) (cat-stringify)\";\n    last if '' . \"$e\" !~ /^[+]?[0-9]+$/;\n    $try = ' < 0 || >= $BASE; '.\"($x, $e)\";\n    last if $e <0 || $e >= $BASE;\n    # this test is disabled, since new/bnorm and certain ops (like early out\n    # in add/sub) are allowed/expected to leave '00000' in some elements\n    #$try = '=~ /^00+/; '.\"($x, $e)\";\n    #last if $e =~ /^00+/;\n    $i++;\n    }\n  return \"Illegal part '$e' at pos $i (tested: $try)\" if $i < $j;\n  0;\n  }\n\n\n###############################################################################\n\nsub _mod\n  {\n  # if possible, use mod shortcut\n  my ($c,$x,$yo) = @_;\n\n  # slow way since $y too big\n  if (scalar @$yo > 1)\n    {\n    my ($xo,$rem) = _div($c,$x,$yo);\n    @$x = @$rem;\n    return $x;\n    }\n\n  my $y = $yo->[0];\n\n  # if both are single element arrays\n  if (scalar @$x == 1)\n    {\n    $x->[0] %= $y;\n    return $x;\n    }\n\n  # if @$x has more than one element, but @$y is a single element\n  my $b = $BASE % $y;\n  if ($b == 0)\n    {\n    # when BASE % Y == 0 then (B * BASE) % Y == 0\n    # (B * BASE) % $y + A % Y => A % Y\n    # so need to consider only last element: O(1)\n    $x->[0] %= $y;\n    }\n  elsif ($b == 1)\n    {\n    # else need to go through all elements in @$x: O(N), but loop is a bit\n    # simplified\n    my $r = 0;\n    foreach (@$x)\n      {\n      $r = ($r + $_) % $y;\t\t# not much faster, but heh...\n      #$r += $_ % $y; $r %= $y;\n      }\n    $r = 0 if $r == $y;\n    $x->[0] = $r;\n    }\n  else\n    {\n    # else need to go through all elements in @$x: O(N)\n    my $r = 0;\n    my $bm = 1;\n    foreach (@$x)\n      {\n      $r = ($_ * $bm + $r) % $y;\n      $bm = ($bm * $b) % $y;\n\n      #$r += ($_ % $y) * $bm;\n      #$bm *= $b;\n      #$bm %= $y;\n      #$r %= $y;\n      }\n    $r = 0 if $r == $y;\n    $x->[0] = $r;\n    }\n  @$x = $x->[0];\t\t# keep one element of @$x\n  return $x;\n  }\n\n##############################################################################\n# shifts\n\nsub _rsft\n  {\n  my ($c,$x,$y,$n) = @_;\n\n  if ($n != 10)\n    {\n    $n = _new($c,$n); return _div($c,$x, _pow($c,$n,$y));\n    }\n\n  # shortcut (faster) for shifting by 10)\n  # multiples of $BASE_LEN\n  my $dst = 0;\t\t\t\t# destination\n  my $src = _num($c,$y);\t\t# as normal int\n  my $xlen = (@$x-1)*$BASE_LEN+length(int($x->[-1]));  # len of x in digits\n  if ($src >= $xlen or ($src == $xlen and ! defined $x->[1]))\n    {\n    # 12345 67890 shifted right by more than 10 digits => 0\n    splice (@$x,1);                    # leave only one element\n    $x->[0] = 0;                       # set to zero\n    return $x;\n    }\n  my $rem = $src % $BASE_LEN;\t\t# remainder to shift\n  $src = int($src / $BASE_LEN);\t\t# source\n  if ($rem == 0)\n    {\n    splice (@$x,0,$src);\t\t# even faster, 38.4 => 39.3\n    }\n  else\n    {\n    my $len = scalar @$x - $src;\t# elems to go\n    my $vd; my $z = '0'x $BASE_LEN;\n    $x->[scalar @$x] = 0;\t\t# avoid || 0 test inside loop\n    while ($dst < $len)\n      {\n      $vd = $z.$x->[$src];\n      $vd = substr($vd,-$BASE_LEN,$BASE_LEN-$rem);\n      $src++;\n      $vd = substr($z.$x->[$src],-$rem,$rem) . $vd;\n      $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;\n      $x->[$dst] = int($vd);\n      $dst++;\n      }\n    splice (@$x,$dst) if $dst > 0;\t\t# kill", 8192) = 8192
09:01:57.241742 read(16, " left-over array elems\n    pop @$x if $x->[-1] == 0 && @$x > 1;\t# kill last element if 0\n    } # else rem == 0\n  $x;\n  }\n\nsub _lsft\n  {\n  my ($c,$x,$y,$n) = @_;\n\n  if ($n != 10)\n    {\n    $n = _new($c,$n); return _mul($c,$x, _pow($c,$n,$y));\n    }\n\n  # shortcut (faster) for shifting by 10) since we are in base 10eX\n  # multiples of $BASE_LEN:\n  my $src = scalar @$x;\t\t\t# source\n  my $len = _num($c,$y);\t\t# shift-len as normal int\n  my $rem = $len % $BASE_LEN;\t\t# remainder to shift\n  my $dst = $src + int($len/$BASE_LEN);\t# destination\n  my $vd;\t\t\t\t# further speedup\n  $x->[$src] = 0;\t\t\t# avoid first ||0 for speed\n  my $z = '0' x $BASE_LEN;\n  while ($src >= 0)\n    {\n    $vd = $x->[$src]; $vd = $z.$vd;\n    $vd = substr($vd,-$BASE_LEN+$rem,$BASE_LEN-$rem);\n    $vd .= $src > 0 ? substr($z.$x->[$src-1],-$BASE_LEN,$rem) : '0' x $rem;\n    $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;\n    $x->[$dst] = int($vd);\n    $dst--; $src--;\n    }\n  # set lowest parts to 0\n  while ($dst >= 0) { $x->[$dst--] = 0; }\n  # fix spurious last zero element\n  splice @$x,-1 if $x->[-1] == 0;\n  $x;\n  }\n\nsub _pow\n  {\n  # power of $x to $y\n  # ref to array, ref to array, return ref to array\n  my ($c,$cx,$cy) = @_;\n\n  if (scalar @$cy == 1 && $cy->[0] == 0)\n    {\n    splice (@$cx,1); $cx->[0] = 1;\t\t# y == 0 => x => 1\n    return $cx;\n    }\n  if ((scalar @$cx == 1 && $cx->[0] == 1) ||\t#    x == 1\n      (scalar @$cy == 1 && $cy->[0] == 1))\t# or y == 1\n    {\n    return $cx;\n    }\n  if (scalar @$cx == 1 && $cx->[0] == 0)\n    {\n    splice (@$cx,1); $cx->[0] = 0;\t\t# 0 ** y => 0 (if not y <= 0)\n    return $cx;\n    }\n\n  my $pow2 = _one();\n\n  my $y_bin = _as_bin($c,$cy); $y_bin =~ s/^0b//;\n  my $len = length($y_bin);\n  while (--$len > 0)\n    {\n    _mul($c,$pow2,$cx) if substr($y_bin,$len,1) eq '1';\t\t# is odd?\n    _mul($c,$cx,$cx);\n    }\n\n  _mul($c,$cx,$pow2);\n  $cx;\n  }\n\nsub _nok {\n    # Return binomial coefficient (n over k).\n    # Given refs to arrays, return ref to array.\n    # First input argument is modified.\n\n    my ($c, $n, $k) = @_;\n\n    # If k > n/2, or, equivalently, 2*k > n, compute nok(n, k) as\n    # nok(n, n-k), to minimize the number if iterations in the loop.\n\n    {\n        my $twok = _mul($c, _two($c), _copy($c, $k));   # 2 * k\n        if (_acmp($c, $twok, $n) > 0) {                 # if 2*k > n\n            $k = _sub($c, _copy($c, $n), $k);           # k = n - k\n        }\n    }\n\n    # Example:\n    #\n    # / 7 \\       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7\n    # |   | = --------- =  --------------- = --------- = 5 * - * -\n    # \\ 3 /   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3\n\n    if (_is_zero($c, $k)) {\n        @$n = 1;\n    }\n\n    else {\n\n        # Make a copy of the original n, since we'll be modifing n in-place.\n\n        my $n_orig = _copy($c, $n);\n\n        # n = 5, f = 6, d = 2 (cf. example above)\n\n        _sub($c, $n, $k);\n        _inc($c, $n);\n\n        my $f = _copy($c, $n);\n        _inc($c, $f);\n\n        my $d = _two($c);\n\n        # while f <= n (the original n, that is) ...\n\n        while (_acmp($c, $f, $n_orig) <= 0) {\n\n            # n = (n * f / d) == 5 * 6 / 2 (cf. example above)\n\n            _mul($c, $n, $f);\n            _div($c, $n, $d);\n\n            # f = 7, d = 3 (cf. example above)\n\n            _inc($c, $f);\n            _inc($c, $d);\n        }\n\n    }\n\n    return $n;\n}\n\nmy @factorials = (\n  1,\n  1,\n  2,\n  2*3,\n  2*3*4,\n  2*3*4*5,\n  2*3*4*5*6,\n  2*3*4*5*6*7,\n);\n\nsub _fac\n  {\n  # factorial of $x\n  # ref to array, return ref to array\n  my ($c,$cx) = @_;\n\n  if ((@$cx == 1) && ($cx->[0] <= 7))\n    {\n    $cx->[0] = $factorials[$cx->[0]];\t\t# 0 => 1, 1 => 1, 2 => 2 etc.\n    return $cx;\n    }\n\n  if ((@$cx == 1) && \t\t# we do this only if $x >= 12 and $x <= 7000\n      ($cx->[0] >= 12 && $cx->[0] < 7000))\n    {\n\n  # Calculate (k-j) * (k-j+1) ... k .. (k+j-1) * (k + j)\n  # See http://blogten.blogspot.com/2007/01/calculating-n.html\n  # The above series can be expressed as factors:\n  #   k * k - (j - i) * 2\n  # We cache k*k, and calculate (j * j) as the sum of the first j odd integers\n\n  # This will not work when N exceeds the storage of a Perl scalar, however,\n  # in this case the algorithm would be way to slow to terminate, anyway.\n\n  # As soon as the last element of $cx is 0, we split it up and remember\n  # how many zeors we got so far. The reason is that n! will accumulate\n  # zeros at the end rather fast.\n  my $zero_elements = 0;\n\n  # If n is even, set n = n -1\n  my $k = _num($c,$cx); my $even = 1;\n  if (($k & 1) == 0)\n    {\n    $even = $k; $k --;\n    }\n  # set k to the center point\n  $k = ($k + 1) / 2;\n#  print \"k $k even: $even\\n\";\n  # now calculate k * k\n  my $k2 = $k * $k;\n  my $odd = 1; my $sum = 1;\n  my $i = $k - 1;\n  # keep reference to x\n  my $new_x = _new($c, $k * $even);\n  @$cx = @$new_x;\n  if ($cx->[0] == 0)\n    {\n    $zero_elements ++; shift @$cx;\n    }\n#  print STDERR \"x = \", _str($c,$cx),\"\\n\";\n  my $BASE2 = int(sqrt($BASE))-1;\n  my $j = 1; \n  while ($j <= $i)\n    {\n    my $m = ($k2 - $sum); $odd += 2; $sum += $odd; $j++;\n    while ($j <= $i && ($m < $BASE2) && (($k2 - $sum) < $BASE2))\n      {\n      $m *= ($k2 - $sum);\n      $odd += 2; $sum += $odd; $j++;\n#      print STDERR \"\\n k2 $k2 m $m sum $sum odd $odd\\n\"; sleep(1);\n      }\n    if ($m < $BASE)\n      {\n      _mul($c,$cx,[$m]);\n      }\n    else\n      {\n      _mul($c,$cx,$c->_new($m));\n      }\n    if ($cx->[0] == 0)\n      {\n      $zero_elements ++; shift @$cx;\n      }\n#    print STDERR \"Calculate $k2 - $sum = $m (x = \", _str($c,$cx),\")\\n\";\n    }\n  # multiply in the zeros again\n  unshift @$cx, (0) x $zero_elements; \n  return $cx;\n  }\n\n  # go forward until $base is exceeded\n  # limit is either $x steps (steps == 100 means a result always too high) or\n  # $base.\n  my $steps = 100; $steps = $cx->[0] if @$cx == 1;\n  my $r = 2; my $cf = 3; my $step = 2; my $last = $r;\n  while ($r*$cf < $BASE && $step < $steps)\n    {\n    $last = $r; $r *= $cf++; $step++;\n    }\n  if ((@$cx == 1) && $step == $cx->[0])\n    {\n    # completely done, so keep reference to $x and return\n    $cx->[0] = $r;\n    return $cx;\n    }\n  \n  # now we must do the left over steps\n  my $n;\t\t\t\t\t# steps still to do\n  if (scalar @$cx == 1)\n    {\n    $n = $cx->[0];\n    }\n  else\n    {\n    $n = _copy($c,$cx);\n    }\n\n  # Set $cx to the last result below $BASE (but keep ref to $x)\n  $cx->[0] = $last; splice (@$cx,1);\n  # As soon as the last element of $cx is 0, we split it up and remember\n  # how many zeors we got so far. The reason is that n! will accumulate\n  # zeros at the end rather fast.\n  my $zero_elements = 0;\n\n  # do left-over steps fit into a scalar?\n  if (ref $n eq 'ARRAY')\n    {\n    # No, so use slower inc() & cmp()\n    # ($n is at least $BASE here)\n    my $base_2 = int(sqrt($BASE)) - 1;\n    #print STDERR \"base_2: $base_2\\n\"; \n    while ($step < $base_2)\n      {\n      if ($cx->[0] == 0)\n        {\n        $zero_elements ++; shift @$cx;\n        }\n      my $b = $step * ($step + 1); $step += 2;\n      _mul($c,$cx,[$b]);\n      }\n    $step = [$step];\n    while (_acmp($c,$step,$n) <= 0)\n      {\n      if ($cx->[0] == 0)\n        {\n        $zero_elements ++; shift @$cx;\n        }\n      _mul($c,$cx,$step); _inc($c,$step);\n      }\n    }\n  else\n    {\n    # Yes, so we can speed it up slightly\n  \n#    print \"# left over steps $n\\n\";\n\n    my $base_4 = int(sqrt(sqrt($BASE))) - 2;\n    #print STDERR \"base_4: $base_4\\n\";\n    my $n4 = $n - 4; \n    while ($step < $n4 && $step < $base_4)\n      {\n      if ($cx->[0] == 0)\n        {\n        $zero_elements ++; shift @$cx;\n        }\n      my $b = $step * ($step + 1); $step += 2; $b *= $step * ($step + 1); $step += 2;\n      _mul($c,$cx,[$b]);\n      }\n    my $base_2 = int(sqrt($BASE)) - 1;\n    my $n2 = $n - 2; \n    #print STDERR \"base_2: $base_2\\n\"; \n    while ($step < $n2 && $step < $base_2)\n      {\n      if ($cx->[0] == 0)\n        {\n        $zero_elements ++; shift @$cx;\n        }\n      my $b = $step * ($step + 1); $step += 2;\n      _mul($c,$cx,[$b]);\n      }\n    # do what's left over\n    while ($step <= $n)\n      {\n      _mul($c,$cx,[$step]); $step++;\n      if ($cx->[0] == 0)\n        {\n        $zero_elements ++; shift @$cx;\n        }\n      }\n    }\n  # multiply in the zeros a", 8192) = 8192
09:01:57.242295 brk(0x1371000)          = 0x1371000
09:01:57.242929 read(16, "gain\n  unshift @$cx, (0) x $zero_elements;\n  $cx;\t\t\t# return result\n  }\n\n#############################################################################\n\nsub _log_int\n  {\n  # calculate integer log of $x to base $base\n  # ref to array, ref to array - return ref to array\n  my ($c,$x,$base) = @_;\n\n  # X == 0 => NaN\n  return if (scalar @$x == 1 && $x->[0] == 0);\n  # BASE 0 or 1 => NaN\n  return if (scalar @$base == 1 && $base->[0] < 2);\n  my $cmp = _acmp($c,$x,$base); # X == BASE => 1\n  if ($cmp == 0)\n    {\n    splice (@$x,1); $x->[0] = 1;\n    return ($x,1)\n    }\n  # X < BASE\n  if ($cmp < 0)\n    {\n    splice (@$x,1); $x->[0] = 0;\n    return ($x,undef);\n    }\n\n  my $x_org = _copy($c,$x);\t\t# preserve x\n  splice(@$x,1); $x->[0] = 1;\t\t# keep ref to $x\n\n  # Compute a guess for the result based on:\n  # $guess = int ( length_in_base_10(X) / ( log(base) / log(10) ) )\n  my $len = _len($c,$x_org);\n  my $log = log($base->[-1]) / log(10);\n\n  # for each additional element in $base, we add $BASE_LEN to the result,\n  # based on the observation that log($BASE,10) is BASE_LEN and\n  # log(x*y) == log(x) + log(y):\n  $log += ((scalar @$base)-1) * $BASE_LEN;\n\n  # calculate now a guess based on the values obtained above:\n  my $res = int($len / $log);\n\n  $x->[0] = $res;\n  my $trial = _pow ($c, _copy($c, $base), $x);\n  my $a = _acmp($c,$trial,$x_org);\n\n#  print STDERR \"# trial \", _str($c,$x),\" was: $a (0 = exact, -1 too small, +1 too big)\\n\";\n\n  # found an exact result?\n  return ($x,1) if $a == 0;\n\n  if ($a > 0)\n    {\n    # or too big\n    _div($c,$trial,$base); _dec($c, $x);\n    while (($a = _acmp($c,$trial,$x_org)) > 0)\n      {\n#      print STDERR \"# big _log_int at \", _str($c,$x), \"\\n\"; \n      _div($c,$trial,$base); _dec($c, $x);\n      }\n    # result is now exact (a == 0), or too small (a < 0)\n    return ($x, $a == 0 ? 1 : 0);\n    }\n\n  # else: result was to small\n  _mul($c,$trial,$base);\n\n  # did we now get the right result?\n  $a = _acmp($c,$trial,$x_org);\n\n  if ($a == 0)\t\t\t\t# yes, exactly\n    {\n    _inc($c, $x);\n    return ($x,1); \n    }\n  return ($x,0) if $a > 0;  \n\n  # Result still too small (we should come here only if the estimate above\n  # was very off base):\n \n  # Now let the normal trial run obtain the real result\n  # Simple loop that increments $x by 2 in each step, possible overstepping\n  # the real result\n\n  my $base_mul = _mul($c, _copy($c,$base), $base);\t# $base * $base\n\n  while (($a = _acmp($c,$trial,$x_org)) < 0)\n    {\n#    print STDERR \"# small _log_int at \", _str($c,$x), \"\\n\"; \n    _mul($c,$trial,$base_mul); _add($c, $x, [2]);\n    }\n\n  my $exact = 1;\n  if ($a > 0)\n    {\n    # overstepped the result\n    _dec($c, $x);\n    _div($c,$trial,$base);\n    $a = _acmp($c,$trial,$x_org);\n    if ($a > 0)\n      {\n      _dec($c, $x);\n      }\n    $exact = 0 if $a != 0;\t\t# a = -1 => not exact result, a = 0 => exact\n    }\n  \n  ($x,$exact);\t\t\t\t# return result\n  }\n\n# for debugging:\n  use constant DEBUG => 0;\n  my $steps = 0;\n  sub steps { $steps };\n\nsub _sqrt\n  {\n  # square-root of $x in place\n  # Compute a guess of the result (by rule of thumb), then improve it via\n  # Newton's method.\n  my ($c,$x) = @_;\n\n  if (scalar @$x == 1)\n    {\n    # fits into one Perl scalar, so result can be computed directly\n    $x->[0] = int(sqrt($x->[0]));\n    return $x;\n    } \n  my $y = _copy($c,$x);\n  # hopefully _len/2 is < $BASE, the -1 is to always undershot the guess\n  # since our guess will \"grow\"\n  my $l = int((_len($c,$x)-1) / 2);\t\n\n  my $lastelem = $x->[-1];\t\t\t\t\t# for guess\n  my $elems = scalar @$x - 1;\n  # not enough digits, but could have more?\n  if ((length($lastelem) <= 3) && ($elems > 1))\n    {\n    # right-align with zero pad\n    my $len = length($lastelem) & 1;\n    print \"$lastelem => \" if DEBUG;\n    $lastelem .= substr($x->[-2] . '0' x $BASE_LEN,0,$BASE_LEN);\n    # former odd => make odd again, or former even to even again\n    $lastelem = $lastelem / 10 if (length($lastelem) & 1) != $len;\n    print \"$lastelem\\n\" if DEBUG;\n    }\n\n  # construct $x (instead of _lsft($c,$x,$l,10)\n  my $r = $l % $BASE_LEN;\t# 10000 00000 00000 00000 ($BASE_LEN=5)\n  $l = int($l / $BASE_LEN);\n  print \"l =  $l \" if DEBUG;\n\n  splice @$x,$l;\t\t# keep ref($x), but modify it\n\n  # we make the first part of the guess not '1000...0' but int(sqrt($lastelem))\n  # that gives us:\n  # 14400 00000 => sqrt(14400) => guess first digits to be 120\n  # 144000 000000 => sqrt(144000) => guess 379\n\n  print \"$lastelem (elems $elems) => \" if DEBUG;\n  $lastelem = $lastelem / 10 if ($elems & 1 == 1);\t\t# odd or even?\n  my $g = sqrt($lastelem); $g =~ s/\\.//;\t\t\t# 2.345 => 2345\n  $r -= 1 if $elems & 1 == 0;\t\t\t\t\t# 70 => 7\n\n  # padd with zeros if result is too short\n  $x->[$l--] = int(substr($g . '0' x $r,0,$r+1));\n  print \"now \",$x->[-1] if DEBUG;\n  print \" would have been \", int('1' . '0' x $r),\"\\n\" if DEBUG;\n\n  # If @$x > 1, we could compute the second elem of the guess, too, to create\n  # an even better guess. Not implemented yet. Does it improve performance?\n  $x->[$l--] = 0 while ($l >= 0);\t# all other digits of guess are zero\n\n  print \"start x= \",_str($c,$x),\"\\n\" if DEBUG;\n  my $two = _two();\n  my $last = _zero();\n  my $lastlast = _zero();\n  $steps = 0 if DEBUG;\n  while (_acmp($c,$last,$x) != 0 && _acmp($c,$lastlast,$x) != 0)\n    {\n    $steps++ if DEBUG;\n    $lastlast = _copy($c,$last);\n    $last = _copy($c,$x);\n    _add($c,$x, _div($c,_copy($c,$y),$x));\n    _div($c,$x, $two );\n    print \" x= \",_str($c,$x),\"\\n\" if DEBUG;\n    }\n  print \"\\nsteps in sqrt: $steps, \" if DEBUG;\n  _dec($c,$x) if _acmp($c,$y,_mul($c,_copy($c,$x),$x)) < 0;\t# overshot? \n  print \" final \",$x->[-1],\"\\n\" if DEBUG;\n  $x;\n  }\n\nsub _root\n  {\n  # take n'th root of $x in place (n >= 3)\n  my ($c,$x,$n) = @_;\n \n  if (scalar @$x == 1)\n    {\n    if (scalar @$n > 1)\n      {\n      # result will always be smaller than 2 so trunc to 1 at once\n      $x->[0] = 1;\n      }\n    else\n      {\n      # fits into one Perl scalar, so result can be computed directly\n      # cannot use int() here, because it rounds wrongly (try \n      # (81 ** 3) ** (1/3) to see what I mean)\n      #$x->[0] = int( $x->[0] ** (1 / $n->[0]) );\n      # round to 8 digits, then truncate result to integer\n      $x->[0] = int ( sprintf (\"%.8f\", $x->[0] ** (1 / $n->[0]) ) );\n      }\n    return $x;\n    } \n\n  # we know now that X is more than one element long\n\n  # if $n is a power of two, we can repeatedly take sqrt($X) and find the\n  # proper result, because sqrt(sqrt($x)) == root($x,4)\n  my $b = _as_bin($c,$n);\n  if ($b =~ /0b1(0+)$/)\n    {\n    my $count = CORE::length($1);\t# 0b100 => len('00') => 2\n    my $cnt = $count;\t\t\t# counter for loop\n    unshift (@$x, 0);\t\t\t# add one element, together with one\n\t\t\t\t\t# more below in the loop this makes 2\n    while ($cnt-- > 0)\n      {\n      # 'inflate' $X by adding one element, basically computing\n      # $x * $BASE * $BASE. This gives us more $BASE_LEN digits for result\n      # since len(sqrt($X)) approx == len($x) / 2.\n      unshift (@$x, 0);\n      # calculate sqrt($x), $x is now one element to big, again. In the next\n      # round we make that two, again.\n      _sqrt($c,$x);\n      }\n    # $x is now one element to big, so truncate result by removing it\n    splice (@$x,0,1);\n    } \n  else\n    {\n    # trial computation by starting with 2,4,8,16 etc until we overstep\n    my $step;\n    my $trial = _two();\n\n    # while still to do more than X steps\n    do\n      {\n      $step = _two();\n      while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)\n        {\n        _mul ($c, $step, [2]);\n        _add ($c, $trial, $step);\n        }\n\n      # hit exactly?\n      if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) == 0)\n        {\n        @$x = @$trial;\t\t\t# make copy while preserving ref to $x\n        return $x;\n        }\n      # overstepped, so go back on step\n      _sub($c, $trial, $step);\n      } while (scalar @$step > 1 || $step->[0] > 128);\n\n    # reset step to 2\n    $step = _two();\n    # add two, because $trial cannot be exactly the result (otherwise we would\n    # already have found it)\n    _add($c, $trial, $step);\n \n    # and now add more and more (2,4,6,8,10 etc)\n    while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)\n      {\n      _add ($c, $trial, $step);", 8192) = 8192
09:01:57.243492 brk(0x1392000)          = 0x1392000
09:01:57.244224 read(16, "\n      }\n\n    # hit not exactly? (overstepped)\n    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)\n      {\n      _dec($c,$trial);\n      }\n\n    # hit not exactly? (overstepped)\n    # 80 too small, 81 slightly too big, 82 too big\n    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)\n      {\n      _dec ($c, $trial); \n      }\n\n    @$x = @$trial;\t\t\t# make copy while preserving ref to $x\n    return $x;\n    }\n  $x; \n  }\n\n##############################################################################\n# binary stuff\n\nsub _and\n  {\n  my ($c,$x,$y) = @_;\n\n  # the shortcut makes equal, large numbers _really_ fast, and makes only a\n  # very small performance drop for small numbers (e.g. something with less\n  # than 32 bit) Since we optimize for large numbers, this is enabled.\n  return $x if _acmp($c,$x,$y) == 0;\t\t# shortcut\n  \n  my $m = _one(); my ($xr,$yr);\n  my $mask = $AND_MASK;\n\n  my $x1 = $x;\n  my $y1 = _copy($c,$y);\t\t\t# make copy\n  $x = _zero();\n  my ($b,$xrr,$yrr);\n  use integer;\n  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))\n    {\n    ($x1, $xr) = _div($c,$x1,$mask);\n    ($y1, $yr) = _div($c,$y1,$mask);\n\n    # make ints() from $xr, $yr\n    # this is when the AND_BITS are greater than $BASE and is slower for\n    # small (<256 bits) numbers, but faster for large numbers. Disabled\n    # due to KISS principle\n\n#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }\n#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }\n#    _add($c,$x, _mul($c, _new( $c, ($xrr & $yrr) ), $m) );\n    \n    # 0+ due to '&' doesn't work in strings\n    _add($c,$x, _mul($c, [ 0+$xr->[0] & 0+$yr->[0] ], $m) );\n    _mul($c,$m,$mask);\n    }\n  $x;\n  }\n\nsub _xor\n  {\n  my ($c,$x,$y) = @_;\n\n  return _zero() if _acmp($c,$x,$y) == 0;\t# shortcut (see -and)\n\n  my $m = _one(); my ($xr,$yr);\n  my $mask = $XOR_MASK;\n\n  my $x1 = $x;\n  my $y1 = _copy($c,$y);\t\t\t# make copy\n  $x = _zero();\n  my ($b,$xrr,$yrr);\n  use integer;\n  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))\n    {\n    ($x1, $xr) = _div($c,$x1,$mask);\n    ($y1, $yr) = _div($c,$y1,$mask);\n    # make ints() from $xr, $yr (see _and())\n    #$b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }\n    #$b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }\n    #_add($c,$x, _mul($c, _new( $c, ($xrr ^ $yrr) ), $m) );\n\n    # 0+ due to '^' doesn't work in strings\n    _add($c,$x, _mul($c, [ 0+$xr->[0] ^ 0+$yr->[0] ], $m) );\n    _mul($c,$m,$mask);\n    }\n  # the loop stops when the shorter of the two numbers is exhausted\n  # the remainder of the longer one will survive bit-by-bit, so we simple\n  # multiply-add it in\n  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);\n  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);\n  \n  $x;\n  }\n\nsub _or\n  {\n  my ($c,$x,$y) = @_;\n\n  return $x if _acmp($c,$x,$y) == 0;\t\t# shortcut (see _and)\n\n  my $m = _one(); my ($xr,$yr);\n  my $mask = $OR_MASK;\n\n  my $x1 = $x;\n  my $y1 = _copy($c,$y);\t\t\t# make copy\n  $x = _zero();\n  my ($b,$xrr,$yrr);\n  use integer;\n  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))\n    {\n    ($x1, $xr) = _div($c,$x1,$mask);\n    ($y1, $yr) = _div($c,$y1,$mask);\n    # make ints() from $xr, $yr (see _and())\n#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }\n#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }\n#    _add($c,$x, _mul($c, _new( $c, ($xrr | $yrr) ), $m) );\n    \n    # 0+ due to '|' doesn't work in strings\n    _add($c,$x, _mul($c, [ 0+$xr->[0] | 0+$yr->[0] ], $m) );\n    _mul($c,$m,$mask);\n    }\n  # the loop stops when the shorter of the two numbers is exhausted\n  # the remainder of the longer one will survive bit-by-bit, so we simple\n  # multiply-add it in\n  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);\n  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);\n  \n  $x;\n  }\n\nsub _as_hex\n  {\n  # convert a decimal number to hex (ref to array, return ref to string)\n  my ($c,$x) = @_;\n\n  # fits into one element (handle also 0x0 case)\n  return sprintf(\"0x%x\",$x->[0]) if @$x == 1;\n\n  my $x1 = _copy($c,$x);\n\n  my $es = '';\n  my ($xr, $h, $x10000);\n  if ($] >= 5.006)\n    {\n    $x10000 = [ 0x10000 ]; $h = 'h4';\n    }\n  else\n    {\n    $x10000 = [ 0x1000 ]; $h = 'h3';\n    }\n  while (@$x1 != 1 || $x1->[0] != 0)\t\t# _is_zero()\n    {\n    ($x1, $xr) = _div($c,$x1,$x10000);\n    $es .= unpack($h,pack('V',$xr->[0]));\n    }\n  $es = reverse $es;\n  $es =~ s/^[0]+//;   # strip leading zeros\n  '0x' . $es;\t\t\t\t\t# return result prepended with 0x\n  }\n\nsub _as_bin\n  {\n  # convert a decimal number to bin (ref to array, return ref to string)\n  my ($c,$x) = @_;\n\n  # fits into one element (and Perl recent enough), handle also 0b0 case\n  # handle zero case for older Perls\n  if ($] <= 5.005 && @$x == 1 && $x->[0] == 0)\n    {\n    my $t = '0b0'; return $t;\n    }\n  if (@$x == 1 && $] >= 5.006)\n    {\n    my $t = sprintf(\"0b%b\",$x->[0]);\n    return $t;\n    }\n  my $x1 = _copy($c,$x);\n\n  my $es = '';\n  my ($xr, $b, $x10000);\n  if ($] >= 5.006)\n    {\n    $x10000 = [ 0x10000 ]; $b = 'b16';\n    }\n  else\n    {\n    $x10000 = [ 0x1000 ]; $b = 'b12';\n    }\n  while (!(@$x1 == 1 && $x1->[0] == 0))\t\t# _is_zero()\n    {\n    ($x1, $xr) = _div($c,$x1,$x10000);\n    $es .= unpack($b,pack('v',$xr->[0]));\n    }\n  $es = reverse $es;\n  $es =~ s/^[0]+//;   # strip leading zeros\n  '0b' . $es;\t\t\t\t\t# return result prepended with 0b\n  }\n\nsub _as_oct\n  {\n  # convert a decimal number to octal (ref to array, return ref to string)\n  my ($c,$x) = @_;\n\n  # fits into one element (handle also 0 case)\n  return sprintf(\"0%o\",$x->[0]) if @$x == 1;\n\n  my $x1 = _copy($c,$x);\n\n  my $es = '';\n  my $xr;\n  my $x1000 = [ 0100000 ];\n  while (@$x1 != 1 || $x1->[0] != 0)\t\t# _is_zero()\n    {\n    ($x1, $xr) = _div($c,$x1,$x1000);\n    $es .= reverse sprintf(\"%05o\", $xr->[0]);\n    }\n  $es = reverse $es;\n  $es =~ s/^[0]+//;   # strip leading zeros\n  '0' . $es;\t\t\t\t\t# return result prepended with 0\n  }\n\nsub _from_oct\n  {\n  # convert a octal number to decimal (string, return ref to array)\n  my ($c,$os) = @_;\n\n  # for older Perls, play safe\n  my $m = [ 0100000 ];\n  my $d = 5;\t\t\t\t\t# 5 digits at a time\n\n  my $mul = _one();\n  my $x = _zero();\n\n  my $len = int( (length($os)-1)/$d );\t\t# $d digit parts, w/o the '0'\n  my $val; my $i = -$d;\n  while ($len >= 0)\n    {\n    $val = substr($os,$i,$d);\t\t\t# get oct digits\n    $val = CORE::oct($val);\n    $i -= $d; $len --;\n    my $adder = [ $val ];\n    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;\n    _mul ($c, $mul, $m ) if $len >= 0; \t\t# skip last mul\n    }\n  $x;\n  }\n\nsub _from_hex\n  {\n  # convert a hex number to decimal (string, return ref to array)\n  my ($c,$hs) = @_;\n\n  my $m = _new($c, 0x10000000);\t\t\t# 28 bit at a time (<32 bit!)\n  my $d = 7;\t\t\t\t\t# 7 digits at a time\n  if ($] <= 5.006)\n    {\n    # for older Perls, play safe\n    $m = [ 0x10000 ];\t\t\t\t# 16 bit at a time (<32 bit!)\n    $d = 4;\t\t\t\t\t# 4 digits at a time\n    }\n\n  my $mul = _one();\n  my $x = _zero();\n\n  my $len = int( (length($hs)-2)/$d );\t\t# $d digit parts, w/o the '0x'\n  my $val; my $i = -$d;\n  while ($len >= 0)\n    {\n    $val = substr($hs,$i,$d);\t\t\t# get hex digits\n    $val =~ s/^0x// if $len == 0;\t\t# for last part only because\n    $val = CORE::hex($val);\t\t\t# hex does not like wrong chars\n    $i -= $d; $len --;\n    my $adder = [ $val ];\n    # if the resulting number was to big to fit into one element, create a\n    # two-element version (bug found by Mark Lakata - Thanx!)\n    if (CORE::length($val) > $BASE_LEN)\n      {\n      $adder = _new($c,$val);\n      }\n    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;\n    _mul ($c, $mul, $m ) if $len >= 0; \t\t# skip last mul\n    }\n  $x;\n  }\n\nsub _from_bin\n  {\n  # convert a hex number to decimal (string, return ref to array)\n  my ($c,$bs) = @_;\n\n  # instead of converting X (8) bit at a time, it is faster to \"convert\" the\n  # number to hex, and then call _from_hex.\n\n  my $hs = $bs;\n  $hs =~ s/^[+-]?0b//;\t\t\t\t\t# remove sign and 0b\n  my $l = length($hs);\t\t\t\t\t# bits\n  $hs = '0' x (8-($l % 8)) . $hs if ($l % 8) != 0;\t# padd left side w/ 0\n  my $h = '0x' . unpack('H*', pack ('B*', $hs));\t# repack as hex\n  \n  $c->_from_hex($h);\n  }\n\n###########################################################################", 8192) = 8192
09:01:57.245512 brk(0x13b3000)          = 0x13b3000
09:01:57.246244 read(16, "###\n# special modulus functions\n\nsub _modinv\n  {\n  # modular multiplicative inverse\n  my ($c,$x,$y) = @_;\n\n  # modulo zero\n  if (_is_zero($c, $y)) {\n      return (undef, undef);\n  }\n\n  # modulo one\n  if (_is_one($c, $y)) {\n      return (_zero($c), '+');\n  }\n\n  my $u = _zero($c);\n  my $v = _one($c);\n  my $a = _copy($c,$y);\n  my $b = _copy($c,$x);\n\n  # Euclid's Algorithm for bgcd(), only that we calc bgcd() ($a) and the result\n  # ($u) at the same time. See comments in BigInt for why this works.\n  my $q;\n  my $sign = 1;\n  {\n      ($a, $q, $b) = ($b, _div($c, $a, $b));        # step 1\n      last if _is_zero($c, $b);\n\n      my $t = _add($c,                              # step 2:\n                   _mul($c, _copy($c, $v), $q) ,    #  t =   v * q\n                   $u );                            #      + u\n      $u = $v;                                      #  u = v\n      $v = $t;                                      #  v = t\n      $sign = -$sign;\n      redo;\n  }\n\n  # if the gcd is not 1, then return NaN\n  return (undef, undef) unless _is_one($c, $a);\n\n  ($v, $sign == 1 ? '+' : '-');\n  }\n\nsub _modpow\n  {\n  # modulus of power ($x ** $y) % $z\n  my ($c,$num,$exp,$mod) = @_;\n\n  # a^b (mod 1) = 0 for all a and b\n  if (_is_one($c,$mod))\n    {\n        @$num = 0;\n        return $num;\n    }\n\n  # 0^a (mod m) = 0 if m != 0, a != 0\n  # 0^0 (mod m) = 1 if m != 0\n  if (_is_zero($c, $num)) {\n      if (_is_zero($c, $exp)) {\n          @$num = 1;\n      } else {\n          @$num = 0;\n      }\n      return $num;\n  }\n\n#  $num = _mod($c,$num,$mod);\t# this does not make it faster\n\n  my $acc = _copy($c,$num); my $t = _one();\n\n  my $expbin = _as_bin($c,$exp); $expbin =~ s/^0b//;\n  my $len = length($expbin);\n  while (--$len >= 0)\n    {\n    if ( substr($expbin,$len,1) eq '1')\t\t\t# is_odd\n      {\n      _mul($c,$t,$acc);\n      $t = _mod($c,$t,$mod);\n      }\n    _mul($c,$acc,$acc);\n    $acc = _mod($c,$acc,$mod);\n    }\n  @$num = @$t;\n  $num;\n  }\n\nsub _gcd {\n    # Greatest common divisor.\n\n    my ($c, $x, $y) = @_;\n\n    # gcd(0,0) = 0\n    # gcd(0,a) = a, if a != 0\n\n    if (@$x == 1 && $x->[0] == 0) {\n        if (@$y == 1 && $y->[0] == 0) {\n            @$x = 0;\n        } else {\n            @$x = @$y;\n        }\n        return $x;\n    }\n\n    # Until $y is zero ...\n\n    until (@$y == 1 && $y->[0] == 0) {\n\n        # Compute remainder.\n\n        _mod($c, $x, $y);\n\n        # Swap $x and $y.\n\n        my $tmp = [ @$x ];\n        @$x = @$y;\n        $y = $tmp;      # no deref here; that would modify input $y\n    }\n\n    return $x;\n}\n\n##############################################################################\n##############################################################################\n\n1;\n__END__\n\n=pod\n\n=head1 NAME\n\nMath::BigInt::Calc - Pure Perl module to support Math::BigInt\n\n=head1 SYNOPSIS\n\nThis library provides support for big integer calculations. It is not\nintended to be used by other modules. Other modules which support the same\nAPI (see below) can also be used to support Math::BigInt, like\nMath::BigInt::GMP and Math::BigInt::Pari.\n\n=head1 DESCRIPTION\n\nIn this library, the numbers are represented in base B = 10**N, where N is\nthe largest possible value that does not cause overflow in the intermediate\ncomputations. The base B elements are stored in an array, with the least\nsignificant element stored in array element zero. There are no leading zero\nelements, except a single zero element when the number is zero.\n\nFor instance, if B = 10000, the number 1234567890 is represented internally\nas [3456, 7890, 12].\n\n=head1 THE Math::BigInt API\n\nIn order to allow for multiple big integer libraries, Math::BigInt was\nrewritten to use a plug-in library for core math routines. Any module which\nconforms to the API can be used by Math::BigInt by using this in your program:\n\n\tuse Math::BigInt lib => 'libname';\n\n'libname' is either the long name, like 'Math::BigInt::Pari', or only the short\nversion, like 'Pari'.\n\n=head2 General Notes\n\nA library only needs to deal with unsigned big integers. Testing of input\nparameter validity is done by the caller, so there is no need to worry about\nunderflow (e.g., in C<_sub()> and C<_dec()>) nor about division by zero (e.g.,\nin C<_div()>) or similar cases.\n\nFor some methods, the first parameter can be modified. That includes the\npossibility that you return a reference to a completely different object\ninstead. Although keeping the reference and just changing its contents is\npreferred over creating and returning a different reference.\n\nReturn values are always objects, strings, Perl scalars, or true/false for\ncomparison routines.\n\n=head2 API version 1\n\nThe following methods must be defined in order to support the use by\nMath::BigInt v1.70 or later.\n\n=head3 API version\n\n=over 4\n\n=item I<api_version()>\n\nReturn API version as a Perl scalar, 1 for Math::BigInt v1.70, 2 for\nMath::BigInt v1.83.\n\n=back\n\n=head3 Constructors\n\n=over 4\n\n=item I<_new(STR)>\n\nConvert a string representing an unsigned decimal number to an object\nrepresenting the same number. The input is normalize, i.e., it matches\nC<^(0|[1-9]\\d*)$>.\n\n=item I<_zero()>\n\nReturn an object representing the number zero.\n\n=item I<_one()>\n\nReturn an object representing the number one.\n\n=item I<_two()>\n\nReturn an object representing the number two.\n\n=item I<_ten()>\n\nReturn an object representing the number ten.\n\n=item I<_from_bin(STR)>\n\nReturn an object given a string representing a binary number. The input has a\n'0b' prefix and matches the regular expression C<^0[bB](0|1[01]*)$>.\n\n=item I<_from_oct(STR)>\n\nReturn an object given a string representing an octal number. The input has a\n'0' prefix and matches the regular expression C<^0[1-7]*$>.\n\n=item I<_from_hex(STR)>\n\nReturn an object given a string representing a hexadecimal number. The input\nhas a '0x' prefix and matches the regular expression\nC<^0x(0|[1-9a-fA-F][\\da-fA-F]*)$>.\n\n=back\n\n=head3 Mathematical functions\n\nEach of these methods may modify the first input argument, except I<_bgcd()>,\nwhich shall not modify any input argument, and I<_sub()> which may modify the\nsecond input argument.\n\n=over 4\n\n=item I<_add(OBJ1, OBJ2)>\n\nReturns the result of adding OBJ2 to OBJ1.\n\n=item I<_mul(OBJ1, OBJ2)>\n\nReturns the result of multiplying OBJ2 and OBJ1.\n\n=item I<_div(OBJ1, OBJ2)>\n\nReturns the result of dividing OBJ1 by OBJ2 and truncating the result to an\ninteger.\n\n=item I<_sub(OBJ1, OBJ2, FLAG)>\n\n=item I<_sub(OBJ1, OBJ2)>\n\nReturns the result of subtracting OBJ2 by OBJ1. If C<flag> is false or omitted,\nOBJ1 might be modified. If C<flag> is true, OBJ2 might be modified.\n\n=item I<_dec(OBJ)>\n\nDecrement OBJ by one.\n\n=item I<_inc(OBJ)>\n\nIncrement OBJ by one.\n\n=item I<_mod(OBJ1, OBJ2)>\n\nReturn OBJ1 modulo OBJ2, i.e., the remainder after dividing OBJ1 by OBJ2.\n\n=item I<_sqrt(OBJ)>\n\nReturn the square root of the object, truncated to integer.\n\n=item I<_root(OBJ, N)>\n\nReturn Nth root of the object, truncated to int. N is E<gt>= 3.\n\n=item I<_fac(OBJ)>\n\nReturn factorial of object (1*2*3*4*...).\n\n=item I<_pow(OBJ1, OBJ2)>\n\nReturn OBJ1 to the power of OBJ2. By convention, 0**0 = 1.\n\n=item I<_modinv(OBJ1, OBJ2)>\n\nReturn modular multiplicative inverse, i.e., return OBJ3 so that\n\n    (OBJ3 * OBJ1) % OBJ2 = 1 % OBJ2\n\nThe result is returned as two arguments. If the modular multiplicative\ninverse does not exist, both arguments are undefined. Otherwise, the\narguments are a number (object) and its sign (\"+\" or \"-\").\n\nThe output value, with its sign, must either be a positive value in the\nrange 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the\ninput arguments are objects representing the numbers 7 and 5, the method\nmust either return an object representing the number 3 and a \"+\" sign, since\n(3*7) % 5 = 1 % 5, or an object representing the number 2 and \"-\" sign,\nsince (-2*7) % 5 = 1 % 5.\n\n=item I<_modpow(OBJ1, OBJ2, OBJ3)>\n\nReturn modular exponentiation, (OBJ1 ** OBJ2) % OBJ3.\n\n=item I<_rsft(OBJ, N, B)>\n\nShift object N digits right in base B and return the resulting object. This is\nequivalent to performing integer division by B**N and discarding the remainder,\nexcept that it might be much faster, depending on how the number is represented\ninternally.\n\nFor instance, if the objec", 8192) = 8192
09:01:57.247222 brk(0x13d4000)          = 0x13d4000
09:01:57.247454 lseek(16, 68233, SEEK_SET) = 68233
09:01:57.247562 lseek(16, 0, SEEK_CUR)  = 68233
09:01:57.247607 close(16)               = 0
09:01:57.247745 stat("modules/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.247801 stat("modules/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.247857 stat("modules/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.247906 stat("modules/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.247955 stat("/etc/perl/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248007 stat("/etc/perl/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248057 stat("/usr/local/lib/perl/5.14.2/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248116 stat("/usr/local/lib/perl/5.14.2/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248168 stat("/usr/local/share/perl/5.14.2/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248220 stat("/usr/local/share/perl/5.14.2/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248271 stat("/usr/lib/perl5/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248321 stat("/usr/lib/perl5/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248371 stat("/usr/share/perl5/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248423 stat("/usr/share/perl5/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248473 stat("/usr/lib/perl/5.14/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248526 stat("/usr/lib/perl/5.14/Time/Local.pm", 0x7ffe12338520) = -1 ENOENT (No such file or directory)
09:01:57.248578 stat("/usr/share/perl/5.14/Time/Local.pmc", 0x7ffe123385d0) = -1 ENOENT (No such file or directory)
09:01:57.248632 stat("/usr/share/perl/5.14/Time/Local.pm", {st_mode=S_IFREG|0644, st_size=12053, ...}) = 0
09:01:57.248692 open("/usr/share/perl/5.14/Time/Local.pm", O_RDONLY) = 16
09:01:57.248746 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123382b0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.248794 lseek(16, 0, SEEK_CUR)  = 0
09:01:57.248850 read(16, "package Time::Local;\n\nrequire Exporter;\nuse Carp;\nuse Config;\nuse strict;\n\nuse vars qw( $VERSION @ISA @EXPORT @EXPORT_OK );\n$VERSION   = '1.2000';\n\n@ISA       = qw( Exporter );\n@EXPORT    = qw( timegm timelocal );\n@EXPORT_OK = qw( timegm_nocheck timelocal_nocheck );\n\nmy @MonthDays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );\n\n# Determine breakpoint for rolling century\nmy $ThisYear    = ( localtime() )[5];\nmy $Breakpoint  = ( $ThisYear + 50 ) % 100;\nmy $NextCentury = $ThisYear - $ThisYear % 100;\n$NextCentury += 100 if $Breakpoint < 50;\nmy $Century = $NextCentury - 100;\nmy $SecOff  = 0;\n\nmy ( %Options, %Cheat );\n\nuse constant SECS_PER_MINUTE => 60;\nuse constant SECS_PER_HOUR   => 3600;\nuse constant SECS_PER_DAY    => 86400;\n\nmy $MaxDay;\nif ($] < 5.012000) {\n    my $MaxInt;\n    if ( $^O eq 'MacOS' ) {\n        # time_t is unsigned...\n        $MaxInt = ( 1 << ( 8 * $Config{ivsize} ) ) - 1;\n    }\n    else {\n        $MaxInt = ( ( 1 << ( 8 * $Config{ivsize} - 2 ) ) - 1 ) * 2 + 1;\n    }\n\n    $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;\n}\nelse {\n    # recent localtime()'s limit is the year 2**31\n    $MaxDay = 365 * (2**31);\n}\n\n# Determine the EPOC day for this machine\nmy $Epoc = 0;\nif ( $^O eq 'vos' ) {\n    # work around posix-977 -- VOS doesn't handle dates in the range\n    # 1970-1980.\n    $Epoc = _daygm( 0, 0, 0, 1, 0, 70, 4, 0 );\n}\nelsif ( $^O eq 'MacOS' ) {\n    $MaxDay *=2 if $^O eq 'MacOS';  # time_t unsigned ... quick hack?\n    # MacOS time() is seconds since 1 Jan 1904, localtime\n    # so we need to calculate an offset to apply later\n    $Epoc = 693901;\n    $SecOff = timelocal( localtime(0)) - timelocal( gmtime(0) ) ;\n    $Epoc += _daygm( gmtime(0) );\n}\nelse {\n    $Epoc = _daygm( gmtime(0) );\n}\n\n%Cheat = ();    # clear the cache as epoc has changed\n\nsub _daygm {\n\n    # This is written in such a byzantine way in order to avoid\n    # lexical variables and sub calls, for speed\n    return $_[3] + (\n        $Cheat{ pack( 'ss', @_[ 4, 5 ] ) } ||= do {\n            my $month = ( $_[4] + 10 ) % 12;\n            my $year  = $_[5] + 1900 - int($month / 10);\n\n            ( ( 365 * $year )\n              + int( $year / 4 )\n              - int( $year / 100 )\n              + int( $year / 400 )\n              + int( ( ( $month * 306 ) + 5 ) / 10 )\n            )\n            - $Epoc;\n        }\n    );\n}\n\nsub _timegm {\n    my $sec =\n        $SecOff + $_[0] + ( SECS_PER_MINUTE * $_[1] ) + ( SECS_PER_HOUR * $_[2] );\n\n    return $sec + ( SECS_PER_DAY * &_daygm );\n}\n\nsub timegm {\n    my ( $sec, $min, $hour, $mday, $month, $year ) = @_;\n\n    if ( $year >= 1000 ) {\n        $year -= 1900;\n    }\n    elsif ( $year < 100 and $year >= 0 ) {\n        $year += ( $year > $Breakpoint ) ? $Century : $NextCentury;\n    }\n\n    unless ( $Options{no_range_check} ) {\n        croak \"Month '$month' out of range 0..11\"\n            if $month > 11\n            or $month < 0;\n\n\tmy $md = $MonthDays[$month];\n        ++$md\n            if $month == 1 && _is_leap_year( $year + 1900 );\n\n        croak \"Day '$mday' out of range 1..$md\"  if $mday > $md or $mday < 1;\n        croak \"Hour '$hour' out of range 0..23\"  if $hour > 23  or $hour < 0;\n        croak \"Minute '$min' out of range 0..59\" if $min > 59   or $min < 0;\n        croak \"Second '$sec' out of range 0..59\" if $sec > 59   or $sec < 0;\n    }\n\n    my $days = _daygm( undef, undef, undef, $mday, $month, $year );\n\n    unless ($Options{no_range_check} or abs($days) < $MaxDay) {\n        my $msg = '';\n        $msg .= \"Day too big - $days > $MaxDay\\n\" if $days > $MaxDay;\n\n\t$year += 1900;\n        $msg .=  \"Cannot handle date ($sec, $min, $hour, $mday, $month, $year)\";\n\n\tcroak $msg;\n    }\n\n    return $sec\n           + $SecOff\n           + ( SECS_PER_MINUTE * $min )\n           + ( SECS_PER_HOUR * $hour )\n           + ( SECS_PER_DAY * $days );\n}\n\nsub _is_leap_year {\n    return 0 if $_[0] % 4;\n    return 1 if $_[0] % 100;\n    return 0 if $_[0] % 400;\n\n    return 1;\n}\n\nsub timegm_nocheck {\n    local $Options{no_range_check} = 1;\n    return &timegm;\n}\n\nsub timelocal {\n    my $ref_t = &timegm;\n    my $loc_for_ref_t = _timegm( localtime($ref_t) );\n\n    my $zone_off = $loc_for_ref_t - $ref_t\n        or return $loc_for_ref_t;\n\n    # Adjust for timezone\n    my $loc_t = $ref_t - $zone_off;\n\n    # Are we close to a DST change or are we done\n    my $dst_off = $ref_t - _timegm( localtime($loc_t) );\n\n    # If this evaluates to true, it means that the value in $loc_t is\n    # the _second_ hour after a DST change where the local time moves\n    # backward.\n    if ( ! $dst_off &&\n         ( ( $ref_t - SECS_PER_HOUR ) - _timegm( localtime( $loc_t - SECS_PER_HOUR ) ) < 0 )\n       ) {\n        return $loc_t - SECS_PER_HOUR;\n    }\n\n    # Adjust for DST change\n    $loc_t += $dst_off;\n\n    return $loc_t if $dst_off > 0;\n\n    # If the original date was a non-extent gap in a forward DST jump,\n    # we should now have the wrong answer - undo the DST adjustment\n    my ( $s, $m, $h ) = localtime($loc_t);\n    $loc_t -= $dst_off if $s != $_[0] || $m != $_[1] || $h != $_[2];\n\n    return $loc_t;\n}\n\nsub timelocal_nocheck {\n    local $Options{no_range_check} = 1;\n    return &timelocal;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nTime::Local - efficiently compute time from local and GMT time\n\n=head1 SYNOPSIS\n\n    $time = timelocal($sec,$min,$hour,$mday,$mon,$year);\n    $time = timegm($sec,$min,$hour,$mday,$mon,$year);\n\n=head1 DESCRIPTION\n\nThis module provides functions that are the inverse of built-in perl\nfunctions C<localtime()> and C<gmtime()>. They accept a date as a\nsix-element array, and return the corresponding C<time(2)> value in\nseconds since the system epoch (Midnight, January 1, 1970 GMT on Unix,\nfor example). This value can be positive or negative, though POSIX\nonly requires support for positive values, so dates before the\nsystem's epoch may not work on all operating systems.\n\nIt is worth drawing particular attention to the expected ranges for\nthe values provided. The value for the day of the month is the actual\nday (ie 1..31), while the month is the number of months since January\n(0..11). This is consistent with the values returned from\nC<localtime()> and C<gmtime()>.\n\n=head1 FUNCTIONS\n\n=head2 C<timelocal()> and C<timegm()>\n\nThis module exports two functions by default, C<timelocal()> and\nC<timegm()>.\n\nThe C<timelocal()> and C<timegm()> functions perform range checking on\nthe input $sec, $min, $hour, $mday, and $mon values by default.\n\n=head2 C<timelocal_nocheck()> and C<timegm_nocheck()>\n\nIf you are working with data you know to be valid, you can speed your\ncode up by using the \"nocheck\" variants, C<timelocal_nocheck()> and\nC<timegm_nocheck()>. These variants must be explicitly imported.\n\n    use Time::Local 'timelocal_nocheck';\n\n    # The 365th day of 1999\n    print scalar localtime timelocal_nocheck 0,0,0,365,0,99;\n\nIf you supply data which is not valid (month 27, second 1,000) the\nresults will be unpredictable (so don't do that).\n\n=head2 Year Value Interpretation\n\nStrictly speaking, the year should be specified in a form consistent\nwith C<localtime()>, i.e. the offset from 1900. In order to make the\ninterpretation of the year easier for humans, however, who are more\naccustomed to seeing years as two-digit or four-digit values, the\nfollowing conventions are followed:\n\n=over 4\n\n=item *\n\nYears greater than 999 are interpreted as being the actual year,\nrather than the offset from 1900. Thus, 1964 would indicate the year\nMartin Luther King won the Nobel prize, not the year 3864.\n\n=item *\n\nYears in the range 100..999 are interpreted as offset from 1900, so\nthat 112 indicates 2012. This rule also applies to years less than\nzero (but see note below regarding date range).\n\n=item *\n\nYears in the range 0..99 are interpreted as shorthand for years in the\nrolling \"current century,\" defined as 50 years on either side of the\ncurrent year. Thus, today, in 1999, 0 would refer to 2000, and 45 to\n2045, but 55 would refer to 1955. Twenty years from now, 55 would\ninstead refer to 2055. This is messy, but matches the way people\ncurrently think about two digit dates. Whenever possible, use an\nabsolute four digit year instead.\n\n=back\n\nThe scheme above allows interpretation o", 8192) = 8192
09:01:57.249952 lseek(16, 5182, SEEK_SET) = 5182
09:01:57.250001 lseek(16, 0, SEEK_CUR)  = 5182
09:01:57.250059 close(16)               = 0
09:01:57.250149 open("/etc/localtime", O_RDONLY) = 16
09:01:57.250205 fstat(16, {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.250258 fstat(16, {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.250310 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f2f000
09:01:57.250361 read(16, "TZif2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\7\0\0\0\0\0\0\0\362\0\0\0\7\0\0\0\r\233&\255\240\233\326\5 \234\3170\240\235\244\303\240\236\234\235\240\237\227\32\240\240\205\272 \241v\374\240\242e\234 \243{\310\240\244N\270\240\245?\373 \246%` \247'\306 \250*, \250\353\370\240\252\0\323\240\252\325\25 \253\351\360 \254\307l \255\311\322 \256\247N \257\240y\240\260\2070 \261\222\320\240\262pL\240\263r\262\240\264P.\240\265IZ \2660\20\240\2672v\240\270\17\362\240\271\22X\240\271\357\324\240\272\351\0 \273\330\361 \274\333W \275\270\323 \276\261\376\240\277\230\265 \300\233\33 \301x\227 \302z\375 \303Xy \304Q\244\240\3058[ \306:\301 \307X\326\240\307\332\t\240\312\26&\220\312\227Y\220\313\321\36\220\314w;\220\315\261\0\220\316`X\20\317\220\342\220\320n^\220\321r\26\20\321\3732\20\322i\376 \323c)\240\324I\340 \325\36!\240\325B\375\220\325\337\340\20\326N\254 \326\376\3\240\330.\216 \330\371\225 \332\16p \332\353\354 \333\345\27\240\334\313\316 \335\304\371\240\336\264\352\240\337\256\26 \340\224\314\240\341rH\240\342kt \343R*\240\344T\220\240\3452\f\240\346=\255 \347\33) \350\24T\240\350\373\v \351\375q \352\332\355 \353\335S \354\272\317 \355\263\372\240\356\232\261 \357\201g\240\360\237} \361aI\240\362\177_ \363Jf \364_A \365!\r\240\366?# \367\0\357\240\370\37\5 \370\340\321\240\371\376\347 \372\300\263\240\373\350\3\240\374{\253\240\375\307\273p\3p\306 \4)X \5P\250 \6\t: \0070\212 \7\351\34 \t\20l \t\310\376 \n\360N \v\262\32\240\f\3200 \r\221\374\240\16\260\22 \17q\336\240\20\231.\240\21Q\300\240\22y\20\240\0231\242\240\24X\362\240\25#\353\220\0268\306\220\27\3\315\220\30\30\250\220\30\343\257\220\31\370\212\220\32\303\221\220\33\341\247\20\34\254\256\20\35\301\211\20\36\214\220\20\37\241k\20 lr\20!\201M\20\"LT\20#a/\20$,6\20%JK\220&\f\30\20'*-\220'\3654\220)\n\17\220)\325\26\220*\351\361\220+\264\370\220,\311\323\220-\224\332\220.\251\265\220/t\274\2200\211\227\2200\347$\0001]\331\0202r\264\0203=\273\0204R\226\0205\35\235\02062x\0206\375\177\0208\33\224\2208\335a\0209\373v\220:\275C\20;\333X\220<\246_\220=\273:\220>\206A\220?\233\34\220@f#\220A\2049\20BF\5\220Cd\33\20D%\347\220EC\375\20F\5\311\220G#\337\20G\356\346\20I\3\301\20I\316\310\20J\343\243\20K\256\252\20L\314\277\220M\216\214\20N\254\241\220Onn\20P\214\203\220QW\212\220Rle\220S7l\220TLG\220U\27N\220V,)\220V\3670\220X\25F\20X\327\22\220Y\365(\20Z\266\364\220[\325\n\20\\\240\21\20]\264\354\20^\177\363\20_\224\316\20`_\325\20a}\352\220b?\267\20c]\314\220d\37\231\20e=\256\220f\10\265\220g\35\220\220g\350\227\220h\375r\220i\310y\220j\335T\220k\250[\220l\306q\20m\210=\220n\246S\20oh\37\220p\2065\20qQ<\20rf\27\20s1\36\20tE\371\20u\21\0\20v/\25\220v\360\342\20x\16\367\220x\320\304\20y\356\331\220z\260\246\20{\316\273\220|\231\302\220}\256\235\220~y\244\220\177\216\177\220\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\2\0\2\0\2\0\2\0\2\0\1\0\1\0\2\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\3\5\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\0\1\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\6\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\4\5\0\0\16\20\1\0\0\0\0\0\0\4\0\0\34 \1\10\0\0\16\20\0\0\0\0\16\20\1\0\0\0\0\0\0\4\0\0\0\0\0\4BST\0GMT\0BDST\0\1\1\1\0\1\1\0\0\0\0\0\1\1\0TZif2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\10\0\0\0\0\0\0\0\363\0\0\0\10\0\0\0\21\377\377\377\377\32]\t\313\377\377\377\377\233&\255\240\377\377\377\377\233\326\5 \377\377\377\377\234\3170\240\377\377\377\377\235\244\303\240\377\377\377\377\236\234\235\240\377\377\377\377\237\227\32\240\377\377\377\377\240\205\272 \377\377\377\377\241v\374\240\377\377\377\377\242e\234 \377\377\377\377\243{\310\240\377\377\377\377\244N\270\240\377\377\377\377\245?\373 \377\377\377\377\246%` \377\377\377\377\247'\306 \377\377\377\377\250*, \377\377\377\377\250\353\370\240\377\377\377\377\252\0\323\240\377\377\377\377\252\325\25 \377\377\377\377\253\351\360 \377\377\377\377\254\307l \377\377\377\377\255\311\322 \377\377\377\377\256\247N \377\377\377\377\257\240y\240\377\377\377\377\260\2070 \377\377\377\377\261\222\320\240\377\377\377\377\262pL\240\377\377\377\377\263r\262\240\377\377\377\377\264P.\240\377\377\377\377\265IZ \377\377\377\377\2660\20\240\377\377\377\377\2672v\240\377\377\377\377\270\17\362\240\377\377\377\377\271\22X\240\377\377\377\377\271\357\324\240\377\377\377\377\272\351\0 \377\377\377\377\273\330\361 \377\377\377\377\274\333W \377\377\377\377\275\270\323 \377\377\377\377\276\261\376\240\377\377\377\377\277\230\265 \377\377\377\377\300\233\33 \377\377\377\377\301x\227 \377\377\377\377\302z\375 \377\377\377\377\303Xy \377\377\377\377\304Q\244\240\377\377\377\377\3058[ \377\377\377\377\306:\301 \377\377\377\377\307X\326\240\377\377\377\377\307\332\t\240\377\377\377\377\312\26&\220\377\377\377\377\312\227Y\220\377\377\377\377\313\321\36\220\377\377\377\377\314w;\220\377\377\377\377\315\261\0\220\377\377\377\377\316`X\20\377\377\377\377\317\220\342\220\377\377\377\377\320n^\220\377\377\377\377\321r\26\20\377\377\377\377\321\3732\20\377\377\377\377\322i\376 \377\377\377\377\323c)\240\377\377\377\377\324I\340 \377\377\377\377\325\36!\240\377\377\377\377\325B\375\220\377\377\377\377\325\337\340\20\377\377\377\377\326N\254 \377\377\377\377\326\376\3\240\377\377\377\377\330.\216 \377\377\377\377\330\371\225 \377\377\377\377\332\16p \377\377\377\377\332\353\354 \377\377\377\377\333\345\27\240\377\377\377\377\334\313\316 \377\377\377\377\335\304\371\240\377\377\377\377\336\264\352\240\377\377\377\377\337\256\26 \377\377\377\377\340\224\314\240\377\377\377\377\341rH\240\377\377\377\377\342kt \377\377\377\377\343R*\240\377\377\377\377\344T\220\240\377\377\377\377\3452\f\240\377\377\377\377\346=\255 \377\377\377\377\347\33) \377\377\377\377\350\24T\240\377\377\377\377\350\373\v \377\377\377\377\351\375q \377\377\377\377\352\332\355 \377\377\377\377\353\335S \377\377\377\377\354\272\317 \377\377\377\377\355\263\372\240\377\377\377\377\356\232\261 \377\377\377\377\357\201g\240\377\377\377\377\360\237} \377\377\377\377\361aI\240\377\377\377\377\362\177_ \377\377\377\377\363Jf \377\377\377\377\364_A \377\377\377\377\365!\r\240\377\377\377\377\366?# \377\377\377\377\367\0\357\240\377\377\377\377\370\37\5 \377\377\377\377\370\340\321\240\377\377\377\377\371\376\347 \377\377\377\377\372\300\263\240\377\377\377\377\373\350\3\240\377\377\377\377\374{\253\240\377\377\377\377\375\307\273p\0\0\0\0\3p\306 \0\0\0\0\4)X \0\0\0\0\5P\250 \0\0\0\0\6\t: \0\0\0\0\0070\212 \0\0\0\0\7\351\34 \0\0\0\0\t\20l \0\0\0\0\t\310\376 \0\0\0\0\n\360N \0\0\0\0\v\262\32\240\0\0\0\0\f\3200 \0\0\0\0\r\221\374\240\0\0\0\0\16\260\22 \0\0\0\0\17q\336\240\0\0\0\0\20\231.\240\0\0\0\0\21Q\300\240\0\0\0\0\22y\20\240\0\0\0\0\0231\242\240\0\0\0\0\24X\362\240\0\0\0\0\25#\353\220\0\0\0\0\0268\306\220\0\0\0\0\27\3\315\220\0\0\0\0\30\30\250\220\0\0\0\0\30\343\257\220\0\0\0\0\31\370\212\220\0\0\0\0\32\303\221\220\0\0\0\0\33\341\247\20\0\0\0\0\34\254\256\20\0\0\0\0\35\301\211\20\0\0\0\0\36\214\220\20\0\0\0\0\37\241k\20\0\0\0\0 lr\20\0\0\0\0!\201M\20\0\0\0\0\"LT\20\0\0\0\0#a/\20\0\0\0\0$,6\20\0\0\0\0%JK\220\0\0\0\0&\f\30\20\0\0\0\0'*-\220\0\0\0\0'\3654\220\0\0\0\0)\n\17\220\0\0\0\0)\325\26\220\0\0\0\0*\351\361\220\0\0\0\0+\264\370\220\0\0\0\0,\311\323\220\0\0\0\0-\224\332\220\0\0\0\0.\251\265\220\0\0\0\0/t\274\220\0\0\0\0000\211\227\220\0\0\0\0000\347$\0\0\0\0\0001]\331\20\0\0\0\0002r\264\20\0\0\0\0003=\273\20\0\0\0\0004R\226\20\0\0\0\0005\35\235\20\0\0\0\00062x\20\0\0\0\0006\375\177\20\0\0\0\0008\33\224\220\0\0\0\0008\335a\20\0\0\0\0009\373v\220\0\0\0\0:\275C\20\0\0\0\0;\333X\220\0\0\0\0<\246_\220\0\0\0\0=\273:\220\0\0\0\0>\206A\220\0\0\0\0?\233\34\220\0\0\0\0@f#\220\0\0\0\0A\2049\20\0\0\0\0BF\5\220\0\0\0\0Cd\33\20\0\0\0\0D%\347\220\0\0\0\0EC\375\20\0\0\0\0F\5\311\220\0\0\0\0G#\337\20\0\0\0\0G\356\346\20\0\0\0\0I\3\301\20\0\0\0\0I\316\310\20\0\0\0\0J\343\243\20\0\0\0\0K\256\252\20\0\0\0\0L\314\277\220\0\0\0\0M\216\214\20\0\0\0\0N\254\241\220\0\0\0\0Onn\20\0\0\0\0P\214\203\220\0\0\0\0QW\212\220\0\0\0\0Rle\220\0\0\0\0S7l\220\0\0\0\0TLG\220\0\0\0\0U\27N\220\0\0\0\0V,)\220\0\0\0\0V\3670\220\0\0\0\0X\25F\20\0\0\0\0X\327\22\220\0\0\0\0Y\365(\20\0\0\0\0Z\266\364\220\0\0\0\0[\325\n\20\0\0\0\0\\\240\21\20\0\0\0\0]\264\354\20\0\0\0\0^\177\363\20\0\0\0\0_\224\316\20\0\0\0\0`_\325\20\0\0\0\0a}\352\220\0\0\0\0b?\267\20\0\0\0\0c]\314\220\0\0\0\0d\37\231\20\0\0\0\0e=\256\220\0\0\0\0f\10\265\220\0\0\0\0g\35\220\220\0\0\0\0g\350\227\220\0\0\0\0h\375r\220\0\0\0\0i\310y\220\0\0\0\0j\335T\220\0\0\0\0k\250[\220\0\0\0\0l\306q\20\0\0\0\0m\210=\220\0\0\0\0n\246S\20\0\0\0\0oh\37\220\0\0\0\0p\2065\20\0\0\0\0qQ<\20\0\0\0\0rf\27\20\0\0\0\0s1\36\20\0\0\0\0tE\371\20\0\0\0\0u\21\0\20\0\0\0\0v/\25\220\0\0\0\0v\360\342\20\0\0\0\0x\16\367\220\0\0\0\0x\320\304\20\0\0\0\0y\356\331\220\0\0\0\0z\260\246\20\0\0\0\0{\316\273\220\0\0\0\0|\231\302\220\0\0\0\0}\256\235\220\0\0\0\0~y\244\220\0\0\0\0\177\216\177\220\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\3\1\3\1\3\1\3\1\3\1\2\1\2\1\3\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\4\6\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\7\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\377\377\377\265\0\0\0\0\16\20\1\4\0\0\0\0\0\10\0\0\34 \1\f\0\0\16\20\0\4\0\0\16\20\1\4\0\0\0\0\0\10\0\0\0\0\0\10LMT\0BST\0GMT\0BDST\0\0\1\1\1\0\1\1\0\0\0\0\0\0\1\1\0\nGMT0BST,M3.5.0/1,M10.5.0\n", 4096) = 3661
09:01:57.250788 lseek(16, -2338, SEEK_CUR) = 1323
09:01:57.250834 read(16, "TZif2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\10\0\0\0\0\0\0\0\363\0\0\0\10\0\0\0\21\377\377\377\377\32]\t\313\377\377\377\377\233&\255\240\377\377\377\377\233\326\5 \377\377\377\377\234\3170\240\377\377\377\377\235\244\303\240\377\377\377\377\236\234\235\240\377\377\377\377\237\227\32\240\377\377\377\377\240\205\272 \377\377\377\377\241v\374\240\377\377\377\377\242e\234 \377\377\377\377\243{\310\240\377\377\377\377\244N\270\240\377\377\377\377\245?\373 \377\377\377\377\246%` \377\377\377\377\247'\306 \377\377\377\377\250*, \377\377\377\377\250\353\370\240\377\377\377\377\252\0\323\240\377\377\377\377\252\325\25 \377\377\377\377\253\351\360 \377\377\377\377\254\307l \377\377\377\377\255\311\322 \377\377\377\377\256\247N \377\377\377\377\257\240y\240\377\377\377\377\260\2070 \377\377\377\377\261\222\320\240\377\377\377\377\262pL\240\377\377\377\377\263r\262\240\377\377\377\377\264P.\240\377\377\377\377\265IZ \377\377\377\377\2660\20\240\377\377\377\377\2672v\240\377\377\377\377\270\17\362\240\377\377\377\377\271\22X\240\377\377\377\377\271\357\324\240\377\377\377\377\272\351\0 \377\377\377\377\273\330\361 \377\377\377\377\274\333W \377\377\377\377\275\270\323 \377\377\377\377\276\261\376\240\377\377\377\377\277\230\265 \377\377\377\377\300\233\33 \377\377\377\377\301x\227 \377\377\377\377\302z\375 \377\377\377\377\303Xy \377\377\377\377\304Q\244\240\377\377\377\377\3058[ \377\377\377\377\306:\301 \377\377\377\377\307X\326\240\377\377\377\377\307\332\t\240\377\377\377\377\312\26&\220\377\377\377\377\312\227Y\220\377\377\377\377\313\321\36\220\377\377\377\377\314w;\220\377\377\377\377\315\261\0\220\377\377\377\377\316`X\20\377\377\377\377\317\220\342\220\377\377\377\377\320n^\220\377\377\377\377\321r\26\20\377\377\377\377\321\3732\20\377\377\377\377\322i\376 \377\377\377\377\323c)\240\377\377\377\377\324I\340 \377\377\377\377\325\36!\240\377\377\377\377\325B\375\220\377\377\377\377\325\337\340\20\377\377\377\377\326N\254 \377\377\377\377\326\376\3\240\377\377\377\377\330.\216 \377\377\377\377\330\371\225 \377\377\377\377\332\16p \377\377\377\377\332\353\354 \377\377\377\377\333\345\27\240\377\377\377\377\334\313\316 \377\377\377\377\335\304\371\240\377\377\377\377\336\264\352\240\377\377\377\377\337\256\26 \377\377\377\377\340\224\314\240\377\377\377\377\341rH\240\377\377\377\377\342kt \377\377\377\377\343R*\240\377\377\377\377\344T\220\240\377\377\377\377\3452\f\240\377\377\377\377\346=\255 \377\377\377\377\347\33) \377\377\377\377\350\24T\240\377\377\377\377\350\373\v \377\377\377\377\351\375q \377\377\377\377\352\332\355 \377\377\377\377\353\335S \377\377\377\377\354\272\317 \377\377\377\377\355\263\372\240\377\377\377\377\356\232\261 \377\377\377\377\357\201g\240\377\377\377\377\360\237} \377\377\377\377\361aI\240\377\377\377\377\362\177_ \377\377\377\377\363Jf \377\377\377\377\364_A \377\377\377\377\365!\r\240\377\377\377\377\366?# \377\377\377\377\367\0\357\240\377\377\377\377\370\37\5 \377\377\377\377\370\340\321\240\377\377\377\377\371\376\347 \377\377\377\377\372\300\263\240\377\377\377\377\373\350\3\240\377\377\377\377\374{\253\240\377\377\377\377\375\307\273p\0\0\0\0\3p\306 \0\0\0\0\4)X \0\0\0\0\5P\250 \0\0\0\0\6\t: \0\0\0\0\0070\212 \0\0\0\0\7\351\34 \0\0\0\0\t\20l \0\0\0\0\t\310\376 \0\0\0\0\n\360N \0\0\0\0\v\262\32\240\0\0\0\0\f\3200 \0\0\0\0\r\221\374\240\0\0\0\0\16\260\22 \0\0\0\0\17q\336\240\0\0\0\0\20\231.\240\0\0\0\0\21Q\300\240\0\0\0\0\22y\20\240\0\0\0\0\0231\242\240\0\0\0\0\24X\362\240\0\0\0\0\25#\353\220\0\0\0\0\0268\306\220\0\0\0\0\27\3\315\220\0\0\0\0\30\30\250\220\0\0\0\0\30\343\257\220\0\0\0\0\31\370\212\220\0\0\0\0\32\303\221\220\0\0\0\0\33\341\247\20\0\0\0\0\34\254\256\20\0\0\0\0\35\301\211\20\0\0\0\0\36\214\220\20\0\0\0\0\37\241k\20\0\0\0\0 lr\20\0\0\0\0!\201M\20\0\0\0\0\"LT\20\0\0\0\0#a/\20\0\0\0\0$,6\20\0\0\0\0%JK\220\0\0\0\0&\f\30\20\0\0\0\0'*-\220\0\0\0\0'\3654\220\0\0\0\0)\n\17\220\0\0\0\0)\325\26\220\0\0\0\0*\351\361\220\0\0\0\0+\264\370\220\0\0\0\0,\311\323\220\0\0\0\0-\224\332\220\0\0\0\0.\251\265\220\0\0\0\0/t\274\220\0\0\0\0000\211\227\220\0\0\0\0000\347$\0\0\0\0\0001]\331\20\0\0\0\0002r\264\20\0\0\0\0003=\273\20\0\0\0\0004R\226\20\0\0\0\0005\35\235\20\0\0\0\00062x\20\0\0\0\0006\375\177\20\0\0\0\0008\33\224\220\0\0\0\0008\335a\20\0\0\0\0009\373v\220\0\0\0\0:\275C\20\0\0\0\0;\333X\220\0\0\0\0<\246_\220\0\0\0\0=\273:\220\0\0\0\0>\206A\220\0\0\0\0?\233\34\220\0\0\0\0@f#\220\0\0\0\0A\2049\20\0\0\0\0BF\5\220\0\0\0\0Cd\33\20\0\0\0\0D%\347\220\0\0\0\0EC\375\20\0\0\0\0F\5\311\220\0\0\0\0G#\337\20\0\0\0\0G\356\346\20\0\0\0\0I\3\301\20\0\0\0\0I\316\310\20\0\0\0\0J\343\243\20\0\0\0\0K\256\252\20\0\0\0\0L\314\277\220\0\0\0\0M\216\214\20\0\0\0\0N\254\241\220\0\0\0\0Onn\20\0\0\0\0P\214\203\220\0\0\0\0QW\212\220\0\0\0\0Rle\220\0\0\0\0S7l\220\0\0\0\0TLG\220\0\0\0\0U\27N\220\0\0\0\0V,)\220\0\0\0\0V\3670\220\0\0\0\0X\25F\20\0\0\0\0X\327\22\220\0\0\0\0Y\365(\20\0\0\0\0Z\266\364\220\0\0\0\0[\325\n\20\0\0\0\0\\\240\21\20\0\0\0\0]\264\354\20\0\0\0\0^\177\363\20\0\0\0\0_\224\316\20\0\0\0\0`_\325\20\0\0\0\0a}\352\220\0\0\0\0b?\267\20\0\0\0\0c]\314\220\0\0\0\0d\37\231\20\0\0\0\0e=\256\220\0\0\0\0f\10\265\220\0\0\0\0g\35\220\220\0\0\0\0g\350\227\220\0\0\0\0h\375r\220\0\0\0\0i\310y\220\0\0\0\0j\335T\220\0\0\0\0k\250[\220\0\0\0\0l\306q\20\0\0\0\0m\210=\220\0\0\0\0n\246S\20\0\0\0\0oh\37\220\0\0\0\0p\2065\20\0\0\0\0qQ<\20\0\0\0\0rf\27\20\0\0\0\0s1\36\20\0\0\0\0tE\371\20\0\0\0\0u\21\0\20\0\0\0\0v/\25\220\0\0\0\0v\360\342\20\0\0\0\0x\16\367\220\0\0\0\0x\320\304\20\0\0\0\0y\356\331\220\0\0\0\0z\260\246\20\0\0\0\0{\316\273\220\0\0\0\0|\231\302\220\0\0\0\0}\256\235\220\0\0\0\0~y\244\220\0\0\0\0\177\216\177\220\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\3\1\3\1\3\1\3\1\3\1\2\1\2\1\3\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\4\6\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\7\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\5\6\377\377\377\265\0\0\0\0\16\20\1\4\0\0\0\0\0\10\0\0\34 \1\f\0\0\16\20\0\4\0\0\16\20\1\4\0\0\0\0\0\10\0\0\0\0\0\10LMT\0BST\0GMT\0BDST\0\0\1\1\1\0\1\1\0\0\0\0\0\0\1\1\0\nGMT0BST,M3.5.0/1,M10.5.0\n", 4096) = 2338
09:01:57.251182 close(16)               = 0
09:01:57.251230 munmap(0x7f7436f2f000, 4096) = 0
09:01:57.251823 brk(0x13f5000)          = 0x13f5000
09:01:57.252259 read(15, "  Crypt::OpenSSL::RSA->import_random_seed();\n      }\n    $rsa = Crypt::OpenSSL::RSA->generate_key($size);\n    $self->{\"privatekey\"}=$rsa;\n    $self->{\"keytag\"}=$self->dump_rsa_keytag($flags);\n    return $self;\n}\n\n\n\n\n1;\n\n\n\n\n\n\n\n\n=head1 NAME\n\nNet::DNS::SEC::Private - DNS SIG Private key object\n\n=head1 SYNOPSIS\n\nuse Net::DNS::SEC::Private;\nmy $private=Net::DNS::SEC::Private->new($keypath);\n\n=head1 DESCRIPTION\n\nClass containing a the private key as read from a dnssec-keygen\ngenerate zonefile. The class is written to be used only in the context\nof the Net::DNS::RR::SIG create method. This class is not designed to\ninteract with any other system.\n\n\n\n=head1 METHODS\n\n=head2 new\n\n$private->new(\"/home/foo/ Kexample.com.+001+11567.private\")\n\nCreator method. The argument is the full path to a private key\ngenerated by the BIND dnssec-keygen tool. Note that the filename contains\ninformation about the algorithm and keyid.\n\n\n=head2 private\n\n$private->private\n\nReturns the private key material. This is either a Crypt::OpenSSL::RSA\nor Crypt::OpenSSL::DSA object. This is really only relevant to the\nNet::DNS::RR::SIG class.\n\n\n=head2  algorithm, keytag, signame\n \n $private->algorithm\n $private->keytag\n $private->signame\n\nReturns components as determined from the filename and needed by\nNet::DNS::RR::RRSIG.\n\n\n=head1 RSASHA1 specific helper functions\n\nThese functions may be usefull to read and transfer BIND private keys to and\nfrom X509 format.\n\n=head2 new_rsa_private\n\nConstructor method.\n\n my $private=Net::DNS::SEC::Private->new_rsa_private($keyblob,$domain,$flag);\n\nCreates a Net::DNS::SEC::Private object from the supplied string.  For\nthe object to be useful you will have to provide the \"domain\" name for\nwhich this key is to be used as the second argument and the flag\n(either 256 or 257 for a non SEP and a SEP key respectivly).\n\n\nThe string should include the -----BEGIN...----- and -----END...-----\nlines.  The padding is set to PKCS1_OAEP, but can be changed with the\nuse_xxx_padding methods\n\nIt is the same \n\n=head2 dump_rsa_priv\n\n  my $bind_keyfilecontent=$private->dump_rsa_priv\n  \nReturns the content of a BIND private keyfile (Private-key-format: v1.2).\n\nAn empty string will be returned if not all parameters are available (please\nsupply the author with example code if this ever happens).\n\n=head2 dump_rsa_pub\n\n    my $bind_keyfilecontent=$private->dump_rsa_pub\n\nReturns the publick key part of the DNSKEY RR.\n\nReturns an empty string on failure.\n\n\n=head2 dump_rsa_keytag\n    \n    my $flags=257;   # SEP key.\n    my $keytag=$private->dump_rsa_keytag($flags);\n\nThis function will calculate the keyt with the value of the DNSKEY\nflags as input.\n\nThe flags field may be needed in case it was not specified when the\nkey was created. If the object allready knows it's flags vallue the\ninput is ignored. \n\nreturns undefined on failure\n\n=head2 dump_rsa_private_der\n\n    my $keyblob=$private->dump_rsa_privat_der\n\nReturn the DER-encoded PKCS1 representation of the private key. (Same format that\ncan be read with the read_rsa_private method.)\n\n=head2 generate_rsa\n\n    my $keypair=Net::DNS::SEC::Private->generate_rsa(\"example.com\",$flag,1024,$random);\nprin $newkey->dump_rsa_priv;\nprint $newkey->dump_rsa_pub();\n\n\nUses Crypt::OpenSSL::RSA generate_key to create a keypair.\n\nFirst argument is the name of the key, the second argument is the flag\nfield (take a value of 257 for Keysigning keys and a value of 256 for\nzone signing keys). The 3rd argument is the keysize.\n\nIf the 4th argument is defined it is passed to the\nCrypt::OpenSSL::Random::random_seed method (see Crypt::OpenSSL::RSA\nfor details), not needed with a proper /dev/random.\n\n=head1 Example\n\nThis is a code sniplet from the test script. First a new keypair is\ngenerated.  An Net::DNS::RR object is created by constructing\nthe resource record string - using the dump_rsa_pub() method.\n\nThen a self signature over the public key is created and verified.\n\n    my $newkey=Net::DNS::SEC::Private->generate_rsa(\"example.com\",257,1024);\n    my $tstpubkeyrr= Net::DNS::RR->new ($newkey->signame .\n                                    \"  IN DNSKEY 257 3 5 \".\n\t\t\t\t    $newkey->dump_rsa_pub());\n    # flags not needed as argument for dump_rsa_keytag\n    $ since they where set by generate_rsa\n\n    is($tstpubkeyrr->keytag,$newkey->dump_rsa_keytag(),\n                \"Consistent keytag calculation\");\n\n    my $sigrr= create Net::DNS::RR::RRSIG([$tstpubkeyrr],$newkey);\n    is ($sigrr->keytag,$tstpubkeyrr->keytag,\n            \"Consisted keytag in the created signature\");;\n\n    ok($sigrr->verify([$tstpubkeyrr],$tstpubkeyrr), \n             \"Self verification consistent.\");\n\n\n\n\n\n\n\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2002-2005 RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nThis code uses Crypt::OpenSSL which uses the openssl library\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/>\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::RR::SIG>, L<Crypt::OpenSSL::RSA>,L<Crypt::OpenSSL::DSA>, RFC 2435 Section 4, RFC 2931.\n\n=cut\n\n", 8192) = 5896
09:01:57.252643 read(15, "", 8192)      = 0
09:01:57.252693 close(15)               = 0
09:01:57.252931 stat("modules/Digest/SHA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.252984 stat("modules/Digest/SHA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.253035 stat("modules/Digest/SHA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.253083 stat("modules/Digest/SHA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.253136 stat("/etc/perl/Digest/SHA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.253188 stat("/etc/perl/Digest/SHA.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.253237 stat("/usr/local/lib/perl/5.14.2/Digest/SHA.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.253290 stat("/usr/local/lib/perl/5.14.2/Digest/SHA.pm", {st_mode=S_IFREG|0444, st_size=22447, ...}) = 0
09:01:57.253350 open("/usr/local/lib/perl/5.14.2/Digest/SHA.pm", O_RDONLY) = 15
09:01:57.253404 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.253451 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.253509 read(15, "package Digest::SHA;\n\nrequire 5.003000;\n\nuse strict;\nuse warnings;\nuse vars qw($VERSION @ISA @EXPORT @EXPORT_OK);\nuse Fcntl;\nuse integer;\n\n$VERSION = '5.95';\n\nrequire Exporter;\nrequire DynaLoader;\n@ISA = qw(Exporter DynaLoader);\n@EXPORT_OK = qw(\n\thmac_sha1\thmac_sha1_base64\thmac_sha1_hex\n\thmac_sha224\thmac_sha224_base64\thmac_sha224_hex\n\thmac_sha256\thmac_sha256_base64\thmac_sha256_hex\n\thmac_sha384\thmac_sha384_base64\thmac_sha384_hex\n\thmac_sha512\thmac_sha512_base64\thmac_sha512_hex\n\thmac_sha512224\thmac_sha512224_base64\thmac_sha512224_hex\n\thmac_sha512256\thmac_sha512256_base64\thmac_sha512256_hex\n\tsha1\t\tsha1_base64\t\tsha1_hex\n\tsha224\t\tsha224_base64\t\tsha224_hex\n\tsha256\t\tsha256_base64\t\tsha256_hex\n\tsha384\t\tsha384_base64\t\tsha384_hex\n\tsha512\t\tsha512_base64\t\tsha512_hex\n\tsha512224\tsha512224_base64\tsha512224_hex\n\tsha512256\tsha512256_base64\tsha512256_hex);\n\n# Inherit from Digest::base if possible\n\neval {\n\trequire Digest::base;\n\tpush(@ISA, 'Digest::base');\n};\n\n# The following routines aren't time-critical, so they can be left in Perl\n\nsub new {\n\tmy($class, $alg) = @_;\n\t$alg =~ s/\\D+//g if defined $alg;\n\tif (ref($class)) {\t# instance method\n\t\tif (!defined($alg) || ($alg == $class->algorithm)) {\n\t\t\tsharewind($class);\n\t\t\treturn($class);\n\t\t}\n\t\treturn shainit($class, $alg) ? $class : undef;\n\t}\n\t$alg = 1 unless defined $alg;\n\treturn $class->newSHA($alg);\n}\n\nBEGIN { *reset = \\&new }\n\nsub add_bits {\n\tmy($self, $data, $nbits) = @_;\n\tunless (defined $nbits) {\n\t\t$nbits = length($data);\n\t\t$data = pack(\"B*\", $data);\n\t}\n\t$nbits = length($data) * 8 if $nbits > length($data) * 8;\n\tshawrite($data, $nbits, $self);\n\treturn($self);\n}\n\nsub _bail {\n\tmy $msg = shift;\n\n\t$msg .= \": $!\";\n\trequire Carp;\n\tCarp::croak($msg);\n}\n\n{\n\tmy $_can_T_filehandle;\n\n\tsub _istext {\n\t\tlocal *FH = shift;\n\t\tmy $file = shift;\n\n\t\tif (! defined $_can_T_filehandle) {\n\t\t\tlocal $^W = 0;\n\t\t\tmy $istext = eval { -T FH };\n\t\t\t$_can_T_filehandle = $@ ? 0 : 1;\n\t\t\treturn $_can_T_filehandle ? $istext : -T $file;\n\t\t}\n\t\treturn $_can_T_filehandle ? -T FH : -T $file;\n\t}\n}\n\nsub _addfile {\n\tmy ($self, $handle) = @_;\n\n\tmy $n;\n\tmy $buf = \"\";\n\n\twhile (($n = read($handle, $buf, 4096))) {\n\t\t$self->add($buf);\n\t}\n\t_bail(\"Read failed\") unless defined $n;\n\n\t$self;\n}\n\nsub addfile {\n\tmy ($self, $file, $mode) = @_;\n\n\treturn(_addfile($self, $file)) unless ref(\\$file) eq 'SCALAR';\n\n\t$mode = defined($mode) ? $mode : \"\";\n\tmy ($binary, $UNIVERSAL, $BITS, $portable) =\n\t\tmap { $_ eq $mode } (\"b\", \"U\", \"0\", \"p\");\n\n\t\t## Always interpret \"-\" to mean STDIN; otherwise use\n\t\t## sysopen to handle full range of POSIX file names\n\n\tlocal *FH;\n\t$file eq '-' and open(FH, '< -')\n\t\tor sysopen(FH, $file, O_RDONLY)\n\t\t\tor _bail('Open failed');\n\n\tif ($BITS) {\n\t\tmy ($n, $buf) = (0, \"\");\n\t\twhile (($n = read(FH, $buf, 4096))) {\n\t\t\t$buf =~ s/[^01]//g;\n\t\t\t$self->add_bits($buf);\n\t\t}\n\t\t_bail(\"Read failed\") unless defined $n;\n\t\tclose(FH);\n\t\treturn($self);\n\t}\n\n\tbinmode(FH) if $binary || $portable || $UNIVERSAL;\n\tif ($UNIVERSAL && _istext(*FH, $file)) {\n\t\t$self->_addfileuniv(*FH);\n\t}\n\telsif ($portable && _istext(*FH, $file)) {\n\t\twhile (<FH>) {\n\t\t\ts/\\015?\\015\\012/\\012/g;\n\t\t\ts/\\015/\\012/g;\n\t\t\t$self->add($_);\n\t\t}\n\t}\n\telse { $self->_addfilebin(*FH) }\n\tclose(FH);\n\n\t$self;\n}\n\nsub getstate {\n\tmy $self = shift;\n\n\tmy $alg = $self->algorithm or return;\n\tmy $state = $self->_getstate or return;\n\tmy $nD = $alg <= 256 ?  8 :  16;\n\tmy $nH = $alg <= 256 ? 32 :  64;\n\tmy $nB = $alg <= 256 ? 64 : 128;\n\tmy($H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) =\n\t\t$state =~ /^(.{$nH})(.{$nB})(.{4})(.{4})(.{4})(.{4})(.{4})$/s;\n\tfor ($alg, $H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) {\n\t\treturn unless defined $_;\n\t}\n\n\tmy @s = ();\n\tpush(@s, \"alg:\" . $alg);\n\tpush(@s, \"H:\" . join(\":\", unpack(\"H*\", $H) =~ /.{$nD}/g));\n\tpush(@s, \"block:\" . join(\":\", unpack(\"H*\", $block) =~ /.{2}/g));\n\tpush(@s, \"blockcnt:\" . unpack(\"N\", $blockcnt));\n\tpush(@s, \"lenhh:\" . unpack(\"N\", $lenhh));\n\tpush(@s, \"lenhl:\" . unpack(\"N\", $lenhl));\n\tpush(@s, \"lenlh:\" . unpack(\"N\", $lenlh));\n\tpush(@s, \"lenll:\" . unpack(\"N\", $lenll));\n\tjoin(\"\\n\", @s) . \"\\n\";\n}\n\nsub putstate {\n\tmy($class, $state) = @_;\n\n\tmy %s = ();\n\tfor (split(/\\n/, $state)) {\n\t\ts/^\\s+//;\n\t\ts/\\s+$//;\n\t\tnext if (/^(#|$)/);\n\t\tmy @f = split(/[:\\s]+/);\n\t\tmy $tag = shift(@f);\n\t\t$s{$tag} = join('', @f);\n\t}\n\n\t# H and block may contain arbitrary values, but check everything else\n\tgrep { $_ == $s{'alg'} } (1,224,256,384,512,512224,512256) or return;\n\tlength($s{'H'}) == ($s{'alg'} <= 256 ? 64 : 128) or return;\n\tlength($s{'block'}) == ($s{'alg'} <= 256 ? 128 : 256) or return;\n\t{\n\t\tno integer;\n\t\tfor (qw(blockcnt lenhh lenhl lenlh lenll)) {\n\t\t\t0 <= $s{$_} or return;\n\t\t\t$s{$_} <= 4294967295 or return;\n\t\t}\n\t\t$s{'blockcnt'} < ($s{'alg'} <= 256 ? 512 : 1024) or return;\n\t}\n\n\tmy $packed_state = (\n\t\tpack(\"H*\", $s{'H'}) .\n\t\tpack(\"H*\", $s{'block'}) .\n\t\tpack(\"N\",  $s{'blockcnt'}) .\n\t\tpack(\"N\",  $s{'lenhh'}) .\n\t\tpack(\"N\",  $s{'lenhl'}) .\n\t\tpack(\"N\",  $s{'lenlh'}) .\n\t\tpack(\"N\",  $s{'lenll'})\n\t);\n\n\treturn $class->new($s{'alg'})->_putstate($packed_state);\n}\n\nsub dump {\n\tmy $self = shift;\n\tmy $file = shift;\n\n\tmy $state = $self->getstate or return;\n\t$file = \"-\" if (!defined($file) || $file eq \"\");\n\n\tlocal *FH;\n\topen(FH, \"> $file\") or return;\n\tprint FH $state;\n\tclose(FH);\n\n\treturn($self);\n}\n\nsub load {\n\tmy $class = shift;\n\tmy $file = shift;\n\n\t$file = \"-\" if (!defined($file) || $file eq \"\");\n\n\tlocal *FH;\n\topen(FH, \"< $file\") or return;\n\tmy $str = join('', <FH>);\n\tclose(FH);\n\n\t$class->putstate($str);\n}\n\nDigest::SHA->bootstrap($VERSION);\n\n1;\n__END__\n\n=head1 NAME\n\nDigest::SHA - Perl extension for SHA-1/224/256/384/512\n\n=head1 SYNOPSIS\n\nIn programs:\n\n\t\t# Functional interface\n\n\tuse Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);\n\n\t$digest = sha1($data);\n\t$digest = sha1_hex($data);\n\t$digest = sha1_base64($data);\n\n\t$digest = sha256($data);\n\t$digest = sha384_hex($data);\n\t$digest = sha512_base64($data);\n\n\t\t# Object-oriented\n\n\tuse Digest::SHA;\n\n\t$sha = Digest::SHA->new($alg);\n\n\t$sha->add($data);\t\t# feed data into stream\n\n\t$sha->addfile(*F);\n\t$sha->addfile($filename);\n\n\t$sha->add_bits($bits);\n\t$sha->add_bits($data, $nbits);\n\n\t$sha_copy = $sha->clone;\t# make copy of digest object\n\t$state = $sha->getstate;\t# save current state to string\n\t$sha->putstate($state);\t\t# restore previous $state\n\n\t$digest = $sha->digest;\t\t# compute digest\n\t$digest = $sha->hexdigest;\n\t$digest = $sha->b64digest;\n\nFrom the command line:\n\n\t$ shasum files\n\n\t$ shasum --help\n\n=head1 SYNOPSIS (HMAC-SHA)\n\n\t\t# Functional interface only\n\n\tuse Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);\n\n\t$digest = hmac_sha1($data, $key);\n\t$digest = hmac_sha224_hex($data, $key);\n\t$digest = hmac_sha256_base64($data, $key);\n\n=head1 ABSTRACT\n\nDigest::SHA is a complete implementation of the NIST Secure Hash Standard.\nIt gives Perl programmers a convenient way to calculate SHA-1, SHA-224,\nSHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests.\nThe module can handle all types of input, including partial-byte data.\n\n=head1 DESCRIPTION\n\nDigest::SHA is written in C for speed.  If your platform lacks a\nC compiler, you can install the functionally equivalent (but much\nslower) L<Digest::SHA::PurePerl> module.\n\nThe programming interface is easy to use: it's the same one found\nin CPAN's L<Digest> module.  So, if your applications currently\nuse L<Digest::MD5> and you'd prefer the stronger security of SHA,\nit's a simple matter to convert them.\n\nThe interface provides two ways to calculate digests:  all-at-once,\nor in stages.  To illustrate, the following short program computes\nthe SHA-256 digest of \"hello world\" using each approach:\n\n\tuse Digest::SHA qw(sha256_hex);\n\n\t$data = \"hello world\";\n\t@frags = split(//, $data);\n\n\t# all-at-once (Functional style)\n\t$digest1 = sha256_hex($data);\n\n\t# in-stages (OOP style)\n\t$state = Digest::SHA->new(256);\n\tfor (@frags) { $state->add($_) }\n\t$digest2 = $state->hexdigest;\n\n\tprint $digest1 eq $digest2 ?\n\t\t\"whew!\\n\" : \"oops!\\n\";\n\nTo calculate the digest of an n-bit message where I<n> is not a\nmultiple of 8, use the I<add_bits()> method.  For example, consider\nthe 446-bit message consisting of the bit-string \"110\" repeated\n148 times, followed by \"11\".  Here's how to display its SHA-1\ndigest:\n\n\tuse Digest::SHA;\n\t$bits ", 8192) = 8192
09:01:57.254376 brk(0x1416000)          = 0x1416000
09:01:57.255044 lseek(15, 5505, SEEK_SET) = 5505
09:01:57.255092 lseek(15, 0, SEEK_CUR)  = 5505
09:01:57.255136 close(15)               = 0
09:01:57.255217 stat("modules/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255269 stat("modules/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255318 stat("modules/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255366 stat("modules/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255415 stat("/etc/perl/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255464 stat("/etc/perl/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255514 stat("/usr/local/lib/perl/5.14.2/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255565 stat("/usr/local/lib/perl/5.14.2/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255616 stat("/usr/local/share/perl/5.14.2/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255668 stat("/usr/local/share/perl/5.14.2/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255718 stat("/usr/lib/perl5/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255767 stat("/usr/lib/perl5/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255817 stat("/usr/share/perl5/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255872 stat("/usr/share/perl5/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.255924 stat("/usr/lib/perl/5.14/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.255977 stat("/usr/lib/perl/5.14/Digest/base.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.256033 stat("/usr/share/perl/5.14/Digest/base.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.256084 stat("/usr/share/perl/5.14/Digest/base.pm", {st_mode=S_IFREG|0644, st_size=1804, ...}) = 0
09:01:57.256144 open("/usr/share/perl/5.14/Digest/base.pm", O_RDONLY) = 15
09:01:57.256197 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.256243 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.256304 read(15, "package Digest::base;\n\nuse strict;\nuse vars qw($VERSION);\n$VERSION = \"1.16\";\n\n# subclass is supposed to implement at least these\nsub new;\nsub clone;\nsub add;\nsub digest;\n\nsub reset {\n    my $self = shift;\n    $self->new(@_);  # ugly\n}\n\nsub addfile {\n    my ($self, $handle) = @_;\n\n    my $n;\n    my $buf = \"\";\n\n    while (($n = read($handle, $buf, 4*1024))) {\n        $self->add($buf);\n    }\n    unless (defined $n) {\n\trequire Carp;\n\tCarp::croak(\"Read failed: $!\");\n    }\n\n    $self;\n}\n\nsub add_bits {\n    my $self = shift;\n    my $bits;\n    my $nbits;\n    if (@_ == 1) {\n\tmy $arg = shift;\n\t$bits = pack(\"B*\", $arg);\n\t$nbits = length($arg);\n    }\n    else {\n\t($bits, $nbits) = @_;\n    }\n    if (($nbits % 8) != 0) {\n\trequire Carp;\n\tCarp::croak(\"Number of bits must be multiple of 8 for this algorithm\");\n    }\n    return $self->add(substr($bits, 0, $nbits/8));\n}\n\nsub hexdigest {\n    my $self = shift;\n    return unpack(\"H*\", $self->digest(@_));\n}\n\nsub b64digest {\n    my $self = shift;\n    require MIME::Base64;\n    my $b64 = MIME::Base64::encode($self->digest(@_), \"\");\n    $b64 =~ s/=+$//;\n    return $b64;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nDigest::base - Digest base class\n\n=head1 SYNOPSIS\n\n  package Digest::Foo;\n  use base 'Digest::base';\n\n=head1 DESCRIPTION\n\nThe C<Digest::base> class provide implementations of the methods\nC<addfile> and C<add_bits> in terms of C<add>, and of the methods\nC<hexdigest> and C<b64digest> in terms of C<digest>.\n\nDigest implementations might want to inherit from this class to get\nthis implementations of the alternative I<add> and I<digest> methods.\nA minimal subclass needs to implement the following methods by itself:\n\n    new\n    clone\n    add\n    digest\n\nThe arguments and expected behaviour of these methods are described in\nL<Digest>.\n\n=head1 SEE ALSO\n\nL<Digest>\n", 8192) = 1804
09:01:57.256629 brk(0x1437000)          = 0x1437000
09:01:57.256698 lseek(15, 1125, SEEK_SET) = 1125
09:01:57.256744 lseek(15, 0, SEEK_CUR)  = 1125
09:01:57.256788 close(15)               = 0
09:01:57.256866 stat("modules/auto/Digest/SHA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.256920 stat("modules/auto/Digest/SHA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.256970 stat("/etc/perl/auto/Digest/SHA", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.257022 stat("/usr/local/lib/perl/5.14.2/auto/Digest/SHA", {st_mode=S_IFDIR|S_ISGID|0755, st_size=4096, ...}) = 0
09:01:57.257085 stat("/usr/local/lib/perl/5.14.2/auto/Digest/SHA/SHA.so", {st_mode=S_IFREG|0555, st_size=158501, ...}) = 0
09:01:57.257172 stat("/usr/local/lib/perl/5.14.2/auto/Digest/SHA/SHA.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.257245 open("/usr/local/lib/perl/5.14.2/auto/Digest/SHA/SHA.so", O_RDONLY) = 15
09:01:57.257299 read(15, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\24\0\0\0\0\0\0@\0\0\0\0\0\0\0@P\2\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0$\0!\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\234\227\0\0\0\0\0\0\234\227\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\240\227\0\0\0\0\0\0\240\227 \0\0\0\0\0\240\227 \0\0\0\0\0\220\3\0\0\0\0\0\0\230\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\270\227\0\0\0\0\0\0\270\227 \0\0\0\0\0\270\227 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\344\217\0\0\0\0\0\0\344\217\0\0\0\0\0\0\344\217\0\0\0\0\0\0\374\0\0\0\0\0\0\0\374\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\3\300W1s\30\231\0057C\2639\201X\223\10\26\213\301\274\0\0\0\0%\0\0\0008\0\0\0007\0\0\0\35\0\0\0\16\0\0\0\0\0\0\0\27\0\0\0 \0\0\0\7\0\0\0\34\0\0\0005\0\0\0000\0\0\0\23\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\32\0\0\0\24\0\0\0,\0\0\0)\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0006\0\0\0003\0\0\0#\0\0\0001\0\0\0\37\0\0\0\t\0\0\0\0\0\0\0!\0\0\0004\0\0\0\0\0\0\0.\0\0\0\0\0\0\0\36\0\0\0\33\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0\5\0\0\0$\0\0\0\2\0\0\0\3\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\0\0\0'\0\0\0\26\0\0\0/\0\0\0\0\0\0\0\17\0\0\0*\0\0\0\22\0\0\0\f\0\0\0\n\0\0\0\v\0\0\0002\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\0\0\0\0\0\0\0\31\0\0\0\20\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\30\0\0\0\21\0\0\0-\0\0\0\0\0\0\0\0\0\0\0\21\0\0\0#\0\0\0", 832) = 832
09:01:57.257440 fstat(15, {st_mode=S_IFREG|0555, st_size=158501, ...}) = 0
09:01:57.257497 mmap(NULL, 2136888, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 15, 0) = 0x7f7432bcc000
09:01:57.257560 mprotect(0x7f7432bd6000, 2093056, PROT_NONE) = 0
09:01:57.257613 mmap(0x7f7432dd5000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 15, 0x9000) = 0x7f7432dd5000
09:01:57.257675 close(15)               = 0
09:01:57.258727 read(14, "EC::Private->new($priv_key);\n    }\n\n    die \"Create did not manage obtain a Net::DNS::SEC::Private object \"unless (UNIVERSAL::isa($Private,\"Net::DNS::SEC::Private\"));\n\n    $self->{\"algorithm\"}=$Private->algorithm;\n    $self->{\"keytag\"}=$Private->keytag;\n    $self->{\"signame\"}=$Private->signame;\n\n\n    # if $datarrset is a plain datastrream then construct a sigzero sig.\n    # So any number will actually do.\n\n    my $sigzero= ! ref ($datarrset);\n    $self->{\"rr_rdata_recursion\"}=0;\n\n    # Start with seting up the data in the packet we can get our hands on...\n\n    if ($sigzero){\n\t$self->{\"name\"}=\"\";\n    }else{\n\t$self->{\"name\"}=$datarrset->[0]->name;\n    }\n\n    $self->{\"type\"}=\"SIG\";\n    $self->{\"class\"}=\"IN\";\n\n\n    if ($sigzero){\n\t# RFC 2931 sect 3\n\t$self->{\"ttl\"}=0;\n\t$self->{\"class\"}=\"any\";\n    }elsif ($args{ttl}){\n\tprint \"\\nSetting TTL to \".  $args{\"ttl\"} if $debug;\n\t$self->{\"ttl\"}= $args{\"ttl\"};\n    }else{\n\t$self->{\"ttl\"}= 3600;\n    }\n\n    if ($sigzero){\n\t$self->{\"typecovered\"}=\"TYPE000\";\n    }else{\n\tprint \"Note: the SIG RR has been deprecated for use other than SIG0; use the RRSIG instead\\n\"\t\t  if !$__DeprecationWarningCreateShown ;\n\t\t$__DeprecationWarningCreateShown=1;\n\n\t$self->{\"typecovered\"}=$datarrset->[0]->type;  #Sanity checks elsewhere\n    }\n\n\n    if ($args{response}){\n\t$self->{\"response\"}=$args{\"response\"};\n    }\n\n    if ($args{\"sigin\"}){\n\t_checktimeformat($args{\"sigin\"});\n\tprint \"\\nSetting siginception to \" . $args{\"sigin\"} if $debug;\n\t$self->{\"siginception\"} =$args{\"sigin\"};\n    }else{\n\tmy @inct=gmtime(time);\n\tmy $currentdatestring=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t $inct[0]);\t\n\t$self->{\"siginception\"} = $currentdatestring ;\n    }\n\n    # This will fail if the dateformat is not correct...\n    $self->{\"siginception\"} =~ \n\t/(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ ;\n    my $siginc_time=timegm ($6, $5, $4, $3, $2-1, $1-1900);\n\n    if ($args{\"sigval\"}){ #sigexpiration set by siginception + sigval\n\tmy @inct;\n\n\n\tif ($sigzero){\n\t    # treat sigval as minutes\n\t    @inct=gmtime($siginc_time+$args{\"sigval\"}*60 );  \n\t}else{\n\t    # treat sigval as days\n\t    @inct=gmtime($siginc_time+$args{\"sigval\"}*24*3600 );  \n\t}\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t   $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t   $inct[0]);\t\n    }elsif ($args{\"sigex\"}) { #sigexpiration set by the argument\n\t_checktimeformat($args{\"sigex\"});\n\tif ( $self->{\"siginception\"} > $args{\"sigex\"} ){\n\t    croak \"Signature can only expire after it has been incepted (\".\n\t\t$args{\"sigex\"} . \"<\" . $self->{\"siginception\"} .\n\t\t    \")\";\n\t}\n\tprint \"\\nSetting sigexpiration to \" . $args{\"sigexp\"} if $debug;\n\t$self->{\"sigexpiration\"}=$args{\"sigex\"} ;\n    }else{ \n\tmy @inct;\n\tif ($sigzero){\n\t    #default 5 minutes\n\t    @inct=gmtime($siginc_time+5*60  );  \n\t}else{\n\t   # Take the 30 days default for sigexpiration \t\n\t    @inct=gmtime($siginc_time+30*24*3600 );  \n\t}\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t   $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t   $inct[0]);\t\n    }\n\n\n    if (!$sigzero)    {   \n\tmy  $labels=$datarrset->[0]->name;\n\t$labels =~ s/\\.$//;  # remove trailing dot.\n        $labels =~ s/^\\*\\.//;  # remove initial asterisk label\n\tmy @labels= split /\\./ , $labels;\n\t$self->{\"labels\"}= scalar(@labels);\n\t\n    }else{\n\t$self->{\"labels\"}= 0;\n    }\n\n    # All the TTLs need to be the same in the data RRset.\n    if ( (!$sigzero) && @{$datarrset}>1){\n\tfor (my $i=0; $i<@{$datarrset}; $i++){\n\t    if ($datarrset->[0]->{\"ttl\"} != $datarrset->[$i]->{\"ttl\"}){\n\t\tcroak \"\\nNot all TTLs  in the data RRset are equal \";\n\t    }\n\t}\n    }\n  \n    if ($sigzero){\n\t$self->{\"orgttl\"}=0;\n    }else{\t\n\t$self->{\"orgttl\"}=$datarrset->[0]->{\"ttl\"};  \n    }\n\n\n    $self->{\"sig\"}=  \"NOTYETCALCULATED\";  # This is what we'll do in a bit...\n    $self->{\"sigbin\"}= decode_base64($self->{\"sig\"});\n\n    # Bless the whole thing so we can get access to the methods...\n    # (Don not ask me why I havent called the new method, There are\n    # more ways to do things)\n\n    bless $self, $class;\n    \n    my $sigdata=$self->_CreateSigData($datarrset);\n\n    my $signature;\n    \n    #\n    # Enjoy the crypto\n    if ($self->{\"algorithm\"} == 1 || $self->{\"algorithm\"} == 5) {  #RSA\n\tif (! ($Private->algorithm == 1 || $self->algorithm == 5 )) {\n\t    die \"Private key mismatch, not RSAMD5 or RSASHA.\";\n\t    \n\t}\n#\tmy $rsa_priv = Crypt::OpenSSL::RSA->new_private_key($Private->privatekey);\n\tmy $rsa_priv = $Private->privatekey;\n\t$self->{\"private_key\"}=$Private->privatekey;\n\teval {\n\t    $rsa_priv->use_pkcs1_oaep_padding;\n\t    if ($self->{\"algorithm\"} == 1) {\n\t\t$rsa_priv->use_md5_hash;\n\t    } else {\n\t\t$rsa_priv->use_sha1_hash;\n\t    }\n\n\t};\n\tdie \"RSA private key loading failed:\".$@ if $@;\n\teval {\n\t    $signature = $rsa_priv->sign($sigdata);\n\t};\n\tdie \"RSA Signature generation failed \".$@ if $@;\n\n\tprint \"\\n SIGNED\" if $debug ;\n\t\n    }elsif ($self->{\"algorithm\"} == 3){  #DSA\n\t$self->{\"private_key\"}=$Private->privatekey;\n\tmy $private_dsa=$Private->privatekey;\n\n\t# If $sigzero then we want to sign data if given in the\n\t# argument. If the argument is empty we sign when the packet\n\t# put on the wire.\n\tif ($datarrset ne \"\" ){\n\t    if (my $sig_obj= $private_dsa->do_sign(sha1($sigdata)))\n\t    {\n\t\t\n\t\tprint \"\\n SIGNED\" if $debug ;\n\t\t# See RFC 2535 for the content of the SIG\n\t\tmy $T_parameter= (length($private_dsa->get_g)-64)/8;\n\t\t$signature=pack(\"C\",$T_parameter);\n\n\t\tmy $sig_r_param=$sig_obj->get_r;\n\t\tmy $sig_s_param=$sig_obj->get_s;\n\t\t# both the R and S paramater in the RDATA need to be\n\t\t# 20 octets:\n\t\twhile (length($sig_r_param)<20){\n\t\t    $sig_r_param=pack('x').$sig_r_param ; \n\t\t}\n\t\twhile (length($sig_s_param)<20) {\t\n\t\t    $sig_s_param=pack('x').$sig_s_param ;\n\t\t}\n\t\t$signature.=$sig_r_param.$sig_s_param;\n\n\n\t    }else\n\t    {  \n\t\tconfess \"creation of DSA Signature failed \" ;\n\t    }\n\t}\n\t\n    }\n\n    if ($datarrset ne \"\" ){\n\t# Replace the \"sig\" by the real signature and return the object.\n\t$self->{\"sigbin\"}=$signature;\n\t$self->{\"sig\"}= encode_base64($signature);\n    }\n\n    return $self;\n}\n\n\nsub verify {\n    my ($self, $dataref, $keyrr) = @_;\n\n    # Reminder...\n\n    # $dataref may be a reference to an array of RR objects:\n    # $dataref->[$i]->method is the call to the method of the $i th\n    # object in the array...  @{$dataref} is length of the array when\n    # called in numerical context\n\n    # Alternatively %dataref may refer to a a Net::DNS::Packet.\n\n    # if $dataref is not a reference it contains a string with data to be \n    # verified using SIG0\n    \n    my $sigzero_verify=0;\n    my $packet_verify=0;\n    my $rrarray_verify=0;\n   \n    print \"Verifying data of class:\".  ref( $dataref) . \"\\n\" if $debug;\n    $sigzero_verify=1 unless (ref($dataref));\n    if (! $sigzero_verify ){\n\tif (ref($dataref) eq \"ARRAY\"){\n\t    if (ref($dataref->[0]) and $dataref->[0]->isa('Net::DNS::RR')){\n\t\t$rrarray_verify=1;\n\n\tprint \"Note: the SIG RR has been deprecated for use other than SIG0; use the RRSIG instead\\n\"\t\t  \n\t\t  if !$__DeprecationWarningVerifyShown ;\n\t\t$__DeprecationWarningVerifyShown=1;\n\t    }else{\n\t\tdie \"Trying to verify an array of \".  ref( $dataref->[0]) .\"\\n\";\n\t    }\n\t}elsif( (ref($dataref)) and $dataref->isa(\"Net::DNS::Packet\")){\n\t    $packet_verify=1 if ((ref($dataref)) and $dataref->isa(\"Net::DNS::Packet\"));\n\t    die \"Trying to verify a packet while signature is not of SIG0 type\"\n\t\tif ($self->{\"typecovered\"} ne \"TYPE000\");\n\t}else{\n\t    die \"Do not know what kind of data this is\" . ref( $dataref) . \")\\n\";\n\t}\n    }\n\n    $self->{\"vrfyerrstr\"}=\"---- Unknown Error Condition ------\";\n    print \"\\n ------------------------------- SIG DEBUG  -----------------\\n\"  if $debug;\n    print \"Reference: \".ref($dataref) if $debug;;\n    print \"\\n  SIG:\\t\", $self->string if $debug;\n    if ( $rrarray_verify ){\n\tfor (my $i=0; $i<@{$dataref}; $i++){\n\t    print \"\\n DATA:\\t\", $dataref->[$i]->string if $debug ;\n\t}\n    }\n    print \"\\n  KEY:\\t\" , $keyrr->string if $debug;\n    print \"\\n ------------------------------------------------------------\\n\" if $debug;\n\n\n\n     \n    if (!$sigzero_verify && !$packe", 8192) = 8192
09:01:57.259151 brk(0x1459000)          = 0x1459000
09:01:57.259925 read(14, "t_verify && $dataref->[0]->type ne $self->typecovered ) {\n\t$self->{\"vrfyerrstr\"} = \"\\nCannot verify datatype  \" . $self->typecovered . \n\t    \" with a key intended for \" . \n\t\t$dataref->[0]->type .\n\t\t    \" verification\\n\";\n\treturn 0;\n    }\n\n\n    if ( $rrarray_verify &&  !$dataref->[0]->type eq \"SIG\" ) {\n\t# if [0] has type SIG the whole RRset is type SIG. \n\t# There are no SIGs over SIG RRsets\n\t$self->{\"vrfyerrstr\"} = \n\t    \"SIGs over SIGs???\\n\" .\n \t   \" What are you trying to do. This is not possible.\\n\";\n\treturn 0;\n    }\n    if ( $self->algorithm != $keyrr->algorithm ){\n\t$self->{\"vrfyerrstr\"} = \n\t    \"It is impossible to verify a signature made with algorithm \" .\n\t\t$self->algorithm . \"\\nagainst a key made with algorithm \" .\n\t\t    $keyrr->algorithm . \"\\n\";\n\treturn 0;\n\n    }\n\n    if ( $packet_verify){\n\t# We keep the intelligence for verification in here....\n\t# The packet is compressed ... we have to undo the compression.\n\t# Do this by creating a newpaclet\n\tmy $newpacket;\n\tbless($newpacket = {},\"Net::DNS::Packet\");\n\t%{$newpacket} = %{$dataref};\n\tbless($newpacket->{\"header\"} = {},\"Net::DNS::Header\");\n\t%{$newpacket->{\"header\"}} = %{$dataref->{\"header\"}};\n\t@{$newpacket->{\"additional\"}} = @{$dataref->{\"additional\"}};\n\tshift(@{$newpacket->{\"additional\"}});\n\t$newpacket->{\"header\"}{\"arcount\"}--;\n\t$newpacket->{\"compnames\"} = {};\n\t$dataref=$dataref->data;\n    }\n\n\n    # The data that is to be signed\n    my $sigdata=$self->_CreateSigData($dataref);\n    my $signature=$self->sigbin; \n    my $verified=0;\n    if ( $self->algorithm == 1 ){    #Verifying for RSA\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,0) || return 0;\n    }     \n    elsif ( $self->algorithm == 3 )  # Verifying for DSA\n    {\n\t $verified=$self->_verifyDSA($sigdata,$signature,$keyrr) || return 0;\n    }\n    elsif ( $self->algorithm == 5 )  # Verifying for RSASHA1\n    {\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,1) || return 0;\n    }\n    else                                  # Verifying other algorithms\n    { \n\t$self->{\"vrfyerrstr\"}= \"Algoritm \". $self->algorithm . \" has not yet been implemented\";\n\treturn 0;\n    }\t\n    \n    # This really is a redundant test\n    if ($verified) {  \n        # time to do some time checking.\n\tmy @inct=gmtime(time);\n\tmy $currentdatestring=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t     $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t     $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t     $inct[0]);\t\n\tif ($self->{\"siginception\"} > $currentdatestring ){\n\t    $self->{\"vrfyerrstr\"}= \"Signature may only be used in the future; after \" .\n\t\t$self->{\"siginception\"} ;\n\t    return 0;\n\t}elsif($self->{\"sigexpiration\"} < $currentdatestring ){\n\t    $self->{\"vrfyerrstr\"}= \"Signature has expired since: \" .\n\t\t$self->{\"sigexpiration\"} ;\n\t    return 0;\n\t}\n\t$self->{\"vrfyerrstr\"}= \"No Error\";\n\treturn 1;\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"Verification method error.\";\n    return 0;\n\n} #END verify block\n\n\n\n\n# Below are all sorts of helper functions. \n# They should not really be used outside the scope of this class ...\n#\n# To do:  make these functions invisable outside the class.\n#\nsub _type2string {\n    my $index=shift;\n    if( Net::DNS::typesbyval($index)){\n\treturn Net::DNS::typesbyval($index) ;\n    }else{\n\treturn \"UNKNOWN TYPE\";\n    }\n}\n\nsub _string2type {\n    my $index=shift;\n        if( Net::DNS::typesbyname(uc($index))){\n\treturn Net::DNS::typesbyname(uc($index)) ;\n    }else{\n\tcarp \"UNKNOWN QTYPE, cannot continue \";\n    }\n}\n\n\n\n\n\n\nsub _verifyDSA {\n    my ($self, $sigdata, $signature, $keyrr) = @_; \n\n    print \"\\nDSA verification called with key:\\n\". $keyrr->string . \n\t\n\t\" and sig:\\n\" . $self->string .\"\\n\" if $debug;\n\n    # RSA RFC2536\n    #\n    # Setup a DSA::Key. \n    #\n\n\n    \n    \n    \n    my $t_param=ord substr($keyrr->keybin,\n\t\t\t0,\n\t\t\t1);   # This works since T is only one octed .\n    \n    my $q_param=substr($keyrr->keybin, \n\t\t       1,\n\t\t       20);\n    my $p_param=substr($keyrr->keybin, \n\t\t       21, \n\t\t       64+$t_param*8 );\n    my $g_param=substr($keyrr->keybin, \n\t\t       21+64+$t_param*8,\n\t\t\t\t    64+$t_param*8);\n    \n\n\n    #rfc3279  section 2.3.2\n    # (...)\n    # The DSA public key MUST be ASN.1 DER encoded as an INTEGER; this\n    # encoding shall be used as the contents (i.e., the value) of the\n    # subjectPublicKey component (a BIT STRING) of the\n    # SubjectPublicKeyInfo data element.\n    # (...)\n\n    \nmy $pubkey_param=substr($keyrr->keybin, \n\t\t\t21+2*(64+$t_param*8),\n\t\t\t64+$t_param*8);\n\nmy $dsa_pub=Crypt::OpenSSL::DSA->new();\n    $dsa_pub->set_q($q_param);\n    $dsa_pub->set_g($g_param);\n    $dsa_pub->set_p($p_param);\n    $dsa_pub->set_pub_key($pubkey_param);\n\n\n\n    my $r_field=(substr($self->sigbin,\n\t\t\t1,\n\t\t\t20));\n    my $s_field=(substr($self->sigbin,\n\t\t\t21,\n\t\t\t20));\n    \n    my $DSAsig=Crypt::OpenSSL::DSA::Signature->new();\n    $DSAsig->set_r($r_field);\n    $DSAsig->set_s($s_field);\n\n\n    if (my $valid=$dsa_pub->do_verify (sha1( $sigdata) ,\n\t\t\t\t       $DSAsig\n\t\t\t\t       )){\n\tif ($valid==-1){\n\t    print \"Crypt::OpenSSL::DSA Verification failed with error\\n\" if $debug;\n\t    $self->{\"vrfyerrstr\"}=\"DSA Verification failed with error\";\n\t    return(0);\n\t}else{\n\t    print \"Crypt::OpenSSL::DSA Verification successful:$valid\\n\" if $debug;;\n\t    \n\t    $self->{\"vrfyerrstr\"}=\"DSA Verification successful \";\n\t    return(1);\n\t}\n    }else{\n\tprint \"Crypt::OpenSSL::DSA Verification failed\\n \" if $debug;;\n\t$self->{\"vrfyerrstr\"}=\"DSA Verification failed \";\n\treturn(0);\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"DSA Verification failed: undefined error \";\n    \n    return 0;\t\n}\n\n\nsub _verifyRSA {\n    # Implementation using crypt::openssl\n\n    my ($self, $sigdata, $signature, $keyrr, $isSHA) = @_; \n\n    print \"\\nRSA verification called with key:\\n\". $keyrr->string . \n\t\n\t\" sig:\\n\" . $self->string .\"\\non sigdata:\\t\".\n\t    unpack (\"H*\",$sigdata) . \"\\n\" \n\t    if $debug;\n    # RSA RFC2535\n    # \n    \n    my $explength;\n    my $exponent;\n    my $modulus;\n    my $RSAPublicKey;\n\t\n    {   #localise dummy\n\tmy $dummy=1;\n\t# determine exponent length\n\t\n\t#RFC 2537 sect 2\n\t($dummy, $explength)=unpack(\"Cn\",$keyrr->keybin) \n\t    if ! ($explength=unpack(\"C\",$keyrr->keybin));\n\tprint \"\\n\\nEXPLENGTH:\",$explength if $debug;\n\t\n\t# We are constructing the exponent and modulus as a hex number so \n\t# the AUTOLOAD function in Crypt::RSA::Key::Public can deal with it\n\t# later, there must be better ways to do this,\n\tif ($dummy) { # skip one octet\n\t    $exponent=(substr ($keyrr->keybin, \n\t\t\t       1, \n\t\t\t       $explength));\n\t    \n\t    $modulus=( substr ($keyrr->keybin,\n\t\t\t       1+$explength, \n\t\t\t       (length $keyrr->keybin) - 1\n\t\t\t       - $explength));\n\t    \n\t    \n\t}else{ # skip two octets\n\t    $exponent=(substr ($keyrr->keybin, \n\t\t\t       3,\n\t\t\t       $explength));\n\t    \n\t    $modulus=( substr ($keyrr->keybin, \n\t\t\t       3+$explength, \n\t\t\t       (length $keyrr->keybin) - 3\n\t\t\t       - $explength));\n\t}\n    }\n    \n\n    my $bn_modulus=Crypt::OpenSSL::Bignum->new_from_bin($modulus);\n    my $bn_exponent=Crypt::OpenSSL::Bignum->new_from_bin($exponent);\n\n  \n\n    my $rsa_pub = Crypt::OpenSSL::RSA->new_key_from_parameters($bn_modulus,$bn_exponent);\n\n\n    die \"Could not load public key\" unless $rsa_pub;\n    $rsa_pub->use_pkcs1_oaep_padding;\n    if ($isSHA) {\n\t$rsa_pub->use_sha1_hash;\n    } else {\n\t$rsa_pub->use_md5_hash;\n    }\n    \n\n    \n    my $verified;\n    eval {\n\t$verified=$rsa_pub->verify($sigdata, $signature);\n    };\n\n    if ($@){\n\t $self->{\"vrfyerrstr\"}=\n\t     \"Verification of RSA string generated error: \". $@;\n\t print \"\\nRSA library error.\\n\" if $debug;\n\t return 0;\n     }\n    if ($verified )\n    {\n\tprint \"\\nVERIFIED\\n\\n\" if $debug ;\n\t$self->{\"vrfyerrstr\"}=\"RSA Verification successful\";\n\treturn 1;\n    }else\n    {   $self->{\"vrfyerrstr\"}=\"RSA Verification failed\";\n\t# Data is not verified\n\tprint \"\\nNOT VERIFIED\\n\" if $debug;\n\treturn 0;\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"RSA Verification failed: This code should not be run \";\n    0;\n\n}\n\nsub _CreateSigData {\n    # this is the data that will be  signed, it will be fed to the\n    # verifier. See RFC4034 section 6 on how this string is constructed\n\n    # This method is called by the method that creates as signature\n    # and by the method that verifies the signature. It is a", 8192) = 8192
09:01:57.260427 brk(0x147a000)          = 0x147a000
09:01:57.261053 read(14, "ssumed\n    # that the creation method has checked that all the TTL are the same\n    # for the dataref and that sig->orgttl has been set to the TTL of\n    # the data. This method will set the datarr->ttl to the sig->orgttl for\n    # all the RR in the dataref.\n\n\n\n    my ($self,$rawdata)=@_;\n\n    my $sigzero= ! ref ($rawdata);\n    my $sigdata;\n    # construction of message \n\n\n    my $rdatawithoutsig=$self->rr_rdata_without_sigbin;\n    print \"\\n\\nstrip:\\t\\t\",  unpack(\"H*\", $rdatawithoutsig) if $debug;\n    $sigdata= $rdatawithoutsig;\n\n\n    if ( ! $sigzero ){  \n\t# Not a SIG0\n\tif (@{$rawdata}>1) {\n\t    my @canonicaldataarray;\n\t    for (my $i=0; $i<@{$rawdata}; $i++){\n\t\tif ($debug){\n\t\t    print \"Setting TTL to from \". $rawdata->[$i]->{\"ttl\"} . \" to \" .\n\t\t\t$self->orgttl . \"\\n\" \n\t\t\t    if ( $rawdata->[$i]->{\"ttl\"}!=$self->orgttl);\n\t\t}\n\t\t$rawdata->[$i]->{\"ttl\"}=$self->orgttl;\n\t\t# Some error checking is done to. A RRset is defined by \n\t\t# Same label,class,qtype\n\t\tif ($rawdata->[$i]->name ne $rawdata->[0]->name){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nNot all labels in the data RRset above are equal \";\n\t\t}\n\t\t\n\t\tif ($rawdata->[$i]->type ne $rawdata->[0]->type){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nThe  the data RRset consists of different types \";\n\t\t}\n\t\t\n\t\tif ($rawdata->[$i]->class ne $rawdata->[0]->class){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nThe  the data RRset has different classes (What are you trying to do?)  \";\n\t\t}\n\t\t\n\t\tprint \"\\n\\nCan Data RR: $i\\t\", \n\t\tunpack(\"H*\", ($rawdata->[$i]->_canonicaldata)) if $debug;\n\t\t\n\t\t# To allow for sorting on RDATA we create an array of hashes.\n\t\t# We sort on canonicalRdata and use the full RR representation \n\t\t# in rr to build the digest.\n\t\t$canonicaldataarray[$i]= \n\t\t{ rrdigest => $rawdata->[$i]->_canonicaldata,\n\t\t  canonicalRdata => $rawdata->[$i]->_canonicalRdata,\n\t      };\n\t    }\n\t    \n\t    # Sort acording to RFC2535 section 8.3\n\t    # Comparing left justified octet strings: perl sort does just that.\n\t    # We have to sort on RDATA.. the array contains the whole RRset.\n\t    #  the sort routine\n\t    \n\t    my @sortedcanonicaldataarray= sort        {\n\t\t$a->{\"canonicalRdata\"} cmp $b->{\"canonicalRdata\"};   \n\t    }\n\t    @canonicaldataarray;\n\t    \n\t    \n\t    \n\t    for (my $i=0; $i<@sortedcanonicaldataarray ; $i++){\n\t\tprint \"\\n>>>\" . $i \t.\n\t\t    \">>> \\t\" .\n\t\t\tunpack(\"H*\",$sortedcanonicaldataarray[$i]{canonicalRdata}) .\n\t\t\t    \"\\n>>>\\t \" .\n\t\t\t\tunpack(\"H*\",$sortedcanonicaldataarray[$i]{rrdigest}) .\n\t\t\t\t    \"\\n\" if $debug;\n\t\t$sigdata .=  $sortedcanonicaldataarray[$i]{rrdigest};\n\t    }\n\t}else{\n\t    if ($debug) {\n\t\tprint \"\\nSetting TTL to from \". $rawdata->[0]->{\"ttl\"} . \" to \" .\n\t\t    $self->orgttl . \"\\n\" if \n\t\t\t( $rawdata->[0]->{\"ttl\"}!=$self->orgttl );\n\t    }\n\t    print \"\\nRDATA: \\t\" .$rawdata->[0]->_canonicalRdata .\"\\t\" .\n\t\tunpack(\"H*\",$rawdata->[0]->_canonicalRdata) .\"\\n\" if $debug;\n\t    \n\t    $rawdata->[0]->{\"ttl\"}=$self->orgttl;\t    \n\t    $sigdata .= $rawdata->[0]->_canonicaldata;\n\t    \n\t}\n\t\n    }else{ #SIG0 case  \n\n\tprint \"\\nsig0 proccessing\\nrawdata:\\t\". unpack(\"H*\",$rawdata).\"\\n\"if $debug;\n\t$sigdata=$sigdata.$rawdata;\n    }\n    \n\n    print \"\\n sigdata:\\t\".   unpack(\"H*\",$sigdata) . \"\\n\" if $debug;\n\n    return $sigdata;\n}\n\n\nsub _checktimeformat {\n    # Function to check if the strings entered as time are properly formated.\n    # Croaks if the format does not make sense...\n    \n    \n    my $timestring=shift;\n\n    my @timeval=($timestring =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/);\n    if (@timeval != 6) {\n\tcroak \"The time \" . $timestring . \" is not in the expected format (yyyymmddhhmmss)\";\n    }\n    if ($timeval[0]< 1970) {\n\tcroak \"The year \". $timeval[0] . \" is before the epoch (1970)\";\n    }\n    if ($timeval[1]> 12) {\n\tcroak \"What??? There is no month number \". $timeval[1] ;\n    }\n    # This is a rough check... \n    # Feb 31 will work... \n    if ($timeval[2]> 31) {\n\tcroak \"Intresting, a month with \". $timeval[2] . \" days\" ;\n    }\n\n    if ($timeval[3]> 24) {\n\tcroak \"Intresting, a day with \". $timeval[3] . \" hours\" ;\n    }\n\n    if ($timeval[4]> 60) {\n\tcroak \"Intresting, an hour with \". $timeval[3] . \" minutes\" ;\n    }\n    if ($timeval[5]> 60) {\n\tcroak \"Intresting, a minute with \". $timeval[3] . \" seconds\" ;\n    }\n\n    \n    0;\n}\n\n\n# The previous versions had a typo... *Sigh*\nsub siginceptation {\n    my $self=shift;\n    return $self->siginception(@_);\n}\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::SIG - DNS SIG resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\n\nIMPORTANT: For any other use than SIG0 signatures the SIG RR has been\ndeprecated (RFC3755). Use the DNSSIG instead.\n\nAll functionality currently remains present although a warning will be\nprinted at first usage of the verify and create methods.\n\n\nClass for DNS Address (SIG) resource records. In addition to the\nregular methods in the Net::DNS::RR the Class contains a method to\nsign RRsets using private keys (create). And a class for verifying\nsignatures over RRsets (verify).\n\nThe SIG RR is an implementation of RFC 2931.\n\n\n\n=head1 SIG0 Support\n\nWhen Net::DNS::RR::SIG.pm is available the Net::DNS::Packet module will have\nthe abilityh for sig0 support. See L<Net::DNS::Packet> for details.\n\n\n    my $keypathrsa=\"Ktest.example.+001+11567.private\";\n    my $update1 = Net::DNS::Update->new(\"test.example\");\n\n    $update1->push(\"update\", Net::DNS::rr_add(\"foo.test.example 3600 IN A 10.0.0.1\"));\n    $update1->sign_sig0($keypathrsa);\n\n\n=head1 METHODS\n\n=head2 create \n\n\ncreate is an alternative constructor for a SIG RR object.  \n\nYou are advised to create a packet object and then use the sign_sig0\nmethod to create a sig0 signature. \n\n\nTo create a signature over a packet (SIG0) you can use the following\nalternative recipe.\n\n    my $keypath= \n            \"/home/olaf/keys/Kbla.foo.+001+60114.private\";\n\n    $sig0 = Net::DNS::RR::SIG->create('', $keypath);\n    $packet->push('additional', $sig0) if $sig0;\n    $packet->data;  # When the data method on a packet is called\n                    # the actual sig0 calculation is done.\n\n\nThe first argument to the create method should be an empty string in\norder for the SIG0 magic to work.\n\nThe second argument is a string containing the path to a file\ncontaining the the private key as generated with dnssec-keygen, a\nprogram that commes with the bind distribution.\n\nThe third argument is an anonymous hash containing the following\npossible arguments:  \n\n    ( ttl => 3600,                        # TTL \n      sigin =>   20010501010101,          # signature inception\n      sigex =>   20010501010101,          # signature expiration\n      sigval => 1.5                       # signature validity\n      )\n\nThe default for the ttl is 3600 seconds. sigin and sigex need to be\nspecified in the following format 'yyyymmddhhmmss'. The default for\nsigin is the time of signing. \n\nsigval is the validity of the signature in minutes. If sigval is\nspecified then sigex is ignored. The default for sigval is 5 minutes.\n\nNote that for SIG0 signatures the default sigin is calculated at the\nmoment the object is created, not at the moment that the packet is put\non the wire. \n\n\nNotes: \n\n- Do not change the name of the file generated by dnssec-keygen, the\n  create method uses the filename as generated by dnssec-keygen to determine \n  the keyowner, algorithm and the keyid (keytag).\n\n- Only RSA signatures (algorithm 1 and 5) and DSA signatures\n  (algorithm 3) have been implemented.\n\n\n\n=head2 typecovered\n\n    print \"typecovered =\", $rr->typecovered, \"\\n\"\n\nReturns the type covered by the sig (should be TYPE000 with common\nSIG0 usage)\n\n=head2 algorithm\n\n    print \"algorithm =\", $rr->algorithm, \"\\n\"\n\nReturns the algorithm number used for the signature\n\n=head2 sigexpiration\n\n    print \"sigexpiration =\", $rr->sigexpiration, \"\\n\"\n\nReturns the expiration date of the signature\n\n=head2 siginception\n\n    print \"siginception =\", $rr->siginception, \"\\n\"\n\nReturns the date the signat", 8192) = 8192
09:01:57.261708 brk(0x149b000)          = 0x149b000
09:01:57.262042 read(14, "ure was incepted.\n\n=head2 keytag\n\n    print \"keytag =\", $rr->keytag, \"\\n\"\n\nReturns the the keytag (key id) of the key the sig was made with.\nRead \"KeyID Bug in bind.\" below.\n\n=head2 signame\n\n    print \"signame =\", $rr->signame, \"\\n\"\n\nReturns the name of the public KEY RRs  this sig was made with.\n(Note: the name does not contain a trailing dot.)\n\n=head2 sig\n\n    print \"sig =\", $rr->sig, \"\\n\"\n\nReturns the base64 representation of the signature.\n\n\n=head2 verify and vrfyerrstr\n\n\n    my $sigrr=$update1->pop(\"additional\");\n    $sigrr->verify($packet, $keyrr) || croak $sigrr->vrfyerrstr;\n\n\nIf the first argument is a Net::DNS::Packet object and if $sig->type\nequals zero a a sig0 verification is performed. Note that the\nsignature needs to be 'popped' from the packet before verifying.\n\nReturns 0 on error and sets $sig->vrfyerrstr\n\n=head2 Example\n\n\n   my $sigrr=$packet->pop(\"additional\");\n   print $sigrr->vrfyerrstr unless $sigrr1->verify($update1, $keyrr1);\n\n\n=head1 Remarks\n\n- The code is not optimized for speed whatsoever. It is probably not\n  suitable to be used for signing large zones. \n\n=head1 TODO\n\n- Clean up the code, it still contains some cruft left from the times that\n  the SIG RR was used for signing packets and RR sets.\n\n- If this code is still around by 2030 you have a few years to check\n  the proper handling of times...\n\n\n=head1 ACKNOWLEDGMENTS\n\nAndy Vaskys (Network Associates Laboratories) supplied the code for\nhandling RSA with SHA1 (Algorithm 5).\n\nChris Reinardt for maintianing Net::DNS.\n\nT.J. Mather, <tjmather@tjmather.com>, the Crypt::OpenSSL::DSA\nmaintainer, for his quick responses to bug report and feature\nrequests.\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman \n<olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\nThis code uses Crypt::OpenSSL which uses the openssl library\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>,\nL<Net::DNS::RR>,L<Crypt::OpenSSL::RSA>,L<Crypt::OpenSSL::DSA>, RFC 2931.\n\n=cut\n\n\n", 8192) = 3041
09:01:57.262243 read(14, "", 8192)      = 0
09:01:57.262292 close(14)               = 0
09:01:57.262377 stat("modules/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262430 stat("modules/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262481 stat("modules/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262529 stat("modules/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262579 stat("/etc/perl/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262629 stat("/etc/perl/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262679 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262730 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262781 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262838 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262889 stat("/usr/lib/perl5/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.262941 stat("/usr/lib/perl5/Net/DNS/RR/NXT.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.262992 stat("/usr/share/perl5/Net/DNS/RR/NXT.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.263045 stat("/usr/share/perl5/Net/DNS/RR/NXT.pm", {st_mode=S_IFREG|0644, st_size=5549, ...}) = 0
09:01:57.263104 open("/usr/share/perl5/Net/DNS/RR/NXT.pm", O_RDONLY) = 14
09:01:57.263158 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.263204 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.263261 read(14, "package Net::DNS::RR::NXT;\n\n# $Id: NXT.pm 318 2005-05-30 16:36:52Z olaf $\n\nuse strict;\nuse vars qw(@ISA $VERSION);\nuse Carp;\nuse bytes;\nuse Net::DNS;\nuse Net::DNS::Packet;\n\n\nuse Carp;\n\n@ISA = qw(Net::DNS::RR);\n$VERSION = do { my @r=(q$Revision: 318 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n    carp \"The NXT RR is depricated as of RFC3755, please refrain from using this record\";\n    \n    if ($self->{\"rdlength\"} > 0) {\n\tmy($nxtdname,$nxtoffset) = \n\t  Net::DNS::Packet::dn_expand($data, $offset);\n\n\t$self->{\"nxtdname\"} = \"$nxtdname\";\n\n\tmy $typebm =substr($$data,$nxtoffset,\n\t\t\t\t $self->{\"rdlength\"}-\n\t\t\t\t $nxtoffset+$offset);\n\n\t$self->{\"typebm\"}=$typebm;\n\t$self->{\"typelist\"} = join \" \" \n\t    ,  _typebm2typestr($typebm);\n    }\n    return bless $self, $class;\n}\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    carp \"The NXT RR is depricated as of RFC3755\";\n    if ($string) {\n\t$string =~ tr/()//d;\n\t$string =~ s/;.*$//mg;\n\t$string =~ s/\\n//mg;\n\tmy ($nxtdname,$nxtstr) = \n\t    $string =~ /^\\s*(\\S+)\\s+(.*)/;\n\tmy @nxttypes = split /\\s+/ , $nxtstr;       # everything after last match...\n\t\n\t$self->{\"nxtdname\"}= lc($nxtdname) ;\n\t$self->{\"typelist\"}= join \" \" , sort @nxttypes ;\n\t$self->{\"typebm\"}=_typestr2typebm(@nxttypes);\n\t\n    }\n    return bless $self, $class;\n}\n\n\n\n\n#sub is_optin {\n#    my $self =shift;\n#    return 1 if $self->{\"typelist\"}!~/NXT/;\n#    0;\n#}\n\n#sub set_optin {\n#    my $self =shift;\n#    $self->{\"typelist\"}=~s/NXT//;\n#    1;\n#}\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\n\tif (exists $self->{\"nxtdname\"}) {\n\t    $rdatastr  = $self->{nxtdname};\n\t    $rdatastr .= \"  \"  . \"$self->{typelist}\";\n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n    my $rdata = \"\" ;\n    if (exists $self->{\"nxtdname\"}) {\n\t# Compression used here... \n\t$rdata = $packet->dn_comp($self->{\"nxtdname\"},$offset);\n\t$rdata .= $self->{\"typebm\"};\n    }\n    \n    return $rdata;\n    \n}\n\n\n\nsub _canonicalRdata {\n    # rdata contains a compressed domainname... we should not have that.\n\tmy ($self) = @_;\n\tmy $rdata;\n\n\t$rdata=$self->_name2wire($self->{\"nxtdname\"});\n\t$rdata .= $self->{\"typebm\"};\t\n\treturn $rdata;\n}\n\n\nsub _typestr2typebm {\n    # RFC2535 5.1 needs the typebm\n    # This needs to check for values > 127....\n\n    # Sets a bit for every qtype in the input array.\n    # Minimum bitmaplenght 4 octets because NXT (30) is allways there\n    # may be longer but trailing all zero octets should be dropped.\n\n    my (@typelist, @typebitarray);\n    @typelist= @_;\n    for(my $i=0;$i < @typelist; $i++){\n\t$typebitarray[$Net::DNS::typesbyname{uc($typelist[$i])}]=1;\n    }\n    \n    my $finalsize=0;\n    {\n\tuse integer;\n\t$finalsize = 8 * ((@typebitarray / 8)  + 1);\n    }\n\n    for (my $i=0;$i< $finalsize; $i++){\n\t$typebitarray[$i]=0 if ! defined $typebitarray[$i];\n    }\n    my $typebm= pack(\"B$finalsize\",join \"\", @typebitarray );\n    return $typebm\n\n}\n\nsub _typebm2typestr {\n    # RFC2535 5.1 needs the typebm\n    # This needs to check for values > 127....\n    my @typebm=split //, unpack(\"B*\", shift);  # bit representation in array\n    my @typelist;\n    carp \"Cannot deal with qtype > 127\" \n\tif ($#typebm > 127);\n    \n    my($foo);\n    foreach $foo (sort { $a <=> $b } keys(%Net::DNS::typesbyval)  ){\n\tnext if $foo > $#typebm;           # Skip larger aray vallues.\n\t@typelist=(@typelist,$Net::DNS::typesbyval{$foo}) if \n\t    ($typebm[$foo] eq \"1\");\n    }\n\n    return sort @typelist;\n}\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::NXT - DNS NXT resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nB<NOTE: THE NXT RR has been deprecated! Use NSEC instead.>\n\n\n\nClass for DNS Address (NXT) resource records.\n\n\n=head1 METHODS\n\n=head2 nxtdname\n\n    print \"nxtdname\" = \", $rr->nxtdname, \"\\n\";\n\nReturns the RR's next domain name field.\n\n\n=head2 typelist\n\n    print \"typelist\" = \", $rr->typelist, \"\\n\";\n\nReturns a string with the list of qtypes for which data exists for\nthis particular label.\n\n\n\n=head2 typebm\n\n    print \"typebm\" = \" unpack(\"B*\", $rr->typebm), \"\\n\";\n\nSame as the typelist but now in a representation  bitmap as in \nspecified in the RFC. This is not the kind of method you will need\non daily basis.\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 2435 Section 5\n\n\n\n=cut\n", 8192) = 5549
09:01:57.264113 read(14, "", 8192)      = 0
09:01:57.264164 close(14)               = 0
09:01:57.264241 stat("modules/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264292 stat("modules/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264342 stat("modules/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264390 stat("modules/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264440 stat("/etc/perl/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264488 stat("/etc/perl/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264539 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264590 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264641 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264691 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264741 stat("/usr/lib/perl5/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264798 stat("/usr/lib/perl5/Net/DNS/RR/KEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.264850 stat("/usr/share/perl5/Net/DNS/RR/KEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.264901 stat("/usr/share/perl5/Net/DNS/RR/KEY.pm", {st_mode=S_IFREG|0644, st_size=3069, ...}) = 0
09:01:57.264960 open("/usr/share/perl5/Net/DNS/RR/KEY.pm", O_RDONLY) = 14
09:01:57.265013 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.265059 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.265119 read(14, "package Net::DNS::RR::KEY;\n\n# $Id: KEY.pm 847 2010-03-12 13:04:13Z olaf $\n\nuse strict;\nuse vars qw(@ISA $VERSION);\nuse bytes;\nuse Net::DNS;\nuse MIME::Base64;\nuse Carp;\n\n@ISA = qw(Net::DNS::RR Net::DNS::RR::DNSKEY);\n$VERSION = do { my @r=(q$Revision: 847 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n\treturn Net::DNS::RR::DNSKEY::new(@_);\n}\n\nsub new_from_string {\n\treturn Net::DNS::RR::DNSKEY::new_from_string(@_);\n}\n\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::KEY - DNS KEY resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for DNS Address (KEY) resource records.\n\n=head1 METHODS\n\nThis class inherits most of its methods from DNSKEY. See DNSKEY for a\ncomplete list of available methods.\n\n=head2 flags\n\n    print \"flags\" = \", $rr->flags, \"\\n\";\n\nReturns the RR's flags in decimal representation\n\n\n=head2 protocol\n\n    print \"protocol\" = \", $rr->protocol, \"\\n\";\n\nReturns the RR's protocol field in decimal representation\n\n=head2 algorithm\n\n    print \"algoritm\" = \", $rr->algorithm, \"\\n\";\n\nReturns the RR's algorithm field in decimal representation\n\n    1 = MD5 RSA\n    2 = DH\n    3 = DSA                \n    4 = Elliptic curve\n    5 = SHA1 RSA\n\nNote that only algorithm 1 and 3 are supported by the methods provided\nthrough Net::DNS::RR::SIG.pm.\n\n=head2 key\n\n    print \"key\" = \", $rr->key, \"\\n\";\n\nReturns the key in base64 representation\n\n\n=head2 keybin\n\n    $keybin =  $rr->keybin;\n\nReturns the key binary material\n\n\n=head2 keytag\n\n    print \"keytag\" = \", $rr->keytag, \"\\n\";\n\nReturns the key tag of the key. (RFC2535 4.1.6)\n\n=head2 privatekeyname\n\n    $privatekeyname=$rr->privatekeyname\n\nReturns the name of the privatekey as it would be generated by\nthe BIND dnssec-keygen program. The format of that name being\nK\\<fqdn\\>+\\<algorithm\\>+\\<keyid\\>.private\n\n\n\n    \n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 2931.\n\n=cut\n", 8192) = 3069
09:01:57.265491 read(14, "", 8192)      = 0
09:01:57.265541 close(14)               = 0
09:01:57.265618 stat("modules/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.265674 stat("modules/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.265729 stat("modules/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.265778 stat("modules/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.265827 stat("/etc/perl/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.265876 stat("/etc/perl/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.265925 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.265975 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.266025 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.266093 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.266145 stat("/usr/lib/perl5/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.266196 stat("/usr/lib/perl5/Net/DNS/RR/DS.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.266247 stat("/usr/share/perl5/Net/DNS/RR/DS.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.266300 stat("/usr/share/perl5/Net/DNS/RR/DS.pm", {st_mode=S_IFREG|0644, st_size=7879, ...}) = 0
09:01:57.266359 open("/usr/share/perl5/Net/DNS/RR/DS.pm", O_RDONLY) = 14
09:01:57.266413 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.266459 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.266514 read(14, "package Net::DNS::RR::DS;\n\n# $Id: DS.pm 728 2008-10-12 09:02:24Z olaf $\n\n\nuse strict;\nuse vars qw(@ISA $VERSION $_Babble);\n\nuse Net::DNS;\nuse Carp;\n\nuse Digest::SHA  qw(sha1 sha1_hex sha256 sha256_hex );\n\nBEGIN {\n\n    $_Babble=0;    \n    $_Babble=1 unless (eval \"require Digest::BubbleBabble; import Digest::BubbleBabble qw(bubblebabble)\") ;\n\n}\n\n\n\n\n\n$VERSION = do { my @r=(q$Revision: 728 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\nmy $debug=0;\n\n@ISA = qw(Net::DNS::RR);\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n    if ($self->{\"rdlength\"} > 0) {\n\t\n\tmy $offsettoalg=$offset+2;\n\tmy $offsettodigtype=$offset+3;\n\tmy $offsettodigest=$offset+4;\n\tmy $digestlength;\n\n\n\t$self->{\"keytag\"}=unpack(\"n\",substr($$data,$offset,2));\n\t$self->{\"algorithm\"}=unpack(\"C\",substr($$data,$offsettoalg,1));\n\t$self->{\"digtype\"}=unpack(\"C\",substr($$data,$offsettodigtype,1));\n\tif ($self->{\"digtype\"}==1){\n\t    $digestlength=20; # SHA1 digest 20 bytes long\n\t}elsif($self->{\"digtype\"}==2){\n\t    $digestlength=32; # SHA256 digest 32 bytes long\n\t}else{\n\t    $digestlength=0;\n\t}\n\t\n\t$self->{\"digestbin\"}= substr($$data,$offsettodigest,\n\t\t\t\t     $digestlength); \n\n\n\t$self->{\"digest\"}= unpack(\"H*\",$self->{\"digestbin\"});\n\t\n\t\n    }\n    return bless $self, $class;\n}\n\n\n\n\n\nsub new_from_string {\n\tmy ($class, $self, $string) = @_;\n\tif ($string) {\n\t\t$string =~ tr/()//d;\n\t\t$string =~ s/;.*$//mg;\n\t\t$string =~ s/\\n//g;\n\t\tmy ($keytag,  $algorithm, $digtype, $digest) = \n\t\t    $string =~ /^\\s*(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+((\\S+\\s*)+)/;\n\t\t# We allow spaces in the digest.\n\t\t$digest=~s/\\s//g;\n\t\t$self->{\"keytag\"}=$keytag;\n\t\t$self->{\"algorithm\"}=Net::DNS::SEC->algorithm($algorithm)|| \n\t\t    return undef;\t\t\n\t\t$self->{\"digtype\"}=Net::DNS::SEC->digtype($digtype) || \n\t\t    return undef;\n\t\t$self->{\"digest\"}=$digest;\n\t\t$self->{\"digestbin\"}=pack(\"H*\",$digest);\n\t    }\n\treturn bless $self, $class;\n}\n\n\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\tif (exists $self->{\"keytag\"}) {\n\t    $rdatastr  = $self->{keytag};\n\t    $rdatastr .= \"  \"  . \"$self->{algorithm}\";\n\t    $rdatastr .= \"  \"  . \"$self->{digtype}\";\n\t    $rdatastr .= \"  \"  . \"$self->{digest}\";\n\t    $rdatastr .= \" ; \".$self->babble if $_Babble;   \n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\nsub rr_rdata {\n    my $self = shift;\n    my $rdata;\n    if (exists $self->{\"digest\"}) {\n      $rdata= pack(\"n\",$self->{\"keytag\"}) ;\n      $rdata.= pack(\"C\",  $self->{\"algorithm\"}) ;\n      $rdata.= pack(\"C\",  $self->{\"digtype\"}) ;\n      $rdata.= $self->digestbin;\n    }\n    return $rdata;\n}\n\nsub verify {\n    my ($self, $key) = @_;\n    my $tstds=create Net::DNS::RR::DS($key,(\n\t\t\t\t\t  digtype => $self->digtype,\n\t\t\t\t      )\n\t);\n    if ($tstds->digestbin eq $self->digestbin){\n\treturn 1;\n    }else{\n\treturn 0;\n    }\n}\n\n\n\n\nsub babble {\n    my $self=shift;\n    if ($_Babble){\n        return bubblebabble(Digest=>$self->digestbin);\n    }else{\n\treturn(\"\");\n    }\n}\n\n\nsub digestbin {\n    my ($self,$new_val)=@_;\n\n    if (defined $new_val) {\n\t$self->{\"digestbin\"} = $new_val;\n\t$self->{\"digest\"} = unpack(\"H*\",$new_val);\n\treturn  $self->{\"digestbin\"};\n    }\n    \n\n    $self->{\"digestbin\"}=pack(\"H*\",$self->{\"digest\"}) unless(  $self->{\"digestbin\"} ); \n    return $self->{\"digestbin\"};\n\n\n}\n\nsub create {\n    my ($class, $keyrr ,%args) = @_;\n\n    my $self;\n\n    # Default SHA1...\n    $self->{\"digtype\"}=1;\n   \n    if ($args{\"digtype\"}){\n\t$self->{\"digtype\"}=2 if Net::DNS::SEC->digtype($args{\"digtype\"})==2;\n    }\n    \n    $self->{\"name\"}=$keyrr->name;  # Label is per definition the same as \n                                   # keylabll\n    $self->{\"type\"}=\"DS\";\n    $self->{\"class\"}=\"IN\";\n    \n    if ($args{ttl}){\n\tprint \"\\nSetting TTL to \".  $args{\"ttl\"} if $debug;\n\t$self->{\"ttl\"}= $args{\"ttl\"};\n    }else{\n\t$self->{\"ttl\"}= $keyrr->ttl;\n    }\n\n\n    # The key must not be a NULL key.\n    if (($keyrr->{\"flags\"} & hex(\"0xc000\") ) == hex(\"0xc000\") ){\n\tcroak \"\\nCreating a DS record for a NULL key is illegal\";\n    }\n    \n\n    # Bit 0 must not be set.\n    if (($keyrr->{\"flags\"}) & hex(\"0x8000\")) {\n\tcroak \"\\nCreating a DS record for a key with flag bit 0 set \".\n\t    \"to 0 is illegal\";\n    }\n    \n    # Bit 6 must be set to 0 bit 7 must be set to 1\n    if ( ($keyrr->{\"flags\"} & hex(\"0x300\")) != hex(\"0x100\")){\n\tcroak \"\\nCreating a DS record for a key with flags 6 and 7 not set \".\n\t    \"0  and 1 respectively is illegal\";\n    }\n    \n\n    if ($keyrr->{\"protocol\"}  != 3 ){\n\tcroak \"\\nCreating a DS record for a non DNSSEC (protocol=3) \".\n\t    \"key is illegal\";\n    }\n\n    $self->{\"keytag\"}=$keyrr->keytag;\n    $self->{\"algorithm\"}=$keyrr->algorithm;\n\n    my $data = $keyrr->_name2wire ($keyrr->name) . $keyrr->_canonicalRdata;\n\n    if ($self->{\"digtype\"}==1){\n\t$self->{\"digestbin\"}=  sha1($data);\n\t$self->{\"digest\"}= uc(sha1_hex($data));\n    }elsif($self->{\"digtype\"}==2){\n\t$self->{\"digestbin\"}=  sha256($data);\n\t$self->{\"digest\"}= uc(sha256_hex($data));\n    }else{\n\treturn undef;\n    }\n\n    return bless $self, $class;\n\n\n}\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::DS - DNS DS resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for Delegation signer (DS) resource records.\n\n=head1 METHODS\n\nIn addition to the regular methods \n\n\n=head2 create\n\nThis constructor takes a key object as argument and will return a DS\nRR object.\n\n$dsrr=create Net::DNS::RR::DS($keyrr, (\n                  digtype => \"SHA256\"\n);\n$keyrr->print;\n$dsrr->print;\n\nThe digest type defaults to SHA1.\n\n=head2 verify\n\nThe verify method will return 1 if the hash over the key provided in\nthe argument matches the data in the $dsrr itself i.e. if the DS\npointing to the DNSKEY from the argument. It will return 0\notherwise.\n\n$dsrr->($keyrr);\n\n\n=head2 algorithm\n\n    print \"algoritm\" = \", $rr->algorithm, \"\\n\";\n\nReturns the RR's algorithm field in decimal representation\n\n    1 = MD5 RSA\n    2 = DH\n    3 = DSA\n    4 = Elliptic curve\n\n=head2 digest\n\n    print \"digest\" = \", $dsrr->digest, \"\\n\";\n\nReturns the SHA1 digest over the label and key in hexadecimal representation\n\n\n=head2 digestbin\n\n    $digestbin =  $dsrr->digestbin;\n\nReturns the digest as  binary material\n\n=head2 keytag\n\n    print \"keytag\" .\" = \". $dsrr->keytag . \"\\n\";\n\nReturns the key tag of the key. (RFC2535 4.1.6)\n\n\n=head2 digtype\n\n   print \"digest type\" . \" = \" . $dsrr->digtype .\"\\n\";\n\nReturns the digest type of the DS RR.\n\n=head2 babble\n\n   print $dsrr->babble;\n\nReturns the 'BabbleBubble' representation of the digest. The\n'BabbleBubble' string may be handy for telephone confirmation.\n\nThe 'BabbleBubble' string returned as a comment behind the RDATA when\nthe string method is called.\n\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 4033, RFC4034, RFC4035\n\n=cut\n\n\n\n\n\n", 8192) = 7879
09:01:57.267078 stat("modules/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267132 stat("modules/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267182 stat("modules/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267231 stat("modules/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267280 stat("/etc/perl/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267330 stat("/etc/perl/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267380 stat("/usr/local/lib/perl/5.14.2/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267432 stat("/usr/local/lib/perl/5.14.2/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267484 stat("/usr/local/share/perl/5.14.2/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267534 stat("/usr/local/share/perl/5.14.2/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267585 stat("/usr/lib/perl5/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267634 stat("/usr/lib/perl5/Digest/BubbleBabble.pm", 0x7ffe12338ba0) = -1 ENOENT (No such file or directory)
09:01:57.267684 stat("/usr/share/perl5/Digest/BubbleBabble.pmc", 0x7ffe12338c50) = -1 ENOENT (No such file or directory)
09:01:57.267736 stat("/usr/share/perl5/Digest/BubbleBabble.pm", {st_mode=S_IFREG|0644, st_size=3596, ...}) = 0
09:01:57.267796 open("/usr/share/perl5/Digest/BubbleBabble.pm", O_RDONLY) = 15
09:01:57.267853 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338930) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.267899 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.267954 brk(0x14bc000)          = 0x14bc000
09:01:57.268010 read(15, "package Digest::BubbleBabble;\nuse strict;\nuse 5.008_001;\n\nuse Exporter;\nuse vars qw( @EXPORT_OK @ISA $VERSION );\n@ISA = qw( Exporter );\n@EXPORT_OK = qw( bubblebabble );\n\n$VERSION = '0.02';\n\nuse vars qw( @VOWELS @CONSONANTS );\n@VOWELS = qw( a e i o u y );\n@CONSONANTS = qw( b c d f g h k l m n p r s t v z x );\n\nsub bubblebabble {\n    my %param = @_;\n    my @dgst = map ord, split //, $param{Digest};\n    my $dlen = length $param{Digest};\n\n    my $seed = 1;\n    my $rounds = int($dlen / 2) + 1;\n    my $retval = 'x';\n    for my $i (0..$rounds-1) {\n        if ($i+1 < $rounds || $dlen % 2) {\n            my $idx0 = ((($dgst[2 * $i] >> 6) & 3) + $seed) % 6;\n            my $idx1 = ($dgst[2 * $i] >> 2) & 15;\n            my $idx2 = (($dgst[2 * $i] & 3) + $seed / 6) % 6;\n            $retval .= $VOWELS[$idx0] . $CONSONANTS[$idx1] . $VOWELS[$idx2];\n            if ($i+1 < $rounds) {\n                my $idx3 = ($dgst[2 * $i + 1] >> 4) & 15;\n                my $idx4 = $dgst[2 * $i + 1] & 15;\n                $retval .= $CONSONANTS[$idx3] . '-' . $CONSONANTS[$idx4];\n                $seed = ($seed * 5 + $dgst[2 * $i] * 7 +\n                        $dgst[2 * $i + 1]) % 36;\n            }\n        }\n        else {\n            my $idx0 = $seed % 6;\n            my $idx1 = 16;\n            my $idx2 = $seed / 6;\n            $retval .= $VOWELS[$idx0] . $CONSONANTS[$idx1] . $VOWELS[$idx2];\n        }\n    }\n    $retval .= 'x';\n    $retval;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nDigest::BubbleBabble - Create bubble-babble fingerprints\n\n=head1 SYNOPSIS\n\n    # Create a fingerprint of a simple string.\n    use Digest::BubbleBabble qw( bubblebabble );\n    my $fingerprint = bubblebabble( Digest => \"Pineapple\" );\n\n    # Create a fingerprint of a SHA-1 hash.\n    use Digest::SHA qw( sha1 );\n    $fingerprint = bubblebabble( Digest => sha1(\"hello\") );\n\n=head1 DESCRIPTION\n\nI<Digest::BubbleBabble> takes a message digest (often generated by\neither of the MD5 or SHA-1 message digest algorithms) and creates\na fingerprint of that digest in \"bubble babble\" format.\nBubble babble is a method of representing a message digest\nas a string of \"real\" words, to make the fingerprint easier\nto remember. The \"words\" are not necessarily real words, but\nthey look more like words than a string of hex characters.\n\nBubble babble fingerprinting is used by the SSH2 suite\n(and, consequently, by I<Net::SSH::Perl>, the Perl SSH\nimplementation) to display easy-to-remember key fingerprints.\nThe key (a DSA or RSA key) is converted into a textual form,\ndigested using I<Digest::SHA>, and run through I<bubblebabble>\nto create the key fingerprint.\n\n=head1 USAGE\n\nI<Digest::BubbleBabble> conditionally exports one function called\nI<bubblebabble>; to import the function you must choose to\nimport it, like this:\n\n    use Digest::BubbleBabble qw( bubblebabble );\n\n=head2 bubblebabble( Digest => $digest )\n\nCurrently takes only one pair of arguments, the key of\nwhich must be I<Digest>, the value of which is the actual\nmessage digest I<$digest>. You should generate this message\ndigest yourself using either I<Digest::MD5> of I<Digest::SHA>.\n\nReturns the bubble babble form of the digest.\n\n=head1 SEE ALSO\n\nThe BubbleBabble specification is available at:\nhttp://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt\n\n=head1 LICENSE\n\nDigest::BubbleBabble is free software; you may redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=head1 AUTHOR & COPYRIGHTS\n\nBenjamin Trott, cpan@stupidfool.org\n\nExcept where otherwise noted, Digest::BubbleBabble is Copyright\n2001 Benjamin Trott. All rights reserved.\n\n=cut\n", 8192) = 3596
09:01:57.268483 lseek(15, 1441, SEEK_SET) = 1441
09:01:57.268531 lseek(15, 0, SEEK_CUR)  = 1441
09:01:57.268575 close(15)               = 0
09:01:57.269234 read(14, "", 8192)      = 0
09:01:57.269284 close(14)               = 0
09:01:57.269360 stat("modules/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269412 stat("modules/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269467 stat("modules/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269516 stat("modules/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269565 stat("/etc/perl/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269615 stat("/etc/perl/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269668 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269719 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269770 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269820 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269871 stat("/usr/lib/perl5/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.269921 stat("/usr/lib/perl5/Net/DNS/RR/RRSIG.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.269972 stat("/usr/share/perl5/Net/DNS/RR/RRSIG.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.270022 stat("/usr/share/perl5/Net/DNS/RR/RRSIG.pm", {st_mode=S_IFREG|0644, st_size=35590, ...}) = 0
09:01:57.270096 open("/usr/share/perl5/Net/DNS/RR/RRSIG.pm", O_RDONLY) = 14
09:01:57.270151 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.270197 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.270253 read(14, "# perldoc RRSIG.pm for documentation.\n# Specs: RFC 2535 section 4\n# $Id: RRSIG.pm 814 2009-11-27 09:28:30Z olaf $\n\npackage Net::DNS::RR::RRSIG;\n\nuse vars qw(@ISA $VERSION @EXPORT );\n\nuse Net::DNS;\nuse Carp;\nuse bytes;\nuse Data::Dumper;\n\nuse Crypt::OpenSSL::DSA;\nuse Crypt::OpenSSL::RSA;\nuse Crypt::OpenSSL::Bignum;\nuse Net::DNS::SEC::Private;\n\nuse File::Basename;\nuse MIME::Base64;\nuse Math::BigInt;\nuse Time::Local;\nuse Digest::SHA qw (sha1 sha256 sha512);\n\n\n\n\n\n#\n# Most of the cryptovariables should be interpred as unsigned\n#\n#\n\n\nrequire Exporter;\n\n$VERSION = do { my @r=(q$Revision: 814 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n@ISA = qw (\n\t   Exporter\n  \t Net::DNS::RR\n  \t Net::DNS::SEC\n\t   );\n\n\n@EXPORT = qw (          \n\t      );\n\n\n\n\nuse strict;\nmy $crypt_open_ssl=1;\nmy $debug=0;\n\n\n\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n\n    if ($self->{\"rdlength\"} > 0) {\n\t#RFC2535 section 4.1\n\tmy $offsettoalg=$offset+2;\n\tmy $offsettolabels=$offset+3;\n\tmy $offsettoorgttl=$offset+4;\n\tmy $offsettosigexp=$offset+8;\n\tmy $offsettosiginc=$offset+12;\n\tmy $offsettokeytag=$offset+16;\n\tmy $offsettosignm=$offset+18;\n\n\t$self->{\"typecovered\"}= _type2string(unpack(\"n\",substr($$data,$offset,2)));\n\t$self->{\"algorithm\"}=unpack(\"C\",substr($$data,$offsettoalg,1));\n\t$self->{\"labels\"}=lc(unpack(\"C\",substr($$data,$offsettolabels,1)));\n\t$self->{\"orgttl\"}=unpack(\"N\",substr($$data,$offsettoorgttl,4));\n\tmy @expt=gmtime(unpack(\"N\",substr($$data,$offsettosigexp,4)));\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $expt[5]+1900 ,$expt[4]+1 , \n\t\t\t\t\t   $expt[3] ,$expt[2] , $expt[1]  , \n\t\t\t\t\t   $expt[0]);\n\tmy @inct=gmtime(unpack(\"N\",substr($$data,$offsettosiginc,4)));\n\t$self->{\"siginception\"}=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t     $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t     $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t     $inct[0]);\n\t$self->{\"keytag\"}=unpack(\"n\",substr($$data,$offsettokeytag,2));\n\tmy($signame,$sigoffset) = Net::DNS::Packet::dn_expand\n\t    ($data, $offsettosignm);\n\t$self->{\"signame\"}=lc($signame); \n\tmy($sigmaterial)=substr($$data,$sigoffset,\n\t\t\t\t($self->{\"rdlength\"}-$sigoffset+$offset));\n\t$self->{\"sigbin\"}=$sigmaterial;\n\t$self->{\"sig\"}= encode_base64($sigmaterial);\n\t$self->{\"vrfyerrstr\"}=\"\";\n\t\n    }\n    return bless $self, $class;\n}\n\n\n\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    if ($string) {\n\t$string =~ tr/()//d;\n\t$string =~ s/;.*$//mg;\n\t$string =~ s/\\n//mg;\n\tmy ($typecovered, $algoritm,\n\t    $labels, $orgttl, $sigexpiration,\n\t    $siginception, $keytag,$signame,$sig) = \n\t\t$string =~ \n\t\t    /^\\s*(\\S+)\\s+(\\S+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)\\s+(.*)/;\n\tcroak (\" Invallid RRSIG RR, check your fomat \") if !$keytag;\n\t$sig =~ s/\\s*//g;\n\t$self->{\"typecovered\"}= $typecovered;\n\t$self->{\"algorithm\"}= Net::DNS::SEC->algorithm($algoritm);\n\t$self->{\"labels\"}= lc($labels);\n\t$self->{\"orgttl\"}= $orgttl;\n\t_checktimeformat($sigexpiration);\n\t_checktimeformat($siginception);\n\t$self->{\"sigexpiration\"}=  $sigexpiration;\n\t$self->{\"siginception\"}= $siginception;\n\t$self->{\"keytag\"}= $keytag;\n\t$self->{\"signame\"}= lc(Net::DNS::stripdot($signame));\n\t$self->{\"sig\"}= $sig;\n\t$self->{\"sigbin\"}= decode_base64($sig);\n\t$self->{\"vrfyerrstr\"}=\"\";\n    }\n    return bless $self, $class;\n}\n\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\tif (exists $self->{\"typecovered\"}) {\n\t    $rdatastr  = $self->{typecovered};\n\t    $rdatastr .= \"  \"  . $self->algorithm;\n\t    $rdatastr .= \"  \"  . \"$self->{labels}\";\n\t    $rdatastr .= \"  \"  . \"$self->{orgttl}\";\n\t    $rdatastr .= \"  \"  . \"$self->{sigexpiration}\";\n\t    $rdatastr .= \" (\\n\\t\\t\\t\"  . \"$self->{siginception}\";\n\t    $rdatastr .= \" \"  . \"$self->{keytag}\";\n\t    $rdatastr .= \"  \"  . \"$self->{signame}.\";\n\t    # do some nice formatting\n\t    my $sigstring=$self->{sig};\n\t    $sigstring =~ s/\\n//g;\n\t    $sigstring =~ s/(\\S{45})/$1\\n\\t\\t\\t/g;\n\t    $rdatastr .=  \"\\n\\t\\t\\t\".$sigstring;\n\t    $rdatastr .= \" )\";\n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\n\nsub rr_rdata_without_sigbin {\n    my ($self) = shift;\n    my $rdata = \"\";\n\n    if (exists $self->{\"typecovered\"}) {\n\t$rdata  = pack(\"n\",_string2type($self->{typecovered}));\n\t$rdata .= pack(\"C\",$self->algorithm);\n\t$rdata .= pack(\"C\",$self->{\"labels\"});\n\t$rdata .= pack(\"N\",$self->{\"orgttl\"});\n\n\t$self->{\"sigexpiration\"} =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/;\n\t$rdata .= pack(\"N\",timegm ($6, $5, $4, $3, $2-1, $1-1900));\n\n\t$self->{\"siginception\"} =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/;\n\t$rdata .= pack(\"N\",timegm ($6, $5, $4, $3, $2-1, $1-1900));\n\t$rdata .= pack(\"n\",$self->{\"keytag\"});\n\t# Since we will need canonical and expanded names while checking \n\t# we do not use the packet->dn_comp here but use RFC1035 p10.\n\t{   my @dname= split /\\./,lc($self->{\"signame\"}.\".\");  #/ emacs fontlock\n\t    for (my $i=0;$i<@dname;$i++){\n\t\t$rdata .= pack (\"C\",length $dname[$i] );\n\t\t$rdata .= $dname[$i] ;\n\n\t    }\n\t    $rdata .= pack (\"C\",\"0\");\n\t}\n    }\n    return $rdata;\n\n}\n\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n    my $rdata = \"\";\n    if (exists $self->{\"typecovered\"}) {\n\t$rdata=$self->rr_rdata_without_sigbin;\n\t\n\tif ($self->{\"sig\"} ne \"NOTYETCALCULATED\") {\n            $self->{\"sigbin\"}= decode_base64($self->{\"sig\"}) unless defined $self->{\"sigbin\"} ;\n\t    $rdata .= $self->{\"sigbin\"};\n\t}else{\n\t    die \"RRSIGs should not be used for SIG0 type signatures, use Net::DNS::RR::SIG\";\n\t}\n    }\n    return $rdata;\n}\n\nsub create {\n    my ($class,  $datarrset, $priv_key, %args) = @_;\n\n\n    # This method returns a sigrr with the signature over the\n    # datatrrset (an array of RRs) made with the private key stored in\n    # the $key_file.\n\n    my $self;\n    $self->{\"sigerrstr\"}=\"---- Unknown Error Condition ------\";\n    my $Private;\n\n\n    if (UNIVERSAL::isa($priv_key,\"Net::DNS::SEC::Private\")){\n\t$Private=$priv_key;\n    }else{\n\t$Private=Net::DNS::SEC::Private->new($priv_key);\n    }\n\n    unless (UNIVERSAL::isa($Private,\"Net::DNS::SEC::Private\")){\n\t$self->{\"sigerrstr\"}= \"Create did not manage to parse a private key into a Net::DNS::SEC::Private object \";\n\treturn (0);\n\t    \n    }\n    $self->{\"algorithm\"}=Net::DNS::SEC->algorithm($Private->algorithm);\n    $self->{\"keytag\"}=$Private->keytag;\n    $self->{\"signame\"}=Net::DNS::stripdot($Private->signame);\n   \n\n    die \"Argument is not a reference to an array, are you trying to create a SIG0 using RRSIG?\" if ! ref ($datarrset);\n\n\n    $self->{\"rr_rdata_recursion\"}=0;\n\n    # Start with seting up the data in the packet we can get our hands on...\n\n\n    $self->{\"name\"}=$datarrset->[0]->name;\n\n    $self->{\"type\"}=\"RRSIG\";\n    $self->{\"class\"}=\"IN\";\n\n\n    if (defined ($args{ttl})){\n\tprint \"Setting TTL to \".  $args{\"ttl\"} . \"\\n\" if $debug;\n\t$self->{\"ttl\"}= $args{\"ttl\"};\n    }else{\n\t$self->{\"ttl\"}= $datarrset->[0]->ttl;\n    }\n\n    $self->{\"typecovered\"}=$datarrset->[0]->type;  #Sanity checks elsewhere\n\n\n\n    if (defined ($args{response})){\n\t$self->{\"response\"}=$args{\"response\"};\n    }\n\n    if (defined($args{\"sigin\"})){\n\t_checktimeformat($args{\"sigin\"});\n\tprint \"\\nSetting siginception to \" . $args{\"sigin\"} if $debug;\n\t$self->{\"siginception\"} =$args{\"sigin\"};\n    }else{\n\tmy @inct=gmtime(time);\n\tmy $currentdatestring=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t $inct[0]);\t\n\t$self->{\"siginception\"} = $currentdatestring ;\n    }\n\n    # This will fail if the dateformat is not correct...\n    $self->{\"siginception\"} =~ \n\t/(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ ;\n    my $siginc_time=timegm ($6, $5, $4, $3, $2-1, $1-1900);\n\n    if (defined($args{\"sigval\"})){ #sigexpiration set by siginception + sigval\n\tmy @inct;\n\n\n\t# treat sigval as days\n\t@inct=gmtime($siginc_time+$args{\"sigval\"}*24*3600 );  \n\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t   $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t   $inct[0]);\t\n    }elsif ($args{\"sigex\"}) { #sigexpiration set by the argument\n\t_checktimeformat($args{\"sigex\"});\n\n\tif ( $self->{\"siginception\"} > $args{\"sigex\"} ){\n\t    croak \"Signature can only expire after it has been incepted (\".\n\t\t$args{\"sigex\"} . \"<\" . $self->{\"siginception\"} .\n\t\t    \")\";\n\t}\n\tpri", 8192) = 8192
09:01:57.270782 stat("modules/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.270835 stat("modules/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.270884 stat("modules/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.270932 stat("modules/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.270981 stat("/etc/perl/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271031 stat("/etc/perl/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.271080 stat("/usr/local/lib/perl/5.14.2/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271133 stat("/usr/local/lib/perl/5.14.2/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.271183 stat("/usr/local/share/perl/5.14.2/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271233 stat("/usr/local/share/perl/5.14.2/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.271284 stat("/usr/lib/perl5/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271334 stat("/usr/lib/perl5/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.271385 stat("/usr/share/perl5/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271436 stat("/usr/share/perl5/Data/Dumper.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.271492 stat("/usr/lib/perl/5.14/Data/Dumper.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.271546 stat("/usr/lib/perl/5.14/Data/Dumper.pm", {st_mode=S_IFREG|0644, st_size=40659, ...}) = 0
09:01:57.271605 open("/usr/lib/perl/5.14/Data/Dumper.pm", O_RDONLY) = 15
09:01:57.271660 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.271707 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.271766 read(15, "#\n# Data/Dumper.pm\n#\n# convert perl data structures into perl syntax suitable for both printing\n# and eval\n#\n# Documentation at the __END__\n#\n\npackage Data::Dumper;\n\n$VERSION = '2.130_02'; # Don't forget to set version and release date in POD!\n\n#$| = 1;\n\nuse 5.006_001;\nrequire Exporter;\nrequire overload;\n\nuse Carp;\n\nBEGIN {\n    @ISA = qw(Exporter);\n    @EXPORT = qw(Dumper);\n    @EXPORT_OK = qw(DumperX);\n\n    # if run under miniperl, or otherwise lacking dynamic loading,\n    # XSLoader should be attempted to load, or the pure perl flag\n    # toggled on load failure.\n    eval {\n\trequire XSLoader;\n    };\n    $Useperl = 1 if $@;\n}\n\nXSLoader::load( 'Data::Dumper' ) unless $Useperl;\n\n# module vars and their defaults\n$Indent     = 2         unless defined $Indent;\n$Purity     = 0         unless defined $Purity;\n$Pad        = \"\"        unless defined $Pad;\n$Varname    = \"VAR\"     unless defined $Varname;\n$Useqq      = 0         unless defined $Useqq;\n$Terse      = 0         unless defined $Terse;\n$Freezer    = \"\"        unless defined $Freezer;\n$Toaster    = \"\"        unless defined $Toaster;\n$Deepcopy   = 0         unless defined $Deepcopy;\n$Quotekeys  = 1         unless defined $Quotekeys;\n$Bless      = \"bless\"   unless defined $Bless;\n#$Expdepth   = 0         unless defined $Expdepth;\n$Maxdepth   = 0         unless defined $Maxdepth;\n$Pair       = ' => '    unless defined $Pair;\n$Useperl    = 0         unless defined $Useperl;\n$Sortkeys   = 0         unless defined $Sortkeys;\n$Deparse    = 0         unless defined $Deparse;\n$Maxrecurse = 1000      unless defined $Maxrecurse;\n\n#\n# expects an arrayref of values to be dumped.\n# can optionally pass an arrayref of names for the values.\n# names must have leading $ sign stripped. begin the name with *\n# to cause output of arrays and hashes rather than refs.\n#\nsub new {\n  my($c, $v, $n) = @_;\n\n  croak \"Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])\" \n    unless (defined($v) && (ref($v) eq 'ARRAY'));\n  $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));\n\n  my($s) = { \n             level      => 0,           # current recursive depth\n\t     indent     => $Indent,     # various styles of indenting\n\t     pad\t=> $Pad,        # all lines prefixed by this string\n\t     xpad       => \"\",          # padding-per-level\n\t     apad       => \"\",          # added padding for hash keys n such\n\t     sep        => \"\",          # list separator\n\t     pair\t=> $Pair,\t# hash key/value separator: defaults to ' => '\n\t     seen       => {},          # local (nested) refs (id => [name, val])\n\t     todump     => $v,          # values to dump []\n\t     names      => $n,          # optional names for values []\n\t     varname    => $Varname,    # prefix to use for tagging nameless ones\n             purity     => $Purity,     # degree to which output is evalable\n             useqq \t=> $Useqq,      # use \"\" for strings (backslashitis ensues)\n             terse \t=> $Terse,      # avoid name output (where feasible)\n             freezer\t=> $Freezer,    # name of Freezer method for objects\n             toaster\t=> $Toaster,    # name of method to revive objects\n             deepcopy\t=> $Deepcopy,   # dont cross-ref, except to stop recursion\n             quotekeys\t=> $Quotekeys,  # quote hash keys\n             'bless'\t=> $Bless,\t# keyword to use for \"bless\"\n#\t     expdepth   => $Expdepth,   # cutoff depth for explicit dumping\n\t     maxdepth\t=> $Maxdepth,   # depth beyond which we give up\n         maxrecurse => $Maxrecurse, # depth beyond which we abort\n\t     useperl    => $Useperl,    # use the pure Perl implementation\n\t     sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys\n\t     deparse\t=> $Deparse,\t# use B::Deparse for coderefs\n\t   };\n\n  if ($Indent > 0) {\n    $s->{xpad} = \"  \";\n    $s->{sep} = \"\\n\";\n  }\n  return bless($s, $c);\n}\n\nif ($] >= 5.008) {\n  # Packed numeric addresses take less memory. Plus pack is faster than sprintf\n  *init_refaddr_format = sub {};\n\n  *format_refaddr  = sub {\n    require Scalar::Util;\n    pack \"J\", Scalar::Util::refaddr(shift);\n  };\n} else {\n  *init_refaddr_format = sub {\n    require Config;\n    my $f = $Config::Config{uvxformat};\n    $f =~ tr/\"//d;\n    our $refaddr_format = \"0x%\" . $f;\n  };\n\n  *format_refaddr = sub {\n    require Scalar::Util;\n    sprintf our $refaddr_format, Scalar::Util::refaddr(shift);\n  }\n}\n\n#\n# add-to or query the table of already seen references\n#\nsub Seen {\n  my($s, $g) = @_;\n  if (defined($g) && (ref($g) eq 'HASH'))  {\n    init_refaddr_format();\n    my($k, $v, $id);\n    while (($k, $v) = each %$g) {\n      if (defined $v and ref $v) {\n\t$id = format_refaddr($v);\n\tif ($k =~ /^[*](.*)$/) {\n\t  $k = (ref $v eq 'ARRAY') ? ( \"\\\\\\@\" . $1 ) :\n\t       (ref $v eq 'HASH')  ? ( \"\\\\\\%\" . $1 ) :\n\t       (ref $v eq 'CODE')  ? ( \"\\\\\\&\" . $1 ) :\n\t\t\t\t     (   \"\\$\" . $1 ) ;\n\t}\n\telsif ($k !~ /^\\$/) {\n\t  $k = \"\\$\" . $k;\n\t}\n\t$s->{seen}{$id} = [$k, $v];\n      }\n      else {\n\tcarp \"Only refs supported, ignoring non-ref item \\$$k\";\n      }\n    }\n    return $s;\n  }\n  else {\n    return map { @$_ } values %{$s->{seen}};\n  }\n}\n\n#\n# set or query the values to be dumped\n#\nsub Values {\n  my($s, $v) = @_;\n  if (defined($v) && (ref($v) eq 'ARRAY'))  {\n    $s->{todump} = [@$v];        # make a copy\n    return $s;\n  }\n  else {\n    return @{$s->{todump}};\n  }\n}\n\n#\n# set or query the names of the values to be dumped\n#\nsub Names {\n  my($s, $n) = @_;\n  if (defined($n) && (ref($n) eq 'ARRAY'))  {\n    $s->{names} = [@$n];         # make a copy\n    return $s;\n  }\n  else {\n    return @{$s->{names}};\n  }\n}\n\nsub DESTROY {}\n\nsub Dump {\n    return &Dumpxs\n\tunless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl}) ||\n\t       $Data::Dumper::Useqq   || (ref($_[0]) && $_[0]->{useqq}) ||\n\t       $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse});\n    return &Dumpperl;\n}\n\n#\n# dump the refs in the current dumper object.\n# expects same args as new() if called via package name.\n#\nsub Dumpperl {\n  my($s) = shift;\n  my(@out, $val, $name);\n  my($i) = 0;\n  local(@post);\n  init_refaddr_format();\n\n  $s = $s->new(@_) unless ref $s;\n\n  for $val (@{$s->{todump}}) {\n    my $out = \"\";\n    @post = ();\n    $name = $s->{names}[$i++];\n    if (defined $name) {\n      if ($name =~ /^[*](.*)$/) {\n\tif (defined $val) {\n\t  $name = (ref $val eq 'ARRAY') ? ( \"\\@\" . $1 ) :\n\t\t  (ref $val eq 'HASH')  ? ( \"\\%\" . $1 ) :\n\t\t  (ref $val eq 'CODE')  ? ( \"\\*\" . $1 ) :\n\t\t\t\t\t  ( \"\\$\" . $1 ) ;\n\t}\n\telse {\n\t  $name = \"\\$\" . $1;\n\t}\n      }\n      elsif ($name !~ /^\\$/) {\n\t$name = \"\\$\" . $name;\n      }\n    }\n    else {\n      $name = \"\\$\" . $s->{varname} . $i;\n    }\n\n    my $valstr;\n    {\n      local($s->{apad}) = $s->{apad};\n      $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};\n      $valstr = $s->_dump($val, $name);\n    }\n\n    $valstr = \"$name = \" . $valstr . ';' if @post or !$s->{terse};\n    $out .= $s->{pad} . $valstr . $s->{sep};\n    $out .= $s->{pad} . join(';' . $s->{sep} . $s->{pad}, @post) \n      . ';' . $s->{sep} if @post;\n\n    push @out, $out;\n  }\n  return wantarray ? @out : join('', @out);\n}\n\n# wrap string in single quotes (escaping if needed)\nsub _quote {\n    my $val = shift;\n    $val =~ s/([\\\\\\'])/\\\\$1/g;\n    return  \"'\" . $val .  \"'\";\n}\n\n#\n# twist, toil and turn;\n# and recurse, of course.\n# sometimes sordidly;\n# and curse if no recourse.\n#\nsub _dump {\n  my($s, $val, $name) = @_;\n  my($sname);\n  my($out, $realpack, $realtype, $type, $ipad, $id, $blesspad);\n\n  $type = ref $val;\n  $out = \"\";\n\n  if ($type) {\n\n    # Call the freezer method if it's specified and the object has the\n    # method.  Trap errors and warn() instead of die()ing, like the XS\n    # implementation.\n    my $freezer = $s->{freezer};\n    if ($freezer and UNIVERSAL::can($val, $freezer)) {\n      eval { $val->$freezer() };\n      warn \"WARNING(Freezer method call failed): $@\" if $@;\n    }\n\n    require Scalar::Util;\n    $realpack = Scalar::Util::blessed($val);\n    $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;\n    $id = format_refaddr($val);\n\n    # if it has a name, we need to either look it up, or keep a tab\n    # on it so we know when we hit it later\n    if (defined($name) and length($name)) {\n      # keep a tab on it so that we don", 8192) = 8192
09:01:57.272161 brk(0x14de000)          = 0x14de000
09:01:57.273011 brk(0x14ff000)          = 0x14ff000
09:01:57.273134 read(15, "t fall into recursive pit\n      if (exists $s->{seen}{$id}) {\n#\tif ($s->{expdepth} < $s->{level}) {\n\t  if ($s->{purity} and $s->{level} > 0) {\n\t    $out = ($realtype eq 'HASH')  ? '{}' :\n\t      ($realtype eq 'ARRAY') ? '[]' :\n\t\t'do{my $o}' ;\n\t    push @post, $name . \" = \" . $s->{seen}{$id}[0];\n\t  }\n\t  else {\n\t    $out = $s->{seen}{$id}[0];\n\t    if ($name =~ /^([\\@\\%])/) {\n\t      my $start = $1;\n\t      if ($out =~ /^\\\\$start/) {\n\t\t$out = substr($out, 1);\n\t      }\n\t      else {\n\t\t$out = $start . '{' . $out . '}';\n\t      }\n\t    }\n          }\n\t  return $out;\n#        }\n      }\n      else {\n        # store our name\n        $s->{seen}{$id} = [ (($name =~ /^[@%]/)     ? ('\\\\' . $name ) :\n\t\t\t     ($realtype eq 'CODE' and\n\t\t\t      $name =~ /^[*](.*)$/) ? ('\\\\&' . $1 )   :\n\t\t\t     $name          ),\n\t\t\t    $val ];\n      }\n    }\n    my $no_bless = 0; \n    my $is_regex = 0;\n    if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {\n        $is_regex = 1;\n        $no_bless = $realpack eq 'Regexp';\n    }\n\n    # If purity is not set and maxdepth is set, then check depth: \n    # if we have reached maximum depth, return the string\n    # representation of the thing we are currently examining\n    # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)'). \n    if (!$s->{purity}\n\tand $s->{maxdepth} > 0\n\tand $s->{level} >= $s->{maxdepth})\n    {\n      return qq['$val'];\n    }\n\n    # avoid recursing infinitely [perl #122111]\n    if ($s->{maxrecurse} > 0\n        and $s->{level} >= $s->{maxrecurse}) {\n        die \"Recursion limit of $s->{maxrecurse} exceeded\";\n    }\n\n    # we have a blessed ref\n    if ($realpack and !$no_bless) {\n      $out = $s->{'bless'} . '( ';\n      $blesspad = $s->{apad};\n      $s->{apad} .= '       ' if ($s->{indent} >= 2);\n    }\n\n    $s->{level}++;\n    $ipad = $s->{xpad} x $s->{level};\n\n    if ($is_regex) {\n        my $pat;\n        # This really sucks, re:regexp_pattern is in ext/re/re.xs and not in \n        # universal.c, and even worse we cant just require that re to be loaded\n        # we *have* to use() it. \n        # We should probably move it to universal.c for 5.10.1 and fix this.\n        # Currently we only use re::regexp_pattern when the re is blessed into another\n        # package. This has the disadvantage of meaning that a DD dump won't round trip\n        # as the pattern will be repeatedly wrapped with the same modifiers.\n        # This is an aesthetic issue so we will leave it for now, but we could use\n        # regexp_pattern() in list context to get the modifiers separately.\n        # But since this means loading the full debugging engine in process we wont\n        # bother unless its necessary for accuracy.\n        if (($realpack ne 'Regexp') && defined(*re::regexp_pattern{CODE})) {\n            $pat = re::regexp_pattern($val);\n        } else {\n            $pat = \"$val\";\n        }\n        $pat =~ s,/,\\\\/,g;\n        $out .= \"qr/$pat/\";\n    }\n    elsif ($realtype eq 'SCALAR' || $realtype eq 'REF') {\n      if ($realpack) {\n\t$out .= 'do{\\\\(my $o = ' . $s->_dump($$val, \"\\${$name}\") . ')}';\n      }\n      else {\n\t$out .= '\\\\' . $s->_dump($$val, \"\\${$name}\");\n      }\n    }\n    elsif ($realtype eq 'GLOB') {\n\t$out .= '\\\\' . $s->_dump($$val, \"*{$name}\");\n    }\n    elsif ($realtype eq 'ARRAY') {\n      my($pad, $mname);\n      my($i) = 0;\n      $out .= ($name =~ /^\\@/) ? '(' : '[';\n      $pad = $s->{sep} . $s->{pad} . $s->{apad};\n      ($name =~ /^\\@(.*)$/) ? ($mname = \"\\$\" . $1) : \n\t# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}\n\t($name =~ /^\\\\?[\\%\\@\\*\\$][^{].*[]}]$/) ? ($mname = $name) :\n\t  ($mname = $name . '->');\n      $mname .= '->' if $mname =~ /^\\*.+\\{[A-Z]+\\}$/;\n      for my $v (@$val) {\n\t$sname = $mname . '[' . $i . ']';\n\t$out .= $pad . $ipad . '#' . $i if $s->{indent} >= 3;\n\t$out .= $pad . $ipad . $s->_dump($v, $sname);\n\t$out .= \",\" if $i++ < $#$val;\n      }\n      $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;\n      $out .= ($name =~ /^\\@/) ? ')' : ']';\n    }\n    elsif ($realtype eq 'HASH') {\n      my($k, $v, $pad, $lpad, $mname, $pair);\n      $out .= ($name =~ /^\\%/) ? '(' : '{';\n      $pad = $s->{sep} . $s->{pad} . $s->{apad};\n      $lpad = $s->{apad};\n      $pair = $s->{pair};\n      ($name =~ /^\\%(.*)$/) ? ($mname = \"\\$\" . $1) :\n\t# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}\n\t($name =~ /^\\\\?[\\%\\@\\*\\$][^{].*[]}]$/) ? ($mname = $name) :\n\t  ($mname = $name . '->');\n      $mname .= '->' if $mname =~ /^\\*.+\\{[A-Z]+\\}$/;\n      my ($sortkeys, $keys, $key) = (\"$s->{sortkeys}\");\n      if ($sortkeys) {\n\tif (ref($s->{sortkeys}) eq 'CODE') {\n\t  $keys = $s->{sortkeys}($val);\n\t  unless (ref($keys) eq 'ARRAY') {\n\t    carp \"Sortkeys subroutine did not return ARRAYREF\";\n\t    $keys = [];\n\t  }\n\t}\n\telse {\n\t  $keys = [ sort keys %$val ];\n\t}\n      }\n\n      # Ensure hash iterator is reset\n      keys(%$val);\n\n      while (($k, $v) = ! $sortkeys ? (each %$val) :\n\t     @$keys ? ($key = shift(@$keys), $val->{$key}) :\n\t     () ) \n      {\n\tmy $nk = $s->_dump($k, \"\");\n\t$nk = $1 if !$s->{quotekeys} and $nk =~ /^[\\\"\\']([A-Za-z_]\\w*)[\\\"\\']$/;\n\t$sname = $mname . '{' . $nk . '}';\n\t$out .= $pad . $ipad . $nk . $pair;\n\n\t# temporarily alter apad\n\t$s->{apad} .= (\" \" x (length($nk) + 4)) if $s->{indent} >= 2;\n\t$out .= $s->_dump($val->{$k}, $sname) . \",\";\n\t$s->{apad} = $lpad if $s->{indent} >= 2;\n      }\n      if (substr($out, -1) eq ',') {\n\tchop $out;\n\t$out .= $pad . ($s->{xpad} x ($s->{level} - 1));\n      }\n      $out .= ($name =~ /^\\%/) ? ')' : '}';\n    }\n    elsif ($realtype eq 'CODE') {\n      if ($s->{deparse}) {\n\trequire B::Deparse;\n\tmy $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);\n\t$pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);\n\t$sub    =~ s/\\n/$pad/gse;\n\t$out   .=  $sub;\n      } else {\n        $out .= 'sub { \"DUMMY\" }';\n        carp \"Encountered CODE ref, using dummy placeholder\" if $s->{purity};\n      }\n    }\n    else {\n      croak \"Can\\'t handle $realtype type.\";\n    }\n    \n    if ($realpack and !$no_bless) { # we have a blessed ref\n      $out .= ', ' . _quote($realpack) . ' )';\n      $out .= '->' . $s->{toaster} . '()'  if $s->{toaster} ne '';\n      $s->{apad} = $blesspad;\n    }\n    $s->{level}--;\n\n  }\n  else {                                 # simple scalar\n\n    my $ref = \\$_[1];\n    # first, catalog the scalar\n    if ($name ne '') {\n      $id = format_refaddr($ref);\n      if (exists $s->{seen}{$id}) {\n        if ($s->{seen}{$id}[2]) {\n\t  $out = $s->{seen}{$id}[0];\n\t  #warn \"[<$out]\\n\";\n\t  return \"\\${$out}\";\n\t}\n      }\n      else {\n\t#warn \"[>\\\\$name]\\n\";\n\t$s->{seen}{$id} = [\"\\\\$name\", $ref];\n      }\n    }\n    if (ref($ref) eq 'GLOB' or \"$ref\" =~ /=GLOB\\([^()]+\\)$/) {  # glob\n      my $name = substr($val, 1);\n      if ($name =~ /^[A-Za-z_][\\w:]*$/) {\n\t$name =~ s/^main::/::/;\n\t$sname = $name;\n      }\n      else {\n\t$sname = $s->_dump($name, \"\");\n\t$sname = '{' . $sname . '}';\n      }\n      if ($s->{purity}) {\n\tmy $k;\n\tlocal ($s->{level}) = 0;\n\tfor $k (qw(SCALAR ARRAY HASH)) {\n\t  my $gval = *$val{$k};\n\t  next unless defined $gval;\n\t  next if $k eq \"SCALAR\" && ! defined $$gval;  # always there\n\n\t  # _dump can push into @post, so we hold our place using $postlen\n\t  my $postlen = scalar @post;\n\t  $post[$postlen] = \"\\*$sname = \";\n\t  local ($s->{apad}) = \" \" x length($post[$postlen]) if $s->{indent} >= 2;\n\t  $post[$postlen] .= $s->_dump($gval, \"\\*$sname\\{$k\\}\");\n\t}\n      }\n      $out .= '*' . $sname;\n    }\n    elsif (!defined($val)) {\n      $out .= \"undef\";\n    }\n    elsif ($val =~ /^(?:0|-?[1-9]\\d{0,8})\\z/) { # safe decimal number\n      $out .= $val;\n    }\n    else {\t\t\t\t # string\n      if ($s->{useqq} or $val =~ tr/\\0-\\377//c) {\n        # Fall back to qq if there's Unicode\n\t$out .= qquote($val, $s->{useqq});\n      }\n      else {\n        $out .= _quote($val);\n      }\n    }\n  }\n  if ($id) {\n    # if we made it this far, $id was added to seen list at current\n    # level, so remove it to get deep copies\n    if ($s->{deepcopy}) {\n      delete($s->{seen}{$id});\n    }\n    elsif ($name) {\n      $s->{seen}{$id}[2] = 1;\n    }\n  }\n  return $out;\n}\n  \n#\n# non-OO style of earlier version\n#\nsub Dumper {\n  return Data::Dumper->Dump([@_]);\n}\n\n# compat stub\nsub DumperX {\n  return Dat", 8192) = 8192
09:01:57.274243 brk(0x1520000)          = 0x1520000
09:01:57.274622 read(15, "a::Dumper->Dumpxs([@_], []);\n}\n\nsub Dumpf { return Data::Dumper->Dump(@_) }\n\nsub Dumpp { print Data::Dumper->Dump(@_) }\n\n#\n# reset the \"seen\" cache \n#\nsub Reset {\n  my($s) = shift;\n  $s->{seen} = {};\n  return $s;\n}\n\nsub Indent {\n  my($s, $v) = @_;\n  if (defined($v)) {\n    if ($v == 0) {\n      $s->{xpad} = \"\";\n      $s->{sep} = \"\";\n    }\n    else {\n      $s->{xpad} = \"  \";\n      $s->{sep} = \"\\n\";\n    }\n    $s->{indent} = $v;\n    return $s;\n  }\n  else {\n    return $s->{indent};\n  }\n}\n\nsub Pair {\n    my($s, $v) = @_;\n    defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};\n}\n\nsub Pad {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};\n}\n\nsub Varname {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};\n}\n\nsub Purity {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};\n}\n\nsub Useqq {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};\n}\n\nsub Terse {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};\n}\n\nsub Freezer {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};\n}\n\nsub Toaster {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};\n}\n\nsub Deepcopy {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};\n}\n\nsub Quotekeys {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};\n}\n\nsub Bless {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};\n}\n\nsub Maxdepth {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};\n}\n\nsub Maxrecurse {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'maxrecurse'} = $v), return $s) : $s->{'maxrecurse'};\n}\n\nsub Useperl {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};\n}\n\nsub Sortkeys {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};\n}\n\nsub Deparse {\n  my($s, $v) = @_;\n  defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};\n}\n\n# used by qquote below\nmy %esc = (  \n    \"\\a\" => \"\\\\a\",\n    \"\\b\" => \"\\\\b\",\n    \"\\t\" => \"\\\\t\",\n    \"\\n\" => \"\\\\n\",\n    \"\\f\" => \"\\\\f\",\n    \"\\r\" => \"\\\\r\",\n    \"\\e\" => \"\\\\e\",\n);\n\n# put a string value in double quotes\nsub qquote {\n  local($_) = shift;\n  s/([\\\\\\\"\\@\\$])/\\\\$1/g;\n  my $bytes; { use bytes; $bytes = length }\n  s/([^\\x00-\\x7f])/'\\x{'.sprintf(\"%x\",ord($1)).'}'/ge if $bytes > length;\n  return qq(\"$_\") unless \n    /[^ !\"\\#\\$%&'()*+,\\-.\\/0-9:;<=>?\\@A-Z[\\\\\\]^_`a-z{|}~]/;  # fast exit\n\n  my $high = shift || \"\";\n  s/([\\a\\b\\t\\n\\f\\r\\e])/$esc{$1}/g;\n\n  if (ord('^')==94)  { # ascii\n    # no need for 3 digits in escape for these\n    s/([\\0-\\037])(?!\\d)/'\\\\'.sprintf('%o',ord($1))/eg;\n    s/([\\0-\\037\\177])/'\\\\'.sprintf('%03o',ord($1))/eg;\n    # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--\n    if ($high eq \"iso8859\") {\n      s/([\\200-\\240])/'\\\\'.sprintf('%o',ord($1))/eg;\n    } elsif ($high eq \"utf8\") {\n#     use utf8;\n#     $str =~ s/([^\\040-\\176])/sprintf \"\\\\x{%04x}\", ord($1)/ge;\n    } elsif ($high eq \"8bit\") {\n        # leave it as it is\n    } else {\n      s/([\\200-\\377])/'\\\\'.sprintf('%03o',ord($1))/eg;\n      s/([^\\040-\\176])/sprintf \"\\\\x{%04x}\", ord($1)/ge;\n    }\n  }\n  else { # ebcdic\n      s{([^ !\"\\#\\$%&'()*+,\\-.\\/0-9:;<=>?\\@A-Z[\\\\\\]^_`a-z{|}~])(?!\\d)}\n       {my $v = ord($1); '\\\\'.sprintf(($v <= 037 ? '%o' : '%03o'), $v)}eg;\n      s{([^ !\"\\#\\$%&'()*+,\\-.\\/0-9:;<=>?\\@A-Z[\\\\\\]^_`a-z{|}~])}\n       {'\\\\'.sprintf('%03o',ord($1))}eg;\n  }\n\n  return qq(\"$_\");\n}\n\n# helper sub to sort hash keys in Perl < 5.8.0 where we don't have\n# access to sortsv() from XS\nsub _sortkeys { [ sort keys %{$_[0]} ] }\n\n1;\n__END__\n\n=head1 NAME\n\nData::Dumper - stringified perl data structures, suitable for both printing and C<eval>\n\n=head1 SYNOPSIS\n\n    use Data::Dumper;\n\n    # simple procedural interface\n    print Dumper($foo, $bar);\n\n    # extended usage with names\n    print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);\n\n    # configuration variables\n    {\n      local $Data::Dumper::Purity = 1;\n      eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);\n    }\n\n    # OO usage\n    $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);\n       ...\n    print $d->Dump;\n       ...\n    $d->Purity(1)->Terse(1)->Deepcopy(1);\n    eval $d->Dump;\n\n\n=head1 DESCRIPTION\n\nGiven a list of scalars or reference variables, writes out their contents in\nperl syntax. The references can also be objects.  The content of each\nvariable is output in a single Perl statement.  Handles self-referential\nstructures correctly.\n\nThe return value can be C<eval>ed to get back an identical copy of the\noriginal reference structure.\n\nAny references that are the same as one of those passed in will be named\nC<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references\nto substructures within C<$VAR>I<n> will be appropriately labeled using arrow\nnotation.  You can specify names for individual values to be dumped if you\nuse the C<Dump()> method, or you can change the default C<$VAR> prefix to\nsomething else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>\nbelow.\n\nThe default output of self-referential structures can be C<eval>ed, but the\nnested references to C<$VAR>I<n> will be undefined, since a recursive\nstructure cannot be constructed using one Perl statement.  You should set the\nC<Purity> flag to 1 to get additional statements that will correctly fill in\nthese references.  Moreover, if C<eval>ed when strictures are in effect,\nyou need to ensure that any variables it accesses are previously declared.\n\nIn the extended usage form, the references to be dumped can be given\nuser-specified names.  If a name begins with a C<*>, the output will \ndescribe the dereferenced type of the supplied reference for hashes and\narrays, and coderefs.  Output of names will be avoided where possible if\nthe C<Terse> flag is set.\n\nIn many cases, methods that are used to set the internal state of the\nobject will return the object itself, so method calls can be conveniently\nchained together.\n\nSeveral styles of output are possible, all controlled by setting\nthe C<Indent> flag.  See L<Configuration Variables or Methods> below \nfor details.\n\n\n=head2 Methods\n\n=over 4\n\n=item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)\n\nReturns a newly created C<Data::Dumper> object.  The first argument is an\nanonymous array of values to be dumped.  The optional second argument is an\nanonymous array of names for the values.  The names need not have a leading\nC<$> sign, and must be comprised of alphanumeric characters.  You can begin\na name with a C<*> to specify that the dereferenced type must be dumped\ninstead of the reference itself, for ARRAY and HASH references.\n\nThe prefix specified by C<$Data::Dumper::Varname> will be used with a\nnumeric suffix if the name for a value is undefined.\n\nData::Dumper will catalog all references encountered while dumping the\nvalues. Cross-references (in the form of names of substructures in perl\nsyntax) will be inserted at all possible points, preserving any structural\ninterdependencies in the original set of values.  Structure traversal is\ndepth-first,  and proceeds in order from the first supplied value to\nthe last.\n\n=item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)\n\nReturns the stringified form of the values stored in the object (preserving\nthe order in which they were supplied to C<new>), subject to the\nconfiguration options below.  In a list context, it returns a list\nof strings corresponding to the supplied values.\n\nThe second form, for convenience, simply calls the C<new> method on its\narguments before dumping the object immediately.\n\n=item I<$OBJ>->Seen(I<[HASHREF]>)\n\nQueries or adds to the internal table of already encountered references.\nYou must use C<Reset> to explicitly clear the table if needed.  Such\nreferences are not dumped; instead, their names are inserted wherever they\nare encountered subsequently.  This is useful especially for properly\ndumping subroutine references.\n\nExpects an anonymous hash of name => value pairs.  Same ", 8192) = 8192
09:01:57.275549 brk(0x1541000)          = 0x1541000
09:01:57.275681 lseek(15, 20179, SEEK_SET) = 20179
09:01:57.275728 lseek(15, 0, SEEK_CUR)  = 20179
09:01:57.275773 close(15)               = 0
09:01:57.275872 stat("/usr/lib/perl/5.14/auto/Data/Dumper/Dumper.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.275934 stat("/usr/lib/perl/5.14/auto/Data/Dumper/Dumper.so", {st_mode=S_IFREG|0644, st_size=35344, ...}) = 0
09:01:57.275995 stat("/usr/lib/perl/5.14/auto/Data/Dumper/Dumper.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.276061 open("/usr/lib/perl/5.14/auto/Data/Dumper/Dumper.so", O_RDONLY) = 15
09:01:57.276116 read(15, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\35\0\0\0\0\0\0@\0\0\0\0\0\0\0\20\203\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\34\0\33\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\fu\0\0\0\0\0\0\fu\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\220}\0\0\0\0\0\0\220} \0\0\0\0\0\220} \0\0\0\0\0x\4\0\0\0\0\0\0\200\4\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\310}\0\0\0\0\0\0\310} \0\0\0\0\0\310} \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\10s\0\0\0\0\0\0\10s\0\0\0\0\0\0\10s\0\0\0\0\0\0L\0\0\0\0\0\0\0L\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\220}\0\0\0\0\0\0\220} \0\0\0\0\0\220} \0\0\0\0\0p\2\0\0\0\0\0\0p\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0M\7\213\217v\355\r\202`\310\250\213\371\204\303\32\37\340?~\0\0\0\0C\0\0\0Q\0\0\0\"\0\0\0003\0\0\0B\0\0\0\0\0\0\0?\0\0\0\v\0\0\0;\0\0\0#\0\0\0.\0\0\0\0\0\0\0<\0\0\0I\0\0\0006\0\0\0\0\0\0\0(\0\0\0E\0\0\0\7\0\0\0'\0\0\0\21\0\0\0G\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0N\0\0\0\0\0\0\0\0\0\0\0001\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0*\0\0\0\36\0\0\0D\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\0\0\0-\0\0\0\16\0\0\0@\0\0\0007\0\0\0009\0\0\0\0\0\0\0)\0\0\0:\0\0\0 \0\0\0\f\0\0\0004\0\0\0\0\0\0\0002\0\0\0\0\0\0\0=\0\0\0\20\0\0\0&\0\0\0H\0\0\0\0\0\0\0\31\0\0\0L\0\0\0%\0\0\0A\0\0\0\0\0\0\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.276254 fstat(15, {st_mode=S_IFREG|0644, st_size=35344, ...}) = 0
09:01:57.276311 mmap(NULL, 2130448, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 15, 0) = 0x7f74329c3000
09:01:57.276361 mprotect(0x7f74329cb000, 2093056, PROT_NONE) = 0
09:01:57.276410 mmap(0x7f7432bca000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 15, 0x7000) = 0x7f7432bca000
09:01:57.276467 close(15)               = 0
09:01:57.276527 mprotect(0x7f7432bca000, 4096, PROT_READ) = 0
09:01:57.277681 read(14, "nt \"\\nSetting sigexpiration to \" . $args{\"sigex\"} if $debug;\n\t$self->{\"sigexpiration\"}=$args{\"sigex\"} ;\n\n    }else{ \n\tmy @inct;\n\n\t# Take the 30 days default for sigexpiration \t\n\t@inct=gmtime($siginc_time+30*24*3600 );  \n\n\t$self->{\"sigexpiration\"}= sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t   $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t   $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t   $inct[0]);\t\n    }\n\n\n    my  $labels=$datarrset->[0]->name;\n    $labels =~ s/\\.$//;  # remove trailing dot.\n    $labels =~ s/^\\*\\.//;  # remove initial asterisk label\n    my @labels= split /\\./ , $labels;    # / emacs font-lock-mode\t\n    $self->{\"labels\"}= scalar(@labels);\n\n\n    # All the TTLs need to be the same in the data RRset.\n    if ( @{$datarrset}>1 ){\n\tfor (my $i=0; $i<@{$datarrset}; $i++){\n\t    if ($datarrset->[0]->{\"ttl\"} != $datarrset->[$i]->{\"ttl\"}){\n\t\tcroak \"\\nNot all TTLs  in the data RRset are equal \";\n\t    }\n\t}\n    }\n    $self->{\"orgttl\"}=$datarrset->[0]->{\"ttl\"};\n\n    $self->{\"sig\"}=  \"NOTYETCALCULATED\";  # This is what we'll do in a bit...\n    $self->{\"sigbin\"}= decode_base64($self->{\"sig\"});\n\n    # Bless the whole thing so we can get access to the methods...\n    # (Don not ask me why I havent called the new method, There are\n    # more ways to do things)\n\n    bless $self, $class;\n    \n    my $sigdata=$self->_CreateSigData($datarrset);\n\n    my $signature;\n    \n    #\n    # Enjoy the crypto\n    if ($self->algorithm == 1 \n\t|| $self->algorithm == 5\n\t|| $self->algorithm == 7\n\t|| $self->algorithm == 8\n\t|| $self->algorithm == 10) {  #RSA\n\tif (! ($Private->algorithm == 1 \n\t       || $Private->algorithm == 5 \n\t       || $Private->algorithm == 7 \n\t       || $Private->algorithm == 8 \n\t       || $Private->algorithm == 10  )) {\n\t    die \"Private key mismatch, not RSAMD5 or RSASHA.\";\n\t    \n\t}\n#\tmy $rsa_priv = Crypt::OpenSSL::RSA->new_private_key($Private->privatekey);\n\tmy $rsa_priv = $Private->privatekey;\n\t$self->{\"private_key\"}=$Private->privatekey;\n\teval {\n\t    $rsa_priv->use_pkcs1_oaep_padding;\n\t    if ($self->algorithm == 1) {\n\t\t$rsa_priv->use_md5_hash;\n\t    } elsif ($self->algorithm == 8) {\n    \t$rsa_priv->use_sha256_hash;\n\t    } elsif ($self->algorithm == 10) {\n    \t$rsa_priv->use_sha512_hash;\n\t    } else {\n\t\t$rsa_priv->use_sha1_hash;\n\t    }\n\n\t};\n\tdie \"RSA private key loading failed:\".$@ if $@;\n\teval {\n\t    $signature = $rsa_priv->sign($sigdata);\n\t};\n\tdie \"RSA Signature generation failed \".$@ if $@;\n\n\tprint \"\\n SIGNED\" if $debug ;\n\t\n    }elsif ($self->algorithm == 3 || $self->algorithm == 6  ){  #DSA\n\t$self->{\"private_key\"}=$Private->privatekey;\n\tmy $private_dsa=$Private->privatekey;\n\n\t\n      \tif ($datarrset ne \"\" ){\n\t    if (my $sig_obj= $private_dsa->do_sign(sha1($sigdata)))\n\t    {\n\t\t\n\t\tprint \"\\n SIGNED\" if $debug ;\n\t\t# See RFC 2535 for the content of the SIG\n\t\tmy $T_parameter= (length($private_dsa->get_g)-64)/8;\n\t\t$signature=pack(\"C\",$T_parameter);\n\n\t\tmy $sig_r_param=$sig_obj->get_r;\n\t\tmy $sig_s_param=$sig_obj->get_s;\n\t\t# both the R and S paramater in the RDATA need to be\n\t\t# 20 octets:\n\t\twhile (length($sig_r_param)<20){\n\t\t    $sig_r_param=pack('x').$sig_r_param ; \n\t\t}\n\t\twhile (length($sig_s_param)<20) {\t\n\t\t    $sig_s_param=pack('x').$sig_s_param ;\n\t\t}\n\t\t$signature.=$sig_r_param.$sig_s_param;\n\n\n\t    }else\n\t    {  \n\t\tconfess \"creation of DSA Signature failed \" ;\n\t    }\n\t}\n\t\n    }\n\n    if ($datarrset ne \"\" ){\n\t# Replace the \"sig\" by the real signature and return the object.\n\t$self->{\"sigbin\"}=$signature;\n\t$self->{\"sig\"}= encode_base64($signature);\n    }\n\n    return $self;\n}\n\n\nsub verify {\n    my ($self, $dataref, $keyrrref ) = @_;\n\n    # Reminder...\n\n    # $dataref may be a reference to an array of RR objects:\n    # $dataref->[$i]->method is the call to the method of the $i th\n    # object in the array...  @{$dataref} is length of the array when\n    # called in numerical context\n\n    # $keyref is eiter a reference to an array of keys or a a key object.\n\n    # if $dataref is not a reference it contains a string with data to be \n    # verified using SIG0\n    \n    my $sigzero_verify=0;\n    my $packet_verify=0;\n    my $rrarray_verify=0;\n\n    my $keyrr; # This will be used to store the key to which we want to \n               # verify.\n   \n\n    print \"Second argument is of class\".ref($keyrrref).\"\\n\" if $debug;;\n    if (ref($keyrrref) eq \"ARRAY\"){\n\t#  We will recurse for each key that matches algorithm and key-id \n\t#  we return when there is a succesful verification.\n        #  If not we'll continue so that we even survive key-id collission.\n\t#  The downside of this is that the error string only matches the\n\t#  last error.\n\tmy @keyarray=@{$keyrrref};\n\tmy $errorstring=\"\";\n\tmy $i=0;\n\tprint \"Itterating over \" . @keyarray .\" keys \\n\" if $debug;\n      KEYRR: foreach my $keyrr (@keyarray) {\n\t  $i++;\n\t  unless ($keyrr->algorithm == $self->algorithm){\n\t      print \"key $i: algorithm does not match\\n\" if $debug;\n\t      $errorstring.=\"key $i: algorithm does not match \";\n\t      next KEYRR;\n\t  }\n\t  unless ($keyrr->keytag == $self->keytag){\n\t      print \"key $i: keytag does not match (\".$keyrr->keytag.\" \".$self->keytag.\")\\n\" if $debug;\n\t      $errorstring.=\"key $i: keytag does not match \";\n\t      next KEYRR ;\n\t      \n\t  }\n\t  my $result=$self->verify($dataref,$keyrr);\n\t  print \"key $i:\".$self->vrfyerrstr if $debug;\n\t  $errorstring.=\"key $i:\".$self->vrfyerrstr.\" \";\n\t  next KEYRR unless $result;\n\t  $self->{\"vrfyerrstr\"}=\"No Error\";\n\t  return $result;\n      }\n\t$self->{\"vrfyerrstr\"}=$errorstring;\t  \n\treturn (0);\n    }elsif(ref($keyrrref) eq 'Net::DNS::RR::DNSKEY' ||\n\t   ref($keyrrref) eq 'Net::DNS::RR::KEY' # we are liberal...\n\t){\n\t# substitute and continue processing after this conditional\n\t$keyrr=$keyrrref;\n\tprint \"Validating using key with keytag:\".$keyrr->keytag.\" \\n\" if $debug;\n\n    }else{\n\t# Error condition\n\t$self->{\"vrfyerrstr\"} = \"You are trying to pass \".ref($keyrrref) .\" data for a key\";\n\treturn (0);\n    }\n\n\n\n\n    print \"Verifying data of class:\".  ref( $dataref) . \"\\n\" if $debug;\n    $sigzero_verify=1 unless (ref($dataref));\n    if (! $sigzero_verify ){\n\tif (ref($dataref) eq \"ARRAY\"){\n\n\t    if (ref($dataref->[0]) and $dataref->[0]->isa('Net::DNS::RR')){\n\t\t$rrarray_verify=1;\n\t    }else{\n\t\tdie \"Trying to verify an array of \".  ref( $dataref->[0]) .\"\\n\";\n\t    }\n\t}elsif( (ref($dataref)) and $dataref->isa(\"Net::DNS::Packet\")){\n\t    $packet_verify=1 if ((ref($dataref)) and $dataref->isa(\"Net::DNS::Packet\"));\n\t    die \"Trying to verify a packet while signature is not of SIG0 type\"\n\t\tif ($self->{\"typecovered\"} ne \"SIGZERO\");\n\t    \n\t}else{\n\t    die \"Do not know what kind of data this is\" . ref( $dataref) . \")\\n\";\n\t}\n    }\n\n\n\n    $self->{\"vrfyerrstr\"}=\"---- Unknown Error Condition ------\";\n    print \"\\n ------------------------------- RRSIG DEBUG  -----------------\\n\"  if $debug;\n    print \"Reference: \".ref($dataref) if $debug;;\n    print \"\\n  RRSIG:\\t\", $self->string if $debug;\n    if ( $rrarray_verify ){\n\tfor (my $i=0; $i<@{$dataref}; $i++){\n\t    print \"\\n DATA:\\t\", $dataref->[$i]->string if $debug ;\n\t}\n    }\n    print \"\\n  KEY:\\t\" , $keyrr->string if $debug;\n    print \"\\n ------------------------------------------------------------\\n\" if $debug;\n\n\n\n     \n    if (!$sigzero_verify && !$packet_verify && $dataref->[0]->type ne $self->typecovered ) {\n\t$self->{\"vrfyerrstr\"} = \"\\nCannot verify datatype  \" . $self->typecovered . \n\t    \" with a key intended for \" . \n\t\t$dataref->[0]->type .\n\t\t    \" verification\\n\";\n\treturn 0;\n    }\n\n\n    if ( $rrarray_verify &&  !$dataref->[0]->type eq \"RRSIG\" ) {\n\t# if [0] has type RRSIG the whole RRset is type RRSIG. \n\t# There are no SIGs over SIG RRsets\n\t$self->{\"vrfyerrstr\"} = \n\t    \"RRSIGs over RRSIGs???\\n\" .\n \t   \" What are you trying to do. This is not possible.\\n\";\n\treturn 0;\n    }\n    if ( $self->algorithm != $keyrr->algorithm ){\n\t$self->{\"vrfyerrstr\"} = \n\t    \"It is impossible to verify a signature made with algorithm \" .\n\t\t$self->algorithm . \"\\nagainst a key made with algorithm \" .\n\t\t    $keyrr->algorithm . \"\\n\";\n\treturn 0;\n\n    }\n\n    if ( $packet_verify){\n\t# We keep the intelligence for verification in here....\n\t# The packet is compressed ... we have to undo the compression.\n\t# Do this by creating a newpaclet\n\tmy $newpacket;\n\tbless($newpacket = {},\"", 8192) = 8192
09:01:57.278262 brk(0x1562000)          = 0x1562000
09:01:57.278846 read(14, "Net::DNS::Packet\");\n\t%{$newpacket} = %{$dataref};\n\tbless($newpacket->{\"header\"} = {},\"Net::DNS::Header\");\n\t%{$newpacket->{\"header\"}} = %{$dataref->{\"header\"}};\n\t@{$newpacket->{\"additional\"}} = @{$dataref->{\"additional\"}};\n\tshift(@{$newpacket->{\"additional\"}});\n\t$newpacket->{\"header\"}{\"arcount\"}--;\n\t$newpacket->{\"compnames\"} = {};\n\t$dataref=$dataref->data;\n    }\n\n\n    # The data that is to be signed\n    my $sigdata=$self->_CreateSigData($dataref);\n    my $signature=$self->sigbin; \n    my $verified=0;\n    if ( $self->algorithm == 1 ){    #Verifying for RSA\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,0) || return 0;\n    }     \n    elsif ( $self->algorithm == 3 ||  $self->algorithm == 6 )  # Verifying for DSA\n    {\n\t $verified=$self->_verifyDSA($sigdata,$signature,$keyrr) || return 0;\n    }\n    elsif ( $self->algorithm == 5 ||  $self->algorithm == 7 )  # Verifying for RSASHA1\n    {\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,1) || return 0;\n    }\n    elsif ( $self->algorithm == 8 )  # Verifying for RSASHA256\n    {\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,256) || return 0;\n    }\n    elsif ( $self->algorithm == 10 )  # Verifying for RSASHA512\n    {\n\t$verified=$self->_verifyRSA($sigdata,$signature,$keyrr,512) || return 0;\n    }\n    else                                  # Verifying other algorithms\n    { \n\t$self->{\"vrfyerrstr\"}= \"Algoritm \". $self->algorithm . \" has not yet been implemented\";\n\treturn 0;\n    }\t\n    \n    # This really is a redundant test\n    if ($verified) {  \n        # time to do some time checking.\n\tmy @inct=gmtime(time);\n\tmy $currentdatestring=  sprintf (\"%d%02d%02d%02d%02d%02d\",\n\t\t\t\t\t     $inct[5]+1900 ,$inct[4]+1 , \n\t\t\t\t\t     $inct[3] ,$inct[2] , $inct[1]  ,\n\t\t\t\t\t     $inct[0]);\t\n\tif ($self->{\"siginception\"} > $currentdatestring ){\n\t    $self->{\"vrfyerrstr\"}= \"Signature may only be used in the future; after \" .\n\t\t$self->{\"siginception\"} ;\n\t    return 0;\n\t}elsif($self->{\"sigexpiration\"} < $currentdatestring ){\n\t    $self->{\"vrfyerrstr\"}= \"Signature has expired since: \" .\n\t\t$self->{\"sigexpiration\"} ;\n\t    return 0;\n\t}\n\t$self->{\"vrfyerrstr\"}= \"No Error\";\n\treturn 1;\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"Verification method error.\";\n    return 0;\n\n} #END verify block\n\n\n\n\n# Below are all sorts of helper functions. \n# They should not really be used outside the scope of this class ...\n#\n# To do:  make these functions invisable outside the class.\n#\nsub _type2string {\n    my $index=shift;\n    if( Net::DNS::typesbyval($index)){\n\treturn Net::DNS::typesbyval($index) ;\n    }else{\n\treturn \"UNKNOWN TYPE\";\n    }\n}\n\nsub _string2type {\n    my $index=shift;\n        if( Net::DNS::typesbyname(uc($index))){\n\treturn Net::DNS::typesbyname(uc($index)) ;\n    }else{\n\tcarp \"UNKNOWN TYPE, cannot continue \";\n    }\n}\n\n\n\n\n\n\nsub _verifyDSA {\n    my ($self, $sigdata, $signature, $keyrr) = @_; \n\n    print \"\\nDSA verification called with key:\\n\". $keyrr->string . \n\t\n\t\" and sig:\\n\" . $self->string .\"\\n\" if $debug;\n\n    # RSA RFC2536\n    #\n    # Setup a DSA::Key. \n    #\n\n\n    \n    \n    \n    my $t_param=ord substr($keyrr->keybin,\n\t\t\t0,\n\t\t\t1);   # This works since T is only one octed .\n    \n    my $q_param=substr($keyrr->keybin, \n\t\t       1,\n\t\t       20);\n    my $p_param=substr($keyrr->keybin, \n\t\t       21, \n\t\t       64+$t_param*8 );\n    my $g_param=substr($keyrr->keybin, \n\t\t       21+64+$t_param*8,\n\t\t\t\t    64+$t_param*8);\n    \n\n\n    #rfc3279  section 2.3.2\n    # (...)\n    # The DSA public key MUST be ASN.1 DER encoded as an INTEGER; this\n    # encoding shall be used as the contents (i.e., the value) of the\n    # subjectPublicKey component (a BIT STRING) of the\n    # SubjectPublicKeyInfo data element.\n    # (...)\n\n    \nmy $pubkey_param=substr($keyrr->keybin, \n\t\t\t21+2*(64+$t_param*8),\n\t\t\t64+$t_param*8);\n\nmy $dsa_pub=Crypt::OpenSSL::DSA->new();\n    $dsa_pub->set_q($q_param);\n    $dsa_pub->set_g($g_param);\n    $dsa_pub->set_p($p_param);\n    $dsa_pub->set_pub_key($pubkey_param);\n\n\n\n    my $r_field=(substr($self->sigbin,\n\t\t\t1,\n\t\t\t20));\n    my $s_field=(substr($self->sigbin,\n\t\t\t21,\n\t\t\t20));\n    \n    my $DSAsig=Crypt::OpenSSL::DSA::Signature->new();\n    $DSAsig->set_r($r_field);\n    $DSAsig->set_s($s_field);\n\n\n    if (my $valid=$dsa_pub->do_verify (sha1( $sigdata) ,\n\t\t\t\t       $DSAsig\n\t\t\t\t       )){\n\tif ($valid==-1){\n\t    print \"Crypt::OpenSSL::DSA Verification failed with error\\n\" if $debug;\n\t    $self->{\"vrfyerrstr\"}=\"DSA Verification failed with error\";\n\t    return(0);\n\t}else{\n\t    print \"Crypt::OpenSSL::DSA Verification successful:$valid\\n\" if $debug;;\n\t    \n\t    $self->{\"vrfyerrstr\"}=\"DSA Verification successful \";\n\t    return(1);\n\t}\n    }else{\n\tprint \"Crypt::OpenSSL::DSA Verification failed\\n \" if $debug;;\n\t$self->{\"vrfyerrstr\"}=\"DSA Verification failed \";\n\treturn(0);\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"DSA Verification failed: undefined error \";\n    \n    return 0;\t\n}\n\n\nsub _verifyRSA {\n    # Implementation using crypt::openssl\n\n    my ($self, $sigdata, $signature, $keyrr, $isSHA) = @_; \n\n    print \"\\nRSA verification called with key:\\n\". $keyrr->string . \n\t\n\t\" sig:\\n\" . $self->string .\"\\non sigdata:\\t\".\n\t    unpack (\"H*\",$sigdata) . \"\\n\" \n\t    if $debug;\n    # RSA RFC2535\n    # \n    \n    my $explength;\n    my $exponent;\n    my $modulus;\n    my $RSAPublicKey;\n\t\n    {   #localise dummy\n\tmy $dummy=1;\n\t# determine exponent length\n\t\n\t#RFC 2537 sect 2\n\t($dummy, $explength)=unpack(\"Cn\",$keyrr->keybin) \n\t    if ! ($explength=unpack(\"C\",$keyrr->keybin));\n\tprint \"\\n\\nEXPLENGTH:\",$explength if $debug;\n\t\n\t# We are constructing the exponent and modulus as a hex number so \n\t# the AUTOLOAD function in Crypt::RSA::Key::Public can deal with it\n\t# later, there must be better ways to do this,\n\tif ($dummy) { # skip one octet\n\t    $exponent=(substr ($keyrr->keybin, \n\t\t\t       1, \n\t\t\t       $explength));\n\t    \n\t    $modulus=( substr ($keyrr->keybin,\n\t\t\t       1+$explength, \n\t\t\t       (length $keyrr->keybin) - 1\n\t\t\t       - $explength));\n\t    \n\t    \n\t}else{ # skip two octets\n\t    $exponent=(substr ($keyrr->keybin, \n\t\t\t       3,\n\t\t\t       $explength));\n\t    \n\t    $modulus=( substr ($keyrr->keybin, \n\t\t\t       3+$explength, \n\t\t\t       (length $keyrr->keybin) - 3\n\t\t\t       - $explength));\n\t}\n    }\n    \n\n    my $bn_modulus=Crypt::OpenSSL::Bignum->new_from_bin($modulus);\n    my $bn_exponent=Crypt::OpenSSL::Bignum->new_from_bin($exponent);\n\n  \n\n    my $rsa_pub = Crypt::OpenSSL::RSA->new_key_from_parameters($bn_modulus,$bn_exponent);\n\n\n    die \"Could not load public key\" unless $rsa_pub;\n    $rsa_pub->use_pkcs1_oaep_padding;\n    if ($isSHA == 1) {\n\t$rsa_pub->use_sha1_hash;\n    } elsif ($isSHA == 256) {\n\t$rsa_pub->use_sha256_hash;\n    } elsif ($isSHA == 512) {\n\t$rsa_pub->use_sha512_hash;\n    } else {\n\t$rsa_pub->use_md5_hash;\n    }\n    \n\n    \n    my $verified;\n    eval {\n\t$verified=$rsa_pub->verify($sigdata, $signature);\n    };\n\n    if ($@){\n\t $self->{\"vrfyerrstr\"}=\n\t     \"Verification of RSA string generated error: \". $@;\n\t print \"\\nRSA library error.\\n\" if $debug;\n\t return 0;\n     }\n    if ($verified )\n    {\n\tprint \"\\nVERIFIED\\n\\n\" if $debug ;\n\t$self->{\"vrfyerrstr\"}=\"RSA Verification successful\";\n\treturn 1;\n    }else\n    {   $self->{\"vrfyerrstr\"}=\"RSA Verification failed\";\n\t# Data is not verified\n\tprint \"\\nNOT VERIFIED\\n\" if $debug;\n\treturn 0;\n    }\n    \n    $self->{\"vrfyerrstr\"}=\"RSA Verification failed: This code should not be run \";\n    0;\n\n}\n\nsub _CreateSigData {\n    # this is the data that will be  signed, it will be fed to the\n    # verifier. See RFC4034 section 6 on how this string is constructed\n\n    # This method is called by the method that creates as signature\n    # and by the method that verifies the signature. It is assumed\n    # that the creation method has checked that all the TTL are the same\n    # for the dataref and that sig->orgttl has been set to the TTL of\n    # the data. This method will set the datarr->ttl to the sig->orgttl for\n    # all the RR in the dataref.\n\n\n\n    my ($self,$rawdata)=@_;\n\n    my $sigzero= ! ref ($rawdata);\n    my $sigdata;\n    # construction of message \n\n    print \"_CreatSigData\\n\" if $debug;\n    my $rdatawithoutsig=$self->rr_rdata_without_sigbin;\n    print \"raw RRsig:\\t\",  unpack(\"H*\", $rdatawithoutsig) if $deb", 8192) = 8192
09:01:57.279494 brk(0x1583000)          = 0x1583000
09:01:57.280033 read(14, "ug;\n    $sigdata= $rdatawithoutsig;\n\n\n    if ( ! $sigzero ){\n\t# Not a SIG0\n\tif (@{$rawdata}>1) {\n\t    my @canonicaldataarray;\n\t    for (my $i=0; $i<@{$rawdata}; $i++){\n\t\tif ($debug){\n\t\t    print \"Setting TTL to from \". $rawdata->[$i]->{\"ttl\"} . \" to \" .\n\t\t\t$self->orgttl . \"\\n\" \n\t\t\t    if ( $rawdata->[$i]->{\"ttl\"}!=$self->orgttl);\n\t\t}\n\t\t$rawdata->[$i]->{\"ttl\"}=$self->orgttl;\n\t\t# Some error checking is done to. A RRset is defined by \n\t\t# Same label,class,qtype\n\t\tif (lc($rawdata->[$i]->name) ne lc($rawdata->[0]->name)){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nNot all labels in the data RRset above are equal \";\n\t\t}\n\t\t\n\t\tif ($rawdata->[$i]->type ne $rawdata->[0]->type){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nThe  the data RRset consists of different types \";\n\t\t}\n\t\t\n\t\tif ($rawdata->[$i]->class ne $rawdata->[0]->class){\n\t\t    print \"\\nError:\\n\";\n\t\t    for  (my $j=0; $j<@{$rawdata}; $j++){\n\t\t\tprint \"\\n\";\n\t\t\t$rawdata->[$j]->print;\n\t\t    }\n\t\t    croak \"\\nThe  the data RRset has different classes (What are you trying to do?)  \";\n\t\t}\n\t\t\n\t\tprint \"\\n\\nCan Data RR: $i\\t\", \n\t\tunpack(\"H*\", ($rawdata->[$i]->_canonicaldata)) if $debug;\n\t\t\n\t\t# To allow for sorting on RDATA we create an array of hashes.\n\t\t# We sort on canonicalRdata and use the full RR representation \n\t\t# in rr to build the digest.\n\t\t$canonicaldataarray[$i]= \n\t\t{ rrdigest => $rawdata->[$i]->_canonicaldata,\n\t\t  canonicalRdata => $rawdata->[$i]->_canonicalRdata,\n\t      };\n\t    }\n\t    \n\t    # Sort acording to RFC2535 section 8.3\n\t    # Comparing left justified octet strings: perl sort does just that.\n\t    # We have to sort on RDATA.. the array contains the whole RRset.\n\t    #  the sort routine\n\t    \n\t    my @sortedcanonicaldataarray= sort        {\n\t\t$a->{\"canonicalRdata\"} cmp $b->{\"canonicalRdata\"};   \n\t    }\n\t    @canonicaldataarray;\n\t    \n\t    \n\t    \n\t    for (my $i=0; $i<@sortedcanonicaldataarray ; $i++){\n\t\tprint \"\\n>>>\" . $i \t.\n\t\t    \">>> \\t\" .\n\t\t\tunpack(\"H*\",$sortedcanonicaldataarray[$i]{canonicalRdata}) .\n\t\t\t    \"\\n>>>\\t \" .\n\t\t\t\tunpack(\"H*\",$sortedcanonicaldataarray[$i]{rrdigest}) .\n\t\t\t\t    \"\\n\" if $debug;\n\t\t$sigdata .=  $sortedcanonicaldataarray[$i]{rrdigest};\n\t    }\n\t}else{\n\t    if ($debug) {\n\t\tprint \"\\nSetting TTL to from \". $rawdata->[0]->{\"ttl\"} . \" to \" .\n\t\t    $self->orgttl . \"\\n\" if \n\t\t\t( $rawdata->[0]->{\"ttl\"}!=$self->orgttl );\n\t    }\n\t    print \"\\nRDATA:\\t\\t\" .$rawdata->[0]->_canonicalRdata .\"\\n-----:\\t\\t\" .\n\t      unpack(\"H*\",$rawdata->[0]->_canonicalRdata) .\"\\n\" if $debug;\n\t    \n\t    $rawdata->[0]->{\"ttl\"}=$self->orgttl;\t    \n\t    $sigdata .= $rawdata->[0]->_canonicaldata;\n\t    \n\t}\n\t\n    }else{ #SIG0 case  \n\n\tprint \"\\nsig0 proccessing\\nrawdata:\\t\". unpack(\"H*\",$rawdata).\"\\n\"if $debug;\n\t$sigdata=$sigdata.$rawdata;\n    }\n    \n\n    print \"\\n sigdata:\\t\".   unpack(\"H*\",$sigdata) . \"\\n\" if $debug;\n\n    return $sigdata;\n}\n\n\nsub _checktimeformat {\n    # Function to check if the strings entered as time are properly formated.\n    # Croaks if the format does not make sense...\n    \n    \n    my $timestring=shift;\n\n    my @timeval=($timestring =~ /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/);\n    if (@timeval != 6) {\n\tcroak \"The time \" . $timestring . \" is not in the expected format (yyyymmddhhmmss)\";\n    }\n    if ($timeval[0]< 1970) {\n\tcroak \"The year \". $timeval[0] . \" is before the epoch (1970)\";\n    }\n    if ($timeval[1]> 12) {\n\tcroak \"What??? There is no month number \". $timeval[1] ;\n    }\n    # This is a rough check... \n    # Feb 31 will work... \n    if ($timeval[2]> 31) {\n\tcroak \"Intresting, a month with \". $timeval[2] . \" days\" ;\n    }\n\n    if ($timeval[3]> 24) {\n\tcroak \"Intresting, a day with \". $timeval[3] . \" hours\" ;\n    }\n\n    if ($timeval[4]> 60) {\n\tcroak \"Intresting, an hour with \". $timeval[3] . \" minutes\" ;\n    }\n    if ($timeval[5]> 60) {\n\tcroak \"Intresting, a minute with \". $timeval[3] . \" seconds\" ;\n    }\n\n    \n    0;\n}\n\n\n# The previous versions had a typo... *Sigh*\nsub siginceptation {\n    my $self=shift;\n    return $self->siginception(@_);\n}\n\n\n\nsub _normalize_dnames {\n\tmy $self=shift;\n\t$self->_normalize_ownername();\n\t$self->{'signame'}=lc(Net::DNS::stripdot($self->{'signame'})) if defined $self->{'signame'};\n}\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::RRSIG - DNS RRSIG resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\n\nClass for DNS Address (RRSIG) resource records. In addition to the\nregular methods in the Net::DNS::RR the Class contains a method to\nsign RRsets using private keys (create). And a class for verifying\nsignatures over RRsets (verify).\n\nThe RRSIG RR is an implementation of RFC 4034. \nSee L<Net::DNS::RR::SIG> for an impelementation of SIG0 (RFC 2931).\n\n\n\n\n=head1 METHODS\n\n=head2 create\n    \nCreate a signature over a RR set.\n\n    my $keypath= \n            \"/home/olaf/keys/Kbla.foo.+001+60114.private\";\n    my $sigrr= create Net::DNS::RR::RRSIG(\\@datarrset,\n\t\t\t\t\t$keypath);\n    my $sigrr= create Net::DNS::RR::RRSIG(\\@datarrset,\n\t\t\t\t\t$keypath,\n\t\t\t\t\t%arguments);\n    $sigrr->print;\n\n\n\n    #Alternatively use Net::DNS::SEC::Private \n\n    my $private=Net::DNS::SEC::Private-new(\n\t\"/home/olaf/keys/Kbla.foo.+001+60114.private\");\n    my $sigrr= create Net::DNS::RR::RRSIG(\\@datarrset,\n\t\t\t\t\t  $private);\n\n\n\n\ncreate is an alternative constructor for a RRSIG RR object.  \n\nThe first argument is either reference to an array that contains the\nRRset that needs to be signed.\n\nThe second argument is a string containing the path to a file\ncontaining the the private key as generated with dnssec-keygen, a\nprogram that commes with the bind distribution.\n\nThe third argument is an anonymous hash containing the following\npossible arguments:  \n\n    ( ttl => 3600,                        # TTL \n      sigin =>   20010501010101,          # signature inception \n      sigex =>   20010501010101,          # signature expiration\n      sigval => 1.5                       # signature validity\n      )\n\nThe default for the ttl is 3600 seconds. sigin and sigex need to be\nspecified in the following format 'yyyymmddhhmmss'. The default for\nsigin is the time of signing. \n\nsigval is the validity of the signature in minutes for SIG0s and days\nfor other signatures (sigex=sigin+sigval).  If sigval is specified\nthen sigex is ignored. The default for sigval is 5 minutes for SIG0s\nand 30 days other types of signatures.\n\n\n\nNotes: \n\n- Do not change the name of the file generated by dnssec-keygen, the\n  create method uses the filename as generated by dnssec-keygen to\n  determine the keyowner, algorithm and the keyid (keytag).\n\n- Only RSA signatures (algorithm 1,5 and 7) and DSA signatures \n  (algorithm 3, and 6) have been implemented.\n\n\n\n=head2 typecovered\n\n    print \"typecovered =\", $rr->typecovered, \"\\n\"\n\nReturns the qtype covered by the sig.\n\n=head2 algorithm\n\n    print \"algorithm =\", $rr->algorithm, \"\\n\"\n\nReturns the algorithm number used for the signature\n\n=head2 labels\n\n    print \"labels =\", $rr->labels, \"\\n\"\n\nReturns the the number of labels of the RRs over wich the \nsig was made.\n\n=head2 orgttl\n\n    print \"orgttl =\", $rr->orgttl, \"\\n\"\n\nReturns the RRs the original TTL of the signature\n\n=head2 sigexpiration\n\n    print \"sigexpiration =\", $rr->sigexpiration, \"\\n\"\n\nReturns the expiration date of the signature\n\n=head2 siginception\n\n    print \"siginception =\", $rr->siginception, \"\\n\"\n\nReturns the date the signature was incepted.\n\n=head2 keytag\n\n    print \"keytag =\", $rr->keytag, \"\\n\"\n\nReturns the the keytag (key id) of the key the sig was made with.\nRead \"KeyID Bug in bind.\" below.\n\n=head2 signame\n\n    print \"signame =\", $rr->signame, \"\\n\"\n\nReturns the name of the public KEY RRs  this sig was made with.\n\n=head2 sig\n\n    print \"sig =\", $rr->sig, \"\\n\"\n\nReturns the base64 representation of the signature.\n\n\n=head2 verify and vrfyerrstr\n\n    $sigrr->verify($data, $keyrr) || croak $sigrr->vrfyerrstr;\n    $sigrr->verify($data, [$keyrr, $keyrr2, $keyrr3]) || \n                  croak $sigrr->vrfyerrstr;\n\n\nIf $data contains a reference to an array of RR objects then them\nmethod verifies the RRset against the signature c", 8192) = 8192
09:01:57.280792 brk(0x15a4000)          = 0x15a4000
09:01:57.280959 read(14, "ontained in the\n$sigrr object itself using the public key in $keyrr.  Because of the\nKeyID bug in bind (see below) a check on keyid is not performed.\n\nIf $data contains a reference to a Net::DNS::Packet and if $sig->type\nequals zero a a sig0 verification is performed. Note that the\nsignature needs to be 'popped' from the packet before verifying.\n\nThe second argument can either be a Net::DNS::RR::KEYRR object or a\nreference to an array of such objects. Verification will return\nsuccessful as soon as one of the keys in the array leads to positive\nvalidation.\n\nReturns 0 on error and sets $sig->vrfyerrstr\n\n=head2 Example\n\n\n   my $sigrr=$packet->pop(\"additional\");\n   print $sigrr->vrfyerrstr unless $sigrr1->verify($update1, $keyrr1);\n\n\n=head1 Remarks\n\n- The code is not optimized for speed whatsoever. It is probably not\nsuitable to be used for signing large zones. \n\n=head1 TODO\n\n- Clean up the code.\n\n- If this code is still around by 2030 you have a few years to check\nthe proper handling of times...\n\n- Add wildcard handling\n\n\n=head1 ACKNOWLEDGMENTS\n\nAndy Vaskys (Network Associates Laboratories) supplied the code for\nhandling RSA with SHA1 (Algorithm 5).\n\nChris Reinardt for maintianing Net::DNS.  \n\nT.J. Mather, <tjmather@tjmather.com>, the Crypt::OpenSSL::DSA\nmaintainer, for his quick responses to bug report and feature\nrequests.\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001 - 2005  RIPE NCC.  Author Olaf M. Kolkman \nCopyright (c) 2007 - 2008  NLnet Labs.  Author Olaf M. Kolkman \n<olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\nThis code uses Crypt::OpenSSL which uses the openssl library\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>,\nL<Net::DNS::RR>,L<Crypt::OpenSSL::RSA>,\nL<Crypt::OpenSSL::DSA>, L<Net::DNS::SEC::Private>, RFC 4034\n\n=cut\n\n", 8192) = 2822
09:01:57.281149 read(14, "", 8192)      = 0
09:01:57.281197 close(14)               = 0
09:01:57.281281 stat("modules/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281333 stat("modules/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281383 stat("modules/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281432 stat("modules/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281481 stat("/etc/perl/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281531 stat("/etc/perl/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281581 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281632 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281683 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281736 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281796 stat("/usr/lib/perl5/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281847 stat("/usr/lib/perl5/Net/DNS/RR/NSEC.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.281898 stat("/usr/share/perl5/Net/DNS/RR/NSEC.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.281948 stat("/usr/share/perl5/Net/DNS/RR/NSEC.pm", {st_mode=S_IFREG|0644, st_size=7131, ...}) = 0
09:01:57.282008 open("/usr/share/perl5/Net/DNS/RR/NSEC.pm", O_RDONLY) = 14
09:01:57.282072 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.282121 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.282177 read(14, "package Net::DNS::RR::NSEC;\n\n# $Id: NSEC.pm 813 2009-11-27 09:10:10Z olaf $\n\nuse strict;\nuse vars qw(@ISA $VERSION);\nuse Carp;\nuse bytes;\nuse Net::DNS;\nuse Net::DNS::Packet;\nuse Data::Dumper;\n\nuse Carp;\n\n@ISA = qw(Net::DNS::RR);\n$VERSION = do { my @r=(q$Revision: 813 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n    \n    if ($self->{\"rdlength\"} > 0) {\n\tmy($nxtdname,$nxtoffset) = \n\t  Net::DNS::Packet::dn_expand($data, $offset);\n\n\t$self->{\"nxtdname\"} =  $nxtdname;\n\n\tmy $typebm =substr($$data,$nxtoffset,\n\t\t\t\t $self->{\"rdlength\"}-\n\t\t\t\t $nxtoffset+$offset);\n\n\t$self->{\"typebm\"}=$typebm;\n\t$self->{\"typelist\"} = join \" \" \n\t    ,  _typebm2typearray($typebm);\n    }\n    \n    return bless $self, $class;\n}\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    if ($string) {\n\t$string =~ tr/()//d;\n\t$string =~ s/;.*$//mg;\n\t$string =~ s/\\n//mg;\n\tmy ($nxtdname,$nxtstr) = \n\t    $string =~ /^\\s*(\\S+)\\s+(.*)/;\n\tmy @nxttypes = split ' ' , $nxtstr;  # everything after last match...\n\t\n\t$self->{\"nxtdname\"}=  Net::DNS::stripdot($nxtdname);\n\t$self->{\"typelist\"}= join \" \" , sort @nxttypes ;\n\t$self->{\"typebm\"}=_typearray2typebm(@nxttypes);\n\t\n    }\n    return bless $self, $class;\n}\n\n\n\n\n#sub is_optin {\n#    my $self =shift;\n#    return 1 if $self->{\"typelist\"}!~/NSEC/;\n#    0;\n#}\n\n#sub set_optin {\n#    my $self =shift;\n#    $self->{\"typelist\"}=~s/NSEC//;\n#    1;\n#}\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\n\t\n\tif (exists $self->{\"nxtdname\"}) {\n\t    $rdatastr  = $self->{nxtdname}.\".\";\n\t    $rdatastr .= \"  \"  . $self->typelist();\n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n\n\n    my $rdata = \"\" ;\n    if (exists $self->{\"nxtdname\"}) {\n\t# Compression used here... \n\t$rdata = $packet->dn_comp(($self->{\"nxtdname\"}),$offset);\n\t$rdata .= $self->typebm();\n    }\n    \n    return $rdata;\n    \n}\n\n\n\n\nsub _normalize_dnames {\n\tmy $self=shift;\n\t$self->_normalize_ownername();\n\t$self->{'nxtdname'}=lc(Net::DNS::stripdot($self->{'nxtdname'})) if defined $self->{'nxtdname'};\n}\n\n\n\n\n\nsub typebm {\n    my ($self, $new_val) = @_;\n\t\t\t\t\n    if (defined $new_val) {\n\t$self->{\"typebm\"} = $new_val;\n\t$self->{\"typelist\"}= join (\" \",  _typebm2typearray($self->{\"typebm\"}));\n    }\n\n    $self->{\"typebm\"}= _typearray2typebm(split(' ',$self->{\"typelist\"})) unless $self->{\"typebm\"};\n    return $self->{\"typebm\"};\n}\n\n\nsub typelist {\n    my ($self, $new_val) = @_;\n\t\t\t\t\n    if (defined $new_val) {\n\t$self->{\"typelist\"} = $new_val;\n\t$self->{\"typebm\"}= _typearray2typebm(split (' ',($self->{\"typelist\"})));\n    }\n\n    $self->{\"typelist\"}=  join (\" \", \n _typebm2typearray($self->{\"typebm\"})) unless $self->{\"typelist\"};\n\n    return $self->{\"typelist\"};\n}\n\t   \n\n\nsub _canonicalRdata {\n    # rdata contains a compressed domainname... that should not have\n    # been done @specification time :-) \n\tmy ($self) = @_;\n\tmy $rdata;\n\t$rdata=$self->_name2wire($self->{\"nxtdname\"});\n\t$rdata .= $self->{\"typebm\"};\t\n\treturn $rdata;\n}\n\n\nsub _typearray2typebm {\n\n\n    # typebm= (WindowBlockNumber |BitmapLength|Bitmap)+\n\n    my @typelist= @_;\n    return \"\" unless @typelist;\n\n    my $typebm=\"\";\n    my $CurrentWindowNumber=0;\n\n    # $bm is an array of arrays.\n    \n    # The first index maps onto the CurrentWindowNumber and the array\n    # contained has its index mapped to types. The vallues will be set\n    # if there is data for a paricular type otherwise undef.\n    \n    my $bm;\n  TYPE:   for(my $i=0;$i < @typelist; $i++){\n \tuse integer;\n\tmy $typenumber=Net::DNS::typesbyname(uc($typelist[$i]));\n\tnext TYPE if exists ($Net::DSN::qtypesbyname{uc($typelist[$i])});\n\tnext TYPE if  exists ($Net::DSN::metatypesbyname{uc($typelist[$i])});\n\t# Do net set the bitmap for meta types or qtypes.\n\t    $CurrentWindowNumber= ($typenumber / 256); # use integer must be in scope..\t\n\t$bm->[$CurrentWindowNumber]->[$typenumber-$CurrentWindowNumber*256] = 1;\n\t}\n    \n    # Turn the array of arrays referenced through $bm into the bitmap\n    # as used in the RDATA\n\n    for (my $i=0; $i < @{$bm}; $i++){\n\tif (defined ($bm->[$i])){\n\t    use integer;\n\t    my $BitmapLength=0;\n\t    $BitmapLength =  8 * ((@{$bm->[$i]} / 8) );\n\t    # Make sure the remaining bits fit...\n\t    $BitmapLength += 8 if (@{$bm->[$i]} % 8);\n\t    for (my $j=0;$j< $BitmapLength; $j++){\n\t\t$bm->[$i]->[$j]=0 if ! defined $bm->[$i]->[$j];\n\t    }\n\n\t    $typebm.= pack(\"CCB$BitmapLength\",$i,$BitmapLength/8,\n\t\t\t   join (\"\", @{$bm->[$i]} ));\n\t}\n    }\n    return $typebm\n\n}\n\nsub _typebm2typearray {\n\n\n    # This implements draft-ietfdnsext-nsec-rdata-01.\n    # typebm= (WindowBlockNumber |BitmapLength|Bitmap)+\n\n    my $typebm=shift;  # bit representation.\n    my@typelist;\n    while ($typebm){\n\tmy ($WindowBlockNumber,$BitmapLength)=unpack(\"CC\",$typebm);\n\tsubstr($typebm,0,2,\"\");\n\tmy $Bitmap=substr($typebm,0,$BitmapLength,\"\");\n\t# Turn the Bitmap in an array...\n\tmy @bm=split //, unpack(\"B*\", $Bitmap);  # bit representation in arra\n\n\tfor (my $i=0;$i < @bm; $i++){\n\t    @typelist=(@typelist,\n\t\t       Net::DNS::typesbyval($WindowBlockNumber*256+$i))\t   \n\t      if $bm[$i];\n\t}\n    }\n\n    return sort @typelist;\n}\n\n\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::NSEC - DNS NSEC resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for DNS Address (NSEC) resource records.\n\n=head1 METHODS\n\n=head2 nxtdname\n\n    print \"nxtdname\" = \", $rr->nxtdname, \"\\n\";\n\nReturns the RR's next domain name field.\n\n\n=head2 typelist\n\n    print \"typelist\" = \", $rr->typelist, \"\\n\";\n\nReturns a string with the list of qtypes for which data exists for\nthis particular label.\n\n\n\n=head2 typebm\n\n    print \"typebm\" = \" unpack(\"B*\", $rr->typebm), \"\\n\";\n\nSame as the typelist but now in a representation  bitmap as in \nspecified in the RFC. This is not the kind of method you will need\non daily basis.\n\n=head1 COPYRIGHT\n\nCopyright (c) 2001-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC4033, RFC4034, RFC4035.\n\n=cut\n", 8192) = 7131
09:01:57.283280 read(14, "", 8192)      = 0
09:01:57.283331 close(14)               = 0
09:01:57.283409 stat("modules/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283460 stat("modules/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.283510 stat("modules/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283559 stat("modules/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.283608 stat("/etc/perl/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283664 stat("/etc/perl/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.283714 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283766 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.283817 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283871 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.283922 stat("/usr/lib/perl5/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.283973 stat("/usr/lib/perl5/Net/DNS/RR/DNSKEY.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.284025 stat("/usr/share/perl5/Net/DNS/RR/DNSKEY.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.284075 stat("/usr/share/perl5/Net/DNS/RR/DNSKEY.pm", {st_mode=S_IFREG|0644, st_size=8326, ...}) = 0
09:01:57.284133 open("/usr/share/perl5/Net/DNS/RR/DNSKEY.pm", O_RDONLY) = 14
09:01:57.284187 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.284233 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.284295 read(14, "package Net::DNS::RR::DNSKEY;\n\n# $Id: DNSKEY.pm 847 2010-03-12 13:04:13Z olaf $\n\nuse strict;\nuse vars qw(@ISA $VERSION);\nuse bytes;\n\nuse Net::DNS::SEC;\nuse MIME::Base64;\nuse Carp;\n\n@ISA = qw(Net::DNS::RR Net::DNS::SEC);\n\n\n$VERSION = do { my @r=(q$Revision: 847 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n\n    bless $self, $class;\n    if ($self->{\"rdlength\"} > 0) {\n\t\n\tmy $offsettoprot=$offset+2;\n\tmy $offsettoalg=$offset+3;\n\tmy $offsettokey=$offset+4;\n\t\n\t$self->{\"flags\"}=unpack(\"n\",substr($$data,$offset,2));\n\t$self->{\"protocol\"}=unpack(\"C\",substr($$data,$offsettoprot,1));\n\t$self->{\"algorithm\"}=unpack(\"C\",substr($$data,$offsettoalg,1));\n\tmy $keymaterial=substr($$data,$offsettokey,$self->{\"rdlength\"}-4);\n\t$self->{\"keybin\"}=($keymaterial);\n\t$self->{\"key\"}= encode_base64($keymaterial);\n\t\n    }\n    bless $self, $class;\n    $self->setkeytag;\n    return $self;\n\n    \n}\n\n\n\nsub new_from_string {\n\tmy ($class, $self, $string) = @_;\n\n\n\tif ($string) {\n\t\t$string =~ tr/()//d;\n\t\t$string =~ s/;.*$//mg;\n\t\t$string =~ s/\\n//mg;\n\t\tmy ($flags, $protocol, $algorithm,$key) = \n\t\t    $string =~ /^\\s*(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(.*)/;\n\t\t$key =~ s/\\s*//g;\n\t\t$self->{\"flags\"}=$flags;\n\t\t$self->{\"algorithm\"}=Net::DNS::SEC->algorithm($algorithm);\n\t\t$self->{\"protocol\"}=$protocol;\n\t\tmy $keymaterial=decode_base64($key);\n\t\t$self->{\"keybin\"}=($keymaterial);\n\t\t$self->{\"key\"}=$key;\n\t}\n\tbless $self, $class;\n\t\n\t$self->setkeytag();\n\treturn $self;\n\n}\n\n\n\nsub rdatastr {\n\tmy $self = shift;\n\tmy $rdatastr;\n\tif (exists $self->{\"flags\"}) {\n\t    $rdatastr  = $self->{flags};\n\t    $rdatastr .= \"  \"  . \"$self->{protocol}\";\n\t    $rdatastr .= \"  \"  . $self->algorithm;\n\t    $rdatastr .= \" ( \\n\" ;\n\t    # do some nice formatting\n\t    my $keystring=$self->{key};\n\t    $keystring =~ s/\\n//g;\n\t    $keystring =~ s/(\\S{36})/$1\\n\\t\\t\\t/g;\n\t    $rdatastr .=  \"\\t\\t\\t\".$keystring;\n\t    $rdatastr .= \" \\n\\t\\t\\t) ; Key ID = \"  . \"$self->{keytag}\";\n\t    }\n\telse {\n\t    $rdatastr = \"; no data\";\n\t}\n\n\treturn $rdatastr;\n}\n\nsub rr_rdata {\n    my $self = shift;\n    \n    my $rdata;\n    if (exists $self->{\"flags\"}) {\n\t$rdata= pack(\"n\",$self->{\"flags\"}) ;\n\t$rdata.=\n\t    pack(\"C2\",$self->{\"protocol\"} \n\t\t     , $self->algorithm) ;\n\t$rdata.= $self->{\"keybin\"}\n    }\n    return $rdata;\n}\n\n\nsub setkeytag\n{\n    my $self=shift;\n    if (($self->{\"flags\"} & hex(\"0xc000\") ) == hex(\"0xc000\") ){\n\t# NULL KEY\n\t$self->{\"keytag\"} = 0;\n    }elsif ($self->algorithm == '1'){\n\t# RFC 2535 4.1.6  most significant 16 bits of the least\n\t#                 significant 24 bits\n\t\n\tmy @keystr=split //, $self->{\"keybin\"};\n\tmy $keysize= $#keystr+1;\n\t$self->{\"keytag\"} = (unpack(\"C\",$keystr[$keysize - 3]) << 8) \n\t    + unpack(\"C\",$keystr[$keysize - 2]);\n\t0;\n    }else{\n\t# All others\n\t# RFC 2535  Appendix C\n\tmy ($ac, $i);\n\t\n\t# $self->{\"rr_data\"} cannot be \n\t# used if the object has not been constructed ?!?\n\n\tmy $rdata= pack(\"n\",$self->{\"flags\"}) ;   \n\t$rdata.=\n\t    pack(\"C2\",$self->{\"protocol\"} \n\t\t , $self->algorithm) ;\n\t$rdata.= $self->{\"keybin\"};\n\tmy @keyrr=split //, $rdata;\n\n\tfor ( $ac=0 , $i=0; $i <= $#keyrr ; $i++ ){\n\t    $ac += ($i & 1) ? \n\t\tunpack(\"C\",$keyrr[$i]) :\n\t\t    unpack(\"C\", $keyrr[$i])<<8;\n\t}\n\t$ac += ($ac>>16) & 0xFFFF;\n\t$self->{\"keytag\"} =($ac & 0xFFFF);\n\t0;\n    }\n    \n}\n\n\nsub set_sep {\n    my $self=shift;\n     return $self->is_sep if $self->is_sep;\n    $self->{\"flags\"}+=1;\n    $self->setkeytag;\n    return if $self->is_sep;\n}\n\n\n\n\nsub unset_sep {\n    my $self=shift;\n    return $self->clear_sep();\n}\n\nsub clear_sep {\n    my $self=shift;\n     return $self->is_sep if ! $self->is_sep;\n    $self->{\"flags\"}-=1;\n    $self->setkeytag;\n    return $self->is_sep;\n}\n\n\n\nsub is_sep {\n    my $self=shift;\n    return $self->{\"flags\"} % 2;  # Hey it;s odd.\n}\n\n\nsub privatekeyname {\n    my $self=shift;\n    return sprintf(\"K%s.+%03d+%05d.private\",\n\t\t   $self->name,\n\t\t   $self->algorithm,\n\t\t   $self->keytag);\n    \n}\n\n\n\n# Return the length in bits of a RSA key and DSA key (crypto speaking)\n#        -1 if it's not a know algorithm\n# RSA part contributed by Hugo Salgado <hsalgado@nic.cl>\nsub keylength {\n    my $self = shift;\n\n    if ( $self->algorithm(\"mnemonic\") =~ /RSA/ ){\n\t    # Modulus length, see RFC 2537\n\t    \n\t    # First we need the total length in the wire rdata\n\t    my $total = length(unpack(\"B*\",$self->{\"keybin\"}));\n\t    \n\t    # Now we obtain the first octet (exponent length)\n\t    my $octet = unpack(\"B8\", $self->{\"keybin\"});\n\t    \n\t    my $expo_length;\n\t    # If the first octet is zero, we need the next two\n\t    if ($octet == 0) {\n\t\t    # This part is untested. I couldn't create a real key test case :(\n\t\t    $octet = unpack(\"B24\", $self->{\"keybin\"});\n\t\t    $expo_length = unpack(\"N\", pack(\"B32\", substr(\"0\" x 8 . $octet, -24)));\n\t\t    $expo_length += 3; # we add the 3 octets with the length\n\t    }\n\t    else {\n\t\t    $expo_length = unpack(\"N\", pack(\"B32\", substr(\"0\" x 32 . $octet, -32)));\n\t\t    $expo_length++; # we add the first octet\n\t    }\n\t    \n\t    # The modulus is the remaining, in bits\n\t    return $total - ($expo_length*8);\n\n    }elsif (  $self->algorithm(\"mnemonic\") =~ /DSA/ ) {\n\t    # T parameter see RFC 2536\n\t    return  unpack(\"C\", $self->{\"keybin\"});\n\n    }else {\n\t    return -1;\n    }\n}\n\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::DNSKEY - DNS DNSKEY resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for DNSSEC KEY (DNSKEY) resource records.\n\n=head1 METHODS\n\n=head2 flags\n\n    print \"flags\" = \", $rr->flags, \"\\n\";\n\nReturns the RR's flags in decimal representation\n\n\n=head2 protocol\n\n    print \"protocol\" = \", $rr->protocol, \"\\n\";\n\nReturns the RR's protocol field in decimal representation\n\n=head2 algorithm\n\n    print \"algoritm\" = \", $rr->algorithm, \"\\n\";\n\nReturns the RR's algorithm field in decimal representation\n\n    1 = RSA/MD5\n    2 = DH\n    3 = DSA/SHA-1\n    4 = Elliptic Curve\n    5 = RSA/SHA-1\n    6 - DSA/SHA-1 (NSEC3)\n    7 - RSA/SHA-1 (NSEC3)\n    8 - RSA/SHA-256 \n    10 - RSA/SHA-512\n\nNote that only algorithm 1 and 3 are supported by the methods provided\nthrough Net::DNS::RR::SIG.pm.\n\n=head2 key\n\n    print \"key\" = \", $rr->key, \"\\n\";\n\nReturns the key in base64 representation\n\n\n=head2 keybin\n\n    $keybin =  $rr->keybin;\n\nReturns the key binary material\n\n\n=head2 keytag\n\n    print \"keytag\" = \", $rr->keytag, \"\\n\";\n\nReturns the key tag of the key. (RFC2535 4.1.6)\n\n=head2 privatekeyname\n\n    $privatekeyname=$rr->privatekeyname\n\nReturns the name of the privatekey as it would be generated by\nthe BIND dnssec-keygen program. The format of that name being\nK\\<fqdn\\>+\\<algorithm\\>+\\<keyid\\>.private\n\n=head2 is_sep, set_sep, clear_sep\n\nis_sep() returns 1 if the secure entry point flag field is set,\nset_sep() sets secure entry point flag field is set and clear_sep()\nclears the value. \n\n=head2 keylength\n\nReturn the length of a key. \n\nFor RSA this method returns the length (in bits) of the modulus.\n\nFor DSA this method returnse the value of the T parameter (See RFC2536)\n\nReturns -1 if the keysize cannot be determined (e.g. for unknown algorithms\nalgorithm).\n\n=head1 COPYRIGHT\n\nCopyright (c) 2003-2005  RIPE NCC.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \n\nL<perl(1)>, L<Net::DNS>, L<Net::", 8192) = 8192
09:01:57.284984 brk(0x15c5000)          = 0x15c5000
09:01:57.285483 read(14, "DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 4033, RFC 4034, RFC 4035.\n\n=cut\n", 8192) = 134
09:01:57.285541 read(14, "", 8192)      = 0
09:01:57.285588 close(14)               = 0
09:01:57.285676 stat("modules/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.285727 stat("modules/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.285776 stat("modules/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.285824 stat("modules/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.285873 stat("/etc/perl/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.285922 stat("/etc/perl/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.285971 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.286021 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.286089 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.286140 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.286191 stat("/usr/lib/perl5/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.286242 stat("/usr/lib/perl5/Net/DNS/RR/DLV.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.286293 stat("/usr/share/perl5/Net/DNS/RR/DLV.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.286344 stat("/usr/share/perl5/Net/DNS/RR/DLV.pm", {st_mode=S_IFREG|0644, st_size=928, ...}) = 0
09:01:57.286403 open("/usr/share/perl5/Net/DNS/RR/DLV.pm", O_RDONLY) = 14
09:01:57.286463 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.286509 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.286578 read(14, "package Net::DNS::RR::DLV;\n#\n# $Id: DLV.pm 580 2006-04-20 15:56:57Z olaf $\n#\nuse strict;\nBEGIN { \n    eval { require bytes; }\n} \nuse vars qw(@ISA $VERSION);\nuse Net::DNS::RR::DS;\n\n\n@ISA     = qw(Net::DNS::RR::DS);\n$VERSION = (qw$LastChangedRevision: 580 $)[1];\n\n\n\n=head1 NAME\n\nNet::DNS::RR::DLV - DNS DLV resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR>;\n\n=head1 DESCRIPTION\n\nThis is a clone of the DS record. This class therfore completely inherits\nall properties of the Net::DNS::RR::DS class.\n\nPlease see the L<Net::DNS::RR::DS> perldocumentation for details\n\n=head1 COPYRIGHT\n\nCopyright (c) 2005 Olaf Kolkman (NLnet Labs)\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC4431.\n\n\n=cut\n\n", 8192) = 928
09:01:57.286755 read(14, "", 8192)      = 0
09:01:57.286804 close(14)               = 0
09:01:57.286872 stat("modules/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.286923 stat("modules/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.286973 stat("modules/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287022 stat("modules/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.287071 stat("/etc/perl/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287120 stat("/etc/perl/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.287170 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287220 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.287271 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287322 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.287373 stat("/usr/lib/perl5/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287425 stat("/usr/lib/perl5/Net/DNS/RR/NSEC3.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.287477 stat("/usr/share/perl5/Net/DNS/RR/NSEC3.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.287527 stat("/usr/share/perl5/Net/DNS/RR/NSEC3.pm", {st_mode=S_IFREG|0644, st_size=13492, ...}) = 0
09:01:57.287586 open("/usr/share/perl5/Net/DNS/RR/NSEC3.pm", O_RDONLY) = 14
09:01:57.287640 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.287686 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.287741 read(14, "package Net::DNS::RR::NSEC3;\n# \n# $Id: NSEC3.pm 767 2008-12-24 10:02:25Z olaf $\n\nuse strict;\nrequire Exporter;\n\nuse vars qw(\n\t@ISA \n\t$VERSION \n\t@EXPORT_OK\n\t%digestbyname\n\t%digestbyval\n);\n\n\nuse Carp;\nuse bytes;\nuse MIME::Base64;\nuse MIME::Base32;\n\nuse Digest::SHA  qw(sha1 sha1_hex sha256 sha256_hex );\n\nuse Net::DNS qw( name2labels );\nuse Net::DNS::SEC;\nuse Net::DNS::Packet;\nuse Net::DNS::RR::NSEC;\n\n\n#http://www.iana.org/assignments/dnssec-nsec3-parameters\n%digestbyname = (\n\t\t\t\"SHA1\"\t\t   => 1,\t\t\n\t\t\t);      \n\n@EXPORT_OK= qw (\n\t\tname2hash\n               );\n\n\n# Inherit a couple of methods from NSEC.\n@ISA     = qw(Exporter Net::DNS::SEC Net::DNS::RR Net::DNS::RR::NSEC);\n\n\n\n$VERSION = do { my @r=(q$Revision: 510 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n\n    if ($self->{'rdlength'} > 0) {\n\n      # section 3.1 of NSEC3 specs\n      #                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n      #    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      #   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      #   | Hash Alg.     |  Flags Field  |          Iterations           |\n      #   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      #   |  Salt Length  |                     Salt                      /\n      #   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      #   |  Hash Length  |             Next Hashed Ownername             /\n      #   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      #   /                         Type Bit Maps                         /\n      #   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n      my $offsettoits=$offset+2;\n      my $offsettoflags=$offset+1;\n      my $offsettosaltlength=$offset+4;\n      my $offsettosalt=$offset+5;\n      $self->{'hashalgo'}=unpack(\"C\",substr($$data,$offset,1));\n      $self->{'flags'}=unpack(\"C\",substr($$data,$offsettoflags,1));\n      $self->{'iterations'}=unpack(\"n\",substr($$data,$offsettoits,3));\n\n      $self->{'saltlength'}=unpack(\"C\",substr($$data,$offsettosaltlength,1));\n      $self->{'saltbin'}=substr($$data,$offsettosalt,$self->{'saltlength'});\n      $self->{'salt'}= unpack(\"H*\",$self->{'saltbin'});\n\n      my $offsettohashlength= $offsettosalt+$self->{'saltlength'};\n      $self->{'hashlength'}=unpack(\"C\",substr($$data,$offsettohashlength,1));\n\n      $self->{'hnxtnamebin'}=substr($$data,$offsettohashlength+1,$self->{'hashlength'});\n      $self->{'hnxtname'}=MIME::Base32::encode  $self->{'hnxtnamebin'};\n      my $offsettotypebm=$offsettohashlength+1+$self->{'hashlength'};\n\n      my $typebm =substr($$data,$offsettotypebm, $self->{'rdlength'}-$offsettotypebm +$offset );\n\n\n      $self->{'typebm'}=$typebm;\n      $self->{'typelist'} = join \" \" \n\t,  Net::DNS::RR::NSEC::_typebm2typearray($typebm);\n      \n    }\n    bless $self, $class;\n    return $self;\n}\n\n\n\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    if ($string) {\n      $string =~ tr/()//d;\n      $string =~ s/;.*$//mg;\n      $string =~ s/\\n//mg;\n      \n      my ($hashalgo,$flags,$iterations,$salt,$hnxtname,$nxtstr)= \n\t$string =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)\\s+(\\S+)\\s?(.*)/;\n      my @nxttypes = split ' ' , $nxtstr;  # everything after last match...\n\n      bless $self, $class;\n\n      # This assumes that the digest type allocations follow the assignments as used for DS...\n\n      #overwrite the digestby name table used by Net::DNS::SEC digtype\n      $self->{'hashalgo'}=$self->digtype($hashalgo) || \n\t\t    return undef;\n      $self->{'flags'}=$flags;\n      $self->{'iterations'}=$iterations;\n      if ($salt eq '-') {$salt=''}; \n      $self->{'salt'}=$salt;\n      $self->{'saltbin'}=pack(\"H*\",$salt);\n      $self->{'saltlength'}=length $self->{saltbin}; \n\n      $self->{'hnxtname'}= Net::DNS::stripdot($hnxtname);\n      $self->{'hnxtnamebin'}=MIME::Base32::decode uc $hnxtname;\n\n      $self->{'typelist'}= join \" \" , sort @nxttypes ;\n      $self->{'typebm'}=Net::DNS::RR::NSEC::_typearray2typebm(@nxttypes);\n      \n    }\n    return $self;\n}\n\n\n\n\nsub rdatastr \n{\n   my $self = shift;\n   my $rdatastr;\n   if (exists $self->{hashalgo}) \n   {\n      $rdatastr .= $self->{hashalgo} .\" \";\n      $rdatastr .= $self->{flags}.\" \";\n      $rdatastr .= $self->{iterations}. \" \";\n      $rdatastr .=   $self->salt().\" \";\n\n      $rdatastr .= \"(\\n\\t\\t\\t\";\n      $rdatastr .= $self->{hnxtname} . \"\\n\";\n      $rdatastr .= \"\\t\\t\\t$self->{typelist} )\";\n   }\n   else \n   {\n      $rdatastr = \"; no data\"\n   }\n   $rdatastr\n}\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n\n    my $rdata = \"\" ;\n\n    if (exists $self->{'hnxtname'}) {\n      $rdata = pack(\"C\",$self->{'hashalgo'});\n      $rdata .= pack(\"C\", $self->{'flags'} );\n      $rdata .= pack(\"n\", $self->{'iterations'} );\n\n      unless( exists  $self->{'saltbin'}) {      \n\tif ($self->{'salt'} eq \"-\"){\n\t     $self->{'saltbin'}=\"\";\n\t}else{\n\t    $self->{'saltbin'}=pack(\"H*\",$self->{'salt'}) \n\t}\n      }\n      $rdata.= pack(\"C\",length($self->{'saltbin'}));\n      $rdata .= $self->{'saltbin'};\n\n      $self->{'hnxtnamebin'}=MIME::Base32::decode(uc $self->{'hnxtname'}) unless \n\t exists  $self->{'hnxtnamebin'} ;\n      $rdata.= pack(\"C\",length($self->{'hnxtnamebin'}));\n      $rdata .= $self->{'hnxtnamebin'};\n      $rdata .= $self->typebm();\n\n    }\n    return $rdata;\n}\n\n\nsub _normalize_dnames {\n\tmy $self=shift;\n\t$self->_normalize_ownername();\n\t$self->{'hnxtname'}= Net::DNS::stripdot($self->{'hnxtname'}) if defined $self->{'hnxtname'};\n\t$self->{'hnxtnamebin'}=MIME::Base32::decode(uc $self->{'hnxtname'});\n\n}\n\n\n\n\nsub salt {\n  my ($self,$salt)=@_;\n  if (defined $salt){\n    if ($salt eq \"-\"){\n      $self->{'salt'} = \"\" ;\n    }else{\n      $self->{'salt'} = $salt ;\n      unless ($salt =~ /^[0-9a-f]*$/i ) {\n\t# print \"input ($salt) not hex\" ; \n\treturn undef;\n      }\n      $self->{'saltbin'} = pack(\"H*\",$salt);\n    }\n  }\n  return \"-\" if ($self->{'salt'} eq \"\");\n  return $self->{'salt'};\n}\n\n\nsub name2hash {\n  my $hashalg=shift;\n  my $inname= lc shift;\n  my $iterations=shift;\n  my $saltbin=shift;\n\n  my  $hashfunc;\n  if ($hashalg==1){\n    $hashfunc = sub {my $x=shift ; return sha1($x)};\n  }elsif($hashalg==2){\n    $hashfunc = sub {my $x=shift ; return sha256($x)};\n  }else{\n    return;\n  }\n  my $wirename=Net::DNS::RR->_name2wire($inname);\n  my $i=0;\n  for (0..$iterations)\n    {\n      $wirename=&$hashfunc($wirename.$saltbin);\n    }\n  return lc MIME::Base32::encode $wirename;\n\n\n}\n\n\n\nsub ownername {\n\tmy $self=shift;\n\tif (defined $self->{'ownername'}){\n\t\treturn $self->{'ownername'};\n\t}else{\n\t\treturn $self->{'ownername'} = (name2labels($self->name))[0] ;\n\t}\n\t\n}\n\n\nsub _zonelabels {\n    # Extracts the labels that make up the zone from the owner name of the \n    # record, simply by stripping the first label.\n    # returns an array of labels in wire format.\n    my $self=shift;\n    unless (defined $self->{'zonelabels'}){\n\tmy @labels= (name2labels($self->name)) ;\n\tshift @labels;\n\t$self->{'zonelabels'} =  \\@labels ;\n\n    }\n    return @{$self->{'zonelabels'}};\n}\n\nsub _zone {\n    # Returns the result from the zonelabels method in presentation\n    # format (without trailing dot\n    my $self=shift;\n    my $name;\n    foreach my $label ($self->zonelabels){\n\t$name .= wire2presentation($label) . \".\";\n    }\n    chop($name);\n    return $name;\n}\n\n\nsub optout {\n    my ($self,$newval )= @_;\n    if (defined ($newval)) {\n\tif ($newval){\n\t    $self->{'flags'} |= hex(\"0x01\");\n\t}else{\n\t    $self->{'flags'} &= ~hex(\"0x01\");\n\t}\n    }\n\n    return $self->{'flags'} & hex(\"0x01\");\n}\n\n\n\n\t\nsub covered {\n    my $self=shift;\n    my $domainname=shift;\n\n    # first test if the domain name is in the NSEC zone.\n    my @domainlabels=name2labels($domainname);\n    my @zonelabels= $self->_zonelabels();\n\n    while (my $zlabel = pop @zonelabels ){\n\tmy $dlabel= pop @domainlabels;\n\treturn 0 unless ($dlabel eq $zlabel)\n    }\n\n    my $hashedname= Net::DNS::RR::NSEC3::name2hash(\n\t$self->hashalgo,\n\t$domainname,\n\t$self->iterations,\n\t$self->saltbin,\n\t);\n\n    if ( ($self->ownername() cmp $self->hnxtname() )== 1 ) {\n\t# last name in the zone.\n\treturn 1 if ( ( $hashedname cmp $self->hnxtname() ) == 1 );\n\tretur", 8192) = 8192
09:01:57.288263 stat("modules/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288317 stat("modules/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288366 stat("modules/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288414 stat("modules/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288468 stat("/etc/perl/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288519 stat("/etc/perl/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288568 stat("/usr/local/lib/perl/5.14.2/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288619 stat("/usr/local/lib/perl/5.14.2/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288669 stat("/usr/local/share/perl/5.14.2/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288720 stat("/usr/local/share/perl/5.14.2/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288771 stat("/usr/lib/perl5/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288820 stat("/usr/lib/perl5/MIME/Base32.pm", 0x7ffe12338b50) = -1 ENOENT (No such file or directory)
09:01:57.288869 stat("/usr/share/perl5/MIME/Base32.pmc", 0x7ffe12338c00) = -1 ENOENT (No such file or directory)
09:01:57.288920 stat("/usr/share/perl5/MIME/Base32.pm", {st_mode=S_IFREG|0644, st_size=2964, ...}) = 0
09:01:57.288978 open("/usr/share/perl5/MIME/Base32.pm", O_RDONLY) = 15
09:01:57.289030 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123388e0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.289076 lseek(15, 0, SEEK_CUR)  = 0
09:01:57.289143 read(15, "package MIME::Base32;\n\nrequire 5.005_62;\nuse strict;\nuse warnings;\n\nuse vars qw( $VERSION );\n\n\t$VERSION = '1.02'; # minor changes : added COPYRIGHT according to community request; test.pl - extended test string\n\n\nsub import\n{\n\tmy(\t\t$pkg, $arg\t\t)=@_;\n\tif( defined($arg) && $arg =~ /rfc|3548/i )\n\t{\n\t\t*encode = \\&encode_rfc3548;\n\t\t*decode = \\&decode_rfc3548;\n\t}\n\telse\n\t{\n\t\t*encode = \\&encode_09AV;\n\t\t*decode = \\&decode_09AV;\n\t}\n}\n\nsub encode_rfc3548{\t\t\t\n\n\t# base32:\n\t#\n\t#  modified base64 algorithm with\n\t#  32 characters set:  A - Z 2 - 7 compliant with: RFC-3548\n\t#\n\t\n\t\n\t$_ = shift @_;\n\tmy( $buffer, $l, $e );\n\n\t$_=unpack('B*', $_);\n\ts/(.....)/000$1/g;\n\t$l=length;\n\tif ($l & 7)\n\t{\n\t\t$e = substr($_, $l & ~7);\n\t\t$_ = substr($_, 0, $l & ~7);\n\t\t$_ .= \"000$e\" . '0' x (5 - length $e);\n\t}\n\t$_=pack('B*', $_);\n\ttr|\\0-\\37|A-Z2-7|;\n\t$_;\n}\n\nsub decode_rfc3548{\n        $_ = shift;\n        my( $l );\n\t\t\n        tr|A-Z2-7|\\0-\\37|;\n        $_=unpack('B*', $_);\n        s/000(.....)/$1/g;\n        $l=length;\n\t\t\t\t\t\n        # pouzije pouze platnou delku retezce\n        $_=substr($_, 0, $l & ~7) if $l & 7;\n\t\t\t\t\t\n        $_=pack('B*', $_);\n}\n\nsub encode_09AV{\t\t\t\n\n\t# base32:\n\t#\n\t#  modified base64 algorithm with\n\t#  32 characters set:  [0-9A-V] pre 1.00 backward compatibility\n\t#\n\t\n\t\n\t$_ = shift @_;\n\tmy( $buffer, $l, $e );\n\n\t$_=unpack('B*', $_);\n\ts/(.....)/000$1/g;\n\t$l=length;\n\tif ($l & 7)\n\t{\n\t\t$e = substr($_, $l & ~7);\n\t\t$_ = substr($_, 0, $l & ~7);\n\t\t$_ .= \"000$e\" . '0' x (5 - length $e);\n\t}\n\t$_=pack('B*', $_);\n\ttr|\\0-\\37|0-9A-V|;\n\t$_;\n}\n\nsub decode_09AV{\n        $_ = shift;\n        my( $l );\n\t\t\n        tr|0-9A-V|\\0-\\37|;\n        $_=unpack('B*', $_);\n        s/000(.....)/$1/g;\n        $l=length;\n\t\t\t\t\t\n        # pouzije pouze platnou delku retezce\n        $_=substr($_, 0, $l & ~7) if $l & 7;\n\t\t\t\t\t\n        $_=pack('B*', $_);\n}\n\n\n1;\n__END__\n\n=head1 NAME\n\nMIME::Base32 - Base32 encoder / decoder\n\n=head1 SYNOPSIS\n\n  # RFC forces the [A-Z2-7] RFC-3548 compliant encoding \n  # default encoding [0-9A-V] is for backward compatibility with pre v1.0\n  use MIME::Base32 qw( RFC ); \n  \n  $encoded = MIME::Base32::encode($text_or_binary_data);\n  $decoded = MIME::Base32::decode($encoded);\n\t\t\t\t\t \n=head1 DESCRIPTION\n\nEncode data similar way like MIME::Base64 does. \n  \nMain purpose is to create encrypted text used as id or key entry typed-or-submitted by user. It is upper/lowercase safe (not sensitive).\n\n=head1 EXPORT\n\nALLWAYS NOTHING\n\n=head1 AUTHOR\n\nDaniel Peder, sponsored by Infoset s.r.o., Czech Republic \n<Daniel.Peder@InfoSet.COM> http://www.infoset.com\n\n=head1 COPYRIGHT\n\nCopyright (c) 2003-2010 Daniel Peder.  All rights reserved.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n=head1 NOTE\n\nVersion 1.02 provides minor changes only: \n- added COPYRIGHT according to FEDORA & DEBIAN community requests\n- test.pl - extended test string (just for sure ;)\n\n=head1 SEE ALSO\n\nperl(1), MIME::Base64(3pm).\n\n=cut\n", 8192) = 2964
09:01:57.289553 brk(0x15e6000)          = 0x15e6000
09:01:57.289733 lseek(15, 1837, SEEK_SET) = 1837
09:01:57.289779 lseek(15, 0, SEEK_CUR)  = 1837
09:01:57.289824 close(15)               = 0
09:01:57.290750 read(14, "n 1 if ( ( $hashedname cmp $self->ownername() ) == -1  );\n    }\n    elsif ( ($self->ownername() cmp $self->hnxtname() )== 0 ) {\n\t# One entry in the zone.\n\treturn 1;\n    }else{\n\treturn 1 if ( ($self->ownername() cmp $hashedname) == -1  )\n\t    &&\n\t    ( ( $hashedname cmp $self->hnxtname() ) == -1 );\n    }\n    return 0;\n    \n}\n\n\n\nsub match {\n    my $self=shift;\n    my $domainname=shift;\n    my $ownername=$self->ownername();\n    my $hashedname= Net::DNS::RR::NSEC3::name2hash(\n\t$self->hashalgo,\n\t$domainname,\n\t$self->iterations,\n\t$self->saltbin\n\t);\n\n    return $ownername eq $hashedname;\n\n}\n\n\n\n\n\nsub digtype {\n    my $self=shift;\n    $self->{'digestbyname'}= \\%digestbyname;\n    $self->_digtype(@_);\n}\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::NSEC3 - DNS NSEC3 resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for DNS Address (NSEC3) resource records.\n\nThe NSEC3 Resource Record (RR) provides authenticated denial of\nexistence for DNS Resource Record Sets.  The NSEC3 RR lists RR types\npresent at the NSEC3 RR's original ownername.  It includes the next\nhashed ownername in the hash order of the zone.  The complete set of\nNSEC3 RRs in a zone indicates which RRsets exist for the original\nownername of the RRset and form a chain of hashed ownernames in the\nzone.\n\n\n\n=head1 METHODS\n\n=head2 ownername\n\nReturns the hashed value of the original owner name as contained in the first\nlabel of the ownername of the record. \n\n   The owner name for the NSEC3 RR is the base32 encoding of the hashed\n   owner name prepended as a single label to the name of the zone.\n\nIn other words the name(name) method returns the result of the\nownername() method prepended to the name of the containing zone.\n\n\n=head2 optout\n\nReads and sets the opt-out attribute.\n\n\n=head2 flags\n\nReads and sets the flag field. \n\n=head2 hashalgo\n\nReads and sets the hashalgo (hash algorithm) attribute. \n\n=head2 hnxtname\n\nReads and sets the hnxtname (hashed next ownername) attribute. \n\n=head2 typelist  (inhereted from NSEC)\n\n    print \"typelist\" = \", $rr->typelist, \"\\n\";\n\nReturns a string with the list of qtypes for which data exists for\nthis particular label.\n\n\n=head2 typebm  (inhereted from NSEC)\n\n    print \"typebm\" = \" unpack(\"B*\", $rr->typebm), \"\\n\";\n\nSame as the typelist but now in a representation  bitmap as in \nspecified in the RFC. This is not the kind of method you will need\non daily basis.\n\n\n=head2 covered, matched\n\n    print \"covered\" if $rr->covered{'example.foo'}\n\ncovered returns a nonzero value when the the domain name provided as argument\nis covered as defined in the NSEC3 specification:\n\n\n   To cover:  An NSEC3 RR is said to \"cover\" a name if the hash of the\n      name or \"next closer\" name falls between the owner name and the\n      next hashed owner name of the NSEC3.  In other words, if it proves\n      the nonexistence of the name, either directly or by proving the\n      nonexistence of an ancestor of the name.\n\n\n\n\nSimilarly ismatched returns a nonzero value when the domainname in the argument\nmatches as defined in the NSEC3 specification:\n\n   To match: An NSEC3 RR is said to \"match\" a name if the owner name\n      of the NSEC3 RR is the same as the hashed owner name of that\n      name.\n\n\n\n=head1 Functions\n\n=head2 name2hash\n\nTakes the hash identifyer (numeric), a fullyqualfied domain name, the\nnumber of iterations and a binary salt to compute the hash value used\nin the NSEC3 calculations.\n\n    $hashalg=Net::DNS::SEC->digtype(\"SHA1\");\n    $salt=pack(\"H*\",\"aabbccdd\");\n    $iterations=12;\n    $name=\"*.x.w.example\";\n\n    $hashedname= Net::DNS::RR::NSEC3::name2hash($hashalg,$name,$iterations,$salt);\n    print $hashedname;\nresults in:\n    92pqneegtaue7pjatc3l3qnk738c6v5m\n\nNormally the salt and itterations would be fetched from an NSEC3PARAM record.\n\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2007, 2008  NLnet Labs.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\nAcknowledgements to Roy Arends who made a test version for this class\nand whose code I've looked at before writing this module.\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \nL<http://www.iana.org/assignments/dnssec-nsec3-parameters>\nL<Net::DNS::RR::NSEC3PARAM>,\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC4033, RFC4034, RFC4035, RFC5155\n\n=cut\n", 8192) = 5300
09:01:57.291052 brk(0x1607000)          = 0x1607000
09:01:57.291191 read(14, "", 8192)      = 0
09:01:57.291239 close(14)               = 0
09:01:57.291322 stat("modules/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291374 stat("modules/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291424 stat("modules/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291473 stat("modules/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291523 stat("/etc/perl/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291573 stat("/etc/perl/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291623 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291674 stat("/usr/local/lib/perl/5.14.2/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291725 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291776 stat("/usr/local/share/perl/5.14.2/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291827 stat("/usr/lib/perl5/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291881 stat("/usr/lib/perl5/Net/DNS/RR/NSEC3PARAM.pm", 0x7ffe12339180) = -1 ENOENT (No such file or directory)
09:01:57.291932 stat("/usr/share/perl5/Net/DNS/RR/NSEC3PARAM.pmc", 0x7ffe12339230) = -1 ENOENT (No such file or directory)
09:01:57.291983 stat("/usr/share/perl5/Net/DNS/RR/NSEC3PARAM.pm", {st_mode=S_IFREG|0644, st_size=6120, ...}) = 0
09:01:57.292049 open("/usr/share/perl5/Net/DNS/RR/NSEC3PARAM.pm", O_RDONLY) = 14
09:01:57.292104 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338f10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.292150 lseek(14, 0, SEEK_CUR)  = 0
09:01:57.292211 read(14, "package Net::DNS::RR::NSEC3PARAM;\n\n# $Id: NSEC3.pm 602 2006-07-24 14:23:15Z olaf $\n\nuse strict;\nuse vars qw(@ISA $VERSION);\nuse Carp;\nuse bytes;\n\nuse Net::DNS;\nuse Net::DNS::SEC;\nuse Net::DNS::Packet;\nuse Net::DNS::RR::NSEC;\nuse Data::Dumper;\n\nuse Carp qw(cluck);\n\n\n# To be removed when finalized\n\n\n@ISA     = qw(Net::DNS::RR Net::DNS::RR::NSEC3);\n\n\n\n$VERSION = do { my @r=(q$Revision: 510 $=~/\\d+/g); sprintf \"%d.\".\"%03d\"x$#r,@r };\n\nsub new {\n    my ($class, $self, $data, $offset) = @_;\n\n\n    if ($self->{\"rdlength\"} > 0) {\n\n\n\t#                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n\t#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t#   | Hash Alg.     |  Flags Field  |         Iterations            |\n\t#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t#   |  Salt Length  |                     Salt                      /\n\t#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t#\n\t#   Hash Algorithm is a single octet.\n\t#\n\t#   Flags Field is a single octet.\n\t#\n\t#   Iterations is represented as a 16-bit integer, with the most\n\t#   significant bit first.\n\t#\n\t#   Salt Length represents the length of the following Salt field in\n\t#   octets.  If the value is zero, the Salt field is omitted.\n\n\n      my $offsettoflag=$offset+1;\n      my $offsettoits=$offset+2;\n      my $offesttosaltlength=$offset+4;\n      my $offsettosalt=$offset+5;\n\n      $self->{\"hashalgo\"}=unpack(\"C\",substr($$data,$offset,1));\n      $self->{\"flags\"}=unpack(\"C\",substr($$data,$offsettoflag,1));\n      $self->{\"iterations\"}= unpack(\"n\",substr($$data,$offsettoits,2));\n      $self->{\"saltlength\"}=unpack(\"C\",substr($$data,$offesttosaltlength,1));\n\n\n      $self->{\"saltbin\"}=substr($$data,$offsettosalt,$self->{\"saltlength\"});\n      $self->{\"salt\"}= unpack(\"H*\",$self->{\"saltbin\"});\n\n    }\n\n\n    \n    bless $self, $class;\n    return $self;\n}\n\n\n\n\nsub new_from_string {\n    my ($class, $self, $string) = @_;\n    bless $self, $class;\n\n    if ($string) {\n      $string =~ tr/()//d;\n      $string =~ s/;.*$//mg;\n      $string =~ s/\\n//mg;\n\n      my ($hashalgo,$flags,$iterations,$salt)= \n\t$string =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S*)\\s*$/;\n\n\n      # This assumes that the digest type allocations follow the assignments as used for DS...\n      defined($self->{'hashalgo'}=Net::DNS::SEC->digtype($hashalgo)) || \n\t\t    return undef;\n      defined($self->{'iterations'}=$iterations) || return undef;\n\n      defined($self->{'flags'}=$flags) || return undef;\n      \n      defined($self->{\"salt\"}=$self->salt($salt)) || return undef;\n      $self->{\"saltbin\"}=pack(\"H*\",$salt) || return undef;\n      $self->{saltlength}=length $self->{saltbin}; \n\n      \n    }\n    return $self;\n}\n\n\nsub rdatastr \n{\n   my $self = shift;\n   my $rdatastr;\n   if (exists $self->{hashalgo}) \n   {\n      $rdatastr .= $self->{hashalgo} .\" \";\n      $rdatastr .= $self->{flags}.\" \";\n      $rdatastr .= $self->{iterations}. \" \";\n      $rdatastr .=   $self->salt().\" \\n\";\n\n   }\n   else \n   {\n      $rdatastr = \"; no data\"\n   }\n   $rdatastr\n}\n\nsub rr_rdata {\n    my ($self, $packet, $offset) = @_;\n\n\n\n    my $rdata = \"\" ;\n\n    if (exists $self->{'hashalgo'}) {\n\n      $rdata = pack(\"C\",$self->{'hashalgo'});\n      $rdata .= pack(\"C\",$self->{'flags'});\n      $rdata .= pack(\"n\",$self->{'iterations'});\n      unless( exists  $self->{\"saltbin\"}) {      \n\tif ($self->{\"salt\"} eq \"-\"){\n\t  $self->{\"saltbin\"}=\"\";\n\t}else{\n\t  $self->{\"saltbin\"}=pack(\"H*\",$self->{\"salt\"}) \n\n\t}\n      }\n      $rdata .= pack(\"C\",length($self->{'saltbin'}));\n      $rdata .= $self->{'saltbin'};\n\n    }\n    \n    return $rdata;\n}\n\n\n\n\n\n1;\n\n\n=head1 NAME\n\nNet::DNS::RR::NSEC3PARAM - DNS NSEC3PARAM resource record\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::RR;>\n\n=head1 DESCRIPTION\n\nClass for DNS Address (NSEC3PARAM) resource records. \n\n\nThe NSEC3PARAM RR contains the NSEC3 parameters (hash algorithm,\nflags, iterations and salt) needed to calculate hashed ownernames.\nThe presence of an NSEC3PARAM RR at a zone apex indicates that the\nspecified parameters may be used by authoritative servers to choose an\nappropriate set of NSEC3 records for negative responses.\n\n\n\n=head1 METHODS\n\n=head2 hashalgo\n\nReads and sets the hashalgo (hash algorithm) attribute. \n\n=head2 flags\n\nReads and sets the flag field. Check the IANA registry for valid values.\nAt the time of code release the only defined value was 0x00\n\n=head2 iterations\n\nReads and sets the iterations field\n\n=head2 salt\n\nReads and sets the salt value. Accepts and returns a string with a\nnumber in hexadecimal notation.\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 2007,2008  NLnet Labs.  Author Olaf M. Kolkman <olaf@net-dns.org>\n\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of the author not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS; IN NO EVENT SHALL\nAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\nDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBased on, and contains, code by Copyright (c) 1997 Michael Fuhr.\n\nAcknowledgements to Roy Arends who made a test version for this class\nand whose code I've looked at before writing this module.\n\n=head1 SEE ALSO\n\nL<http://www.net-dns.org/> \nL<http://tools.ietf.org/wg/dnsext/draft-ietf-dnsext-nsec3>\nL<Net::DNS::RR::NSEC3>,\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC4033, RFC4034, RFC4035, RFC 5155\n\n=cut\n", 8192) = 6120
09:01:57.292999 read(14, "", 8192)      = 0
09:01:57.293049 close(14)               = 0
09:01:57.293439 read(13, "\t# This converts to known class and type if specified as TYPE###\n\t$rrtype  = Net::DNS::typesbyval(Net::DNS::typesbyname($rrtype))      if $rrtype  =~ m/^TYPE\\d+/o;\n\t$rrclass = Net::DNS::classesbyval(Net::DNS::classesbyname($rrclass)) if $rrclass =~ m/^CLASS\\d+/o;\n\n\n\tif (!$rrtype && $rrclass && $rrclass eq 'ANY') {\n\t\t$rrtype  = 'ANY';\n\t\t$rrclass = 'IN';\n\t} elsif (!$rrclass) {\n\t\t$rrclass = 'IN';\n\t}\n\n\t$rrtype ||= 'ANY';\n\t\n\n\tif ($update_type) {\n\t\t$update_type = lc $update_type;\n\t\t\n\t\tif ($update_type eq 'yxrrset') {\n\t\t\t$ttl     = 0;\n\t\t\t$rrclass = 'ANY' unless $rdata;\n\t\t} elsif ($update_type eq 'nxrrset') {\n\t\t\t$ttl     = 0;\n\t\t\t$rrclass = 'NONE';\n\t\t\t$rdata   = '';\n\t\t} elsif ($update_type eq 'yxdomain') {\n\t\t\t$ttl     = 0;\n\t\t\t$rrclass = 'ANY';\n\t\t\t$rrtype  = 'ANY';\n\t\t\t$rdata   = '';\n\t\t} elsif ($update_type eq 'nxdomain') {\n\t\t\t$ttl     = 0;\n\t\t\t$rrclass = 'NONE';\n\t\t\t$rrtype  = 'ANY';\n\t\t\t$rdata   = '';\n\t\t} elsif ($update_type =~ /^(rr_)?add$/o) {\n\t\t\t$ttl = 86400 unless $ttl;\n\t\t} elsif ($update_type =~ /^(rr_)?del(ete)?$/o) {\n\t\t\t$ttl     = 0;\n\t\t\t$rrclass = $rdata ? 'NONE' : 'ANY';\n\t\t}\n\t}\n\n\t# We used to check if $rrtype was defined at this point.  However,\n\t# we just defaulted it to ANY earlier....\n\n\tmy $self = {\n\t\t'name'     => $name,\n\t\t'type'     => $rrtype,\n\t\t'class'    => $rrclass,\n\t\t'ttl'      => $ttl,\n\t\t'rdlength' => 0,\n\t\t'rdata'    => '',\n\t};\n\n\tif ($RR{$rrtype} && $rdata !~ m/^\\s*\\\\#/o ) {\n\t\tmy $subclass = $class->_get_subclass($rrtype);\n\t\treturn $subclass->new_from_string($self, $rdata);\n\t} elsif ($RR{$rrtype}) {   # A RR type known to Net::DNS starting with \\#\n\t\t$rdata =~ m/\\\\\\#\\s+(\\d+)\\s+(.*)$/o;\n\n\t\tmy $rdlength = $1;\n\t\tmy $hexdump  = $2;\t\t\n\t\t$hexdump =~ s/\\s*//og;\n\n\t\tdie \"$rdata is inconsistent; length does not match content\" \n\t\t\tif length($hexdump) != $rdlength*2;\n\n\t\t$rdata = pack('H*', $hexdump);\n\t\n\t\treturn Net::DNS::RR->new_from_data(\n\t\t\t$name, \n\t\t\t$rrtype, \n\t\t\t$rrclass, \n\t\t\t$ttl, \n\t\t\t$rdlength, \n\t\t\t\\$rdata, \n\t\t\tlength($rdata) - $rdlength\n\t\t);\n\t} elsif ($rdata=~/\\s*\\\\\\#\\s+\\d+\\s+/o) {   \n\t\t#We are now dealing with the truly unknown.\n\t\tdie 'Expected RFC3597 representation of RDATA' \n\t\t\tunless $rdata =~ m/\\\\\\#\\s+(\\d+)\\s+(.*)$/o;\n\n\t\tmy $rdlength = $1;\n\t\tmy $hexdump  = $2;\t\t\n\t\t$hexdump =~ s/\\s*//og;\n\n\t\tdie \"$rdata is inconsistent; length does not match content\" \n\t\t\tif length($hexdump) != $rdlength*2;\n\n\t\t$rdata = pack('H*', $hexdump);\n\n\t\treturn Net::DNS::RR->new_from_data(\n\t\t\t$name,\n\t\t\t$rrtype,\n\t\t\t$rrclass,\n\t\t\t$ttl,\n\t\t\t$rdlength,\n\t\t\t\\$rdata,\n\t\t\tlength($rdata) - $rdlength\n\t\t);\n\t} else {  \n\t\t#God knows how to handle these... bless them in the RR class.\n\t\tbless $self, $class;\n\t\treturn $self\n\t}\n\t\n}\n\nsub new_from_hash {\n\tmy $class    = shift;\n\tmy %keyval   = @_;\n\tmy $self     = {};\n\n\n\n\twhile ( my ($key, $val) = each %keyval ) {\n\t        $self->{lc $key} = $val ;\n\t}\n\n\tcroak('RR name not specified') unless defined $self->{name};\n\tcroak('RR type not specified') unless defined $self->{type};\n\n\t$self->{'ttl'}   ||= 0;\n\t$self->{'class'} ||= 'IN';\n\n\t$self->{'rdlength'} = length $self->{'rdata'}\n\t\tif $self->{'rdata'};\n\n\tif ($RR{$self->{'type'}}) {\n\t\tmy $subclass = $class->_get_subclass($self->{'type'});\n\t    if (uc $self->{'type'} ne 'OPT') {\n\t\t        bless $self, $subclass;\n\t\t\t$self->_normalize_dnames();\n\t\t\treturn _normalize_rdata($self);\n\n\t    } else {  \n\t\t\t# Special processing of OPT. Since TTL and CLASS are\n\t\t\t# set by other variables. See Net::DNS::RR::OPT \n\t\t\t# documentation\n\t\t\treturn $subclass->new_from_hash($self);\n\t    }\n\t} elsif ($self->{'type'} =~ /TYPE\\d+/o) {\n\t\tbless $self, 'Net::DNS::RR::Unknown';\n\t\treturn $self;\n\t} else {\n\t \tbless $self, $class;\n\t \treturn $self;\n\t}\n}\n\n\n\n# Normalizes the content of the rdata so that comparing can be done between\n# RRs created via various methods.\n\n# Based on first creating packet format and then parsing it.\n\nsub _normalize_rdata {\n\tmy $self     = shift;\n\n\n\n\t# There are a bunch of META RR types we do not want to mess with\n\treturn $self if ( ( uc $self ->{'type'} eq \"TSIG\" )||\n\t\t\t  ( uc $self ->{'type'} eq \"TKEY\" )\n\t\t\t);\n\n\n\tmy $pkt = {\theader\t\t=> Net::DNS::Header->new,\n\t\t\tquestion\t=> [],\n\t\t\tanswer\t\t=> [],\n\t\t\tauthority\t=> [],\n\t\t\tadditional\t=> []\t};\n\t\n\tbless $pkt, \"Net::DNS::Packet\";\n\t$pkt->push( answer => $self );\n\tmy $pkt2 = Net::DNS::Packet->new( \\$pkt->data );\n\tundef ($self);\n\treturn ($pkt2->answer)[0];\n}\n\n# When new_from_hash is used to generate the objects then it may be\n# that the names passed are not consistently FQDN or not.  Note that\n# the internal storage is without trailing dot.  this function\n# normalizes the domain names and is implemented in the records\n# themselves if more specific handling is needed\n\nsub _normalize_dnames {\n\tmy $self=shift;\n\t$self->_normalize_ownername();\n}\n\n\nsub _normalize_ownername {\n\tmy $self=shift;\t\n\treturn $self->{'name'}=stripdot($self->{'name'});\n}\n\n\n=head2 parse\n\n    ($rrobj, $offset) = Net::DNS::RR->parse(\\$data, $offset);\n\nParses a DNS resource record at the specified location within a DNS packet.\nThe first argument is a reference to the packet data.\nThe second argument is the offset within the packet where the resource record begins.\n\nReturns a Net::DNS::RR object and the offset of the next location in the packet.\n\nParsing is aborted if the object could not be created (e.g., corrupt or insufficient data).\n\n=cut\n\nuse constant PACKED_LENGTH => length pack 'n2 N n', (0)x4;\n\nsub parse {\n\tmy ($objclass, $data, $offset) = @_;\n\n\tmy ($name, $index) = Net::DNS::Packet::dn_expand($data, $offset);\n\tdie 'Exception: corrupt or incomplete data' unless $index;\n\n\tmy $rdindex = $index + PACKED_LENGTH;\n\tdie 'Exception: incomplete data' if length $$data < $rdindex;\n\tmy ($type, $class, $ttl, $rdlength) = unpack(\"\\@$index n2 N n\", $$data);\n\n\tmy $next = $rdindex + $rdlength;\n\tdie 'Exception: incomplete data' if length $$data < $next;\n\n\t$type = Net::DNS::typesbyval($type) || $type;\n\n\t# Special case for OPT RR where CLASS should be\n\t# interpreted as 16 bit unsigned (RFC2671, 4.3)\n\tif ($type ne 'OPT') {\n\t\t$class = Net::DNS::classesbyval($class) || $class;\n\t}\n\t# else just retain numerical value\n\n\tmy $self = $objclass->new_from_data($name, $type, $class, $ttl, $rdlength, $data, $rdindex);\n\tdie 'Exception: corrupt or incomplete RR subtype data' unless defined $self;\n\n\treturn wantarray ? ($self, $next) : $self;\n}\n\n\n#\n# Some people have reported that Net::DNS dies because AUTOLOAD picks up\n# calls to DESTROY.\n#\nsub DESTROY {}\n\n=head2 print\n\n    $rr->print;\n\nPrints the record to the standard output.  Calls the B<string> method\nto get the RR's string representation.\n\n=cut\n#' someone said that emacs gets screwy here.  Who am I to claim otherwise...\n\nsub print {\tprint &string, \"\\n\"; }\n\n=head2 string\n\n    print $rr->string, \"\\n\";\n\nReturns a string representation of the RR.  Calls the B<rdatastr>\nmethod to get the RR-specific data. Domain names arereturned in\nRFC1035 format, i.e. all non letter, digit, hyphen characters are\nrepresented as \\DDD. Besides, all domain names are expanded to fully\nqualified domain names, with trailing dot.  This is in contrast to\naccessor methods of individual data elements in RR objects, like\nB<name>, which will not return the trailing dot.\n\n=cut\n\nsub string {\n\tmy $self = shift;\n\tmy $data = $self->rdatastr || '; no data';\n  \n\tjoin \"\\t\", \"$self->{name}.\", $self->{ttl}, $self->{class}, $self->{type}, $data;\n}\n\n=head2 rdatastr\n\n    $s = $rr->rdatastr;\n\nReturns a string containing RR-specific data.  Subclasses will need\nto implement this method.\n\n=cut\n\nsub rdatastr {\n\tmy $self = shift;\n\treturn exists $self->{'rdlength'}\n\t       ? \"; rdlength = $self->{'rdlength'}\"\n\t       : '';\n}\n\n=head2 name\n\n    $name = $rr->name;\n\nReturns the record's domain name.\n\n=head2 type\n\n    $type = $rr->type;\n\nReturns the record's type.\n\n=head2 class\n\n    $class = $rr->class;\n\nReturns the record's class.\n\n=cut\n\n# Used to AUTOLOAD this, but apparently some versions of Perl (specifically\n# 5.003_07, included with some Linux distributions) would return the\n# class the object was blessed into, instead of the RR's class.\n\nsub class {\n\tmy $self = shift;\n\n\tif (@_) {\n\t\t$self->{'class'} = shift;\n\t} elsif (!exists $self->{'class'}) {\n\t\tCarp::carp('class: no such method');\n\t\treturn undef;\n\t}\n\treturn $self->{'cl", 8192) = 8192
09:01:57.294451 brk(0x1628000)          = 0x1628000
09:01:57.294660 read(13, "ass'};\n}\n\t\n\n=head2 ttl\n\n    $ttl = $rr->ttl;\n\nReturns the record's time-to-live (TTL).\n\n=head2 rdlength\n\n    $rdlength = $rr->rdlength;\n\nReturns the length of the record's data section.\n\n=head2 rdata\n\n    $rdata = $rr->rdata\n\nReturns the record's data section as binary data.\n\n=cut\n#'\nsub rdata {\n\tmy $self = shift;\n\tmy $retval = undef;\n\n\tif (@_ == 2) {\n\t\tmy ($packet, $offset) = @_;\n\t\t$retval = $self->rr_rdata($packet, $offset);\n\t}\n\telsif (exists $self->{'rdata'}) {\n\t\t$retval = $self->{'rdata'};\n\t}\n\n\treturn $retval;\n}\n\nsub rr_rdata {\n\tmy $self = shift;\n\treturn exists $self->{'rdata'} ? $self->{'rdata'} : '';\n}\n\n#------------------------------------------------------------------------------\n# sub data\n#\n# This method is called by Net::DNS::Packet->data to get the binary\n# representation of an RR.\n#------------------------------------------------------------------------------\n\nsub data {\n\tmy ($self, $packet, $offset) = @_;\n\tmy $data;\n\n\n\t# Don't compress TSIG or TKEY names and don't mess with EDNS0 packets\n\tif (uc($self->{'type'}) eq 'TSIG' || uc($self->{'type'}) eq 'TKEY') {\n\t\tmy $tmp_packet = Net::DNS::Packet->new();\n\t\t$data = $tmp_packet->dn_comp($self->{'name'}, 0);\n\t\treturn undef unless defined $data;\n\t} elsif (uc($self->{'type'}) eq 'OPT') {\n\t\tmy $tmp_packet = Net::DNS::Packet->new();\n\t\t$data = $tmp_packet->dn_comp('', 0);\n\t} else {\n\t\t$data  = $packet->dn_comp($self->{'name'}, $offset);\n\t\treturn undef unless defined $data;\t\n\t}\n\n\tmy $qtype     = uc($self->{'type'});\n\tmy $qtype_val = ($qtype =~ m/^\\d+$/o) ? $qtype : Net::DNS::typesbyname($qtype);\n\t$qtype_val    = 0 if !defined($qtype_val);\n\n\tmy $qclass     = uc($self->{'class'});\n\tmy $qclass_val = ($qclass =~ m/^\\d+$/o) ? $qclass : Net::DNS::classesbyname($qclass);\n\t$qclass_val    = 0 if !defined($qclass_val);\n\t$data .= pack('n', $qtype_val);\n\t\n\t# If the type is OPT then class will need to contain a decimal number\n\t# containing the UDP payload size. (RFC2671 section 4.3)\n\tif (uc($self->{'type'}) ne 'OPT') {\n\t    $data .= pack('n', $qclass_val);\n\t} else {\n\t    $data .= pack('n', $self->{'class'});\n\t}\n\t\n\t$data .= pack('N', $self->{'ttl'});\n\n\t$offset += length($data) + &Net::DNS::INT16SZ;\t# allow for rdlength\n\n\tmy $rdata = $self->rdata($packet, $offset);\n\n\t$data .= pack('n', length $rdata);\n\t$data.=$rdata;\n\n\treturn $data;\n}\n\n\n\n\n\n#------------------------------------------------------------------------------\n#  This method is called by SIG objects verify method. \n#  It is almost the same as data but needed to get an representation of the\n#  packets in wire format withoud domain name compression.\n#  It is essential to DNSSEC RFC 2535 section 8\n#------------------------------------------------------------------------------\n\nsub _canonicaldata {\n\tmy $self = shift;\n\tmy $data='';\n\t{   \n\t    my $name=$self->{'name'};\n\t    my @dname=Net::DNS::name2labels($name);\n\t    for (my $i=0;$i<@dname;$i++){\n\t\t$data .= pack ('C',length $dname[$i] );\n\t\t$data .= lc($dname[$i] );\n\t    }\n\t    $data .= pack ('C','0');\n\t}\n\t$data .= pack('n', Net::DNS::typesbyname(uc($self->{'type'})));\n\t$data .= pack('n', Net::DNS::classesbyname(uc($self->{'class'})));\n\t$data .= pack('N', $self->{'ttl'});\n\t\n\t\n\tmy $rdata = $self->_canonicalRdata;\n\t\n\t$data .= pack('n', length $rdata);\n\t$data .= $rdata;\n\treturn $data;\n\n\n}\n\n# These are methods that are used in the DNSSEC context...  Some RR\n# have domain names in them. Verification works only on RRs with\n# uncompressed domain names. (Canonical format as in sect 8 of\n# RFC2535) _canonicalRdata is overwritten in those RR objects that\n# have domain names in the RDATA and _name2wire is used to convert a\n# domain name to \"wire format\"\n\n\nsub _canonicalRdata {\n    my $self=shift;\n    my $packet=Net::DNS::Packet->new();\n    my $rdata = $self->rr_rdata($packet,0);\n    return $rdata;\n}\n\n\n\n\n\nsub _name2wire   {   \n    my ($self, $name) = @_;\n\n    my $rdata=\"\";\n    my $compname = \"\";\n    my @dname = Net::DNS::name2labels($name);\n\n\n    for (@dname) {\n\t\t$rdata .= pack('C', length $_);\n\t\t$rdata .= $_ ;\n    }\n    \n    $rdata .= pack('C', '0');\n    return $rdata;\n}\n\n\n\n\n\nsub AUTOLOAD {\n\tmy ($self) = @_;  # If we do shift here, it will mess up the goto below.\n\tmy ($name) = $AUTOLOAD =~ m/^.*::(.*)$/o;\n\tif ($name =~ /set_rrsort_func/){\n\t    return Net::DNS::RR::set_rrsort_func(@_);\n\t}\n\tif ($name =~ /get_rrsort_func/){\n\t    return Net::DNS::RR::get_rrsort_func(@_);\n\t}\n\t# XXX -- We should test that we do in fact carp on unknown methods.\t\n\tunless (exists $self->{$name}) {\n\t    my $rr_string = $self->string;\n\t    Carp::carp(<<\"AMEN\");\n\t    \n***\n***  WARNING!!!  The program has attempted to call the method\n***  \"$name\" for the following RR object:\n***\n***  $rr_string\n***\n***  This object does not have a method \"$name\".  THIS IS A BUG\n***  IN THE CALLING SOFTWARE, which has incorrectly assumed that\n***  the object would be of a particular type.  The calling\n***  software should check the type of each RR object before\n***  calling any of its methods.\n***\n***  Net::DNS has returned undef to the caller.\n*** \n\nAMEN\nreturn;\n\t}\n\t\n\tno strict q/refs/;\n\t\n\t# Build a method in the class.\n\t*{$AUTOLOAD} = sub {\n\t    my ($self, $new_val) = @_;\n\t    \n\t    if (defined $new_val) {\n\t\t$self->{$name} = $new_val;\n\t    }\n\t    \n\t    return $self->{$name};\n\t};\n\t\n\t# And jump over to it.\n\tgoto &{$AUTOLOAD};\n}\n\n\n\n#\n#  Net::DNS::RR->_get_subclass($type)\n#\n# Return a subclass, after loading a subclass (if needed)\n#\nsub _get_subclass {\n\tmy ($class, $type) = @_;\n\t\n\treturn unless $type and $RR{$type};\n\t\n\tmy $subclass = join('::', $class, $type);\n\t\n\tunless ($_LOADED{$subclass}) {\n\t\teval \"require $subclass\";\n\t\tdie $@ if $@;\n\t\t$_LOADED{$subclass}++;\n\t}\n\t\n\treturn $subclass;\n}\t\n\n\n\n\n=head1 Sorting of RR arrays\n\nAs of version 0.55 there is functionality to help you sort RR\narrays. The sorting is done by Net::DNS::rrsort(), see the\nL<Net::DNS> documentation. This package provides class methods to set\nthe sorting functions used for a particular RR based on a particular\nattribute.\n\n\n=head2 set_rrsort_func\n\nNet::DNS::RR::SRV->set_rrsort_func(\"priority\",\n\t\t\t       sub {\n\t\t\t\t   my ($a,$b)=($Net::DNS::a,$Net::DNS::b);\n\t\t\t\t   $a->priority <=> $b->priority\n\t\t\t\t   ||\n\t\t\t\t   $b->weight <=> $a->weight\n                     }\n\nNet::DNS::RR::SRV->set_rrsort_func(\"default_sort\",\n\t\t\t       sub {\n\t\t\t\t   my ($a,$b)=($Net::DNS::a,$Net::DNS::b);\n\t\t\t\t   $a->priority <=> $b->priority\n\t\t\t\t   ||\n\t\t\t\t   $b->weight <=> $a->weight\n                     }\n\nset_rrsort_func needs to be called as a class method. The first\nargument is the attribute name on which the sorting will need to take\nplace. If you specify \"default_sort\" than that is the sort algorithm\nthat will be used in the case that rrsort() is called without an RR\nattribute as argument.\n\nThe second argument is a reference to a function that uses the\nvariables $a and $b global to the C<from Net::DNS>(!!)package for the\nsorting. During the sorting $a and $b will contain references to\nobjects from the class you called the set_prop_sort from. In other\nwords, you can rest assured that the above sorting function will only\nget Net::DNS::RR::SRV objects.\n\nThe above example is the sorting function that actually is implemented in \nSRV.\n\n=cut\n\n\n\n\nsub set_rrsort_func{\n    my $class=shift;\n    my $attribute=shift;\n    my $funct=shift;\n#    print \"Using \".__PACKAGE__.\"set_rrsort: $class\\n\";\n    my ($type) = $class =~ m/^.*::(.*)$/o;\n    $Net::DNS::RR::rrsortfunct{$type}{$attribute}=$funct;\n}\n\t\t\nsub get_rrsort_func {\n    my $class=shift;    \n    my $attribute=shift;  #can be undefined.\n    my $sortsub;\n    my ($type) = $class =~ m/^.*::(.*)$/o;\n\n\n#    print \"Using \".__PACKAGE__.\" get_rrsort: $class ($type,$attribute)\\n\";\n#    use Data::Dumper;\n#    print Dumper %Net::DNS::rrsortfunct;\n\n    if (defined($attribute) &&\n\texists($Net::DNS::RR::rrsortfunct{$type}) &&\n\texists($Net::DNS::RR::rrsortfunct{$type}{$attribute})\n\t){\n\t#  The default overwritten by the class variable in Net::DNS\n\treturn $Net::DNS::RR::rrsortfunct{$type}{$attribute};\n    }elsif(\n\t! defined($attribute) &&\n\texists($Net::DNS::RR::rrsortfunct{$type}) &&\n\texists($Net::DNS::RR::rrsortfunct{$type}{'default_sort'})\n\t){\n\t#  The default overwritten by the class variable in Net::DN", 8192) = 8192
09:01:57.295714 read(13, "S\n\treturn $Net::DNS::RR::rrsortfunct{$type}{'default_sort'};\n    }\n    elsif( defined($attribute) ){\n\t\n\treturn sub{\n\t    my ($a,$b)=($Net::DNS::a,$Net::DNS::b);\n\t    ( exists($a->{$attribute}) &&   \n\t      $a->{$attribute} <=> $b->{$attribute})\n\t\t||\n\t\t$a->_canonicaldata() cmp $b->_canonicaldata()\n\t};\n    }else{\n\treturn sub{\n\t    my ($a,$b)=($Net::DNS::a,$Net::DNS::b);\n\t    $a->_canonicaldata() cmp $b->_canonicaldata()\n\t};\n    }    \n\n    return $sortsub;\n}\n\n\n\n\n\n\t\nsub STORABLE_freeze {\n\tmy ($self, $cloning) = @_;\n\n\treturn if $cloning;\n\t\n\treturn ('', {%$self});\n}\n\nsub STORABLE_thaw {\n\tmy ($self, $cloning, undef, $data) = @_;\n\n\t%{$self}  = %{$data};\n\t\n\t__PACKAGE__->_get_subclass($self->{'type'});\n\t\n\treturn $self;\n}\n\n=head1 BUGS\n\nThis version of C<Net::DNS::RR> does little sanity checking on user-created\nRR objects.\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nPortions Copyright (c) 2005-2007 Olaf Kolkman \n\nPortions Copyright (c) 2007 Dick Franks \n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\nEDNS0 extensions by Olaf Kolkman.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Update>, L<Net::DNS::Header>, L<Net::DNS::Question>,\nRFC 1035 Section 4.1.3\n\n=cut\n\n1;\n", 8192) = 1374
09:01:57.295944 brk(0x1649000)          = 0x1649000
09:01:57.296031 read(13, "", 8192)      = 0
09:01:57.296079 close(13)               = 0
09:01:57.296808 read(12, "count != 1 ? 's' : '';\n\t$string .= join \"\\n\", \"\\n\\n;; $authority SECTION ($nscount record$nss)\", @authority;\n\n\tmy @additional = map{$_->string} $self->additional;\n\tmy $arcount = @additional;\n\tmy $ars = $arcount != 1 ? 's' : '';\n\t$string .= join \"\\n\", \"\\n\\n;; ADDITIONAL SECTION ($arcount record$ars)\", @additional;\n\n\treturn $string.\"\\n\\n\";\n}\n\n=head2 answerfrom\n\n    print \"packet received from \", $packet->answerfrom, \"\\n\";\n\nReturns the IP address from which we received this packet.  User-created\npackets will return undef for this method.\n\n=cut\n\nsub answerfrom {\n\tmy $self = shift;\n\n\treturn $self->{answerfrom} = shift if @_;\n\n\treturn $self->{answerfrom};\n}\n\n=head2 answersize\n\n    print \"packet size: \", $packet->answersize, \" bytes\\n\";\n\nReturns the size of the packet in bytes as it was received from a\nnameserver.  User-created packets will return undef for this method\n(use C<< length $packet->data >> instead).\n\n=cut\n\nsub answersize {\n\treturn shift->{answersize};\n}\n\n=head2 push\n\n    $ancount = $packet->push(pre        => $rr);\n    $nscount = $packet->push(update     => $rr);\n    $arcount = $packet->push(additional => $rr);\n\n    $nscount = $packet->push(update => $rr1, $rr2, $rr3);\n    $nscount = $packet->push(update => @rr);\n\nAdds RRs to the specified section of the packet.\n\nReturns the number of resource records in the specified section.\n\n\n=cut\n\nsub push {\n\tmy $self = shift;\n\tmy $section = lc shift || '';\n\tmy @rr = map{ref $_ ? $_ : ()} @_;\n\n\tmy $hdr = $self->{header};\n\tfor ( $section ) {\n\t\treturn $hdr->qdcount(push(@{$self->{question}}, @rr)) if /^question/;\n\n\t\tif ( $hdr->opcode eq 'UPDATE' ) {\n\t\t\tmy ($zone) = $self->zone;\n\t\t\tmy $zclass = $zone->zclass;\n\t\t\tforeach ( @rr ) {\n\t\t\t\t$_->class($zclass) unless $_->class =~ /ANY|NONE/;\n\t\t\t}\n\t\t}\n\n\t\treturn $hdr->ancount(push(@{$self->{answer}}, @rr)) if /^ans|^pre/;\n\t\treturn $hdr->nscount(push(@{$self->{authority}}, @rr)) if /^auth|^upd/;\n\t\treturn $hdr->adcount(push(@{$self->{additional}}, @rr)) if /^add/;\n\t}\n\n\tcarp qq(invalid section \"$section\");\n\treturn undef;\t# undefined record count\n}\n\n\n=head2 unique_push\n\n    $ancount = $packet->unique_push(pre        => $rr);\n    $nscount = $packet->unique_push(update     => $rr);\n    $arcount = $packet->unique_push(additional => $rr);\n\n    $nscount = $packet->unique_push(update => $rr1, $rr2, $rr3);\n    $nscount = $packet->unique_push(update => @rr);\n\nAdds RRs to the specified section of the packet provided that \nthe RRs do not already exist in the packet.\n\nReturns the number of resource records in the specified section.\n\n=cut\n\nsub unique_push {\n\tmy $self = shift;\n\tmy $section = shift;\n\tmy @rr = map{ref $_ ? $_ : ()} @_;\n\n\tmy @unique = map{$self->{seen}->{ (lc $_->name) . $_->class . $_->type  . $_->rdatastr }++ ? () : $_} @rr;\n\n\treturn $self->push($section, @unique);\n}\n\n=head2 safe_push\n\nA deprecated name for C<unique_push()>.\n\n=cut\n\nsub safe_push {\n\tcarp('safe_push() is deprecated, use unique_push() instead,');\n\t&unique_push;\n}\n\t\n\n=head2 pop\n\n    my $rr = $packet->pop(\"pre\");\n    my $rr = $packet->pop(\"update\");\n    my $rr = $packet->pop(\"additional\");\n    my $rr = $packet->pop(\"question\");\n\nRemoves RRs from the specified section of the packet.\n\n=cut\n\nsub pop {\n\tmy $self = shift;\n\tmy $section = lc shift || '';\n\n\tfor ( $section ) {\n\t\treturn pop(@{$self->{answer}}) if /^ans|^pre/;\n\t\treturn pop(@{$self->{question}}) if /^question/;\n\n\t\t$self->additional if $self->{buffer};\t# parse remaining data\n\n\t\treturn pop(@{$self->{authority}}) if /^auth|^upd/;\n\t\treturn pop(@{$self->{additional}}) if /^add/;\n\t}\n\n\tcarp qq(invalid section \"$section\");\n\treturn undef;\n}\n\n\n=head2 dn_comp\n\n    $compname = $packet->dn_comp(\"foo.example.com\", $offset);\n\nReturns a domain name compressed for a particular packet object, to\nbe stored beginning at the given offset within the packet data.  The\nname will be added to a running list of compressed domain names for\nfuture use.\n\n=cut\n\nsub dn_comp {\n\tmy ($self, $name, $offset) = @_;\n\t# The Exporter module does not seem to catch this baby...\n\tmy @names=Net::DNS::name2labels($name);\n\tmy $namehash = $self->{compnames};\n\tmy $compname='';\n\n\twhile (@names) {\n\t\tmy $dname = join('.', @names);\n\n\t\tif ( my $pointer = $namehash->{$dname} ) {\n\t\t\t$compname .= pack('n', 0xc000 | $pointer);\n\t\t\tlast;\n\t\t}\n\t\t$namehash->{$dname} = $offset if ($offset < 0x4000);\n\n\t\tmy $label  = shift @names;\n\t\tmy $length = length $label || next;\t# skip if null\n\t\tif ( $length > 63 ) {\n\t\t\t$length = 63;\n\t\t\t$label = substr($label, 0, $length);\n\t\t\tcarp \"\\n$label...\\ntruncated to $length octets (RFC1035 2.3.1)\";\n\t\t}\n\t\t$compname .= pack('C a*', $length, $label);\n\t\t$offset   += $length + 1;\n\t}\n\n\t$compname .= pack('C', 0) unless @names;\n\n\treturn $compname;\n}\n\n=head2 dn_expand\n\n    use Net::DNS::Packet qw(dn_expand);\n    ($name, $nextoffset) = dn_expand(\\$data, $offset);\n\n    ($name, $nextoffset) = Net::DNS::Packet::dn_expand(\\$data, $offset);\n\nExpands the domain name stored at a particular location in a DNS\npacket.  The first argument is a reference to a scalar containing\nthe packet data.  The second argument is the offset within the\npacket where the (possibly compressed) domain name is stored.\n\nReturns the domain name and the offset of the next location in the\npacket.\n\nReturns B<(undef)> if the domain name couldn't be expanded.\n\n=cut\n# '\n\n# This is very hot code, so we try to keep things fast.  This makes for\n# odd style sometimes.\n\nsub dn_expand {\n#FYI\tmy ($packet, $offset) = @_;\n\treturn dn_expand_XS(@_) if $Net::DNS::HAVE_XS;\n#\twarn \"USING PURE PERL dn_expand()\\n\";\n\treturn dn_expand_PP(@_, {} );\t# $packet, $offset, anonymous hash\n}\n\nsub dn_expand_PP {\n\tmy ($packet, $offset, $visited) = @_;\n\tmy $packetlen = length $$packet;\n\tmy $name = '';\n\n\twhile ( $offset < $packetlen ) {\n\t\tunless ( my $length = unpack(\"\\@$offset C\", $$packet) ) {\n\t\t\t$name =~ s/\\.$//o;\n\t\t\treturn ($name, ++$offset);\n\n\t\t} elsif ( ($length & 0xc0) == 0xc0 ) {\t\t# pointer\n\t\t\tmy $point = 0x3fff & unpack(\"\\@$offset n\", $$packet);\n\t\t\tdie 'Exception: unbounded name expansion' if $visited->{$point}++;\n\n\t\t\tmy ($suffix) = dn_expand_PP($packet, $point, $visited);\n\n\t\t\treturn ($name.$suffix, $offset+2) if defined $suffix;\n\n\t\t} else {\n\t\t\tmy $element = substr($$packet, ++$offset, $length);\n\t\t\t$name .= Net::DNS::wire2presentation($element).'.';\n\t\t\t$offset += $length;\n\t\t}\n\t}\n\treturn undef;\n}\n\n=head2 sign_tsig\n\n    $key_name = \"tsig-key\";\n    $key      = \"awwLOtRfpGE+rRKF2+DEiw==\";\n\n    $update = Net::DNS::Update->new(\"example.com\");\n    $update->push(\"update\", rr_add(\"foo.example.com A 10.1.2.3\"));\n\n    $update->sign_tsig($key_name, $key);\n\n    $response = $res->send($update);\n\nSigns a packet with a TSIG resource record (see RFC 2845).  Uses the\nfollowing defaults:\n\n    algorithm   = HMAC-MD5.SIG-ALG.REG.INT\n    time_signed = current time\n    fudge       = 300 seconds\n\nIf you wish to customize the TSIG record, you'll have to create it\nyourself and call the appropriate Net::DNS::RR::TSIG methods.  The\nfollowing example creates a TSIG record and sets the fudge to 60\nseconds:\n\n    $key_name = \"tsig-key\";\n    $key      = \"awwLOtRfpGE+rRKF2+DEiw==\";\n\n    $tsig = Net::DNS::RR->new(\"$key_name TSIG $key\");\n    $tsig->fudge(60);\n\n    $query = Net::DNS::Packet->new(\"www.example.com\");\n    $query->sign_tsig($tsig);\n\n    $response = $res->send($query);\n\nYou shouldn't modify a packet after signing it; otherwise authentication\nwill probably fail.\n\n=cut\n\nsub sign_tsig {\n\tmy $self = shift;\n\tmy $tsig = shift || return undef;\n\n\tunless ( ref $tsig && ($tsig->type eq \"TSIG\") ) {\n\t\tmy $key = shift || return undef;\n\t\t$tsig = Net::DNS::RR->new(\"$tsig TSIG $key\");\n\t}\n\n\t$self->push('additional', $tsig) if $tsig;\n\treturn $tsig;\n}\n\n\n\n=head2 sign_sig0\n\nSIG0 support is provided through the Net::DNS::RR::SIG class. This class is not part\nof the default Net::DNS distribution but resides in the Net::DNS::SEC distribution.\n\n    $update = Net::DNS::Update->new(\"example.com\");\n    $update->push(\"update\", rr_add(\"foo.example.com A 10.1.2.3\"));\n    $update->sign_sig0(\"Kexample.com+003+25317.private\");\n\n\nSIG0 support is experimental see Net::DNS::RR::SIG for details.\n\nThe method will call C<Carp::croak()> if Net::DNS::RR::SIG cannot be found.\n\n\n=cut\n\nsub sign_sig0 {\n\tmy $self =", 8192) = 8192
09:01:57.297419 brk(0x166a000)          = 0x166a000
09:01:57.297915 read(12, " shift;\n\tmy $arg = shift || return undef;\n\tmy $sig0;\n\t\n\tcroak('sign_sig0() is only available when Net::DNS::SEC is installed') \n\t\tunless $Net::DNS::DNSSEC;\n\t\n\tif ( ref $arg ) {\n\t\tif ( UNIVERSAL::isa($arg,'Net::DNS::RR::SIG') ) {\n\t\t\t$sig0 = $arg;\n\t\t\n\t\t} elsif ( UNIVERSAL::isa($arg,'Net::DNS::SEC::Private') ) {\n\t\t\t$sig0 = Net::DNS::RR::SIG->create('', $arg);\n\t\t\n\t\t} elsif ( UNIVERSAL::isa($arg,'Net::DNS::RR::SIG::Private') ) {\n\t\t\tcarp ref($arg).' is deprecated - use Net::DNS::SEC::Private instead';\n\t\t\t$sig0 = Net::DNS::RR::SIG->create('', $arg);\n\n\t\t} else {\n\t\t\tcroak 'Incompatible class as argument to sign_sig0: '.ref($arg);\n\n\t\t}\n\n\t} else {\n\t\t$sig0 = Net::DNS::RR::SIG->create('', $arg);\n\t}\n\t\n\t$self->push('additional', $sig0) if $sig0;\n\treturn $sig0;\n}\n\n=head2 truncate\n\nThe truncate method takes a maximum length as argument and then tries\nto truncate the packet an set the TC bit according to the rules of\nRFC2181 Section 9.\n\nThe minimum maximum length that is honored is 512 octets.\n\n=cut\n\n# From RFC2181:\n#9. The TC (truncated) header bit\n#\n#   The TC bit should be set in responses only when an RRSet is required\n#   as a part of the response, but could not be included in its entirety.\n#   The TC bit should not be set merely because some extra information\n#   could have been included, but there was insufficient room.  This\n#   includes the results of additional section processing.  In such cases\n#   the entire RRSet that will not fit in the response should be omitted,\n#   and the reply sent as is, with the TC bit clear.  If the recipient of\n#   the reply needs the omitted data, it can construct a query for that\n#   data and send that separately.\n#\n#   Where TC is set, the partial RRSet that would not completely fit may\n#   be left in the response.  When a DNS client receives a reply with TC\n#   set, it should ignore that response, and query again, using a\n#   mechanism, such as a TCP connection, that will permit larger replies.\n\n# Code inspired on a contribution from Aaron Crane via rt.cpan.org 33547\n\nsub truncate {\n\tmy $self=shift;\n\tmy $max_len=shift;\n\tmy $debug=0;\n\t$max_len=$max_len>512?$max_len:512;\n\n\tprint \"Truncating to $max_len\\n\" if $debug;\n\n\tif (length $self->data() > $max_len) {\n\t\t# first remove data from the additional section\n\t\twhile (length $self->data() > $max_len){\n\t\t\t# first remove _complete_ RRstes from the additonal section.\n\t\t\tmy $popped= CORE::pop(@{$self->{'additional'}});\n\t\t\tlast unless defined($popped);\n\t\t\tprint \"Removed \".$popped->string.\" from additional \\n\" if $debug;\n\t\t\tmy $i=0;\n\t\t\tmy @stripped_additonal;\n\n\t\t\twhile ($i< @{$self->{'additional'}}){\n\t\t\t\t#remove all of these same RRtypes\n\t\t\t\tif  (\n\t\t\t\t    ${$self->{'additional'}}[$i]->type eq $popped->type &&\n\t\t\t\t    ${$self->{'additional'}}[$i]->name eq $popped->name &&\n\t\t\t\t    ${$self->{'additional'}}[$i]->class eq $popped->class ){\n\t\t\t\t\tprint \"       Also removed \". ${$self->{'additional'}}[$i]->string.\" from additonal \\n\" if $debug;\t\t\t\t}else{\n\t\t\t\t\tCORE::push @stripped_additonal,  ${$self->{'additional'}}[$i];\n\t\t\t\t}\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\t$self->{'additional'}=\\@stripped_additonal;\n\t\t}\n\t\t\n\t\treturn $self if length $self->data <= $max_len;\n\t\t\n      \t\tmy @sections = qw<authority answer question>;\n\t\twhile (@sections) {\n\t\t\twhile (my $popped=$self->pop($sections[0])) {\n\t\t\t\tlast unless defined($popped);\n\t\t\t\tprint \"Popped \".$popped->string.\" from the $sections[0] section\\n\" if $debug;\n\t\t\t\t$self->header->tc(1);\n\t\t\t\treturn $self if length $self->data <= $max_len;\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tshift @sections;\n\t\t}\n\t}\n\treturn $self;\n}\n\n\n\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nPortions Copyright (c) 2002-2009 Olaf Kolkman\n\nPortions Copyright (c) 2007-2008 Dick Franks\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Update>,\nL<Net::DNS::Header>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 1035 Section 4.1, RFC 2136 Section 2, RFC 2845\n\n=cut\n\n1;\n", 8192) = 4086
09:01:57.298442 read(12, "", 8192)      = 0
09:01:57.298495 close(12)               = 0
09:01:57.298621 stat("modules/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.298673 stat("modules/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.298723 stat("modules/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.298773 stat("modules/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.298822 stat("/etc/perl/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.298871 stat("/etc/perl/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.298921 stat("/usr/local/lib/perl/5.14.2/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.298972 stat("/usr/local/lib/perl/5.14.2/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.299023 stat("/usr/local/share/perl/5.14.2/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.299077 stat("/usr/local/share/perl/5.14.2/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.299127 stat("/usr/lib/perl5/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.299184 stat("/usr/lib/perl5/IO/Socket/INET6.pm", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.299235 stat("/usr/share/perl5/IO/Socket/INET6.pmc", 0x7ffe12339e90) = -1 ENOENT (No such file or directory)
09:01:57.299287 stat("/usr/share/perl5/IO/Socket/INET6.pm", {st_mode=S_IFREG|0644, st_size=19284, ...}) = 0
09:01:57.299346 open("/usr/share/perl5/IO/Socket/INET6.pm", O_RDONLY) = 12
09:01:57.299400 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339b70) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.299446 lseek(12, 0, SEEK_CUR)  = 0
09:01:57.299500 read(12, "# IO::Socket::INET6.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n#\n# Modified by Rafael Martinez-Torres <rafael.martinez@novagnet.com>\n# Euro6IX project (www.euro6ix.org) 2003.\n\npackage IO::Socket::INET6;\n\nuse strict;\nuse warnings;\n\nour(@ISA, $VERSION);\n\n# Do it so we won't import any symbols from IO::Socket which it does export\n# by default:\n# \n# <LeoNerd> IO::Socket is stupidstupidstupid beyond belief. Despite being an\n# object class, it has an import method\n# <LeoNerd> So you have to use IO::Socket ();\n# <LeoNerd> Having done that, this test is now clean\nuse IO::Socket ();\n\nuse Socket (qw(\n    AF_INET6 PF_INET6 SOCK_RAW SOCK_STREAM INADDR_ANY SOCK_DGRAM\n    AF_INET SO_REUSEADDR SO_REUSEPORT AF_UNSPEC SO_BROADCAST\n    sockaddr_in\n    )\n);\n\n# IO::Socket and Socket already import stuff here - possibly AF_INET6\n# and PF_INET6 so selectively import things from Socket6.\nuse Socket6 (\n    qw(AI_PASSIVE getaddrinfo\n    sockaddr_in6 unpack_sockaddr_in6_all pack_sockaddr_in6_all in6addr_any)\n);\n\nuse Carp;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"2.69\";\n#Purpose: allow protocol independent protocol and original interface.\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET6->register_domain( AF_INET6 );\n\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\n#Parsing analisis:\n# addr,port,and proto may be sintactically related...\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();  \n  my @serv = ();\n\n  if (defined $addr) {\n\tif (!Socket6::inet_pton(AF_INET6,$addr)) {\n         if($addr =~ s,^\\[([\\da-fA-F:]+)\\]:([\\w\\(\\)/]+)$,$1,) {\n   \t     $port = $2;\n         } elsif($addr =~ s,^\\[(::[\\da-fA-F.:]+)\\]:([\\w\\(\\)/]+)$,$1,) {\n             $port = $2;\n         } elsif($addr =~ s,^\\[([\\da-fA-F:]+)\\],$1,) {\n             $port = $origport;\n         } elsif($addr =~ s,:([\\w\\(\\)/]+)$,,) {\n             $port = $1\n         }\n\t}\n  }\n\n  # $proto as \"string\".\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol '$proto'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service '$origport'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n #printf \"Selected port  is $port and proto is $proto \\n\";\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef,\n\t);\n\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n        if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n    $arg->{PeerAddr} = $arg->{PeerHost}\n        if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    my $family = $arg->{Domain};\n    # in case no local and peer is given we prefer AF_INET6\n    # because we are IO::Socket::INET6\n    $family ||= ! $arg->{LocalAddr} && ! $arg->{PeerAddr} && AF_INET6 \n        || AF_UNSPEC;\n\n    # parse Local*\n    my ($laddr,$lport,$proto) = _sock_info(\n        $arg->{LocalAddr},\n        $arg->{LocalPort},\n        $arg->{Proto}\n    ) or return _error($sock, $!, \"sock_info: $@\");\n    $laddr ||= '';\n    $lport ||= 0;\n    $proto ||= (getprotobyname('tcp'))[2];\n\n\n    # MSWin32 expects at least one of $laddr or $lport to be specified\n    # and does not accept 0 for $lport if $laddr is specified.\n    if ($^O eq 'MSWin32') {\n        if ((!$laddr) && (!$lport)) {\n            $laddr = ($family == AF_INET) ? '0.0.0.0' : '::';\n            $lport = '';\n        } elsif (!$lport) {\n            $lport = '';\n        }\n    } \n\n    my $type = $arg->{Type} || $socket_type{(getprotobynumber($proto))[0]};\n\n    # parse Peer*\n    my($rport,$raddr); \n    unless(exists $arg->{Listen}) {\n        ($raddr,$rport) = _sock_info(\n            $arg->{PeerAddr},\n            $arg->{PeerPort},\n            $proto\n        ) or return _error($sock, $!, \"sock_info: $@\");\n    }\n\n    # find out all combinations of local and remote addr with\n    # the same family\n    my @lres = getaddrinfo($laddr,$lport,$family,$type,$proto,AI_PASSIVE);\n    return _error($sock, $EINVAL, \"getaddrinfo: $lres[0]\") if @lres<5;\n    my @rres;\n    if ( defined $raddr ) {\n        @rres = getaddrinfo($raddr,$rport,$family,$type,$proto);\n        return _error($sock, $EINVAL, \"getaddrinfo: $rres[0]\") if @rres<5;\n    }\n\n    my @flr;\n    if (@rres) {\n        # collect all combinations whith the same family in lres and rres\n        # the order we search should be defined by the order of @rres, \n        # not @lres!\n        for( my $r=0;$r<@rres;$r+=5 ) {\n            for( my $l=0;$l<@lres;$l+=5) {\n                my $fam_listen = $lres[$l];\n                next if $rres[$r] != $fam_listen; # must be same family\n                push @flr,[ $fam_listen,$lres[$l+3],$rres[$r+3] ];\n            }\n        }\n    } else {\n        for( my $l=0;$l<@lres;$l+=5) {\n            my $fam_listen = $lres[$l];\n            my $lsockaddr = $lres[$l+3];\n            # collect only the binding side\n            push @flr,[ $fam_listen,$lsockaddr ];\n        }\n    }\n\n    # try to bind and maybe connect\n    # if multihomed try all combinations until success\n    for my $flr (@flr) {\n        my ($family,$lres,$rres) = @$flr;\n\n        if ( $family == AF_INET6) {\n            if ($arg->{LocalFlow} || $arg->{LocalScope}) {\n                my @sa_in6 = unpack_sockaddr_in6_all($lres);\n                $sa_in6[1] = $arg->{LocalFlow}  || 0;\n                $sa_in6[3] = _scope_ntohl($arg->{LocalScope}) || 0;\n                $lres = pack_sockaddr_in6_all(@sa_in6);\n            }\n        }\n\n        $sock->socket($family, $type, $proto) or\n            return _error($sock, $!, \"socket: $!\");\n\n        if (defined $arg->{Blocking}) {\n            defined $sock->blocking($arg->{Blocking}) or\n                return _error($sock, $!, \"sockopt: $!\");\n        }\n\n        if ($arg->{Reuse} || $arg->{ReuseAddr}) {\n            $sock->sockopt(SO_REUSEADDR,1) or\n                return _error($sock, $!, \"sockopt: $!\");\n        }\n\n        if ($arg->{ReusePort}) {\n            $sock->sockopt(SO_REUSEPORT,1) or\n                return _error($sock, $!, \"sockopt: $!\");\n        }\n\n        if ($arg->{Broadcast}) {\n            $sock->sockopt(SO_BROADCAST,1) or\n                return _error($sock, $!, \"sockopt: $!\");\n        }\n\n        if ( $family == AF_INET ) {\n            my ($p,$a) = sockaddr_in($lres);\n            $sock->bind($lres) or return _error($sock, $!, \"bind: $!\")\n                if ($a ne INADDR_ANY  or $p!=0);\n        } else {\n            my ($p,$a) = sockaddr_in6($lres);\n            $sock->bind($lres) or return _error($sock, $!, \"bind: $!\")\n                if ($a ne in6addr_any  or $p!=0);\n        }\n\n        if(exists $arg->{Listen}) {\n            $sock->listen($arg->{Listen} || 5) or\n                return _error($sock, $!, \"listen: $!\");\n        }\n\n        # connect only if PeerAddr and thus $rres is given\n        last if ! $rres;\n\n        if ( $family == AF_INET6) {\n            if ($arg->{PeerFlow} || $arg->{PeerScope}) {\n                my @sa_in6 = unpack_sockaddr_in6_all($rres);\n                $sa_in6[1] = $arg->{PeerFlow}  || 0;\n                $sa_in6[3] = _scope_ntohl($arg->{PeerScope}) || 0;\n                $rres = pack_sockaddr_in6_all(@sa_in6);\n            }\n        }\n    \n        undef $@;\n        last if $sock->connect($rres);\n\n        return _error($sock, $!, $@ || \"Timeout\")\n            if ! $arg->{Mult", 8192) = 8192
09:01:57.300030 stat("modules/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300082 stat("modules/Socket6.pm", 0x7ffe123397b0) = -1 ENOENT (No such file or directory)
09:01:57.300133 stat("modules/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300181 stat("modules/Socket6.pm", 0x7ffe123397b0) = -1 ENOENT (No such file or directory)
09:01:57.300230 stat("/etc/perl/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300279 stat("/etc/perl/Socket6.pm", 0x7ffe123397b0) = -1 ENOENT (No such file or directory)
09:01:57.300329 stat("/usr/local/lib/perl/5.14.2/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300379 stat("/usr/local/lib/perl/5.14.2/Socket6.pm", 0x7ffe123397b0) = -1 ENOENT (No such file or directory)
09:01:57.300430 stat("/usr/local/share/perl/5.14.2/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300480 stat("/usr/local/share/perl/5.14.2/Socket6.pm", 0x7ffe123397b0) = -1 ENOENT (No such file or directory)
09:01:57.300531 stat("/usr/lib/perl5/Socket6.pmc", 0x7ffe12339860) = -1 ENOENT (No such file or directory)
09:01:57.300581 stat("/usr/lib/perl5/Socket6.pm", {st_mode=S_IFREG|0644, st_size=9804, ...}) = 0
09:01:57.300639 open("/usr/lib/perl5/Socket6.pm", O_RDONLY) = 13
09:01:57.300691 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.300737 lseek(13, 0, SEEK_CUR)  = 0
09:01:57.300787 brk(0x168b000)          = 0x168b000
09:01:57.300846 read(13, "# Copyright (C) 2000-2008 Hajimu UMEMOTO <ume@mahoroba.org>.\n# All rights reserved.\n#\n# This module is besed on perl5.005_55-v6-19990721 written by KAME\n# Project.\n#\n# Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# 3. Neither the name of the project nor the names of its contributors\n#    may be used to endorse or promote products derived from this software\n#    without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\n# $Id: Socket6.pm,v 1.45 2008/11/01 19:08:39 ume Exp $\n\npackage Socket6;\n\nuse strict;\nuse vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $AUTOLOAD);\n$VERSION = \"0.23\";\n\n=head1 NAME\n\nSocket6 - IPv6 related part of the C socket.h defines and structure manipulators\n\n=head1 SYNOPSIS\n\n    use Socket;\n    use Socket6;\n\n    @res = getaddrinfo('hishost.com', 'daytime', AF_UNSPEC, SOCK_STREAM);\n    $family = -1;\n    while (scalar(@res) >= 5) {\n\t($family, $socktype, $proto, $saddr, $canonname, @res) = @res;\n\n\t($host, $port) = getnameinfo($saddr, NI_NUMERICHOST | NI_NUMERICSERV);\n\tprint STDERR \"Trying to connect to $host port port $port...\\n\";\n\n\tsocket(Socket_Handle, $family, $socktype, $proto) || next;\n        connect(Socket_Handle, $saddr) && last;\n\n\tclose(Socket_Handle);\n\t$family = -1;\n    }\n\n    if ($family != -1) {\n\tprint STDERR \"connected to $host port port $port\\n\";\n    } else {\n\tdie \"connect attempt failed\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThis module provides glue routines to the various IPv6 functions.\n\nIf you use the Socket6 module,\nbe sure to specify \"use Socket\" as well as \"use Socket6\".\n\nFunctions supplied are:\n\n=item inet_pton FAMILY, TEXT_ADDRESS\n\n    This function takes an IP address in presentation (or string) format\n    and converts it into numeric (or binary) format.\n    The type of IP address conversion (IPv4 versus IPv6) is controlled\n    by the FAMILY argument.\n\n=item inet_ntop FAMILY, BINARY_ADDRESS\n\n    This function takes an IP address in numeric (or binary) format\n    and converts it into presentation (or string) format\n    The type of IP address conversion (IPv4 versus IPv6) is controlled\n    by the FAMILY argument.\n\n=item pack_sockaddr_in6 PORT, ADDR\n\n    This function takes two arguments: a port number, and a 16-octet\n    IPv6 address structure (as returned by inet_pton()).\n    It returns the sockaddr_in6 structure with these arguments packed\n    into their correct fields, as well as the AF_INET6 family.\n    The other fields are not set and their values should not be relied upon.\n\n=item pack_sockaddr_in6_all PORT, FLOWINFO, ADDR, SCOPEID\n\n    This function takes four arguments: a port number, a 16-octet\n    IPv6 address structure (as returned by inet_pton), any\n    special flow information, and any specific scope information.\n    It returns a complete sockaddr_in6 structure with these arguments packed\n    into their correct fields, as well as the AF_INET6 family.\n\n=item unpack_sockaddr_in6 NAME\n\n    This function takes a sockaddr_in6 structure (as returned by\n    pack_sockaddr_in6()) and returns a list of of two elements:\n    the port number and the 16-octet IP address.\n    This function will croak if it determines it has not been\n    passed an IPv6 structure.\n\n=item unpack_sockaddr_in6_all NAME\n\n    This function takes a sockaddr_in6 structure (as returned by\n    pack_sockaddr_in6()) and returns a list of of four elements:\n    the port number, the flow information, the 16-octet IP address,\n    and the scope information.\n    This function will croak if it determines it has not been\n    passed an IPv6 structure.\n\n=item gethostbyname2 HOSTNAME, FAMILY\n\n=item getaddrinfo NODENAME, SERVICENAME, [FAMILY, SOCKTYPE, PROTOCOL, FLAGS]\n\n    This function converts node names to addresses and service names\n    to port numbers.\n    If the NODENAME argument is not a false value,\n    then a nodename to address lookup is performed;\n    otherwise a service name to port number lookup is performed.\n    At least one of NODENAME and SERVICENAME must have a true value.\n\n    If the lookup is successful, a list consisting of multiples of\n    five elements is returned.\n    Each group of five elements consists of the address family,\n    socket type, protocol, 16-octet IP address, and the canonical\n    name (undef if the node name passed is already the canonical name).\n\n    The arguments FAMILY, SOCKTYPE, PROTOCOL, and FLAGS are all optional.\n\n    This function will croak if it determines it has not been\n    passed an IPv6 structure.\n\n    If the lookup is unsuccessful, the function returns a single scalar.\n    This will contain the string version of that error in string context,\n    and the numeric value in numeric context.\n\n=item getnameinfo NAME, [FLAGS]\n\n    This function takes a socket address structure. If successful, it returns\n    two strings containing the node name and service name.\n\n    The optional FLAGS argument controls what kind of lookup is performed.\n\n    If the lookup is unsuccessful, the function returns a single scalar.\n    This will contain the string version of that error in string context,\n    and the numeric value in numeric context.\n\n=item getipnodebyname HOST, [FAMILY, FLAGS]\n\n    This function takes either a node name or an IP address string\n    and performs a lookup on that name (or conversion of the string).\n    It returns a list of five elements: the canonical host name,\n    the address family, the length in octets of the IP addresses\n    returned, a reference to a list of IP address structures, and\n    a reference to a list of aliases for the host name.\n\n    The arguments FAMILY and FLAGS are optional.\n    Note: This function does not handle IPv6 scope identifiers,\n    and should be used with care.\n    And, this function was deprecated in RFC3493.\n    The getnameinfo function should be used instead.\n\n=item getipnodebyaddr FAMILY, ADDRESS\n\n    This function takes an IP address family and an IP address structure\n    and performs a reverse lookup on that address.\n    It returns a list of five elements: the canonical host name,\n    the address family, the length in octets of the IP addresses\n    returned, a reference to a list of IP address structures, and\n    a reference to a list of aliases for the host name.\n\n    Note: This function does not handle IPv6 scope identifiers,\n    and should be used with care.\n    And, this function was deprecated in RFC3493.\n    The getaddrinfo function should be used instead.\n\n=item gai_strerror ERROR_NUMBER\n\n    This function returns a string corresponding to the error number\n    passed in as an argument.\n\n=item in6addr_any\n\n    This function returns the 16-octet wildcard address.\n\n=item in6add_loopback\n\n    This function returns the 16-octet loopback address.\n\n=over\n\n=back\n\n=cut\n\nuse Carp;\n\nuse base qw(Exporter DynaLoader);\n\n@EXPORT = qw(\n\tinet_pton inet_ntop pack_sockaddr_in6 pack_sockaddr_in6_all\n\tunpack_sockaddr_in6 unpack_sockaddr_in6_all sockaddr_in6\n\tgethostbyname2 getaddrinfo getnameinfo\n\tin", 8192) = 8192
09:01:57.301425 read(13, "6addr_any in6addr_loopback\n\tgai_strerror getipnodebyname getipnodebyaddr\n\tAI_ADDRCONFIG\n\tAI_ALL\n\tAI_CANONNAME\n\tAI_NUMERICHOST\n\tAI_NUMERICSERV\n\tAI_DEFAULT\n\tAI_MASK\n\tAI_PASSIVE\n\tAI_V4MAPPED\n\tAI_V4MAPPED_CFG\n\tEAI_ADDRFAMILY\n\tEAI_AGAIN\n\tEAI_BADFLAGS\n\tEAI_FAIL\n\tEAI_FAMILY\n\tEAI_MEMORY\n\tEAI_NODATA\n\tEAI_NONAME\n\tEAI_SERVICE\n\tEAI_SOCKTYPE\n\tEAI_SYSTEM\n\tEAI_BADHINTS\n\tEAI_PROTOCOL\n\tIP_AUTH_TRANS_LEVEL\n\tIP_AUTH_NETWORK_LEVEL\n\tIP_ESP_TRANS_LEVEL\n\tIP_ESP_NETWORK_LEVEL\n\tIPPROTO_IP\n\tIPPROTO_IPV6\n\tIPSEC_LEVEL_AVAIL\n\tIPSEC_LEVEL_BYPASS\n\tIPSEC_LEVEL_DEFAULT\n\tIPSEC_LEVEL_NONE\n\tIPSEC_LEVEL_REQUIRE\n\tIPSEC_LEVEL_UNIQUE\n\tIPSEC_LEVEL_USE\n\tIPV6_AUTH_TRANS_LEVEL\n\tIPV6_AUTH_NETWORK_LEVEL\n\tIPV6_ESP_NETWORK_LEVEL\n\tIPV6_ESP_TRANS_LEVEL\n\tNI_NOFQDN\n\tNI_NUMERICHOST\n\tNI_NAMEREQD\n\tNI_NUMERICSERV\n\tNI_DGRAM\n\tNI_WITHSCOPEID\n);\npush @EXPORT, qw(AF_INET6) unless defined eval {Socket::AF_INET6()};\npush @EXPORT, qw(PF_INET6) unless defined eval {Socket::PF_INET6()};\n\n@EXPORT_OK = qw(AF_INET6 PF_INET6);\n\n%EXPORT_TAGS = (\n    all     => [@EXPORT],\n);\n\nsub sockaddr_in6 {\n    if (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in6(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in6(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in6(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in6(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://o;\n    $! = 0;\n    my $val = constant($constname, @_ ? $_[0] : 0);\n    if ($! != 0) {\n\tcroak \"Your vendor has not defined Socket macro $constname, used\";\n    }\n    eval \"sub $AUTOLOAD { $val }\";\n    goto &$AUTOLOAD;\n}\n\nbootstrap Socket6 $VERSION;\n\n1;\n", 8192) = 1612
09:01:57.301722 read(13, "", 8192)      = 0
09:01:57.301772 close(13)               = 0
09:01:57.301853 stat("modules/auto/Socket6", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.301906 stat("modules/auto/Socket6", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.301956 stat("/etc/perl/auto/Socket6", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.302006 stat("/usr/local/lib/perl/5.14.2/auto/Socket6", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.302074 stat("/usr/local/share/perl/5.14.2/auto/Socket6", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.302131 stat("/usr/lib/perl5/auto/Socket6", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.302192 stat("/usr/lib/perl5/auto/Socket6/Socket6.so", {st_mode=S_IFREG|0644, st_size=23280, ...}) = 0
09:01:57.302266 stat("/usr/lib/perl5/auto/Socket6/Socket6.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.302339 open("/usr/lib/perl5/auto/Socket6/Socket6.so", O_RDONLY) = 13
09:01:57.302393 read(13, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000\25\0\0\0\0\0\0@\0\0\0\0\0\0\0pT\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\34P\0\0\0\0\0\0\34P\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0 P\0\0\0\0\0\0 P \0\0\0\0\0 P \0\0\0\0\0\200\3\0\0\0\0\0\0\220\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0HP\0\0\0\0\0\0HP \0\0\0\0\0HP \0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0`K\0\0\0\0\0\0`K\0\0\0\0\0\0`K\0\0\0\0\0\0\224\0\0\0\0\0\0\0\224\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\374\225XuPe\241\n\375\366\220\320\207=r<\254\367+\227\0\0\0\0%\0\0\0<\0\0\0\2\0\0\0 \0\0\0&\0\0\0\0\0\0\0'\0\0\0001\0\0\0\0\0\0\0\r\0\0\0\26\0\0\0\33\0\0\0;\0\0\0-\0\0\0003\0\0\0#\0\0\0\7\0\0\0\0\0\0\0\"\0\0\0\0\0\0\0002\0\0\0)\0\0\0%\0\0\0006\0\0\0\0\0\0\0000\0\0\0005\0\0\0\21\0\0\0\0\0\0\0\27\0\0\0007\0\0\0\n\0\0\0$\0\0\0!\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0:\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0(\0\0\0\0\0\0\0\0\0\0\0+\0\0\0\0\0\0\0\f\0\0\0009\0\0\0\0\0\0\0\20\0\0\0\6\0\0\0\0\0\0\0\4\0\0\0\23\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0,\0\0\0\0\0\0\0.\0\0\0\35\0\0\0\25\0\0\0\36\0\0\0\37\0\0\0004\0\0\0\v\0\0\0\32\0\0\0/\0\0\0\24\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\t\0\0\0\16\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\0\0\0\0\0\0\0\0*\0\0\0", 832) = 832
09:01:57.302527 fstat(13, {st_mode=S_IFREG|0644, st_size=23280, ...}) = 0
09:01:57.302583 mmap(NULL, 2118576, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 13, 0) = 0x7f74327bd000
09:01:57.302633 mprotect(0x7f74327c3000, 2093056, PROT_NONE) = 0
09:01:57.302682 mmap(0x7f74329c2000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 13, 0x5000) = 0x7f74329c2000
09:01:57.302735 close(13)               = 0
09:01:57.303487 brk(0x16ac000)          = 0x16ac000
09:01:57.303769 read(12, "iHomed};\n        \n    }\n\n    return $sock;\n}\n\nsub _scope_ntohl($)\n{\n    # As of Socket6 0.17 the scope field is incorrectly put into\n    # network byte order when it should be in host byte order\n    # in the sockaddr_in6 structure.  We correct for that here.\n\n    if ((Socket6->VERSION <= 0.17) && (pack('s', 0x1234) ne pack('n', 0x1234)))\n    {\n        unpack('N', pack('V', $_[0]));\n    } else {\n        $_[0];\n    }\n}\n\nsub sockdomain\n{\n   my $sock = shift;\n   $sock->SUPER::sockdomain(@_) || AF_INET6;\n} \n\nsub accept\n{\n    my $sock = shift;\n\n    my ($new, $peer) = $sock->SUPER::accept(@_);\n\n    return unless defined($new);\n\n    ${*$new}{io_socket_domain} = ${*$sock}{io_socket_domain}; \n    ${*$new}{io_socket_type}   = ${*$sock}{io_socket_type}; \n    ${*$new}{io_socket_proto}  = ${*$sock}{io_socket_proto}; \n\n    return wantarray ? ($new, $peer) : $new;\n} \n\nsub bind {\n    @_ == 2 or\n       croak 'usage: $sock->bind(NAME) ';\n    my $sock = shift;\n    return $sock->SUPER::bind( shift );\n}\n\nsub connect {\n    @_ == 2 or\n       croak 'usage: $sock->connect(NAME) ';\n    my $sock = shift;\n    return $sock->SUPER::connect( shift );\n}\n\nsub sockaddr {\n    @_ == 1 or croak 'usage: $sock->sockaddr()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->sockname);\n    ($sock->sockdomain == AF_INET) ? (sockaddr_in($name))[1] : (sockaddr_in6($name))[1];\n}\n\nsub sockport {\n    @_ == 1 or croak 'usage: $sock->sockport()';\n    my($sock) = @_;\n    return undef unless (my $name = $sock->sockname);\n    ($sock->sockdomain == AF_INET) ? (sockaddr_in($name))[0] : (sockaddr_in6($name))[0];\n}\n\nsub sockhost {\n    @_ == 1 or croak 'usage: $sock->sockhost()';\n    my ($sock) = @_;\n    return undef unless (my $addr = $sock->sockaddr);\n    Socket6::inet_ntop($sock->sockdomain, $addr);\n}\n\nsub sockflow\n{\n    @_ == 1 or croak 'usage: $sock->sockflow()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->sockname);\n    ($sock->sockdomain == AF_INET6) ? (unpack_sockaddr_in6_all($name))[1] : 0; \n}\n\nsub sockscope\n{\n    @_ == 1 or croak 'usage: $sock->sockscope()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->sockname);\n    _scope_ntohl(($sock->sockdomain == AF_INET6) ? (unpack_sockaddr_in6_all($name))[3] : 0);\n}\n\nsub peeraddr {\n    @_ == 1 or croak 'usage: $sock->peeraddr()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->peername);\n    ($sock->sockdomain == AF_INET) ? (sockaddr_in($name))[1] : (sockaddr_in6($name))[1];\n}\n\nsub peerport {\n    @_ == 1 or croak 'usage: $sock->peerport()';\n    my($sock) = @_;\n    return undef unless (my $name = $sock->peername);\n    ($sock->sockdomain == AF_INET) ? (sockaddr_in($name))[0] : (sockaddr_in6($name))[0];\n}\n\nsub peerhost {\n    @_ == 1 or croak 'usage: $sock->peerhost()';\n    my ($sock) = @_;\n    return undef unless (my $addr = $sock->peeraddr);\n    Socket6::inet_ntop($sock->sockdomain, $addr);\n}\n\nsub peerflow\n{\n    @_ == 1 or croak 'usage: $sock->peerflow()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->peername);\n    _scope_ntohl(($sock->sockdomain == AF_INET6) ? (unpack_sockaddr_in6_all($name))[1] : 0);\n}\n\nsub peerscope\n{\n    @_ == 1 or croak 'usage: $sock->peerscope()';\n    my ($sock) = @_;\n    return undef unless (my $name = $sock->peername);\n    ($sock->sockdomain == AF_INET6) ? (unpack_sockaddr_in6_all($name))[3] : 0;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nIO::Socket::INET6 - Object interface for AF_INET|AF_INET6 domain sockets\n\n=head1 SYNOPSIS\n\n    use IO::Socket::INET6;\n\n=head1 DESCRIPTION\n\nC<IO::Socket::INET6> provides an object interface to creating and using sockets\nin either AF_INET or AF_INET6 domains. It is built upon the L<IO::Socket> interface and\ninherits all the methods defined by L<IO::Socket>.\n\n=head1 CONSTRUCTOR\n\n=over 4\n\n=item new ( [ARGS] )\n\nCreates an C<IO::Socket::INET6> object, which is a reference to a\nnewly created symbol (see the C<Symbol> package). C<new>\noptionally takes arguments, these arguments are in key-value pairs.\n\nIn addition to the key-value pairs accepted by L<IO::Socket>,\nC<IO::Socket::INET6> provides.\n\n\n    Domain\tAddress family               AF_INET | AF_INET6 | AF_UNSPEC (default)\n    PeerAddr\tRemote host address          <hostname>[:<port>]\n    PeerHost\tSynonym for PeerAddr\n    PeerPort\tRemote port or service       <service>[(<no>)] | <no>\n    PeerFlow    Remote flow information\n    PeerScope   Remote address scope \n    LocalAddr\tLocal host bind\taddress      hostname[:port]\n    LocalHost\tSynonym for LocalAddr\n    LocalPort\tLocal host bind\tport         <service>[(<no>)] | <no>\n    LocalFlow   Local host flow information\n    LocalScope  Local host address scope\n    Proto\tProtocol name (or number)    \"tcp\" | \"udp\" | ...\n    Type\tSocket type                  SOCK_STREAM | SOCK_DGRAM | ...\n    Listen\tQueue size for listen\n    ReuseAddr\tSet SO_REUSEADDR before binding\n    Reuse\tSet SO_REUSEADDR before binding (deprecated, prefer ReuseAddr)\n    ReusePort\tSet SO_REUSEPORT before binding\n    Broadcast\tSet SO_BROADCAST before binding\n    Timeout\tTimeout\tvalue for various operations\n    MultiHomed  Try all addresses for multi-homed hosts\n    Blocking    Determine if connection will be blocking mode\n\nIf C<Listen> is defined then a listen socket is created, else if the\nsocket type, which is derived from the protocol, is SOCK_STREAM then\nconnect() is called.\n\nAlthough it is not illegal, the use of C<MultiHomed> on a socket\nwhich is in non-blocking mode is of little use. This is because the\nfirst connect will never fail with a timeout as the connect call\nwill not block.\n\nThe C<PeerAddr> can be a hostname,  the IPv6-address on the\n\"2001:800:40:2a05::10\" form , or the IPv4-address on the \"213.34.234.245\" form.\nThe C<PeerPort> can be a number or a symbolic\nservice name.  The service name might be followed by a number in\nparenthesis which is used if the service is not known by the system.\nThe C<PeerPort> specification can also be embedded in the C<PeerAddr>\nby preceding it with a \":\", and closing the IPv6 address on bracktes \"[]\" if\nnecessary: \"124.678.12.34:23\",\"[2a05:345f::10]:23\",\"any.server.com:23\".\n\nIf C<Domain> is not given, AF_UNSPEC is assumed, that is, both AF_INET and AF_INET6 will\nbe both considered when resolving DNS names. AF_INET6 is prioritary.\nIf you guess you are in trouble not reaching the peer,(the service is not available via\nAF_INET6 but AF_INET) you can either try Multihomed (try any address/family until reach)\nor concrete your address C<family> (AF_INET, AF_INET6).\n\nIf C<Proto> is not given and you specify a symbolic C<PeerPort> port,\nthen the constructor will try to derive C<Proto> from the service\nname.  As a last resort C<Proto> \"tcp\" is assumed.  The C<Type>\nparameter will be deduced from C<Proto> if not specified.\n\nIf the constructor is only passed a single argument, it is assumed to\nbe a C<PeerAddr> specification.\n\nIf C<Blocking> is set to 0, the connection will be in nonblocking mode.\nIf not specified it defaults to 1 (blocking mode).\n\nExamples:\n\n   $sock = IO::Socket::INET6->new(PeerAddr => 'www.perl.org',\n                                 PeerPort => 'http(80)',\n                                 Proto    => 'tcp');\n\nSuppose either you have no IPv6 connectivity or www.perl.org has no http service on IPv6. Then, \n\n(Trying all address/families until reach)\n\n   $sock = IO::Socket::INET6->new(PeerAddr => 'www.perl.org',\n                                 PeerPort => 'http(80)',\n\t\t\t\t Multihomed => 1 ,\n                                 Proto    => 'tcp');\n\n(Concrete to IPv4 protocol)\n\n   $sock = IO::Socket::INET6->new(PeerAddr => 'www.perl.org',\n                                 PeerPort => 'http(80)',\n\t\t\t\t Domain => AF_INET ,\n                                 Proto    => 'tcp');\n\n\n   $sock = IO::Socket::INET6->new(PeerAddr => 'localhost:smtp(25)');\n\n   $sock = IO::Socket::INET6->new(Listen    => 5,\n                                 LocalAddr => 'localhost',\n                                 LocalPort => 9000,\n                                 Proto     => 'tcp');\n\n   $sock = IO::Socket::INET6->new('[::1]:25');\n\n   $sock = IO::Socket::INET6->new(PeerPort  => 9999,\n                                 PeerAddr  => Socket6::inet_ntop(AF", 8192) = 8192
09:01:57.304702 lseek(12, 11567, SEEK_SET) = 11567
09:01:57.304750 lseek(12, 0, SEEK_CUR)  = 11567
09:01:57.304795 close(12)               = 0
09:01:57.305086 brk(0x16cd000)          = 0x16cd000
09:01:57.305659 read(11, "ub cname_addr {\n\t# TODO 20081217\n\t# This code does not follow CNAME chanes, it only looks inside the packet. Out of bailiwick will fail.\n\t# Also it is not IP agnostic\n\tmy $names  = shift;\n\tmy $packet = shift;\n\tmy @addr;\n\tmy @names = @{$names};\n\n\tmy $oct2 = '(?:2[0-4]\\d|25[0-5]|[0-1]?\\d\\d|\\d)';\n\n\tRR: foreach my $rr ($packet->answer) {\n\t\tnext RR unless grep {$rr->name} @names;\n\t\t\t\t\n\t\tif ($rr->type eq 'CNAME') {\n\t\t\tpush(@names, $rr->cname);\n\t\t} elsif ($rr->type eq 'A') {\n\t\t\t# Run a basic taint check.\n\t\t\t# Remark olaf 20081217: This taint check seems to be unneeded (albeit harmless). The packet\n\t\t\t# came from the wire and all parsing (untainting) has been done in Net::DNS::RR::A\n\t\t\tnext RR unless $rr->address =~ m/^($oct2\\.$oct2\\.$oct2\\.$oct2)$/o;\n\t\t\t\n\t\t\tpush(@addr, $1)\n\t\t}\n\t}\n\t\n\t\n\treturn @addr;\n}\n\n\n# if ($self->{\"udppacketsize\"}  > Net::DNS::PACKETSZ() \n# then we use EDNS and $self->{\"udppacketsize\"} \n# should be taken as the maximum packet_data length\nsub _packetsz {\n\tmy ($self) = @_;\n\n\treturn $self->{\"udppacketsize\"} > Net::DNS::PACKETSZ() ? \n\t\t   $self->{\"udppacketsize\"} : Net::DNS::PACKETSZ(); \n}\n\nsub _reset_errorstring {\n\tmy ($self) = @_;\n\t\n\t$self->errorstring($self->defaults->{'errorstring'});\n}\n\n\nsub search {\n\tmy $self = shift;\n\tmy $name = shift || '.';\n\n\tmy $defdomain = $self->{domain} if $self->{defnames};\n\tmy @searchlist = @{$self->{searchlist}} if $self->{dnsrch};\n\n\t# resolve name by trying as absolute name, then applying searchlist\n\tmy @list = (undef, @searchlist);\n\tfor ($name) {\n\t\t# resolve name with no dots or colons by applying searchlist (or domain)\n\t\t@list = @searchlist ? @searchlist : ($defdomain) unless  m/[:.]/;\n\t\t# resolve name with trailing dot as absolute name\n\t\t@list = (undef) if m/\\.$/;\n\t}\n\n\tforeach my $suffix ( @list ) {\n\t        my $fqname = join '.', $name, ($suffix || ());\n\n\t\tprint ';; search(', join(', ', $fqname, @_), \")\\n\" if $self->{debug};\n\n\t\tmy $packet = $self->send($fqname, @_) || return undef;\n\n\t\tnext unless ($packet->header->rcode eq \"NOERROR\"); # something \n\t\t\t\t\t\t\t\t #useful happened\n\t\treturn $packet if $packet->header->ancount;\t# answer found\n\t\tnext unless $packet->header->qdcount;           # question empty?\n\n\t\tlast if ($packet->question)[0]->qtype eq 'PTR';\t# abort search if IP\n\t}\n\treturn undef;\n}\n\n\nsub query {\n\tmy $self = shift;\n\tmy $name = shift || '.';\n\n\t# resolve name containing no dots or colons by appending domain\n\tmy @suffix = ($self->{domain} || ()) if $name !~ m/[:.]/ and $self->{defnames};\n\n\tmy $fqname = join '.', $name, @suffix;\n\n\tprint ';; query(', join(', ', $fqname, @_), \")\\n\" if $self->{debug};\n\n\tmy $packet = $self->send($fqname, @_) || return undef;\n\n\treturn $packet if $packet->header->ancount;\t# answer found\n\treturn undef;\n}\n\n\nsub send {\n\tmy $self = shift;\n\tmy $packet = $self->make_query_packet(@_);\n\tmy $packet_data = $packet->data;\n\n\n\tmy $ans;\n\n\tif ($self->{'usevc'} || length $packet_data > $self->_packetsz) {\n\t  \n\t    $ans = $self->send_tcp($packet, $packet_data);\n\t    \n\t} else {\n\t    $ans = $self->send_udp($packet, $packet_data);\n\n\t    if ($ans && $ans->header->tc && !$self->{'igntc'}) {\n\t\t\tprint \";;\\n;; packet truncated: retrying using TCP\\n\" if $self->{'debug'};\n\t\t\t$ans = $self->send_tcp($packet, $packet_data);\n\t    }\n\t}\n\t\n\treturn $ans;\n}\n\n\n\nsub send_tcp {\n\tmy ($self, $packet, $packet_data) = @_;\n\tmy $lastanswer;\n\t\n\tmy $srcport = $self->{'srcport'};\n\tmy $srcaddr = $self->{'srcaddr'};\n\tmy $dstport = $self->{'port'};\n\n\tunless ( $self->nameservers()) {\n\t\t$self->errorstring('no nameservers');\n\t\tprint \";; ERROR: send_tcp: no nameservers\\n\" if $self->{'debug'};\n\t\treturn;\n\t}\n\t\n\t$self->_reset_errorstring;\n\n\t\n      NAMESERVER: foreach my $ns ($self->nameservers()) {\n\t      \n\t      print \";; attempt to send_tcp($ns:$dstport) (src port = $srcport)\\n\"\n\t\t  if $self->{'debug'};\n\t      \n\t      \n\t      \n\t      my $sock;\n\t      my $sock_key = \"$ns:$dstport\";\n\t      my ($host,$port);\n\t      if ($self->persistent_tcp && $self->{'sockets'}[AF_UNSPEC]{$sock_key}) {\n\t\t      $sock = $self->{'sockets'}[AF_UNSPEC]{$sock_key};\n\t\t      print \";; using persistent socket\\n\"\n\t\t\tif $self->{'debug'};\n\t\t      unless ($sock->connected){\n\t\t\tprint \";; persistent socket disconnected (trying to reconnect)\" \n\t\t\t  if $self->{'debug'};\n\t\t\tundef($sock);\n\t\t\t$sock= $self->_create_tcp_socket($ns);\n\t\t\tnext NAMESERVER unless $sock;\n\t\t\t$self->{'sockets'}[AF_UNSPEC]{$sock_key} = $sock;\n\t\t      }\n\t\t      \n\t      } else {\n\t\t      $sock= $self->_create_tcp_socket($ns);\n\t\t      next NAMESERVER unless $sock;\n\t\t      \n\t\t      $self->{'sockets'}[AF_UNSPEC]{$sock_key} = $sock if \n\t\t\t  $self->persistent_tcp;\n\t      }\n\t      \n\n\t      my $lenmsg = pack('n', length($packet_data));\n\t      print ';; sending ', length($packet_data), \" bytes\\n\"\n\t\t  if $self->{'debug'};\n\t      \n\t      # note that we send the length and packet data in a single call\n\t      # as this produces a single TCP packet rather than two. This\n\t      # is more efficient and also makes things much nicer for sniffers.\n\t      # (ethereal doesn't seem to reassemble DNS over TCP correctly)\n\t      \n\t      \n\t      unless ($sock->send( $lenmsg . $packet_data)) {\n\t\t      $self->errorstring($!);\n\t\t      print \";; ERROR: send_tcp: data send failed: $!\\n\"\n\t\t\t  if $self->{'debug'};\n\t\t      next NAMESERVER;\n\t      }\n\t      \n\t      my $sel = IO::Select->new($sock);\n\t      my $timeout=$self->{'tcp_timeout'};\n\t      if ($sel->can_read($timeout)) {\n\t\t      my $buf = read_tcp($sock, Net::DNS::INT16SZ(), $self->{'debug'});\n\t\t      next NAMESERVER unless length($buf); # Failure to get anything\n\t\t      my ($len) = unpack('n', $buf);\n\t\t      next NAMESERVER unless $len;         # Cannot determine size\n\t\t      \n\t\t      unless ($sel->can_read($timeout)) {\n\t\t\t      $self->errorstring('timeout');\n\t\t\t      print \";; TIMEOUT\\n\" if $self->{'debug'};\n\t\t\t      next;\n\t\t      }\n\t\t      \n\t\t      $buf = read_tcp($sock, $len, $self->{'debug'});\n\t\t      \n\t\t      $self->answerfrom($sock->peerhost);\n\t\t      \n\t\t      print ';; received ', length($buf), \" bytes\\n\"\n\t\t\t  if $self->{'debug'};\n\n\t\t      unless (length($buf) == $len) {\n\t\t\t\t$self->errorstring(\"expected $len bytes, \" .\n\t\t\t\t\t\t   'received ' . length($buf));\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tmy ($ans, $err) = Net::DNS::Packet->new(\\$buf, $self->{'debug'});\n\t\t\tif (defined $ans) {\n\t\t\t\t$self->errorstring($ans->header->rcode);\n\t\t\t\t$ans->answerfrom($self->answerfrom);\n\n\t\t\t\tif ($ans->header->rcode ne \"NOERROR\" &&\n\t\t\t\t    $ans->header->rcode ne \"NXDOMAIN\"){\n\t\t\t\t\t# Remove this one from the stack\n\t\t\t\t\tprint \"RCODE: \".$ans->header->rcode .\"; trying next nameserver\\n\" if $self->{'debug'};\n\t\t\t\t\t$lastanswer=$ans;\n\t\t\t\t\tnext NAMESERVER ;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telsif (defined $err) {\n\t\t\t\t$self->errorstring($err);\n\t\t\t}\n\n\t\t\treturn $ans;\n\t\t}\n\t\telse {\n\t\t\t$self->errorstring('timeout');\n\t\t\tnext;\n\t\t}\n\t}\n\n\tif ($lastanswer){\n\t\t$self->errorstring($lastanswer->header->rcode );\n\t\treturn $lastanswer;\n\n\t}\n\n\treturn;\n}\n\n\n\nsub send_udp {\n\tmy ($self, $packet, $packet_data) = @_;\n\tmy $retrans = $self->{'retrans'};\n\tmy $timeout = $retrans;\n\t\n\tmy $lastanswer;\n\n\tmy $stop_time = time + $self->{'udp_timeout'} if $self->{'udp_timeout'};\n\t\n\t$self->_reset_errorstring;\n\t\n \tmy @ns;\n  \tmy $dstport = $self->{'port'};\n  \tmy $srcport = $self->{'srcport'};\n  \tmy $srcaddr = $self->{'srcaddr'};\n\t\n \tmy @sock;\n\t\n\t\n \tif ($self->persistent_udp){\n \t    if ($has_inet6){\n \t\tif ( defined ($self->{'sockets'}[AF_INET6()]{'UDP'})) {\n \t\t    $sock[AF_INET6()] = $self->{'sockets'}[AF_INET6()]{'UDP'};\n \t\t    print \";; using persistent AF_INET6() family type socket\\n\"\n\t\t\tif $self->{'debug'};\n \t\t}\n \t    }\n \t    if ( defined ($self->{'sockets'}[AF_INET]{'UDP'})) {\n \t\t$sock[AF_INET] = $self->{'sockets'}[AF_INET]{'UDP'};\n \t\tprint \";; using persistent AF_INET() family type socket\\n\"\n \t\t    if $self->{'debug'};\n \t    }\n\t}\n\t\n\tif ($has_inet6  && ! $self->force_v4() && !defined( $sock[AF_INET6()] )){\n\n\n\t    # '::' Otherwise the INET6 socket will fail.\n\t    \n            my $srcaddr6 = $srcaddr eq '0.0.0.0' ? '::' : $srcaddr;\n\t    \n\t    print \";; Trying to set up a AF_INET6() family type UDP socket with srcaddr: $srcaddr ... \"\n\t\tif $self->{'debug'};\n\n\t    \n\t    # IO::Socket carps on errors if Perl's -w flag is turned on.\n\t    # Uncomment the next two", 8192) = 8192
09:01:57.306300 brk(0x16ee000)          = 0x16ee000
09:01:57.306925 read(11, " lines and the line following the \"new\"\n\t    # call to turn off these messages.\n\t    \n\t    #my $old_wflag = $^W;\n\t    #$^W = 0;\n\t    \n\t    $sock[AF_INET6()] = IO::Socket::INET6->new(\n\t\t\t\t\t\t       LocalAddr => $srcaddr6,\n\t\t\t\t\t\t       LocalPort => ($srcport || undef),\n\t\t\t\t\t\t       Proto     => 'udp',\n\t\t\t\t\t\t       );\n\t    \n\n\n\n\t    print (defined($sock[AF_INET6()])?\"done\\n\":\"failed\\n\") if $has_inet6 && $self->debug();\n\n\t}\n\t\n\t# Always set up an AF_INET socket. \n\t# It will be used if the address familly of for the endpoint is V4.\n\n\tif (!defined( $sock[AF_INET]))\n\n\t{\n\t    print \";; setting up an AF_INET() family type UDP socket\\n\"\n\t\tif $self->{'debug'};\n\t    \n\t    #my $old_wflag = $^W;\n\t    #$^W = 0;\n\t    \n \t    $sock[AF_INET] = IO::Socket::INET->new(\n \t\t\t\t\t\t   LocalAddr => $srcaddr,\n \t\t\t\t\t\t   LocalPort => ($srcport || undef),\n \t\t\t\t\t\t   Proto     => 'udp',\n \t\t\t\t\t\t   ) ;\n \t    #$^W = $old_wflag;\n\t}\n\t\n\n\n\tunless (defined $sock[AF_INET] || ($has_inet6 && defined $sock[AF_INET6()])) {\n\n\t    $self->errorstring(\"could not get socket\");   #'\n\t    return;\n\t}\n\t\n\t$self->{'sockets'}[AF_INET]{'UDP'} = $sock[AF_INET] if ($self->persistent_udp) && defined( $sock[AF_INET] );\n\t$self->{'sockets'}[AF_INET6()]{'UDP'} = $sock[AF_INET6()] if $has_inet6 && ($self->persistent_udp) && defined( $sock[AF_INET6()]) && ! $self->force_v4();\n\n \t# Constructing an array of arrays that contain 3 elements: The\n \t# nameserver IP address, its sockaddr and the sockfamily for\n \t# which the sockaddr structure is constructed.\n\t\n\tmy $nmbrnsfailed=0;\n      NSADDRESS: foreach my $ns_address ($self->nameservers()){\n\t  # The logic below determines the $dst_sockaddr.\n\t  # If getaddrinfo is available that is used for both INET4 and INET6\n\t  # If getaddrinfo is not avialable (Socket6 failed to load) we revert\n\t  # to the 'classic mechanism\n\t  if ($has_inet6  && ! $self->force_v4() ){ \n\t      # we can use getaddrinfo\n\t      no strict 'subs';   # Because of the eval statement in the BEGIN\n\t      # AI_NUMERICHOST is not available at compile time.\n\t      # The AI_NUMERICHOST surpresses lookups.\n\t      \n\t      my $old_wflag = $^W; \t\t#circumvent perl -w warnings about 'udp'\n\t      $^W = 0;\n\t      \n\n\n\t      my @res = Socket6::getaddrinfo($ns_address, $dstport, AF_UNSPEC, SOCK_DGRAM, \n\t\t\t\t    0, AI_NUMERICHOST);\n\t      \n\t      $^W=$old_wflag ;\n\t      \n\t      \n\t      use strict 'subs';\n\t      \n\t      my ($sockfamily, $socktype_tmp, \n\t\t  $proto_tmp, $dst_sockaddr, $canonname_tmp) = @res;\n\t      \n\t      if (scalar(@res) < 5) {\n\t\t  die (\"can't resolve \\\"$ns_address\\\" to address\");\n\t      }\n\t      \n\t      push @ns,[$ns_address,$dst_sockaddr,$sockfamily];\n\t      \n\t  }else{\n\t      next NSADDRESS unless( _ip_is_ipv4($ns_address));\n\t      my $dst_sockaddr = sockaddr_in($dstport, inet_aton($ns_address));\n\t      push @ns, [$ns_address,$dst_sockaddr,AF_INET];\n\t  }\n\t  \n      }\n\n      \tunless (@ns) {\n\t    print \"No nameservers\" if $self->debug();\n\t    $self->errorstring('no nameservers');\n\t    return;\n\t}\n\n \tmy $sel = IO::Select->new() ;\n\t# We allready tested that one of the two socket exists\n\t\n \t$sel->add($sock[AF_INET]) if defined ($sock[AF_INET]);\n \t$sel->add($sock[AF_INET6()]) if $has_inet6 &&  defined ($sock[AF_INET6()]) && ! $self->force_v4();\n\t\n\n\t# Perform each round of retries.\n\tfor (my $i = 0;\n\t     $i < $self->{'retry'};\n\t     ++$i, $retrans *= 2, $timeout = int($retrans / (@ns || 1))) {\n\n\t\t$timeout = 1 if ($timeout < 1);\n\t\t\n\t\t# Try each nameserver.\n\t      NAMESERVER: foreach my $ns (@ns) {\n\t\t  next if defined $ns->[3];\n\t\t\tif ($stop_time) {\n\t\t\t\tmy $now = time;\n\t\t\t\tif ($stop_time < $now) {\n\t\t\t\t\t$self->errorstring('query timed out');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ($timeout > 1 && $timeout > ($stop_time-$now)) {\n\t\t\t\t\t$timeout = $stop_time-$now;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmy $nsname = $ns->[0];\n\t\t\tmy $nsaddr = $ns->[1];\n   \t                my $nssockfamily = $ns->[2];\n\n\t\t\t# If we do not have a socket for the transport\n\t\t\t# we are supposed to reach the namserver on we\n\t\t\t# should skip it.\n\t\t\tunless (defined ($sock[ $nssockfamily ])){\n\t\t\t    print \"Send error: cannot reach $nsname (\".\n\n\t\t\t\t( ($has_inet6 && $nssockfamily == AF_INET6()) ? \"IPv6\" : \"\" ).\n\t\t\t\t( ($nssockfamily == AF_INET) ? \"IPv4\" : \"\" ).\n\t\t\t\t\") not available\"\n\t\t\t\tif $self->debug();\n\n\n\t\t\t    $self->errorstring(\"Send error: cannot reach $nsname (\" .\n\t\t\t\t\t       ( ($has_inet6 && $nssockfamily == AF_INET6()) ? \"IPv6\" : \"\" ).\n\t\t\t\t\t       ( ($nssockfamily == AF_INET) ? \"IPv4\" : \"\" ).\n\t\t\t\t\t       \") not available\"\n\n);\n\t\t\t    next NAMESERVER ;\n\t\t\t    }\n\n\t\t\tprint \";; send_udp($nsname:$dstport)\\n\"\n\t\t\t\tif $self->{'debug'};\n\n\t\t\tunless ($sock[$nssockfamily]->send($packet_data, 0, $nsaddr)) {\n\t\t\t\tprint \";; send error: $!\\n\" if $self->{'debug'};\n\t\t\t\t$self->errorstring(\"Send error: $!\");\n\t\t\t\t$nmbrnsfailed++;\n\t\t\t\t$ns->[3]=\"Send error\".$self->errorstring();\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# See ticket 11931 but this works not quite yet\n\t\t\tmy $oldpacket_timeout=time+$timeout;\n\t\t\tuntil ( $oldpacket_timeout && ($oldpacket_timeout < time())) {\n\t\t\t    my @ready = $sel->can_read($timeout);\n\t\t\t  SELECTOR: foreach my $ready (@ready) {\n\t\t\t      my $buf = '';\n\t\t\t      \n\t\t\t      if ($ready->recv($buf, $self->_packetsz)) {\n\t\t\t\t  \n\t\t\t\t  $self->answerfrom($ready->peerhost);\n\t\t\t\t  \n\t\t\t\t  print ';; answer from ',\n\t\t\t\t  $ready->peerhost, ':',\n\t\t\t\t  $ready->peerport, ' : ',\n\t\t\t\t  length($buf), \" bytes\\n\"\n\t\t\t\t      if $self->{'debug'};\n\t\t\t\t  \n\t\t\t\t  my ($ans, $err) = Net::DNS::Packet->new(\\$buf, $self->{'debug'});\n\t\t\t\t  \n\t\t\t\t  if (defined $ans) {\n\t\t\t\t      next SELECTOR unless ( $ans->header->qr || $self->{'ignqrid'});\n\t\t\t\t      next SELECTOR unless  ( ($ans->header->id == $packet->header->id) || $self->{'ignqrid'} );\n\t\t\t\t      $self->errorstring($ans->header->rcode);\n\t\t\t\t      $ans->answerfrom($self->answerfrom);\n\t\t\t\t      if ($ans->header->rcode ne \"NOERROR\" &&\n\t\t\t\t\t  $ans->header->rcode ne \"NXDOMAIN\"){\n\t\t\t\t\t  # Remove this one from the stack\n\n\t\t\t\t\t  print \"RCODE: \".$ans->header->rcode .\"; trying next nameserver\\n\" if $self->{'debug'};\n\t\t\t\t\t  $nmbrnsfailed++;\n\t\t\t\t\t  $ns->[3]=\"RCODE: \".$ans->header->rcode();\n\t\t\t\t\t  $lastanswer=$ans;\n\t\t\t\t\t  next NAMESERVER ;\n\t\t\t\t\t  \n\t\t\t\t      }\n\t\t\t\t  } elsif (defined $err) {\n\t\t\t\t      $self->errorstring($err);\n\t\t\t\t  }\n\t\t\t\t  return $ans;\n\t\t\t      } else {\n\t\t\t\t  $self->errorstring($!);\n      \t\t\t\t  print ';; recv ERROR(',\n\t\t\t\t  $ready->peerhost, ':',\n\t\t\t\t  $ready->peerport, '): ',\n\t\t\t\t  $self->errorstring, \"\\n\"\n\t\t\t\t      if $self->{'debug'};\n\t\t\t\t  $ns->[3]=\"Recv error \".$self->errorstring();\n\t\t\t\t  $nmbrnsfailed++;\n\t\t\t\t  # We want to remain in the SELECTOR LOOP...\n\t\t\t\t  # unless there are no more nameservers\n\t\t\t\t  return unless ($nmbrnsfailed < @ns);\n\t\t\t\t  print ';; Number of failed nameservers: $nmbrnsfailed out of '.scalar @ns.\"\\n\" if $self->{'debug'};\n\n\t\t\t      }\n\t\t\t  } #SELECTOR LOOP\n\t\t\t} # until stop_time loop\n\t\t    } #NAMESERVER LOOP\n\t\t\n\t}\n\t\n\tif ($lastanswer){\n\t\t$self->errorstring($lastanswer->header->rcode );\n\t\treturn $lastanswer;\n\n\t}\n\tif ($sel->handles) {\n\t    # If there are valid hanndles than we have either a timeout or \n\t    # a send error.\n\t    $self->errorstring('query timed out') unless ($self->errorstring =~ /Send error:/);\n\t}\n\telse {\n\t    if ($nmbrnsfailed < @ns){\n\t\t$self->errorstring('Unexpected Error') ;\n\t    }else{\n\t\t$self->errorstring('all nameservers failed');\n\t    }\n\t}\n\treturn;\n}\n\n\nsub bgsend {\n\tmy $self = shift;\n\n\tunless ($self->nameservers()) {\n\t\t$self->errorstring('no nameservers');\n\t\treturn;\n\t}\n\n\t\t$self->_reset_errorstring;\n\n\tmy $packet = $self->make_query_packet(@_);\n\tmy $packet_data = $packet->data;\n\n\tmy $srcaddr = $self->{'srcaddr'};\n\tmy $srcport = $self->{'srcport'};\n\n\n\tmy (@res, $sockfamily, $dst_sockaddr);\n\tmy $ns_address = ($self->nameservers())[0];\n\tmy $dstport = $self->{'port'};\n\n\n\t# The logic below determines ther $dst_sockaddr.\n\t# If getaddrinfo is available that is used for both INET4 and INET6\n\t# If getaddrinfo is not avialable (Socket6 failed to load) we revert\n\t# to the 'classic mechanism\n\tif ($has_inet6  && ! $self->force_v4()){ \n\n\t    my ( $socktype_tmp, $proto_tmp, $canonname_tmp);\n\n\t    no strict 'subs';   # Because of the eval statement in the BEGIN\n\t                      # AI_NUMERICHOST is not available at compile time.\n\n\t      my $old_w", 8192) = 8192
09:01:57.307637 brk(0x170f000)          = 0x170f000
09:01:57.308167 read(11, "flag = $^W; \t\t#circumvent perl -w warnings about 'udp'\n\t      $^W = 0;\n\t      \n\n\t    # The AI_NUMERICHOST surpresses lookups.\n\t    my @res = Socket6::getaddrinfo($ns_address, $dstport, AF_UNSPEC, SOCK_DGRAM,\n\t\t\t\t  0 , AI_NUMERICHOST);\n\n\t    $^W=$old_wflag;\n\n\t    use strict 'subs';\n\n\t    ($sockfamily, $socktype_tmp, \n\t     $proto_tmp, $dst_sockaddr, $canonname_tmp) = @res;\n\n\t    if (scalar(@res) < 5) {\n\t\tdie (\"can't resolve \\\"$ns_address\\\" to address (it could have been an IP address)\");\n\t    }\n\n\t}else{\n\t    $sockfamily=AF_INET;\n\t    \n\t    if (! _ip_is_ipv4($ns_address)){\n\t\t$self->errorstring(\"bgsend(ipv4 only):$ns_address does not seem to be a valid IPv4 address\");\n\t\treturn;\n\t    }\n\n\t    $dst_sockaddr = sockaddr_in($dstport, inet_aton($ns_address));\n\t}\n\tmy @socket;  \n\n\tif ($sockfamily == AF_INET) {\n\t    $socket[$sockfamily] = IO::Socket::INET->new(\n\t\t\t\t\t\t\t Proto => 'udp',\n\t\t\t\t\t\t\t Type => SOCK_DGRAM,\n\t\t\t\t\t\t\t LocalAddr => $srcaddr,\n\t\t\t\t\t\t\t LocalPort => ($srcport || undef),\n\t\t\t\t\t    );\n\t} elsif ($has_inet6 && $sockfamily == AF_INET6() ) {\n\t    # Otherwise the INET6 socket will just fail\n\t    my $srcaddr6 = $srcaddr eq \"0.0.0.0\" ? '::' : $srcaddr;\n\t    $socket[$sockfamily] = IO::Socket::INET6->new(\n\t\t\t\t\t\t\t  Proto => 'udp',\n\t\t\t\t\t\t\t  Type => SOCK_DGRAM,\n\t\t\t\t\t\t\t  LocalAddr => $srcaddr6,\n\t\t\t\t\t\t\t  LocalPort => ($srcport || undef),\n\t\t\t\t\t     );\n\t} else {\n\t    die ref($self).\" bgsend: Unsupported Socket Family: $sockfamily\";\n\t}\n\t\n\tunless ($socket[$sockfamily]) {\n\t\t$self->errorstring(\"could not get socket\");   \n\t\treturn;\n\t}\n\n\tprint \";; bgsend($ns_address : $dstport)\\n\" if $self->{'debug'}\t;\n\n\tforeach my $socket (@socket){\n\t    next if !defined $socket;\n\t    \n\t    unless ($socket->send($packet_data,0,$dst_sockaddr)){\n\t\tmy $err = $!;\n\t\tprint \";; send ERROR($ns_address): $err\\n\" if $self->{'debug'};\n\t\t\n\t\t$self->errorstring(\"Send: \".$err);\n\t\treturn;\n\t    }\n\t    return $socket;\n\t}\n\t$self->errorstring(\"Could not find a socket to send on\");\n\treturn;\n\t    \n}\n\nsub bgread {\n\tmy ($self, $sock) = @_;\n\n\tmy $buf = '';\n\n\tmy $peeraddr = $sock->recv($buf, $self->_packetsz);\n\t\n\tif ($peeraddr) {\n\t\tprint ';; answer from ', $sock->peerhost, ':',\n\t\t      $sock->peerport, ' : ', length($buf), \" bytes\\n\"\n\t\t\tif $self->{'debug'};\n\n\t\tmy ($ans, $err) = Net::DNS::Packet->new(\\$buf, $self->{'debug'});\n\t\t\n\t\tif (defined $ans) {\n\t\t\t$self->errorstring($ans->header->rcode);\n\t\t\t$ans->answerfrom($sock->peerhost);\n\t\t} elsif (defined $err) {\n\t\t\t$self->errorstring($err);\n\t\t}\n\t\t\n\t\treturn $ans;\n\t} else {\n\t\t$self->errorstring($!);\n\t\treturn;\n\t}\n}\n\nsub bgisready {\n\tmy $self = shift;\n\tmy $sel = IO::Select->new(@_);\n\tmy @ready = $sel->can_read(0.0);\n\treturn @ready > 0;\n}\n\n\n\n#\n# Keep this method around. Folk depend on it although its not documented and exported.\n#\nsub make_query_packet {\n\tmy $self = shift;\n\tmy $packet;\n\n\tif (ref($_[0]) and $_[0]->isa('Net::DNS::Packet')) {\n\t\t$packet = shift;\n\t} else {\n\t\t$packet = Net::DNS::Packet->new(@_);\n\t}\n\n\tif ($packet->header->opcode eq 'QUERY') {\n\t\t$packet->header->rd($self->{'recurse'});\n\t}\n\n    if ($self->{'dnssec'}) {\n\t    # RFC 3225\n    \tprint \";; Adding EDNS extention with UDP packetsize $self->{'udppacketsize'} and DNS OK bit set\\n\" \n    \t\tif $self->{'debug'};\n    \t\n    \n\t$packet->header->cd($self->{'cdflag'});\n\t$packet->header->ad($self->{'adflag'});\n\tmy $optrr = Net::DNS::RR->new(\n\t\t\t\t\t\tType         => 'OPT',\n\t\t\t\t\t\tName         => '',\n\t\t\t\t\t\tClass        => $self->{'udppacketsize'},  # Decimal UDPpayload\n\t\t\t\t\t\tednsflags    => 0x8000, # first bit set see RFC 3225 \n\t\t\t\t   );\n\n\t\n\t    $packet->push('additional', $optrr) unless defined  $packet->{'optadded'} ;\n\t    $packet->{'optadded'}=1;\n\t} elsif ($self->{'udppacketsize'} > Net::DNS::PACKETSZ()) {\n\t    print \";; Adding EDNS extention with UDP packetsize  $self->{'udppacketsize'}.\\n\" if $self->{'debug'};\n\t    # RFC 3225\n\t    my $optrr = Net::DNS::RR->new( \n\t\t\t\t\t\tType         => 'OPT',\n\t\t\t\t\t\tName         => '',\n\t\t\t\t\t\tClass        => $self->{'udppacketsize'},  # Decimal UDPpayload\n\t\t\t\t\t\tTTL          => 0x0000 # RCODE 32bit Hex\n\t\t\t\t    );\n\t\t\t\t    \n\t    $packet->push('additional', $optrr) unless defined  $packet->{'optadded'} ;\n\t    $packet->{'optadded'}=1;\n\t}\n\t\n\n\tif ($self->{'tsig_rr'}) {\n\t\tif (!grep { $_->type eq 'TSIG' } $packet->additional) {\n\t\t\t$packet->push('additional', $self->{'tsig_rr'});\n\t\t}\n\t}\n\n\treturn $packet;\n}\n\nsub axfr {\n\tmy $self = shift;\n\tmy @zone;\n\n\tif ($self->axfr_start(@_)) {\n\t\tmy ($rr, $err);\n\t\twhile (($rr, $err) = $self->axfr_next, $rr && !$err) {\n\t\t\tpush @zone, $rr;\n\t\t}\n\t\t@zone = () if $err;\n\t}\n\n\treturn @zone;\n}\n\nsub axfr_old {\n\tcroak \"Use of Net::DNS::Resolver::axfr_old() is deprecated, use axfr() or axfr_start().\";\n}\n\n\nsub axfr_start {\n\tmy $self = shift;\n\tmy ($dname, $class) = @_;\n\t$dname ||= $self->{'searchlist'}->[0];\n\t$class ||= 'IN';\n\tmy $timeout = $self->{'tcp_timeout'};\n\n\tunless ($dname) {\n\t\tprint \";; ERROR: axfr: no zone specified\\n\" if $self->{'debug'};\n\t\t$self->errorstring('no zone');\n\t\treturn;\n\t}\n\n\n\tprint \";; axfr_start($dname, $class)\\n\" if $self->{'debug'};\n\n\tunless ($self->nameservers()) {\n\t\t$self->errorstring('no nameservers');\n\t\tprint \";; ERROR: no nameservers\\n\" if $self->{'debug'};\n\t\treturn;\n\t}\n\n\tmy $packet = $self->make_query_packet($dname, 'AXFR', $class);\n\tmy $packet_data = $packet->data;\n\n\tmy $ns = ($self->nameservers())[0];\n\n\n\tmy $srcport = $self->{'srcport'};\n\tmy $srcaddr = $self->{'srcaddr'};\n\tmy $dstport = $self->{'port'};\n\n\tprint \";; axfr_start nameserver = $ns\\n\" if $self->{'debug'};\n\tprint \";; axfr_start srcport: $srcport, srcaddr: $srcaddr, dstport: $dstport\\n\" if $self->{'debug'};\n\n\n\tmy $sock;\n\tmy $sock_key = \"$ns:$self->{'port'}\";\n\n\t\n\tif ($self->persistent_tcp && $self->{'axfr_sockets'}[AF_UNSPEC]{$sock_key}) {\n\t\t$sock = $self->{'axfr_sockets'}[AF_UNSPEC]{$sock_key};\n\t\tprint \";; using persistent socket\\n\"\n\t\t    if $self->{'debug'};\n\t} else {\n\t\t$sock=$self->_create_tcp_socket($ns);\n\n\t\treturn unless ($sock);  # all error messages \n\t\t                        # are set by _create_tcp_socket\n\n\n\t\t$self->{'axfr_sockets'}[AF_UNSPEC]{$sock_key} = $sock if \n\t\t    $self->persistent_tcp;\n\t}\n\t\n\tmy $lenmsg = pack('n', length($packet_data));\n\n\tunless ($sock->send($lenmsg)) {\n\t\t$self->errorstring($!);\n\t\treturn;\n\t}\n\n\tunless ($sock->send($packet_data)) {\n\t\t$self->errorstring($!);\n\t\treturn;\n\t}\n\n\tmy $sel = IO::Select->new($sock);\n\n\t$self->{'axfr_sel'}       = $sel;\n\t$self->{'axfr_rr'}        = [];\n\t$self->{'axfr_soa_count'} = 0;\n\n\treturn $sock;\n}\n\n\nsub axfr_next {\n\tmy $self = shift;\n\tmy $err  = '';\n\t\n\tunless (@{$self->{'axfr_rr'}}) {\n\t\tunless ($self->{'axfr_sel'}) {\n\t\t\tmy $err = 'no zone transfer in progress';\n\t\t\t\n\t\t\tprint \";; $err\\n\" if $self->{'debug'};\n\t\t\t$self->errorstring($err);\n\t\t\t\t\t\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\tmy $sel = $self->{'axfr_sel'};\n\t\tmy $timeout = $self->{'tcp_timeout'};\n\n\t\t#--------------------------------------------------------------\n\t\t# Read the length of the response packet.\n\t\t#--------------------------------------------------------------\n\n\t\tmy @ready = $sel->can_read($timeout);\n\t\tunless (@ready) {\n\t\t\t$err = 'timeout';\n\t\t\t$self->errorstring($err);\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\tmy $buf = read_tcp($ready[0], Net::DNS::INT16SZ(), $self->{'debug'});\n\t\tunless (length $buf) {\n\t\t\t$err = 'truncated zone transfer';\n\t\t\t$self->errorstring($err);\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\tmy ($len) = unpack('n', $buf);\n\t\tunless ($len) {\n\t\t\t$err = 'truncated zone transfer';\n\t\t\t$self->errorstring($err);\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\t#--------------------------------------------------------------\n\t\t# Read the response packet.\n\t\t#--------------------------------------------------------------\n\n\t\t@ready = $sel->can_read($timeout);\n\t\tunless (@ready) {\n\t\t\t$err = 'timeout';\n\t\t\t$self->errorstring($err);\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\t$buf = read_tcp($ready[0], $len, $self->{'debug'});\n\n\t\tprint ';; received ', length($buf), \" bytes\\n\"\n\t\t\tif $self->{'debug'};\n\n\t\tunless (length($buf) == $len) {\n\t\t\t$err = \"expected $len bytes, received \" . length($buf);\n\t\t\t$self->errorstring($err);\n\t\t\tprint \";; $err\\n\" if $self->{'debug'};\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\tmy $an", 8192) = 8192
09:01:57.308967 brk(0x1730000)          = 0x1730000
09:01:57.309527 read(11, "s;\n\t\t($ans, $err) = Net::DNS::Packet->new(\\$buf, $self->{'debug'});\n\n\t\tif ($ans) {\n\t\t\tif ($ans->header->rcode ne 'NOERROR') {\t\n\t\t\t\t$self->errorstring('Response code from server: ' . $ans->header->rcode);\n\t\t\t\tprint ';; Response code from server: ' . $ans->header->rcode . \"\\n\" if $self->{'debug'};\n\t\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t\t}\n\t\t\tif ($ans->header->ancount < 1) {\n\t\t\t\t$err = 'truncated zone transfer';\n\t\t\t\t$self->errorstring($err);\n\t\t\t\tprint \";; $err\\n\" if $self->{'debug'};\n\t\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$err ||= 'unknown error during packet parsing';\n\t\t\t$self->errorstring($err);\n\t\t\tprint \";; $err\\n\" if $self->{'debug'};\n\t\t\treturn wantarray ? (undef, $err) : undef;\n\t\t}\n\n\t\tforeach my $rr ($ans->answer) {\n\t\t\tif ($rr->type eq 'SOA') {\n\t\t\t\tif (++$self->{'axfr_soa_count'} < 2) {\n\t\t\t\t\tpush @{$self->{'axfr_rr'}}, $rr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpush @{$self->{'axfr_rr'}}, $rr;\n\t\t\t}\n\t\t}\n\n\t\tif ($self->{'axfr_soa_count'} >= 2) {\n\t\t\t$self->{'axfr_sel'} = undef;\n\t\t\t# we need to mark the transfer as over if the responce was in \n\t\t\t# many answers.  Otherwise, the user will call axfr_next again\n\t\t\t# and that will cause a 'no transfer in progress' error.\n\t\t\tpush(@{$self->{'axfr_rr'}}, undef);\n\t\t}\n\t}\n\n\tmy $rr = shift @{$self->{'axfr_rr'}};\n\n\treturn wantarray ? ($rr, undef) : $rr;\n}\n\n\n\n\nsub dnssec {\n    my ($self, $new_val) = @_;\n    if (defined $new_val) {\n\t$self->{\"dnssec\"} = $new_val;\n\t# Setting the udppacket size to some higher default\n\t$self->udppacketsize(2048) if $new_val;\n    }\n    \n    Carp::carp (\"You called the Net::DNS::Resolver::dnssec() method but do not have Net::DNS::SEC installed\") if $self->{\"dnssec\"} && ! $Net::DNS::DNSSEC;\n    return $self->{\"dnssec\"};\n};\n\n\n\nsub tsig {\n\tmy $self = shift;\n\n\tif (@_ == 1) {\n\t\tif ($_[0] && ref($_[0])) {\n\t\t\t$self->{'tsig_rr'} = $_[0];\n\t\t}\n\t\telse {\n\t\t\t$self->{'tsig_rr'} = undef;\n\t\t}\n\t}\n\telsif (@_ == 2) {\n\t\tmy ($key_name, $key) = @_;\n\t\t$self->{'tsig_rr'} = Net::DNS::RR->new(\"$key_name TSIG $key\");\n\t}\n\n\treturn $self->{'tsig_rr'};\n}\n\n#\n# Usage:  $data = read_tcp($socket, $nbytes, $debug);\n#\nsub read_tcp {\n\tmy ($sock, $nbytes, $debug) = @_;\n\tmy $buf = '';\n\n\twhile (length($buf) < $nbytes) {\n\t\tmy $nread = $nbytes - length($buf);\n\t\tmy $read_buf = '';\n\n\t\tprint \";; read_tcp: expecting $nread bytes\\n\" if $debug;\n\n\t\t# During some of my tests recv() returned undef even\n\t\t# though there wasn't an error.  Checking for the amount\n\t\t# of data read appears to work around that problem.\n\n\t\tunless ($sock->recv($read_buf, $nread)) {\n\t\t\tif (length($read_buf) < 1) {\n\t\t\t\tmy $errstr = $!;\n\n\t\t\t\tprint \";; ERROR: read_tcp: recv failed: $!\\n\"\n\t\t\t\t\tif $debug;\n\n\t\t\t\tif ($errstr eq 'Resource temporarily unavailable') {\n\t\t\t\t\twarn \"ERROR: read_tcp: recv failed: $errstr\\n\";\n\t\t\t\t\twarn \"ERROR: try setting \\$res->timeout(undef)\\n\";\n\t\t\t\t}\n\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\n\t\tprint ';; read_tcp: received ', length($read_buf), \" bytes\\n\"\n\t\t\tif $debug;\n\n\t\tlast unless length($read_buf);\n\t\t$buf .= $read_buf;\n\t}\n\n\treturn $buf;\n}\n\n\n\nsub _create_tcp_socket {\n\tmy $self=shift;\n\tmy $ns=shift;\n\tmy $sock;\n\n\tmy $srcport = $self->{'srcport'};\n\tmy $srcaddr = $self->{'srcaddr'};\n\tmy $dstport = $self->{'port'};\n\n\tmy $timeout = $self->{'tcp_timeout'};\n\t# IO::Socket carps on errors if Perl's -w flag is\n\t# turned on.  Uncomment the next two lines and the\n\t# line following the \"new\" call to turn off these\n\t# messages.\n\t\n\t#my $old_wflag = $^W;\n\t#$^W = 0;\n\t\n\tif ($has_inet6 && ! $self->force_v4() && _ip_is_ipv6($ns) ){\n\t\t# XXX IO::Socket::INET6 fails in a cryptic way upon send()\n\t\t# on AIX5L if \"0\" is passed in as LocalAddr\n\t\t# $srcaddr=\"0\" if $srcaddr eq \"0.0.0.0\";  # Otherwise the INET6 socket will just fail\n\t\t\n\t\tmy $srcaddr6 = $srcaddr eq '0.0.0.0' ? '::' : $srcaddr;\n\t\t\n\t\t$sock = \n\t\t    IO::Socket::INET6->new(\n\t\t\t\t\t   PeerPort =>    $dstport,\n\t\t\t\t\t   PeerAddr =>    $ns,\n\t\t\t\t\t   LocalAddr => $srcaddr6,\n\t\t\t\t\t   LocalPort => ($srcport || undef),\n\t\t\t\t\t   Proto     => 'tcp',\n\t\t\t\t\t   Timeout   => $timeout,\n\t\t\t\t\t   );\n\t\t\n\t\tunless($sock){\n\t\t\t$self->errorstring('connection failed(IPv6 socket failure)');\n\t\t\tprint \";; ERROR: send_tcp: IPv6 connection to $ns\".\n\t\t\t    \"failed: $!\\n\" if $self->{'debug'};\n\t\t\treturn();\n\t\t}\n\t}\n\t\n\t# At this point we have sucessfully obtained an\n\t# INET6 socket to an IPv6 nameserver, or we are\n\t# running forced v4, or we do not have v6 at all.\n\t# Try v4.\n\t\n\tunless($sock){\n\t\tif (_ip_is_ipv6($ns)){\n\t\t\t$self->errorstring(\n\t\t\t\t\t   'connection failed (trying IPv6 nameserver without having IPv6)');\n\t\t\tprint \n\t\t\t    ';; ERROR: send_tcp: You are trying to connect to '.\n\t\t\t    $ns . \" but you do not have IPv6 available\\n\"\n\t\t\t    if $self->{'debug'};\n\t\t\treturn();\n\t\t}\t\t    \n\t\t\n\t\t\n\t\t$sock = IO::Socket::INET->new(\n\t\t\t\t\t      PeerAddr  => $ns,\n\t\t\t\t\t      PeerPort  => $dstport,\n\t\t\t\t\t      LocalAddr => $srcaddr,\n\t\t\t\t\t      LocalPort => ($srcport || undef),\n\t\t\t\t\t      Proto     => 'tcp',\n\t\t\t\t\t      Timeout   => $timeout\n\t\t\t\t\t      )\n\t    }\n\t\n\t#$^W = $old_wflag;\n\t\n\tunless ($sock) {\n\t\t$self->errorstring('connection failed');\n\t\tprint ';; ERROR: send_tcp: connection ',\n\t\t\"failed: $!\\n\" if $self->{'debug'};\n\t\treturn();\n\t}\n\n\treturn $sock;\n}\n\n\n# Lightweight versions of subroutines from Net::IP module, recoded to fix rt#28198\n\nsub _ip_is_ipv4 {\n\tmy @field = split /\\./, shift;\n\n\treturn 0 if @field > 4;\t\t\t\t# too many fields\n\treturn 0 if @field == 0;\t\t\t# no fields at all\n\n\tforeach ( @field ) {\n\t\treturn 0 unless /./;\t\t\t# reject if empty\n\t\treturn 0 if /[^0-9]/;\t\t\t# reject non-digit\n\t\treturn 0 if $_ > 255;\t\t\t# reject bad value\n\t}\n\n\n\treturn 1;\n}\n\n\nsub _ip_is_ipv6 {\n\n\tfor ( shift ) {\n\t\tmy @field = split /:/;\t\t\t# split into fields\n\t\treturn 0 if (@field < 3) or (@field > 8);\n\n\t\treturn 0 if /::.*::/;\t\t\t# reject multiple ::\n\n\t\tif ( /\\./ ) {\t\t\t\t# IPv6:IPv4\n\t\t\treturn 0 unless _ip_is_ipv4(pop @field);\n\t\t}\n\n\t\tforeach ( @field ) {\n\t\t\tnext unless /./;\t\t# skip ::\n\t\t\treturn 0 if /[^0-9a-f]/i;\t# reject non-hexdigit\n\t\t\treturn 0 if length $_ > 4;\t# reject bad value\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n\nsub AUTOLOAD {\n\tmy ($self) = @_;\n\n\tmy $name = $AUTOLOAD;\n\t$name =~ s/.*://;\n\n\tCarp::croak \"$name: no such method\" unless exists $self->{$name};\n\t\n\tno strict q/refs/;\n\t\n\t\n\t*{$AUTOLOAD} = sub {\n\t\tmy ($self, $new_val) = @_;\n\t\t\n\t\tif (defined $new_val) {\n\t\t\t$self->{\"$name\"} = $new_val;\n\t\t}\n\t\t\n\t\treturn $self->{\"$name\"};\n\t};\n\n\t\n\tgoto &{$AUTOLOAD};\t\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nNet::DNS::Resolver::Base - Common Resolver Class\n\n=head1 SYNOPSIS\n\n use base qw/Net::DNS::Resolver::Base/;\n\n=head1 DESCRIPTION\n\nThis class is the common base class for the different platform\nsub-classes of L<Net::DNS::Resolver|Net::DNS::Resolver>.  \n\nNo user serviceable parts inside, see L<Net::DNS::Resolver|Net::DNS::Resolver>\nfor all your resolving needs.\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\nPortions Copyright (c) 2005 Olaf Kolkman  <olaf@net-dns.org>\nPortions Copyright (c) 2006 Dick Franks.\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>\n\n=cut\n\n\n", 8192) = 7121
09:01:57.310155 brk(0x1751000)          = 0x1751000
09:01:57.310669 lseek(11, 39099, SEEK_SET) = 39099
09:01:57.310717 lseek(11, 0, SEEK_CUR)  = 39099
09:01:57.310762 close(11)               = 0
09:01:57.310846 stat("modules/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.310899 stat("modules/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.310949 stat("/etc/perl/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.311000 stat("/usr/local/lib/perl/5.14.2/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.311052 stat("/usr/local/share/perl/5.14.2/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.311103 stat("/usr/lib/perl5/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.311152 stat("/usr/share/perl5/Config_heavy.pl", 0x7ffe12339fd0) = -1 ENOENT (No such file or directory)
09:01:57.311202 stat("/usr/lib/perl/5.14/Config_heavy.pl", {st_mode=S_IFREG|0644, st_size=45500, ...}) = 0
09:01:57.311263 open("/usr/lib/perl/5.14/Config_heavy.pl", O_RDONLY) = 11
09:01:57.311317 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339d60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.311371 lseek(11, 0, SEEK_CUR)  = 0
09:01:57.311430 read(11, "# This file was created by configpm when Perl was built. Any changes\n# made to this file will be lost the next time perl is built.\n\npackage Config;\nuse strict;\nuse warnings;\nuse vars '%Config';\n\nsub bincompat_options {\n    return split ' ', (Internals::V())[0];\n}\n\nsub non_bincompat_options {\n    return split ' ', (Internals::V())[1];\n}\n\nsub compile_date {\n    return (Internals::V())[2]\n}\n\nsub local_patches {\n    my (undef, undef, undef, @patches) = Internals::V();\n    return @patches;\n}\n\nsub _V {\n    my ($bincompat, $non_bincompat, $date, @patches) = Internals::V();\n\n    my $opts = join ' ', sort split ' ', \"$bincompat $non_bincompat\";\n\n    # wrap at 76 columns.\n\n    $opts =~ s/(?=.{53})(.{1,53}) /$1\\n                        /mg;\n\n    print Config::myconfig();\n    if ($^O eq 'VMS') {\n        print \"\\nCharacteristics of this PERLSHR image: \\n\";\n    } else {\n        print \"\\nCharacteristics of this binary (from libperl): \\n\";\n    }\n\n    print \"  Compile-time options: $opts\\n\";\n\n    if (@patches) {\n        print \"  Locally applied patches:\\n\";\n        print \"\\t$_\\n\" foreach @patches;\n    }\n\n    print \"  Built under $^O\\n\";\n\n    print \"  $date\\n\" if defined $date;\n\n    my @env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV;\n    push @env, \"CYGWIN=\\\"$ENV{CYGWIN}\\\"\" if $^O eq 'cygwin' and $ENV{CYGWIN};\n\n    if (@env) {\n        print \"  \\%ENV:\\n\";\n        print \"    $_\\n\" foreach @env;\n    }\n    print \"  \\@INC:\\n\";\n    print \"    $_\\n\" foreach @INC;\n}\n\nsub header_files {\n    return qw(EXTERN.h INTERN.h XSUB.h av.h config.h cop.h cv.h\n              dosish.h embed.h embedvar.h form.h gv.h handy.h hv.h intrpvar.h\n              iperlsys.h keywords.h mg.h nostdio.h op.h opcode.h pad.h\n              parser.h patchlevel.h perl.h perlio.h perliol.h perlsdio.h\n              perlsfio.h perlvars.h perly.h pp.h pp_proto.h proto.h regcomp.h\n              regexp.h regnodes.h scope.h sv.h thread.h time64.h unixish.h\n              utf8.h util.h);\n}\n\n##\n## This file was produced by running the Configure script. It holds all the\n## definitions figured out by Configure. Should you modify one of these values,\n## do not forget to propagate your changes by running \"Configure -der\". You may\n## instead choose to run each of the .SH files by yourself, or \"Configure -S\".\n##\n#\n## Package name      : perl5\n## Source directory  : .\n## Configuration time: Tue Sep 30 09:49:44 UTC 2014\n## Configured by     : Debian Project\n## Target system     : linux binet 3.2.0-4-amd64 #1 smp debian 3.2.60-1+deb7u3 x86_64 gnulinux \n#\n#: Configure command line arguments.\n#\n#: Variables propagated from previous config.sh file.\n\nour $summary = <<'!END!';\nSummary of my $package (revision $revision $version_patchlevel_string) configuration:\n  $git_commit_id_title $git_commit_id$git_ancestor_line\n  Platform:\n    osname=$osname, osvers=$osvers, archname=$archname\n    uname='$myuname'\n    config_args='$config_args'\n    hint=$hint, useposix=$useposix, d_sigaction=$d_sigaction\n    useithreads=$useithreads, usemultiplicity=$usemultiplicity\n    useperlio=$useperlio, d_sfio=$d_sfio, uselargefiles=$uselargefiles, usesocks=$usesocks\n    use64bitint=$use64bitint, use64bitall=$use64bitall, uselongdouble=$uselongdouble\n    usemymalloc=$usemymalloc, bincompat5005=undef\n  Compiler:\n    cc='$cc', ccflags ='$ccflags',\n    optimize='$optimize',\n    cppflags='$cppflags'\n    ccversion='$ccversion', gccversion='$gccversion', gccosandvers='$gccosandvers'\n    intsize=$intsize, longsize=$longsize, ptrsize=$ptrsize, doublesize=$doublesize, byteorder=$byteorder\n    d_longlong=$d_longlong, longlongsize=$longlongsize, d_longdbl=$d_longdbl, longdblsize=$longdblsize\n    ivtype='$ivtype', ivsize=$ivsize, nvtype='$nvtype', nvsize=$nvsize, Off_t='$lseektype', lseeksize=$lseeksize\n    alignbytes=$alignbytes, prototype=$prototype\n  Linker and Libraries:\n    ld='$ld', ldflags ='$ldflags'\n    libpth=$libpth\n    libs=$libs\n    perllibs=$perllibs\n    libc=$libc, so=$so, useshrplib=$useshrplib, libperl=$libperl\n    gnulibc_version='$gnulibc_version'\n  Dynamic Linking:\n    dlsrc=$dlsrc, dlext=$dlext, d_dlsymun=$d_dlsymun, ccdlflags='$ccdlflags'\n    cccdlflags='$cccdlflags', lddlflags='$lddlflags'\n\n!END!\nmy $summary_expanded;\n\nsub myconfig {\n    return $summary_expanded if $summary_expanded;\n    ($summary_expanded = $summary) =~ s{\\$(\\w+)}\n\t\t { \n\t\t\tmy $c;\n\t\t\tif ($1 eq 'git_ancestor_line') {\n\t\t\t\tif ($Config::Config{git_ancestor}) {\n\t\t\t\t\t$c= \"\\n  Ancestor: $Config::Config{git_ancestor}\";\n\t\t\t\t} else {\n\t\t\t\t\t$c= \"\";\n\t\t\t\t}\n\t\t\t} else {\n                     \t\t$c = $Config::Config{$1}; \n\t\t\t}\n\t\t\tdefined($c) ? $c : 'undef' \n\t\t}ge;\n    $summary_expanded;\n}\n\nlocal *_ = \\my $a;\n$_ = <<'!END!';\nAuthor=''\nCONFIG='true'\nDate='$Date'\nHeader=''\nId='$Id'\nLocker=''\nLog='$Log'\nPATCHLEVEL='14'\nPERL_API_REVISION='5'\nPERL_API_SUBVERSION='0'\nPERL_API_VERSION='14'\nPERL_CONFIG_SH='true'\nPERL_PATCHLEVEL=''\nPERL_REVISION='5'\nPERL_SUBVERSION='2'\nPERL_VERSION='14'\nRCSfile='$RCSfile'\nRevision='$Revision'\nSUBVERSION='2'\nSource=''\nState=''\n_a='.a'\n_exe=''\n_o='.o'\nafs='false'\nafsroot='/afs'\nalignbytes='8'\nansi2knr=''\naphostname='/bin/hostname'\napi_revision='5'\napi_subversion='0'\napi_version='14'\napi_versionstring='5.14.0'\nar='ar'\narchlib='/usr/lib/perl/5.14'\narchlibexp='/usr/lib/perl/5.14'\narchname64=''\narchname='x86_64-linux-gnu-thread-multi'\narchobjs=''\nasctime_r_proto='REENTRANT_PROTO_B_SB'\nawk='awk'\nbaserev='5.0'\nbash=''\nbin='/usr/bin'\nbin_ELF='define'\nbinexp='/usr/bin'\nbison='bison'\nbyacc='byacc'\nbyteorder='12345678'\nc=''\ncastflags='0'\ncat='cat'\ncc='cc'\ncccdlflags='-fPIC'\nccdlflags='-Wl,-E'\nccflags='-D_REENTRANT -D_GNU_SOURCE -DDEBIAN -fstack-protector -fno-strict-aliasing -pipe -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64'\nccflags_uselargefiles='-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64'\nccname='gcc'\nccsymbols=''\nccversion=''\ncf_by='Debian Project'\ncf_email='perl@packages.debian.org'\ncf_time='Tue Sep 30 09:49:44 UTC 2014'\ncharbits='8'\ncharsize='1'\nchgrp=''\nchmod='chmod'\nchown=''\nclocktype='clock_t'\ncomm='comm'\ncompress=''\nconfig_arg0='Configure'\nconfig_arg10='-Darchlib=/usr/lib/perl/5.14'\nconfig_arg11='-Dvendorprefix=/usr'\nconfig_arg12='-Dvendorlib=/usr/share/perl5'\nconfig_arg13='-Dvendorarch=/usr/lib/perl5'\nconfig_arg14='-Dsiteprefix=/usr/local'\nconfig_arg15='-Dsitelib=/usr/local/share/perl/5.14.2'\nconfig_arg16='-Dsitearch=/usr/local/lib/perl/5.14.2'\nconfig_arg17='-Dman1dir=/usr/share/man/man1'\nconfig_arg18='-Dman3dir=/usr/share/man/man3'\nconfig_arg19='-Dsiteman1dir=/usr/local/man/man1'\nconfig_arg1='-Dusethreads'\nconfig_arg20='-Dsiteman3dir=/usr/local/man/man3'\nconfig_arg21='-Duse64bitint'\nconfig_arg22='-Dman1ext=1'\nconfig_arg23='-Dman3ext=3perl'\nconfig_arg24='-Dpager=/usr/bin/sensible-pager'\nconfig_arg25='-Uafs'\nconfig_arg26='-Ud_csh'\nconfig_arg27='-Ud_ualarm'\nconfig_arg28='-Uusesfio'\nconfig_arg29='-Uusenm'\nconfig_arg2='-Duselargefiles'\nconfig_arg30='-Ui_libutil'\nconfig_arg31='-DDEBUGGING=-g'\nconfig_arg32='-Doptimize=-O2'\nconfig_arg33='-Duseshrplib'\nconfig_arg34='-Dlibperl=libperl.so.5.14.2'\nconfig_arg35='-des'\nconfig_arg3='-Dccflags=-DDEBIAN -D_FORTIFY_SOURCE=2 -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security'\nconfig_arg4='-Dldflags= -Wl,-z,relro'\nconfig_arg5='-Dlddlflags=-shared -Wl,-z,relro'\nconfig_arg6='-Dcccdlflags=-fPIC'\nconfig_arg7='-Darchname=x86_64-linux-gnu'\nconfig_arg8='-Dprefix=/usr'\nconfig_arg9='-Dprivlib=/usr/share/perl/5.14'\nconfig_argc='35'\nconfig_args='-Dusethreads -Duselargefiles -Dccflags=-DDEBIAN -D_FORTIFY_SOURCE=2 -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Dldflags= -Wl,-z,relro -Dlddlflags=-shared -Wl,-z,relro -Dcccdlflags=-fPIC -Darchname=x86_64-linux-gnu -Dprefix=/usr -Dprivlib=/usr/share/perl/5.14 -Darchlib=/usr/lib/perl/5.14 -Dvendorprefix=/usr -Dvendorlib=/usr/share/perl5 -Dvendorarch=/usr/lib/perl5 -Dsiteprefix=/usr/local -Dsitelib=/usr/local/share/perl/5.14.2 -Dsitearch=/usr/local/lib/perl/5.14.2 -Dman1dir=/usr/share/man/man1 -Dman3dir=/usr/share/man/man3 -Dsiteman1dir=/usr/local/man/man1 -Dsiteman3dir=/usr/local/man/man3 -Duse64bitint -Dman1ext=1 -Dman3ext=3perl -Dpager=/usr/bin/sensible-pager -Uafs -Ud_csh -Ud_ualarm -Uusesfi", 8192) = 8192
09:01:57.312154 brk(0x1772000)          = 0x1772000
09:01:57.312325 read(11, "o -Uusenm -Ui_libutil -DDEBUGGING=-g -Doptimize=-O2 -Duseshrplib -Dlibperl=libperl.so.5.14.2 -des'\ncontains='grep'\ncp='cp'\ncpio=''\ncpp='cpp'\ncpp_stuff='42'\ncppccsymbols=''\ncppflags='-D_REENTRANT -D_GNU_SOURCE -DDEBIAN -fstack-protector -fno-strict-aliasing -pipe -I/usr/local/include'\ncpplast='-'\ncppminus='-'\ncpprun='cc -E'\ncppstdin='cc -E'\ncppsymbols='_FILE_OFFSET_BITS=64 _GNU_SOURCE=1 _LARGEFILE64_SOURCE=1 _LARGEFILE_SOURCE=1 _LP64=1 _POSIX_C_SOURCE=200809L _POSIX_SOURCE=1 _REENTRANT=1 _XOPEN_SOURCE=700 _XOPEN_SOURCE_EXTENDED=1 __ATOMIC_ACQUIRE=2 __ATOMIC_ACQ_REL=4 __ATOMIC_CONSUME=1 __ATOMIC_RELAXED=0 __ATOMIC_RELEASE=3 __ATOMIC_SEQ_CST=5 __BIGGEST_ALIGNMENT__=16 __BYTE_ORDER__=1234 __CHAR16_TYPE__=short\\ unsigned\\ int __CHAR32_TYPE__=unsigned\\ int __CHAR_BIT__=8 __DBL_DECIMAL_DIG__=17 __DBL_DENORM_MIN__=((double)4.94065645841246544177e-324L) __DBL_DIG__=15 __DBL_EPSILON__=((double)2.22044604925031308085e-16L) __DBL_HAS_DENORM__=1 __DBL_HAS_INFINITY__=1 __DBL_HAS_QUIET_NAN__=1 __DBL_MANT_DIG__=53 __DBL_MAX_10_EXP__=308 __DBL_MAX_EXP__=1024 __DBL_MAX__=((double)1.79769313486231570815e+308L) __DBL_MIN_10_EXP__=(-307) __DBL_MIN_EXP__=(-1021) __DBL_MIN__=((double)2.22507385850720138309e-308L) __DEC128_EPSILON__=1E-33DL __DEC128_MANT_DIG__=34 __DEC128_MAX_EXP__=6145 __DEC128_MAX__=9.999999999999999999999999999999999E6144DL __DEC128_MIN_EXP__=(-6142) __DEC128_MIN__=1E-6143DL __DEC128_SUBNORMAL_MIN__=0.000000000000000000000000000000001E-6143DL __DEC32_EPSILON__=1E-6DF __DEC32_MANT_DIG__=7 __DEC32_MAX_EXP__=97 __DEC32_MAX__=9.999999E96DF __DEC32_MIN_EXP__=(-94) __DEC32_MIN__=1E-95DF __DEC32_SUBNORMAL_MIN__=0.000001E-95DF __DEC64_EPSILON__=1E-15DD __DEC64_MANT_DIG__=16 __DEC64_MAX_EXP__=385 __DEC64_MAX__=9.999999999999999E384DD __DEC64_MIN_EXP__=(-382) __DEC64_MIN__=1E-383DD __DEC64_SUBNORMAL_MIN__=0.000000000000001E-383DD __DECIMAL_BID_FORMAT__=1 __DECIMAL_DIG__=21 __DEC_EVAL_METHOD__=2 __ELF__=1 __FINITE_MATH_ONLY__=0 __FLOAT_WORD_ORDER__=1234 __FLT_DECIMAL_DIG__=9 __FLT_DENORM_MIN__=1.40129846432481707092e-45F __FLT_DIG__=6 __FLT_EPSILON__=1.19209289550781250000e-7F __FLT_EVAL_METHOD__=0 __FLT_HAS_DENORM__=1 __FLT_HAS_INFINITY__=1 __FLT_HAS_QUIET_NAN__=1 __FLT_MANT_DIG__=24 __FLT_MAX_10_EXP__=38 __FLT_MAX_EXP__=128 __FLT_MAX__=3.40282346638528859812e+38F __FLT_MIN_10_EXP__=(-37) __FLT_MIN_EXP__=(-125) __FLT_MIN__=1.17549435082228750797e-38F __FLT_RADIX__=2 __GCC_ATOMIC_BOOL_LOCK_FREE=2 __GCC_ATOMIC_CHAR16_T_LOCK_FREE=2 __GCC_ATOMIC_CHAR32_T_LOCK_FREE=2 __GCC_ATOMIC_CHAR_LOCK_FREE=2 __GCC_ATOMIC_INT_LOCK_FREE=2 __GCC_ATOMIC_LLONG_LOCK_FREE=2 __GCC_ATOMIC_LONG_LOCK_FREE=2 __GCC_ATOMIC_POINTER_LOCK_FREE=2 __GCC_ATOMIC_SHORT_LOCK_FREE=2 __GCC_ATOMIC_TEST_AND_SET_TRUEVAL=1 __GCC_ATOMIC_WCHAR_T_LOCK_FREE=2 __GCC_HAVE_DWARF2_CFI_ASM=1 __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1=1 __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2=1 __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4=1 __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8=1 __GLIBC_MINOR__=13 __GLIBC__=2 __GNUC_GNU_INLINE__=1 __GNUC_MINOR__=7 __GNUC_PATCHLEVEL__=2 __GNUC__=4 __GNU_LIBRARY__=6 __GXX_ABI_VERSION=1002 __INT16_C(c)=c __INT16_MAX__=32767 __INT16_TYPE__=short\\ int __INT32_C(c)=c __INT32_MAX__=2147483647 __INT32_TYPE__=int __INT64_C(c)=cL __INT64_MAX__=9223372036854775807L __INT64_TYPE__=long\\ int __INT8_C(c)=c __INT8_MAX__=127 __INT8_TYPE__=signed\\ char __INTMAX_C(c)=cL __INTMAX_MAX__=9223372036854775807L __INTMAX_TYPE__=long\\ int __INTPTR_MAX__=9223372036854775807L __INTPTR_TYPE__=long\\ int __INT_FAST16_MAX__=9223372036854775807L __INT_FAST16_TYPE__=long\\ int __INT_FAST32_MAX__=9223372036854775807L __INT_FAST32_TYPE__=long\\ int __INT_FAST64_MAX__=9223372036854775807L __INT_FAST64_TYPE__=long\\ int __INT_FAST8_MAX__=127 __INT_FAST8_TYPE__=signed\\ char __INT_LEAST16_MAX__=32767 __INT_LEAST16_TYPE__=short\\ int __INT_LEAST32_MAX__=2147483647 __INT_LEAST32_TYPE__=int __INT_LEAST64_MAX__=9223372036854775807L __INT_LEAST64_TYPE__=long\\ int __INT_LEAST8_MAX__=127 __INT_LEAST8_TYPE__=signed\\ char __INT_MAX__=2147483647 __LDBL_DENORM_MIN__=3.64519953188247460253e-4951L __LDBL_DIG__=18 __LDBL_EPSILON__=1.08420217248550443401e-19L __LDBL_HAS_DENORM__=1 __LDBL_HAS_INFINITY__=1 __LDBL_HAS_QUIET_NAN__=1 __LDBL_MANT_DIG__=64 __LDBL_MAX_10_EXP__=4932 __LDBL_MAX_EXP__=16384 __LDBL_MAX__=1.18973149535723176502e+4932L __LDBL_MIN_10_EXP__=(-4931) __LDBL_MIN_EXP__=(-16381) __LDBL_MIN__=3.36210314311209350626e-4932L __LONG_LONG_MAX__=9223372036854775807LL __LONG_MAX__=9223372036854775807L __LP64__=1 __MMX__=1 __ORDER_BIG_ENDIAN__=4321 __ORDER_LITTLE_ENDIAN__=1234 __ORDER_PDP_ENDIAN__=3412 __PRAGMA_REDEFINE_EXTNAME=1 __PTRDIFF_MAX__=9223372036854775807L __PTRDIFF_TYPE__=long\\ int __REGISTER_PREFIX__= __SCHAR_MAX__=127 __SHRT_MAX__=32767 __SIG_ATOMIC_MAX__=2147483647 __SIG_ATOMIC_MIN__=(-2147483647\\ -\\ 1) __SIG_ATOMIC_TYPE__=int __SIZEOF_DOUBLE__=8 __SIZEOF_FLOAT__=4 __SIZEOF_INT128__=16 __SIZEOF_INT__=4 __SIZEOF_LONG_DOUBLE__=16 __SIZEOF_LONG_LONG__=8 __SIZEOF_LONG__=8 __SIZEOF_POINTER__=8 __SIZEOF_PTRDIFF_T__=8 __SIZEOF_SHORT__=2 __SIZEOF_SIZE_T__=8 __SIZEOF_WCHAR_T__=4 __SIZEOF_WINT_T__=4 __SIZE_MAX__=18446744073709551615UL __SIZE_TYPE__=long\\ unsigned\\ int __SSE2_MATH__=1 __SSE2__=1 __SSE_MATH__=1 __SSE__=1 __STDC_HOSTED__=1 __STDC__=1 __UINT16_C(c)=c __UINT16_MAX__=65535 __UINT16_TYPE__=short\\ unsigned\\ int __UINT32_C(c)=cU __UINT32_MAX__=4294967295U __UINT32_TYPE__=unsigned\\ int __UINT64_C(c)=cUL __UINT64_MAX__=18446744073709551615UL __UINT64_TYPE__=long\\ unsigned\\ int __UINT8_C(c)=c __UINT8_MAX__=255 __UINT8_TYPE__=unsigned\\ char __UINTMAX_C(c)=cUL __UINTMAX_MAX__=18446744073709551615UL __UINTMAX_TYPE__=long\\ unsigned\\ int __UINTPTR_MAX__=18446744073709551615UL __UINTPTR_TYPE__=long\\ unsigned\\ int __UINT_FAST16_MAX__=18446744073709551615UL __UINT_FAST16_TYPE__=long\\ unsigned\\ int __UINT_FAST32_MAX__=18446744073709551615UL __UINT_FAST32_TYPE__=long\\ unsigned\\ int __UINT_FAST64_MAX__=18446744073709551615UL __UINT_FAST64_TYPE__=long\\ unsigned\\ int __UINT_FAST8_MAX__=255 __UINT_FAST8_TYPE__=unsigned\\ char __UINT_LEAST16_MAX__=65535 __UINT_LEAST16_TYPE__=short\\ unsigned\\ int __UINT_LEAST32_MAX__=4294967295U __UINT_LEAST32_TYPE__=unsigned\\ int __UINT_LEAST64_MAX__=18446744073709551615UL __UINT_LEAST64_TYPE__=long\\ unsigned\\ int __UINT_LEAST8_MAX__=255 __UINT_LEAST8_TYPE__=unsigned\\ char __USER_LABEL_PREFIX__= __USE_BSD=1 __USE_FILE_OFFSET64=1 __USE_GNU=1 __USE_LARGEFILE64=1 __USE_LARGEFILE=1 __USE_MISC=1 __USE_POSIX199309=1 __USE_POSIX199506=1 __USE_POSIX2=1 __USE_POSIX=1 __USE_REENTRANT=1 __USE_SVID=1 __USE_UNIX98=1 __USE_XOPEN=1 __USE_XOPEN_EXTENDED=1 __VERSION__=\"4.7.2\" __WCHAR_MAX__=2147483647 __WCHAR_MIN__=(-2147483647\\ -\\ 1) __WCHAR_TYPE__=int __WINT_MAX__=4294967295U __WINT_MIN__=0U __WINT_TYPE__=unsigned\\ int __amd64=1 __amd64__=1 __gnu_linux__=1 __k8=1 __k8__=1 __linux=1 __linux__=1 __unix=1 __unix__=1 __x86_64=1 __x86_64__=1 linux=1 unix=1'\ncrypt_r_proto='REENTRANT_PROTO_B_CCS'\ncryptlib=''\ncsh='csh'\nctermid_r_proto='0'\nctime_r_proto='REENTRANT_PROTO_B_SB'\nd_Gconvert='gcvt((x),(n),(b))'\nd_PRIEUldbl='define'\nd_PRIFUldbl='define'\nd_PRIGUldbl='define'\nd_PRIXU64='define'\nd_PRId64='define'\nd_PRIeldbl='define'\nd_PRIfldbl='define'\nd_PRIgldbl='define'\nd_PRIi64='define'\nd_PRIo64='define'\nd_PRIu64='define'\nd_PRIx64='define'\nd_SCNfldbl='define'\nd__fwalk='undef'\nd_access='define'\nd_accessx='undef'\nd_aintl='undef'\nd_alarm='define'\nd_archlib='define'\nd_asctime64='undef'\nd_asctime_r='define'\nd_atolf='undef'\nd_atoll='define'\nd_attribute_deprecated='define'\nd_attribute_format='define'\nd_attribute_malloc='define'\nd_attribute_nonnull='define'\nd_attribute_noreturn='define'\nd_attribute_pure='define'\nd_attribute_unused='define'\nd_attribute_warn_unused_result='define'\nd_bcmp='define'\nd_bcopy='define'\nd_bsd='undef'\nd_bsdgetpgrp='undef'\nd_bsdsetpgrp='undef'\nd_builtin_choose_expr='define'\nd_builtin_expect='define'\nd_bzero='define'\nd_c99_variadic_macros='define'\nd_casti32='undef'\nd_castneg='define'\nd_charvspr='undef'\nd_chown='define'\nd_chroot='define'\nd_chsize='undef'\nd_class='undef'\nd_clearenv='define'\nd_closedir='define'\nd_cmsghdr_s='define'\nd_const='define'\nd_copysignl='define'\nd_cplusplus='undef'\nd_crypt='define'\nd_crypt_r='define'\nd_csh='undef'\nd_ctermid='define'\nd_c", 8192) = 8192
09:01:57.312758 read(11, "termid_r='undef'\nd_ctime64='undef'\nd_ctime_r='define'\nd_cuserid='define'\nd_dbl_dig='define'\nd_dbminitproto='define'\nd_difftime64='undef'\nd_difftime='define'\nd_dir_dd_fd='undef'\nd_dirfd='define'\nd_dirnamlen='undef'\nd_dlerror='define'\nd_dlopen='define'\nd_dlsymun='undef'\nd_dosuid='undef'\nd_drand48_r='define'\nd_drand48proto='define'\nd_dup2='define'\nd_eaccess='define'\nd_endgrent='define'\nd_endgrent_r='undef'\nd_endhent='define'\nd_endhostent_r='undef'\nd_endnent='define'\nd_endnetent_r='undef'\nd_endpent='define'\nd_endprotoent_r='undef'\nd_endpwent='define'\nd_endpwent_r='undef'\nd_endsent='define'\nd_endservent_r='undef'\nd_eofnblk='define'\nd_eunice='undef'\nd_faststdio='define'\nd_fchdir='define'\nd_fchmod='define'\nd_fchown='define'\nd_fcntl='define'\nd_fcntl_can_lock='define'\nd_fd_macros='define'\nd_fd_set='define'\nd_fds_bits='define'\nd_fgetpos='define'\nd_finite='define'\nd_finitel='define'\nd_flexfnam='define'\nd_flock='define'\nd_flockproto='define'\nd_fork='define'\nd_fp_class='undef'\nd_fpathconf='define'\nd_fpclass='undef'\nd_fpclassify='undef'\nd_fpclassl='undef'\nd_fpos64_t='undef'\nd_frexpl='define'\nd_fs_data_s='undef'\nd_fseeko='define'\nd_fsetpos='define'\nd_fstatfs='define'\nd_fstatvfs='define'\nd_fsync='define'\nd_ftello='define'\nd_ftime='undef'\nd_futimes='define'\nd_gdbm_ndbm_h_uses_prototypes='undef'\nd_gdbmndbm_h_uses_prototypes='undef'\nd_getaddrinfo='define'\nd_getcwd='define'\nd_getespwnam='undef'\nd_getfsstat='undef'\nd_getgrent='define'\nd_getgrent_r='define'\nd_getgrgid_r='define'\nd_getgrnam_r='define'\nd_getgrps='define'\nd_gethbyaddr='define'\nd_gethbyname='define'\nd_gethent='define'\nd_gethname='define'\nd_gethostbyaddr_r='define'\nd_gethostbyname_r='define'\nd_gethostent_r='define'\nd_gethostprotos='define'\nd_getitimer='define'\nd_getlogin='define'\nd_getlogin_r='define'\nd_getmnt='undef'\nd_getmntent='define'\nd_getnameinfo='define'\nd_getnbyaddr='define'\nd_getnbyname='define'\nd_getnent='define'\nd_getnetbyaddr_r='define'\nd_getnetbyname_r='define'\nd_getnetent_r='define'\nd_getnetprotos='define'\nd_getpagsz='define'\nd_getpbyname='define'\nd_getpbynumber='define'\nd_getpent='define'\nd_getpgid='define'\nd_getpgrp2='undef'\nd_getpgrp='define'\nd_getppid='define'\nd_getprior='define'\nd_getprotobyname_r='define'\nd_getprotobynumber_r='define'\nd_getprotoent_r='define'\nd_getprotoprotos='define'\nd_getprpwnam='undef'\nd_getpwent='define'\nd_getpwent_r='define'\nd_getpwnam_r='define'\nd_getpwuid_r='define'\nd_getsbyname='define'\nd_getsbyport='define'\nd_getsent='define'\nd_getservbyname_r='define'\nd_getservbyport_r='define'\nd_getservent_r='define'\nd_getservprotos='define'\nd_getspnam='define'\nd_getspnam_r='define'\nd_gettimeod='define'\nd_gmtime64='undef'\nd_gmtime_r='define'\nd_gnulibc='define'\nd_grpasswd='define'\nd_hasmntopt='define'\nd_htonl='define'\nd_ilogbl='define'\nd_inc_version_list='undef'\nd_index='undef'\nd_inetaton='define'\nd_inetntop='define'\nd_inetpton='define'\nd_int64_t='define'\nd_isascii='define'\nd_isfinite='undef'\nd_isinf='define'\nd_isnan='define'\nd_isnanl='define'\nd_killpg='define'\nd_lchown='define'\nd_ldbl_dig='define'\nd_libm_lib_version='define'\nd_link='define'\nd_localtime64='undef'\nd_localtime_r='define'\nd_localtime_r_needs_tzset='define'\nd_locconv='define'\nd_lockf='define'\nd_longdbl='define'\nd_longlong='define'\nd_lseekproto='define'\nd_lstat='define'\nd_madvise='define'\nd_malloc_good_size='undef'\nd_malloc_size='undef'\nd_mblen='define'\nd_mbstowcs='define'\nd_mbtowc='define'\nd_memchr='define'\nd_memcmp='define'\nd_memcpy='define'\nd_memmove='define'\nd_memset='define'\nd_mkdir='define'\nd_mkdtemp='define'\nd_mkfifo='define'\nd_mkstemp='define'\nd_mkstemps='define'\nd_mktime64='undef'\nd_mktime='define'\nd_mmap='define'\nd_modfl='define'\nd_modfl_pow32_bug='undef'\nd_modflproto='define'\nd_mprotect='define'\nd_msg='define'\nd_msg_ctrunc='define'\nd_msg_dontroute='define'\nd_msg_oob='define'\nd_msg_peek='define'\nd_msg_proxy='define'\nd_msgctl='define'\nd_msgget='define'\nd_msghdr_s='define'\nd_msgrcv='define'\nd_msgsnd='define'\nd_msync='define'\nd_munmap='define'\nd_mymalloc='undef'\nd_ndbm='define'\nd_ndbm_h_uses_prototypes='undef'\nd_nice='define'\nd_nl_langinfo='define'\nd_nv_preserves_uv='undef'\nd_nv_zero_is_allbits_zero='define'\nd_off64_t='define'\nd_old_pthread_create_joinable='undef'\nd_oldpthreads='undef'\nd_oldsock='undef'\nd_open3='define'\nd_pathconf='define'\nd_pause='define'\nd_perl_otherlibdirs='undef'\nd_phostname='undef'\nd_pipe='define'\nd_poll='define'\nd_portable='define'\nd_prctl='define'\nd_prctl_set_name='define'\nd_printf_format_null='undef'\nd_procselfexe='define'\nd_pseudofork='undef'\nd_pthread_atfork='define'\nd_pthread_attr_setscope='define'\nd_pthread_yield='define'\nd_pwage='undef'\nd_pwchange='undef'\nd_pwclass='undef'\nd_pwcomment='undef'\nd_pwexpire='undef'\nd_pwgecos='define'\nd_pwpasswd='define'\nd_pwquota='undef'\nd_qgcvt='define'\nd_quad='define'\nd_random_r='define'\nd_readdir64_r='define'\nd_readdir='define'\nd_readdir_r='define'\nd_readlink='define'\nd_readv='define'\nd_recvmsg='define'\nd_rename='define'\nd_rewinddir='define'\nd_rmdir='define'\nd_safebcpy='undef'\nd_safemcpy='undef'\nd_sanemcmp='define'\nd_sbrkproto='define'\nd_scalbnl='define'\nd_sched_yield='define'\nd_scm_rights='define'\nd_seekdir='define'\nd_select='define'\nd_sem='define'\nd_semctl='define'\nd_semctl_semid_ds='define'\nd_semctl_semun='define'\nd_semget='define'\nd_semop='define'\nd_sendmsg='define'\nd_setegid='define'\nd_seteuid='define'\nd_setgrent='define'\nd_setgrent_r='undef'\nd_setgrps='define'\nd_sethent='define'\nd_sethostent_r='undef'\nd_setitimer='define'\nd_setlinebuf='define'\nd_setlocale='define'\nd_setlocale_r='undef'\nd_setnent='define'\nd_setnetent_r='undef'\nd_setpent='define'\nd_setpgid='define'\nd_setpgrp2='undef'\nd_setpgrp='define'\nd_setprior='define'\nd_setproctitle='undef'\nd_setprotoent_r='undef'\nd_setpwent='define'\nd_setpwent_r='undef'\nd_setregid='define'\nd_setresgid='define'\nd_setresuid='define'\nd_setreuid='define'\nd_setrgid='undef'\nd_setruid='undef'\nd_setsent='define'\nd_setservent_r='undef'\nd_setsid='define'\nd_setvbuf='define'\nd_sfio='undef'\nd_shm='define'\nd_shmat='define'\nd_shmatprototype='define'\nd_shmctl='define'\nd_shmdt='define'\nd_shmget='define'\nd_sigaction='define'\nd_signbit='define'\nd_sigprocmask='define'\nd_sigsetjmp='define'\nd_sin6_scope_id='define'\nd_sitearch='define'\nd_snprintf='define'\nd_sockaddr_sa_len='undef'\nd_sockatmark='define'\nd_sockatmarkproto='define'\nd_socket='define'\nd_socklen_t='define'\nd_sockpair='define'\nd_socks5_init='undef'\nd_sprintf_returns_strlen='define'\nd_sqrtl='define'\nd_srand48_r='define'\nd_srandom_r='define'\nd_sresgproto='define'\nd_sresuproto='define'\nd_statblks='define'\nd_statfs_f_flags='define'\nd_statfs_s='define'\nd_static_inline='define'\nd_statvfs='define'\nd_stdio_cnt_lval='undef'\nd_stdio_ptr_lval='define'\nd_stdio_ptr_lval_nochange_cnt='undef'\nd_stdio_ptr_lval_sets_cnt='define'\nd_stdio_stream_array='undef'\nd_stdiobase='define'\nd_stdstdio='define'\nd_strchr='define'\nd_strcoll='define'\nd_strctcpy='define'\nd_strerrm='strerror(e)'\nd_strerror='define'\nd_strerror_r='define'\nd_strftime='define'\nd_strlcat='undef'\nd_strlcpy='undef'\nd_strtod='define'\nd_strtol='define'\nd_strtold='define'\nd_strtoll='define'\nd_strtoq='define'\nd_strtoul='define'\nd_strtoull='define'\nd_strtouq='define'\nd_strxfrm='define'\nd_suidsafe='undef'\nd_symlink='define'\nd_syscall='define'\nd_syscallproto='define'\nd_sysconf='define'\nd_sysernlst=''\nd_syserrlst='define'\nd_system='define'\nd_tcgetpgrp='define'\nd_tcsetpgrp='define'\nd_telldir='define'\nd_telldirproto='define'\nd_time='define'\nd_timegm='define'\nd_times='define'\nd_tm_tm_gmtoff='define'\nd_tm_tm_zone='define'\nd_tmpnam_r='define'\nd_truncate='define'\nd_ttyname_r='define'\nd_tzname='define'\nd_u32align='define'\nd_ualarm='undef'\nd_umask='define'\nd_uname='define'\nd_union_semun='undef'\nd_unordered='undef'\nd_unsetenv='define'\nd_usleep='define'\nd_usleepproto='define'\nd_ustat='define'\nd_vendorarch='define'\nd_vendorbin='define'\nd_vendorlib='define'\nd_vendorscript='define'\nd_vfork='undef'\nd_void_closedir='undef'\nd_voidsig='define'\nd_voidtty=''\nd_volatile='define'\nd_vprintf='define'\nd_vsnprintf='define'\nd_wait4='define'\nd_waitpid='define'\nd_wcstombs='define'\nd_wctomb='define'\nd_writev='define'\nd_xenix='undef'\ndate='date'\ndb_hashtype='u_int32_t'\ndb_prefixtype='size_t'\ndb_version_major='5'\ndb_version_minor='1'\ndb_version_patch='29", 8192) = 8192
09:01:57.313210 read(11, "'\ndefvoidused='15'\ndirentrytype='struct dirent'\ndlext='so'\ndlsrc='dl_dlopen.xs'\ndoublesize='8'\ndrand01='drand48()'\ndrand48_r_proto='REENTRANT_PROTO_I_ST'\ndtrace=''\ndynamic_ext='B Compress/Raw/Bzip2 Compress/Raw/Zlib Cwd DB_File Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Fcntl File/Glob Filter/Util/Call GDBM_File Hash/Util Hash/Util/FieldHash I18N/Langinfo IO IPC/SysV List/Util MIME/Base64 Math/BigInt/FastCalc NDBM_File ODBM_File Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Sys/Syslog Text/Soundex Tie/Hash/NamedCapture Time/HiRes Time/Piece Unicode/Collate Unicode/Normalize XS/APItest XS/Typemap attributes mro re threads threads/shared'\neagain='EAGAIN'\nebcdic='undef'\necho='echo'\negrep='egrep'\nemacs=''\nendgrent_r_proto='0'\nendhostent_r_proto='0'\nendnetent_r_proto='0'\nendprotoent_r_proto='0'\nendpwent_r_proto='0'\nendservent_r_proto='0'\neunicefix=':'\nexe_ext=''\nexpr='expr'\nextensions='B Compress/Raw/Bzip2 Compress/Raw/Zlib Cwd DB_File Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Fcntl File/Glob Filter/Util/Call GDBM_File Hash/Util Hash/Util/FieldHash I18N/Langinfo IO IPC/SysV List/Util MIME/Base64 Math/BigInt/FastCalc NDBM_File ODBM_File Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Sys/Syslog Text/Soundex Tie/Hash/NamedCapture Time/HiRes Time/Piece Unicode/Collate Unicode/Normalize XS/APItest XS/Typemap attributes mro re threads threads/shared Archive/Extract Archive/Tar Attribute/Handlers AutoLoader B/Debug B/Deparse B/Lint CGI CPAN CPAN/Meta CPAN/Meta/YAML CPANPLUS CPANPLUS/Dist/Build Devel/SelfStubber Digest Dumpvalue Env Errno ExtUtils/CBuilder ExtUtils/Command ExtUtils/Constant ExtUtils/Install ExtUtils/MakeMaker ExtUtils/Manifest ExtUtils/ParseXS File/CheckTree File/Fetch File/Path File/Temp FileCache Filter/Simple Getopt/Long HTTP/Tiny I18N/Collate I18N/LangTags IO/Compress IO/Zlib IPC/Cmd IPC/Open2 IPC/Open3 JSON/PP Locale/Codes Locale/Maketext Locale/Maketext/Simple Log/Message Log/Message/Simple Math/BigInt Math/BigRat Math/Complex Memoize Module/Build Module/CoreList Module/Load Module/Load/Conditional Module/Loaded Module/Metadata Module/Pluggable NEXT Net/Ping Object/Accessor Package/Constants Params/Check Parse/CPAN/Meta Perl/OSType PerlIO/via/QuotedPrint Pod/Escapes Pod/Html Pod/LaTeX Pod/Parser Pod/Perldoc Pod/Simple Safe SelfLoader Shell Term/ANSIColor Term/Cap Term/UI Test Test/Harness Test/Simple Text/Balanced Text/ParseWords Text/Tabs Thread/Queue Thread/Semaphore Tie/File Tie/Memoize Tie/RefHash Time/Local Version/Requirements XSLoader autodie autouse base bignum constant encoding/warnings if lib libnet parent podlators'\nextern_C='extern'\nextras=''\nfflushNULL='define'\nfflushall='undef'\nfind=''\nfirstmakefile='makefile'\nflex=''\nfpossize='16'\nfpostype='fpos_t'\nfreetype='void'\nfrom=':'\nfull_ar='/usr/bin/ar'\nfull_csh='csh'\nfull_sed='/bin/sed'\ngccansipedantic=''\ngccosandvers=''\ngccversion='4.7.2'\ngetgrent_r_proto='REENTRANT_PROTO_I_SBWR'\ngetgrgid_r_proto='REENTRANT_PROTO_I_TSBWR'\ngetgrnam_r_proto='REENTRANT_PROTO_I_CSBWR'\ngethostbyaddr_r_proto='REENTRANT_PROTO_I_TsISBWRE'\ngethostbyname_r_proto='REENTRANT_PROTO_I_CSBWRE'\ngethostent_r_proto='REENTRANT_PROTO_I_SBWRE'\ngetlogin_r_proto='REENTRANT_PROTO_I_BW'\ngetnetbyaddr_r_proto='REENTRANT_PROTO_I_uISBWRE'\ngetnetbyname_r_proto='REENTRANT_PROTO_I_CSBWRE'\ngetnetent_r_proto='REENTRANT_PROTO_I_SBWRE'\ngetprotobyname_r_proto='REENTRANT_PROTO_I_CSBWR'\ngetprotobynumber_r_proto='REENTRANT_PROTO_I_ISBWR'\ngetprotoent_r_proto='REENTRANT_PROTO_I_SBWR'\ngetpwent_r_proto='REENTRANT_PROTO_I_SBWR'\ngetpwnam_r_proto='REENTRANT_PROTO_I_CSBWR'\ngetpwuid_r_proto='REENTRANT_PROTO_I_TSBWR'\ngetservbyname_r_proto='REENTRANT_PROTO_I_CCSBWR'\ngetservbyport_r_proto='REENTRANT_PROTO_I_ICSBWR'\ngetservent_r_proto='REENTRANT_PROTO_I_SBWR'\ngetspnam_r_proto='REENTRANT_PROTO_I_CSBWR'\ngidformat='\"u\"'\ngidsign='1'\ngidsize='4'\ngidtype='gid_t'\nglibpth='/usr/shlib  /lib /usr/lib /usr/lib/386 /lib/386 /usr/ccs/lib /usr/ucblib /usr/local/lib '\ngmake='gmake'\ngmtime_r_proto='REENTRANT_PROTO_S_TS'\ngnulibc_version='2.13'\ngrep='grep'\ngroupcat='cat /etc/group'\ngroupstype='gid_t'\ngzip='gzip'\nh_fcntl='false'\nh_sysfile='true'\nhint='recommended'\nhostcat='cat /etc/hosts'\nhtml1dir=' '\nhtml1direxp=''\nhtml3dir=' '\nhtml3direxp=''\ni16size='2'\ni16type='short'\ni32size='4'\ni32type='int'\ni64size='8'\ni64type='long'\ni8size='1'\ni8type='signed char'\ni_arpainet='define'\ni_assert='define'\ni_bsdioctl=''\ni_crypt='define'\ni_db='define'\ni_dbm='define'\ni_dirent='define'\ni_dld='undef'\ni_dlfcn='define'\ni_fcntl='undef'\ni_float='define'\ni_fp='undef'\ni_fp_class='undef'\ni_gdbm='define'\ni_gdbm_ndbm='define'\ni_gdbmndbm='undef'\ni_grp='define'\ni_ieeefp='undef'\ni_inttypes='define'\ni_langinfo='define'\ni_libutil='undef'\ni_limits='define'\ni_locale='define'\ni_machcthr='undef'\ni_malloc='define'\ni_mallocmalloc='undef'\ni_math='define'\ni_memory='undef'\ni_mntent='define'\ni_ndbm='undef'\ni_netdb='define'\ni_neterrno='undef'\ni_netinettcp='define'\ni_niin='define'\ni_poll='define'\ni_prot='undef'\ni_pthread='define'\ni_pwd='define'\ni_rpcsvcdbm='undef'\ni_sfio='undef'\ni_sgtty='undef'\ni_shadow='define'\ni_socks='undef'\ni_stdarg='define'\ni_stddef='define'\ni_stdlib='define'\ni_string='define'\ni_sunmath='undef'\ni_sysaccess='undef'\ni_sysdir='define'\ni_sysfile='define'\ni_sysfilio='undef'\ni_sysin='undef'\ni_sysioctl='define'\ni_syslog='define'\ni_sysmman='define'\ni_sysmode='undef'\ni_sysmount='define'\ni_sysndir='undef'\ni_sysparam='define'\ni_syspoll='define'\ni_sysresrc='define'\ni_syssecrt='undef'\ni_sysselct='define'\ni_syssockio='undef'\ni_sysstat='define'\ni_sysstatfs='define'\ni_sysstatvfs='define'\ni_systime='define'\ni_systimek='undef'\ni_systimes='define'\ni_systypes='define'\ni_sysuio='define'\ni_sysun='define'\ni_sysutsname='define'\ni_sysvfs='define'\ni_syswait='define'\ni_termio='undef'\ni_termios='define'\ni_time='define'\ni_unistd='define'\ni_ustat='define'\ni_utime='define'\ni_values='define'\ni_varargs='undef'\ni_varhdr='stdarg.h'\ni_vfork='undef'\nignore_versioned_solibs='y'\ninc_version_list=''\ninc_version_list_init='0'\nincpath=''\ninews=''\ninitialinstalllocation='/usr/bin'\ninstallarchlib='/usr/lib/perl/5.14'\ninstallbin='/usr/bin'\ninstallhtml1dir=''\ninstallhtml3dir=''\ninstallman1dir='/usr/share/man/man1'\ninstallman3dir='/usr/share/man/man3'\ninstallprefix='/usr'\ninstallprefixexp='/usr'\ninstallprivlib='/usr/share/perl/5.14'\ninstallscript='/usr/bin'\ninstallsitearch='/usr/local/lib/perl/5.14.2'\ninstallsitebin='/usr/local/bin'\ninstallsitehtml1dir=''\ninstallsitehtml3dir=''\ninstallsitelib='/usr/local/share/perl/5.14.2'\ninstallsiteman1dir='/usr/local/man/man1'\ninstallsiteman3dir='/usr/local/man/man3'\ninstallsitescript='/usr/local/bin'\ninstallstyle='lib/perl5'\ninstallusrbinperl='undef'\ninstallvendorarch='/usr/lib/perl5'\ninstallvendorbin='/usr/bin'\ninstallvendorhtml1dir=''\ninstallvendorhtml3dir=''\ninstallvendorlib='/usr/share/perl5'\ninstallvendorman1dir='/usr/share/man/man1'\ninstallvendorman3dir='/usr/share/man/man3'\ninstallvendorscript='/usr/bin'\nintsize='4'\nissymlink='test -h'\nivdformat='\"ld\"'\nivsize='8'\nivtype='long'\nknown_extensions='B Compress/Raw/Bzip2 Compress/Raw/Zlib Cwd DB_File Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Fcntl File/Glob Filter/Util/Call GDBM_File Hash/Util Hash/Util/FieldHash I18N/Langinfo IO IPC/SysV List/Util MIME/Base64 Math/BigInt/FastCalc NDBM_File ODBM_File Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Sys/Syslog Text/Soundex Tie/Hash/NamedCapture Time/HiRes Time/Piece Unicode/Collate Unicode/Normalize VMS/DCLsym VMS/Stdio Win32 Win32API/File Win32CORE XS/APItest XS/Typemap attributes mro re threads threads/shared '\nksh=''\nld='cc'\nlddlflags='-shared -L/usr/local/lib -fstack-protector'\nldflags=' -fstack-protector -L/usr/local/lib'\nldflags_uselargefiles=''\nldlibpthname='LD_LIBRARY_PATH'\nless='less'\nlib_ext='.a'\nlibc=''\nlibdb_needs_pthread='N'\nlibperl='libperl.so.5.14.2'\nlibpth='/usr/local/lib /lib/x86_64-linux-gnu /lib/../lib /usr/lib/x86_64-linux-gnu /usr/lib/../lib /lib /usr/lib'\nlibs='-lgdbm -lgdbm_compat -ldb -ldl -lm -lpthread -lc -lcrypt'\nlibsdirs=' ", 8192) = 8192
09:01:57.313649 read(11, "/usr/lib/x86_64-linux-gnu'\nlibsfiles=' libgdbm.so libgdbm_compat.so libdb.so libdl.so libm.so libpthread.so libc.so libcrypt.so'\nlibsfound=' /usr/lib/x86_64-linux-gnu/libgdbm.so /usr/lib/x86_64-linux-gnu/libgdbm_compat.so /usr/lib/x86_64-linux-gnu/libdb.so /usr/lib/x86_64-linux-gnu/libdl.so /usr/lib/x86_64-linux-gnu/libm.so /usr/lib/x86_64-linux-gnu/libpthread.so /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/libcrypt.so'\nlibspath=' /usr/local/lib /lib/x86_64-linux-gnu /lib/../lib /usr/lib/x86_64-linux-gnu /usr/lib/../lib /lib /usr/lib'\nlibswanted='gdbm gdbm_compat db dl m pthread c crypt gdbm_compat'\nlibswanted_uselargefiles=''\nline=''\nlint=''\nlkflags=''\nln='ln'\nlns='/bin/ln -s'\nlocaltime_r_proto='REENTRANT_PROTO_S_TS'\nlocincpth='/usr/local/include /opt/local/include /usr/gnu/include /opt/gnu/include /usr/GNU/include /opt/GNU/include'\nloclibpth='/usr/local/lib /opt/local/lib /usr/gnu/lib /opt/gnu/lib /usr/GNU/lib /opt/GNU/lib'\nlongdblsize='16'\nlonglongsize='8'\nlongsize='8'\nlp=''\nlpr=''\nls='ls'\nlseeksize='8'\nlseektype='off_t'\nmad='undef'\nmadlyh=''\nmadlyobj=''\nmadlysrc=''\nmail=''\nmailx=''\nmake='make'\nmake_set_make='#'\nmallocobj=''\nmallocsrc=''\nmalloctype='void *'\nman1dir='/usr/share/man/man1'\nman1direxp='/usr/share/man/man1'\nman1ext='1p'\nman3dir='/usr/share/man/man3'\nman3direxp='/usr/share/man/man3'\nman3ext='3pm'\nmips_type=''\nmistrustnm=''\nmkdir='mkdir'\nmmaptype='void *'\nmodetype='mode_t'\nmore='more'\nmultiarch='undef'\nmv=''\nmyarchname='x86_64-linux'\nmydomain=''\nmyhostname='localhost'\nmyuname='linux binet 3.2.0-4-amd64 #1 smp debian 3.2.60-1+deb7u3 x86_64 gnulinux '\nn='-n'\nneed_va_copy='define'\nnetdb_hlen_type='size_t'\nnetdb_host_type='char *'\nnetdb_name_type='const char *'\nnetdb_net_type='in_addr_t'\nnm='nm'\nnm_opt=''\nnm_so_opt='--dynamic'\nnonxs_ext='Archive/Extract Archive/Tar Attribute/Handlers AutoLoader B/Debug B/Deparse B/Lint CGI CPAN CPAN/Meta CPAN/Meta/YAML CPANPLUS CPANPLUS/Dist/Build Devel/SelfStubber Digest Dumpvalue Env Errno ExtUtils/CBuilder ExtUtils/Command ExtUtils/Constant ExtUtils/Install ExtUtils/MakeMaker ExtUtils/Manifest ExtUtils/ParseXS File/CheckTree File/Fetch File/Path File/Temp FileCache Filter/Simple Getopt/Long HTTP/Tiny I18N/Collate I18N/LangTags IO/Compress IO/Zlib IPC/Cmd IPC/Open2 IPC/Open3 JSON/PP Locale/Codes Locale/Maketext Locale/Maketext/Simple Log/Message Log/Message/Simple Math/BigInt Math/BigRat Math/Complex Memoize Module/Build Module/CoreList Module/Load Module/Load/Conditional Module/Loaded Module/Metadata Module/Pluggable NEXT Net/Ping Object/Accessor Package/Constants Params/Check Parse/CPAN/Meta Perl/OSType PerlIO/via/QuotedPrint Pod/Escapes Pod/Html Pod/LaTeX Pod/Parser Pod/Perldoc Pod/Simple Safe SelfLoader Shell Term/ANSIColor Term/Cap Term/UI Test Test/Harness Test/Simple Text/Balanced Text/ParseWords Text/Tabs Thread/Queue Thread/Semaphore Tie/File Tie/Memoize Tie/RefHash Time/Local Version/Requirements XSLoader autodie autouse base bignum constant encoding/warnings if lib libnet parent podlators'\nnroff='nroff'\nnvEUformat='\"E\"'\nnvFUformat='\"F\"'\nnvGUformat='\"G\"'\nnv_overflows_integers_at='256.0*256.0*256.0*256.0*256.0*256.0*2.0*2.0*2.0*2.0*2.0'\nnv_preserves_uv_bits='53'\nnveformat='\"e\"'\nnvfformat='\"f\"'\nnvgformat='\"g\"'\nnvsize='8'\nnvtype='double'\no_nonblock='O_NONBLOCK'\nobj_ext='.o'\nold_pthread_create_joinable=''\noptimize='-O2 -g'\norderlib='false'\nosname='linux'\nosvers='3.2.0-4-amd64'\notherlibdirs=' '\npackage='perl5'\npager='/usr/bin/sensible-pager'\npasscat='cat /etc/passwd'\npatchlevel='14'\npath_sep=':'\nperl5='/usr/bin/perl'\nperl='perl'\nperl_patchlevel=''\nperl_static_inline='static __inline__'\nperladmin='root@localhost'\nperllibs='-ldl -lm -lpthread -lc -lcrypt'\nperlpath='/usr/bin/perl'\npg='pg'\nphostname='hostname'\npidtype='pid_t'\nplibpth='/lib/x86_64-linux-gnu/4.7 /lib/x86_64-linux-gnu /lib/../lib /usr/lib/x86_64-linux-gnu/4.7 /usr/lib/x86_64-linux-gnu /usr/lib/../lib /lib /usr/lib'\npmake=''\npr=''\nprefix='/usr'\nprefixexp='/usr'\nprivlib='/usr/share/perl/5.14'\nprivlibexp='/usr/share/perl/5.14'\nprocselfexe='\"/proc/self/exe\"'\nprototype='define'\nptrsize='8'\nquadkind='2'\nquadtype='long'\nrandbits='48'\nrandfunc='drand48'\nrandom_r_proto='REENTRANT_PROTO_I_St'\nrandseedtype='long'\nranlib=':'\nrd_nodata='-1'\nreaddir64_r_proto='REENTRANT_PROTO_I_TSR'\nreaddir_r_proto='REENTRANT_PROTO_I_TSR'\nrevision='5'\nrm='rm'\nrm_try='/bin/rm -f try try a.out .out try.[cho] try..o core core.try* try.core*'\nrmail=''\nrun=''\nrunnm='false'\nsGMTIME_max='67768036191676799'\nsGMTIME_min='-62167219200'\nsLOCALTIME_max='67768036191676799'\nsLOCALTIME_min='-62167219200'\nsPRIEUldbl='\"LE\"'\nsPRIFUldbl='\"LF\"'\nsPRIGUldbl='\"LG\"'\nsPRIXU64='\"lX\"'\nsPRId64='\"ld\"'\nsPRIeldbl='\"Le\"'\nsPRIfldbl='\"Lf\"'\nsPRIgldbl='\"Lg\"'\nsPRIi64='\"li\"'\nsPRIo64='\"lo\"'\nsPRIu64='\"lu\"'\nsPRIx64='\"lx\"'\nsSCNfldbl='\"Lf\"'\nsched_yield='sched_yield()'\nscriptdir='/usr/bin'\nscriptdirexp='/usr/bin'\nsed='sed'\nseedfunc='srand48'\nselectminbits='64'\nselecttype='fd_set *'\nsendmail=''\nsetgrent_r_proto='0'\nsethostent_r_proto='0'\nsetlocale_r_proto='0'\nsetnetent_r_proto='0'\nsetprotoent_r_proto='0'\nsetpwent_r_proto='0'\nsetservent_r_proto='0'\nsh='/bin/sh'\nshar=''\nsharpbang='#!'\nshmattype='void *'\nshortsize='2'\nshrpenv=''\nshsharp='true'\nsig_count='65'\nsig_name='ZERO HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYS NUM32 NUM33 RTMIN NUM35 NUM36 NUM37 NUM38 NUM39 NUM40 NUM41 NUM42 NUM43 NUM44 NUM45 NUM46 NUM47 NUM48 NUM49 NUM50 NUM51 NUM52 NUM53 NUM54 NUM55 NUM56 NUM57 NUM58 NUM59 NUM60 NUM61 NUM62 NUM63 RTMAX IOT CLD POLL UNUSED '\nsig_name_init='\"ZERO\", \"HUP\", \"INT\", \"QUIT\", \"ILL\", \"TRAP\", \"ABRT\", \"BUS\", \"FPE\", \"KILL\", \"USR1\", \"SEGV\", \"USR2\", \"PIPE\", \"ALRM\", \"TERM\", \"STKFLT\", \"CHLD\", \"CONT\", \"STOP\", \"TSTP\", \"TTIN\", \"TTOU\", \"URG\", \"XCPU\", \"XFSZ\", \"VTALRM\", \"PROF\", \"WINCH\", \"IO\", \"PWR\", \"SYS\", \"NUM32\", \"NUM33\", \"RTMIN\", \"NUM35\", \"NUM36\", \"NUM37\", \"NUM38\", \"NUM39\", \"NUM40\", \"NUM41\", \"NUM42\", \"NUM43\", \"NUM44\", \"NUM45\", \"NUM46\", \"NUM47\", \"NUM48\", \"NUM49\", \"NUM50\", \"NUM51\", \"NUM52\", \"NUM53\", \"NUM54\", \"NUM55\", \"NUM56\", \"NUM57\", \"NUM58\", \"NUM59\", \"NUM60\", \"NUM61\", \"NUM62\", \"NUM63\", \"RTMAX\", \"IOT\", \"CLD\", \"POLL\", \"UNUSED\", 0'\nsig_num='0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 6 17 29 31 '\nsig_num_init='0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 6, 17, 29, 31, 0'\nsig_size='69'\nsignal_t='void'\nsitearch='/usr/local/lib/perl/5.14.2'\nsitearchexp='/usr/local/lib/perl/5.14.2'\nsitebin='/usr/local/bin'\nsitebinexp='/usr/local/bin'\nsitehtml1dir=''\nsitehtml1direxp=''\nsitehtml3dir=''\nsitehtml3direxp=''\nsitelib='/usr/local/share/perl/5.14.2'\nsitelib_stem=''\nsitelibexp='/usr/local/share/perl/5.14.2'\nsiteman1dir='/usr/local/man/man1'\nsiteman1direxp='/usr/local/man/man1'\nsiteman3dir='/usr/local/man/man3'\nsiteman3direxp='/usr/local/man/man3'\nsiteprefix='/usr/local'\nsiteprefixexp='/usr/local'\nsitescript='/usr/local/bin'\nsitescriptexp='/usr/local/bin'\nsizesize='8'\nsizetype='size_t'\nsleep=''\nsmail=''\nso='so'\nsockethdr=''\nsocketlib=''\nsocksizetype='socklen_t'\nsort='sort'\nspackage='Perl5'\nspitshell='cat'\nsrand48_r_proto='REENTRANT_PROTO_I_LS'\nsrandom_r_proto='REENTRANT_PROTO_I_TS'\nsrc='.'\nssizetype='ssize_t'\nstartperl='#!/usr/bin/perl'\nstartsh='#!/bin/sh'\nstatic_ext=' '\nstdchar='char'\nstdio_base='((fp)->_IO_read_base)'\nstdio_bufsiz='((fp)->_IO_read_end - (fp)->_IO_read_base)'\nstdio_cnt='((fp)->_IO_read_end - (fp)->_IO_read_ptr)'\nstdio_filbuf=''\nstdio_ptr='((fp)->_IO_read_ptr)'\nstdio_stream_array=''\nstrerror_r_proto='REENTRANT_PROTO_B_IBW'\nstrings='/usr/include/string.h'\nsubmit=''\nsubversion='2'\nsysman='/usr/share/man/man1'\ntail=''\ntar=''\ntargetarch=''\ntbl=''\ntee=''\ntest='test'\ntimeincl='/usr/include/x86_64-linux-gnu/sys/time.h /usr/include/time.h '\ntimetype='time_t'\ntmpnam_r_proto='REENTRANT_PROTO_B_B'\nto=':'\ntouch='touch'\ntr='tr'\ntrnl='\\n'\ntroff=''\nttyname_r_proto='REENTRA", 8192) = 8192
09:01:57.314103 read(11, "NT_PROTO_I_IBW'\nu16size='2'\nu16type='unsigned short'\nu32size='4'\nu32type='unsigned int'\nu64size='8'\nu64type='unsigned long'\nu8size='1'\nu8type='unsigned char'\nuidformat='\"u\"'\nuidsign='1'\nuidsize='4'\nuidtype='uid_t'\nuname='uname'\nuniq='uniq'\nuquadtype='unsigned long'\nuse5005threads='undef'\nuse64bitall='define'\nuse64bitint='define'\nusecrosscompile='undef'\nusedevel='undef'\nusedl='define'\nusedtrace='undef'\nusefaststdio='undef'\nuseithreads='define'\nuselargefiles='define'\nuselongdouble='undef'\nusemallocwrap='define'\nusemorebits='undef'\nusemultiplicity='define'\nusemymalloc='n'\nusenm='false'\nuseopcode='true'\nuseperlio='define'\nuseposix='true'\nusereentrant='undef'\nuserelocatableinc='undef'\nusesfio='false'\nuseshrplib='true'\nusesitecustomize='undef'\nusesocks='undef'\nusethreads='define'\nusevendorprefix='define'\nusevfork='false'\nusrinc='/usr/include'\nuuname=''\nuvXUformat='\"lX\"'\nuvoformat='\"lo\"'\nuvsize='8'\nuvtype='unsigned long'\nuvuformat='\"lu\"'\nuvxformat='\"lx\"'\nvaproto='define'\nvendorarch='/usr/lib/perl5'\nvendorarchexp='/usr/lib/perl5'\nvendorbin='/usr/bin'\nvendorbinexp='/usr/bin'\nvendorhtml1dir=' '\nvendorhtml1direxp=''\nvendorhtml3dir=' '\nvendorhtml3direxp=''\nvendorlib='/usr/share/perl5'\nvendorlib_stem=''\nvendorlibexp='/usr/share/perl5'\nvendorman1dir='/usr/share/man/man1'\nvendorman1direxp='/usr/share/man/man1'\nvendorman3dir='/usr/share/man/man3'\nvendorman3direxp='/usr/share/man/man3'\nvendorprefix='/usr'\nvendorprefixexp='/usr'\nvendorscript='/usr/bin'\nvendorscriptexp='/usr/bin'\nversion='5.14.2'\nversion_patchlevel_string='version 14 subversion 2'\nversiononly='undef'\nvi=''\nvoidflags='15'\nxlibpth='/usr/lib/386 /lib/386'\nyacc='yacc'\nyaccflags=''\nzcat=''\nzip='zip'\n!END!\n\nmy $i = 0;\nforeach my $c (8,7,6,5,4,3,2) { $i |= ord($c); $i <<= 8 }\n$i |= ord(1);\nour $byteorder = join('', unpack('aaaaaaaa', pack('L!', $i)));\ns/(byteorder=)(['\"]).*?\\2/$1$2$Config::byteorder$2/m;\n\nmy $config_sh_len = length $_;\n\nour $Config_SH_expanded = \"\\n$_\" . << 'EOVIRTUAL';\nccflags_nolargefiles='-D_REENTRANT -D_GNU_SOURCE -DDEBIAN -fstack-protector -fno-strict-aliasing -pipe -I/usr/local/include '\nldflags_nolargefiles=' -fstack-protector -L/usr/local/lib'\nlibs_nolargefiles='-lgdbm -lgdbm_compat -ldb -ldl -lm -lpthread -lc -lcrypt'\nlibswanted_nolargefiles='gdbm gdbm_compat db dl m pthread c crypt gdbm_compat'\nEOVIRTUAL\neval {\n\t# do not have hairy conniptions if this isnt available\n\trequire 'Config_git.pl';\n\t$Config_SH_expanded .= $Config::Git_Data;\n\t1;\n} or warn \"Warning: failed to load Config_git.pl, something strange about this perl...\\n\";\n\n# Search for it in the big string\nsub fetch_string {\n    my($self, $key) = @_;\n\n    return undef unless $Config_SH_expanded =~ /\\n$key=\\'(.*?)\\'\\n/s;\n    # So we can say \"if $Config{'foo'}\".\n    $self->{$key} = $1 eq 'undef' ? undef : $1;\n}\n\nmy $prevpos = 0;\n\nsub FIRSTKEY {\n    $prevpos = 0;\n    substr($Config_SH_expanded, 1, index($Config_SH_expanded, '=') - 1 );\n}\n\nsub NEXTKEY {\n    my $pos = index($Config_SH_expanded, qq('\\n), $prevpos) + 2;\n    my $len = index($Config_SH_expanded, \"=\", $pos) - $pos;\n    $prevpos = $pos;\n    $len > 0 ? substr($Config_SH_expanded, $pos, $len) : undef;\n}\n\nsub EXISTS {\n    return 1 if exists($_[0]->{$_[1]});\n\n    return(index($Config_SH_expanded, \"\\n$_[1]='\") != -1\n          );\n}\n\nsub STORE  { die \"\\%Config::Config is read-only\\n\" }\n*DELETE = *CLEAR = \\*STORE; # Typeglob aliasing uses less space\n\nsub config_sh {\n    substr $Config_SH_expanded, 1, $config_sh_len;\n}\n\nsub config_re {\n    my $re = shift;\n    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/,\n    $Config_SH_expanded;\n}\n\nsub config_vars {\n    # implements -V:cfgvar option (see perlrun -V:)\n    foreach (@_) {\n\t# find optional leading, trailing colons; and query-spec\n\tmy ($notag,$qry,$lncont) = m/^(:)?(.*?)(:)?$/;\t# flags fore and aft, \n\t# map colon-flags to print decorations\n\tmy $prfx = $notag ? '': \"$qry=\";\t\t# tag-prefix for print\n\tmy $lnend = $lncont ? ' ' : \";\\n\";\t\t# line ending for print\n\n\t# all config-vars are by definition \\w only, any \\W means regex\n\tif ($qry =~ /\\W/) {\n\t    my @matches = config_re($qry);\n\t    print map \"$_$lnend\", @matches ? @matches : \"$qry: not found\"\t\tif !$notag;\n\t    print map { s/\\w+=//; \"$_$lnend\" } @matches ? @matches : \"$qry: not found\"\tif  $notag;\n\t} else {\n\t    my $v = (exists $Config::Config{$qry}) ? $Config::Config{$qry}\n\t\t\t\t\t\t   : 'UNKNOWN';\n\t    $v = 'undef' unless defined $v;\n\t    print \"${prfx}'${v}'$lnend\";\n\t}\n    }\n}\n\n# Called by the real AUTOLOAD\nsub launcher {\n    undef &AUTOLOAD;\n    goto \\&$Config::AUTOLOAD;\n}\n\n1;\n", 8192) = 4540
09:01:57.314744 read(11, "", 8192)      = 0
09:01:57.314795 close(11)               = 0
09:01:57.314858 brk(0x1797000)          = 0x1797000
09:01:57.314987 brk(0x17be000)          = 0x17be000
09:01:57.315052 stat("modules/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315104 stat("modules/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315152 stat("/etc/perl/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315203 stat("/usr/local/lib/perl/5.14.2/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315254 stat("/usr/local/share/perl/5.14.2/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315305 stat("/usr/lib/perl5/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315355 stat("/usr/share/perl5/Config_git.pl", 0x7ffe12339de0) = -1 ENOENT (No such file or directory)
09:01:57.315405 stat("/usr/lib/perl/5.14/Config_git.pl", {st_mode=S_IFREG|0644, st_size=409, ...}) = 0
09:01:57.315465 open("/usr/lib/perl/5.14/Config_git.pl", O_RDONLY) = 11
09:01:57.315518 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339b70) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.315565 lseek(11, 0, SEEK_CUR)  = 0
09:01:57.315623 read(11, "######################################################################\n# WARNING: 'lib/Config_git.pl' is generated by make_patchnum.pl\n#          DO NOT EDIT DIRECTLY - edit make_patchnum.pl instead\n######################################################################\n$Config::Git_Data=<<'ENDOFGIT';\ngit_commit_id=''\ngit_describe=''\ngit_branch=''\ngit_uncommitted_changes=''\ngit_commit_id_title=''\n\nENDOFGIT\n", 8192) = 409
09:01:57.315708 read(11, "", 8192)      = 0
09:01:57.315756 close(11)               = 0
09:01:57.316024 lseek(10, 977, SEEK_SET) = 977
09:01:57.316072 lseek(10, 0, SEEK_CUR)  = 977
09:01:57.316116 close(10)               = 0
09:01:57.316206 lseek(9, 517, SEEK_SET) = 517
09:01:57.316252 lseek(9, 0, SEEK_CUR)   = 517
09:01:57.316297 close(9)                = 0
09:01:57.316356 stat("/etc/resolv.conf", {st_mode=S_IFREG|0644, st_size=75, ...}) = 0
09:01:57.316417 getgroups(0, NULL)      = 2
09:01:57.316463 getgroups(2, [1000, 1164]) = 2
09:01:57.316532 open("/etc/resolv.conf", O_RDONLY) = 9
09:01:57.316586 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.316632 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.316679 fstat(9, {st_mode=S_IFREG|0644, st_size=75, ...}) = 0
09:01:57.316732 fcntl(9, F_SETFD, FD_CLOEXEC) = 0
09:01:57.316791 read(9, "search fysh.org\noptions edns0\nnameserver 127.0.0.1\nnameserver 192.168.41.1\n", 8192) = 75
09:01:57.316867 read(9, "", 8192)       = 0
09:01:57.316918 close(9)                = 0
09:01:57.316983 stat("/home/athan/.resolv.conf", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.317041 stat("./.resolv.conf", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.317158 stat("modules/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317210 stat("modules/Net/DNS/Update.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.317260 stat("modules/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317308 stat("modules/Net/DNS/Update.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.317357 stat("/etc/perl/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317407 stat("/etc/perl/Net/DNS/Update.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.317457 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317507 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Update.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.317558 stat("/usr/local/share/perl/5.14.2/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317608 stat("/usr/local/share/perl/5.14.2/Net/DNS/Update.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.317664 stat("/usr/lib/perl5/Net/DNS/Update.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.317714 stat("/usr/lib/perl5/Net/DNS/Update.pm", {st_mode=S_IFREG|0644, st_size=5498, ...}) = 0
09:01:57.317774 open("/usr/lib/perl5/Net/DNS/Update.pm", O_RDONLY) = 9
09:01:57.317827 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.317873 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.317930 read(9, "package Net::DNS::Update;\n#\n# $Id: Update.pm 517 2005-11-21 08:38:47Z olaf $\n#\nuse strict;\nBEGIN { \n    eval { require bytes; }\n} \nuse vars qw($VERSION @ISA);\n\nuse Net::DNS;\n\n@ISA     = qw(Net::DNS::Packet);\n$VERSION = (qw$LastChangedRevision: 517 $)[1];\n\n=head1 NAME\n\nNet::DNS::Update - Create a DNS update packet\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::Update;>\n\n=head1 DESCRIPTION\n\nC<Net::DNS::Update> is a subclass of C<Net::DNS::Packet>,\nto be used for making DNS dynamic updates.  Programmers\nshould refer to RFC 2136 for the semantics of dynamic updates.\n\nWARNING:  This code is still under development.  Please use with\ncaution on production nameservers.\n\n=head1 METHODS\n\n=head2 new\n\n    $packet = Net::DNS::Update->new;\n    $packet = Net::DNS::Update->new('example.com');\n    $packet = Net::DNS::Update->new('example.com', 'HS');\n\nReturns a C<Net::DNS::Update> object suitable for performing a DNS\ndynamic update.  Specifically, it creates a packet with the header\nopcode set to UPDATE and the zone record type to SOA (per RFC 2136,\nSection 2.3).\n\nPrograms must use the C<push> method to add RRs to the prerequisite,\nupdate, and additional sections before performing the update.\n\nArguments are the zone name and the class.  If the zone is omitted,\nthe default domain will be taken from the resolver configuration.\nIf the class is omitted, it defaults to IN.\n\nFuture versions of C<Net::DNS> may provide a simpler interface\nfor making dynamic updates.\n\n=cut\n\nsub new {\n\tmy ($package, $zone, $class) = @_;\n\n\tunless ($zone) {\n\t\tmy $res = Net::DNS::Resolver->new;\n\t\t$zone = ($res->searchlist)[0];\n\t\treturn unless $zone;\n\t}\n\n\tmy $type  = 'SOA';\n\t$class  ||= 'IN';\n\n\tmy $self = $package->SUPER::new($zone, $type, $class) || return;\n\n\t$self->header->opcode('UPDATE');\n\t$self->header->rd(0);\n\n\t$self->{'seen'} = {};\n\n\n\treturn $self;\n}\n\n\n=head1 EXAMPLES\n\nThe first example below shows a complete program; subsequent examples\nshow only the creation of the update packet.\n\n=head2 Add a new host\n\n #!/usr/bin/perl -w\n \n use Net::DNS;\n use strict;\n \n # Create the update packet.\n my $update = Net::DNS::Update->new('example.com');\n \n # Prerequisite is that no A records exist for the name.\n $update->push(pre => nxrrset('foo.example.com. A'));\n \n # Add two A records for the name.\n $update->push(update => rr_add('foo.example.com. 86400 A 192.168.1.2'));\n $update->push(update => rr_add('foo.example.com. 86400 A 172.16.3.4'));\n \n # Send the update to the zone's primary master.\n my $res = Net::DNS::Resolver->new;\n $res->nameservers('primary-master.example.com');\n \n my $reply = $res->send($update);\n \n # Did it work?\n if ($reply) {\n     if ($reply->header->rcode eq 'NOERROR') {\n         print \"Update succeeded\\n\";\n     } else {\n         print 'Update failed: ', $reply->header->rcode, \"\\n\";\n     }\n } else {\n     print 'Update failed: ', $res->errorstring, \"\\n\";\n }\n\n=head2 Add an MX record for a name that already exists\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(pre    => yxdomain('example.com'));\n    $update->push(update => rr_add('example.com MX 10 mailhost.example.com'));\n\n=head2 Add a TXT record for a name that doesn't exist\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(pre    => nxdomain('info.example.com'));\n    $update->push(update => rr_add('info.example.com TXT \"yabba dabba doo\"'));\n\n=head2 Delete all A records for a name\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(pre    => yxrrset('foo.example.com A'));\n    $update->push(update => rr_del('foo.example.com A'));\n\n=head2 Delete all RRs for a name\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(pre    => yxdomain('byebye.example.com'));\n    $update->push(update => rr_del('byebye.example.com'));\n\n=head2 Perform a signed update\n\n    my $key_name = 'tsig-key';\n    my $key      = 'awwLOtRfpGE+rRKF2+DEiw==';\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(update => rr_add('foo.example.com A 10.1.2.3'));\n    $update->push(update => rr_add('bar.example.com A 10.4.5.6'));\n    $update->sign_tsig($key_name, $key);\n\n=head2 Another way to perform a signed update\n\n    my $key_name = 'tsig-key';\n    my $key      = 'awwLOtRfpGE+rRKF2+DEiw==';\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(update     => rr_add('foo.example.com A 10.1.2.3'));\n    $update->push(update     => rr_add('bar.example.com A 10.4.5.6'));\n    $update->push(additional => Net::DNS::RR->new(\"$key_name TSIG $key\"));\n\n=head2 Perform a signed update with a customized TSIG record\n\n    my $key_name = 'tsig-key';\n    my $key      = 'awwLOtRfpGE+rRKF2+DEiw==';\n\n    my $tsig = Net::DNS::RR->new(\"$key_name TSIG $key\");\n    $tsig->fudge(60);\n\n    my $update = Net::DNS::Update->new('example.com');\n    $update->push(update     => rr_add('foo.example.com A 10.1.2.3'));\n    $update->push(update     => rr_add('bar.example.com A 10.4.5.6'));\n    $update->push(additional => $tsig);\n\n=head1 BUGS\n\nThis code is still under development.  Please use with caution on\nproduction nameservers.\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Header>,\nL<Net::DNS::Packet>, L<Net::DNS::Question>, L<Net::DNS::RR>, RFC 2136,\nRFC 2845\n\n=cut\n\n1;\n", 8192) = 5498
09:01:57.318406 read(9, "", 8192)       = 0
09:01:57.318457 close(9)                = 0
09:01:57.318544 stat("modules/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.318596 stat("modules/Net/DNS/Header.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.318646 stat("modules/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.318695 stat("modules/Net/DNS/Header.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.318744 stat("/etc/perl/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.318793 stat("/etc/perl/Net/DNS/Header.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.318843 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.318894 stat("/usr/local/lib/perl/5.14.2/Net/DNS/Header.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.318944 stat("/usr/local/share/perl/5.14.2/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.318995 stat("/usr/local/share/perl/5.14.2/Net/DNS/Header.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.319045 stat("/usr/lib/perl5/Net/DNS/Header.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.319096 stat("/usr/lib/perl5/Net/DNS/Header.pm", {st_mode=S_IFREG|0644, st_size=7802, ...}) = 0
09:01:57.319156 open("/usr/lib/perl5/Net/DNS/Header.pm", O_RDONLY) = 9
09:01:57.319208 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.319254 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.319309 read(9, "package Net::DNS::Header;\n#\n# $Id: Header.pm 704 2008-02-06 21:30:59Z olaf $\n#\n\nuse strict;\n\nBEGIN { \n    eval { require bytes; }\n} \n\n\nuse vars qw($VERSION $AUTOLOAD);\n\nuse Carp;\nuse Net::DNS;\n\nuse constant MAX_ID => 65535;\n\n$VERSION = (qw$LastChangedRevision: 704 $)[1];\n\n=head1 NAME\n\nNet::DNS::Header - DNS packet header class\n\n=head1 SYNOPSIS\n\nC<use Net::DNS::Header;>\n\n=head1 DESCRIPTION\n\nA C<Net::DNS::Header> object represents the header portion of a DNS\npacket.\n\n=head1 METHODS\n\n=head2 new\n\n    $header = Net::DNS::Header->new;\n\nC<new> creates a header object appropriate for making a DNS query.\n\n=cut\n\n{\n\tsub nextid {\n\t\tint rand(MAX_ID);\n\t}\n}\n\nsub new {\n\tmy $class = shift;\n\n\tmy $self = {\tid\t=> nextid(),\n\t\t\tqr\t=> 0,\n\t\t\topcode\t=> $Net::DNS::opcodesbyval{0},\n\t\t\taa\t=> 0,\n\t\t\ttc\t=> 0,\n\t\t\trd\t=> 1,\n\t\t\tra\t=> 0,\n\t\t\tad\t=> 0,\n\t\t\tcd\t=> 0,\n\t\t\trcode\t=> $Net::DNS::rcodesbyval{0},\n\t\t\tqdcount\t=> 0,\n\t\t\tancount\t=> 0,\n\t\t\tnscount\t=> 0,\n\t\t\tarcount\t=> 0,\n\t\t\t};\n\n\tbless $self, $class;\n}\n\n\n=head2 parse\n\n    ($header, $offset) = Net::DNS::Header->parse(\\$data);\n\nParses the header record at the start of a DNS packet.\nThe argument is a reference to the packet data.\n\nReturns a Net::DNS::Header object and the offset of the next location\nin the packet.\n\nParsing is aborted if the header object cannot be created (e.g.,\ncorrupt or insufficient data).\n\n=cut\n\nuse constant PACKED_LENGTH => length pack 'n C2 n4', (0)x7;\n\nsub parse {\n\tmy ($class, $data) = @_;\n\n\tdie 'Exception: incomplete data' if length($$data) < PACKED_LENGTH;\n\n\tmy ($id, $b2, $b3, $qd, $an, $ns, $ar) = unpack('n C2 n4', $$data);\n\n\tmy $opval  = ($b2 >> 3) & 0xf;\n\tmy $opcode = $Net::DNS::opcodesbyval{$opval} || $opval;\n\tmy $rval  = $b3 & 0xf;\n\tmy $rcode = $Net::DNS::rcodesbyval{$rval} || $rval;\n\n\tmy $self = {\tid\t=> $id,\n\t\t\tqr\t=> ($b2 >> 7) & 0x1,\n\t\t\topcode\t=> $opcode,\n\t\t\taa\t=> ($b2 >> 2) & 0x1,\n\t\t\ttc\t=> ($b2 >> 1) & 0x1,\n\t\t\trd\t=> $b2 & 0x1,\n\t\t\tra\t=> ($b3 >> 7) & 0x1,\n\t\t\tad\t=> ($b3 >> 5) & 0x1,\n\t\t\tcd\t=> ($b3 >> 4) & 0x1,\n\t\t\trcode\t=> $rcode,\n\t\t\tqdcount\t=> $qd,\n\t\t\tancount\t=> $an,\n\t\t\tnscount\t=> $ns,\n\t\t\tarcount\t=> $ar\n\t\t\t};\n\n\tbless $self, $class;\n\n\treturn wantarray ? ($self, PACKED_LENGTH) : $self;\n}\n\n#\n# Some people have reported that Net::DNS dies because AUTOLOAD picks up\n# calls to DESTROY.\n#\nsub DESTROY {}\n\n=head2 print\n\n    $header->print;\n\nPrints the header record on the standard output.\n\n=cut\n\nsub print {\tprint &string, \"\\n\"; }\n\n=head2 string\n\n    print $header->string;\n\nReturns a string representation of the header object.\n\n=cut\n\nsub string {\n\tmy $self = shift;\n\tmy $retval = \"\";\n\n\t$retval .= \";; id = $self->{id}\\n\";\n\n\tif ($self->{\"opcode\"} eq \"UPDATE\") {\n\t\t$retval .= \";; qr = $self->{qr}    \"      .\n\t\t           \"opcode = $self->{opcode}    \" .\n\t\t           \"rcode = $self->{rcode}\\n\";\n\n\t\t$retval .= \";; zocount = $self->{qdcount}  \" .\n\t\t           \"prcount = $self->{ancount}  \"    .\n\t\t           \"upcount = $self->{nscount}  \"    .\n\t\t           \"adcount = $self->{arcount}\\n\";\n\t}\n\telse {\n\t\t$retval .= \";; qr = $self->{qr}    \"      .\n\t\t           \"opcode = $self->{opcode}    \" .\n\t\t           \"aa = $self->{aa}    \"         .\n\t\t           \"tc = $self->{tc}    \"         .\n\t\t           \"rd = $self->{rd}\\n\";\n\n\t\t$retval .= \";; ra = $self->{ra}    \" .\n\t\t           \"ad = $self->{ad}    \"         .\n\t\t           \"cd = $self->{cd}    \"         .\n\t\t           \"rcode  = $self->{rcode}\\n\";\n\n\t\t$retval .= \";; qdcount = $self->{qdcount}  \" .\n\t\t           \"ancount = $self->{ancount}  \"    .\n\t\t           \"nscount = $self->{nscount}  \"    .\n\t\t           \"arcount = $self->{arcount}\\n\";\n\t}\n\n\treturn $retval;\n}\n\n=head2 id\n\n    print \"query id = \", $header->id, \"\\n\";\n    $header->id(1234);\n\nGets or sets the query identification number.\n\n=head2 qr\n\n    print \"query response flag = \", $header->qr, \"\\n\";\n    $header->qr(0);\n\nGets or sets the query response flag.\n\n=head2 opcode\n\n    print \"query opcode = \", $header->opcode, \"\\n\";\n    $header->opcode(\"UPDATE\");\n\nGets or sets the query opcode (the purpose of the query).\n\n=head2 aa\n\n    print \"answer is \", $header->aa ? \"\" : \"non-\", \"authoritative\\n\";\n    $header->aa(0);\n\nGets or sets the authoritative answer flag.\n\n=head2 tc\n\n    print \"packet is \", $header->tc ? \"\" : \"not \", \"truncated\\n\";\n    $header->tc(0);\n\nGets or sets the truncated packet flag.\n\n=head2 rd\n\n    print \"recursion was \", $header->rd ? \"\" : \"not \", \"desired\\n\";\n    $header->rd(0);\n\nGets or sets the recursion desired flag.\n\n\n=head2 cd\n\n    print \"checking was \", $header->cd ? \"not\" : \"\", \"desired\\n\";\n    $header->cd(0);\n\nGets or sets the checking disabled flag.\n\n\n\n=head2 ra\n\n    print \"recursion is \", $header->ra ? \"\" : \"not \", \"available\\n\";\n    $header->ra(0);\n\nGets or sets the recursion available flag.\n\n\n=head2 ad\n\n    print \"The result has \", $header->ad ? \"\" : \"not\", \"been verified\\n\"\n\n\nRelevant in DNSSEC context.\n\n(The AD bit is only set on answers where signatures have been\ncryptographically verified or the server is authoritative for the data\nand is allowed to set the bit by policy.)\n\n\n=head2 rcode\n\n    print \"query response code = \", $header->rcode, \"\\n\";\n    $header->rcode(\"SERVFAIL\");\n\nGets or sets the query response code (the status of the query).\n\n=head2 qdcount, zocount\n\n    print \"# of question records: \", $header->qdcount, \"\\n\";\n    $header->qdcount(2);\n\nGets or sets the number of records in the question section of the packet.\nIn dynamic update packets, this field is known as C<zocount> and refers\nto the number of RRs in the zone section.\n\n=head2 ancount, prcount\n\n    print \"# of answer records: \", $header->ancount, \"\\n\";\n    $header->ancount(5);\n\nGets or sets the number of records in the answer section of the packet.\nIn dynamic update packets, this field is known as C<prcount> and refers\nto the number of RRs in the prerequisite section.\n\n=head2 nscount, upcount\n\n    print \"# of authority records: \", $header->nscount, \"\\n\";\n    $header->nscount(2);\n\nGets or sets the number of records in the authority section of the packet.\nIn dynamic update packets, this field is known as C<upcount> and refers\nto the number of RRs in the update section.\n\n=head2 arcount, adcount\n\n    print \"# of additional records: \", $header->arcount, \"\\n\";\n    $header->arcount(3);\n\nGets or sets the number of records in the additional section of the packet.\nIn dynamic update packets, this field is known as C<adcount>.\n\n=cut\n\nsub zocount { &qdcount; }\nsub prcount { &ancount; }\nsub upcount { &nscount; }\nsub adcount { &arcount; }\n\n\nsub AUTOLOAD {\n\tmy $self = shift;\n\n\tmy $name = $AUTOLOAD;\n\t$name =~ s/.*://o;\n\n\tcroak \"$AUTOLOAD: no such method\" unless exists $self->{$name};\n\n\treturn $self->{$name} unless @_;\n\n\tmy $value = shift;\n\t$self->{$name} = $value;\n}\n\n\n=head2 data\n\n    $hdata = $header->data;\n\nReturns the header data in binary format, appropriate for use in a\nDNS query packet.\n\n=cut\n\nsub data {\n\tmy $self = shift;\n\n\tmy $opcode = $Net::DNS::opcodesbyname{ $self->{opcode} };\n\tmy $rcode  = $Net::DNS::rcodesbyname{ $self->{rcode} };\n\n\tmy $byte2 =\t($self->{qr} ? 0x80 : 0)\n\t\t\t| ($opcode << 3)\n\t\t\t| ($self->{aa} ? 0x04 : 0)\n\t\t\t| ($self->{tc} ? 0x02 : 0)\n\t\t\t| ($self->{rd} ? 0x01 : 0);\n\n\tmy $byte3 =\t($self->{ra} ? 0x80 : 0)\n\t\t\t| ($self->{ad} ? 0x20 : 0)\n\t\t\t| ($self->{cd} ? 0x10 : 0)\n\t\t\t| ($rcode || 0);\n\n\tpack('n C2 n4', $self->{id}, $byte2, $byte3,\n\t\t\tmap{$self->{$_} || 0} qw(qdcount ancount nscount arcount) );\n}\n\n=head1 COPYRIGHT\n\nCopyright (c) 1997-2002 Michael Fuhr. \n\nPortions Copyright (c) 2002-2004 Chris Reinhardt.\n\nPortions Copyright (c) 2007 Dick Franks.\n\nAll rights reserved.  This program is free software; you may redistribute\nit and/or modify it under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<perl(1)>, L<Net::DNS>, L<Net::DNS::Resolver>, L<Net::DNS::Packet>,\nL<Net::DNS::Update>, L<Net::DNS::Question>, L<Net::DNS::RR>,\nRFC 1035 Section 4.1.1\n\n=cut\n\n1;\n", 8192) = 7802
09:01:57.320263 read(9, "", 8192)       = 0
09:01:57.320314 close(9)                = 0
09:01:57.320668 read(8, "nd metatypesbyval specify special typecodes\n# See rfc2929 and the relevant IANA registry\n# http://www.iana.org/assignments/dns-parameters\n\n\n%qtypesbyname = (\n    'IXFR'   => 251,  # incremental transfer                [RFC1995]\n    'AXFR'   => 252,  # transfer of an entire zone          [RFC1035]\n    'MAILB'  => 253,  # mailbox-related RRs (MB, MG or MR)   [RFC1035]\n    'MAILA'  => 254,  # mail agent RRs (Obsolete - see MX)   [RFC1035]\n    'ANY'    => 255,  # all records                      [RFC1035]\n);\n%qtypesbyval = reverse %qtypesbyname;\n\n\n%metatypesbyname = (\n    'TKEY'        => 249,    # Transaction Key   [RFC2930]\n    'TSIG'        => 250,    # Transaction Signature  [RFC2845]\n    'OPT'         => 41,     # RFC 2671\n);\n%metatypesbyval = reverse %metatypesbyname;\n\n\n%opcodesbyname = (\n    'QUERY'        => 0,        # RFC 1035\n    'IQUERY'       => 1,        # RFC 1035\n    'STATUS'       => 2,        # RFC 1035\n    'NS_NOTIFY_OP' => 4,        # RFC 1996\n    'UPDATE'       => 5,        # RFC 2136\n);\n%opcodesbyval = reverse %opcodesbyname;\n\n\n%rcodesbyname = (\n    'NOERROR'   => 0,       # RFC 1035\n    'FORMERR'   => 1,       # RFC 1035\n    'SERVFAIL'  => 2,       # RFC 1035\n    'NXDOMAIN'  => 3,       # RFC 1035\n    'NOTIMP'    => 4,       # RFC 1035\n    'REFUSED'   => 5,       # RFC 1035\n    'YXDOMAIN'  => 6,       # RFC 2136\n    'YXRRSET'   => 7,       # RFC 2136\n    'NXRRSET'   => 8,       # RFC 2136\n    'NOTAUTH'   => 9,       # RFC 2136\n    'NOTZONE'   => 10,      # RFC 2136\n);\n%rcodesbyval = reverse %rcodesbyname;\n\n\nsub version      { $VERSION; }\nsub PACKETSZ  () { 512; }\nsub HFIXEDSZ  () {  12; }\nsub QFIXEDSZ  () {   4; }\nsub RRFIXEDSZ () {  10; }\nsub INT32SZ   () {   4; }\nsub INT16SZ   () {   2; }\n\n\n\n# mx()\n#\n# Usage:\n#    my @mxes = mx('example.com', 'IN');\n#\nsub mx {\n    my $res = ref $_[0] ? shift : Net::DNS::Resolver->new;\n\n    my ($name, $class) = @_;\n    $class ||= 'IN';\n\n    my $ans = $res->query($name, 'MX', $class) || return;\n\n    # This construct is best read backwords.\n    #\n    # First we take the answer secion of the packet.\n    # Then we take just the MX records from that list\n    # Then we sort the list by preference\n    # Then we return it.\n    # We do this into an array to force list context.\n    my @ret = sort { $a->preference <=> $b->preference } \n              grep { $_->type eq 'MX'} $ans->answer;\n\n\n    return @ret;\n}\n\nsub yxrrset {\n    return Net::DNS::RR->new_from_string(shift, 'yxrrset');\n}\n\nsub nxrrset {\n    return Net::DNS::RR->new_from_string(shift, 'nxrrset');\n}\n\nsub yxdomain {\n    return Net::DNS::RR->new_from_string(shift, 'yxdomain');\n}\n\nsub nxdomain {\n    return Net::DNS::RR->new_from_string(shift, 'nxdomain');\n}\n\nsub rr_add {\n    return Net::DNS::RR->new_from_string(shift, 'rr_add');\n}\n\nsub rr_del {\n    return Net::DNS::RR->new_from_string(shift, 'rr_del');\n}\n\n\n\n# Utility function\n#\n# name2labels to translate names from presentation format into an\n# array of \"wire-format\" labels.\n\n\n# in: $dname a string with a domain name in presentation format (1035\n# sect 5.1)\n# out: an array of labels in wire format.\n\n\nsub name2labels {\n    my $dname=shift;\n    my @names;\n    my $j=0;\n    while ($dname){\n\t($names[$j],$dname)=presentation2wire($dname);\n\t$j++;\n    }\n\n    return @names;\n}\n\n\n\n\nsub wire2presentation {\n    my  $wire=shift;\n    my  $presentation=\"\";\n    my $length=length($wire);\n    # There must be a nice regexp to do this.. but since I failed to\n    # find one I scan the name string until I find a '\\', at that time\n    # I start looking forward and do the magic.\n\n    my $i=0;\n    \n    while ($i < $length ){\n\tmy $char=unpack(\"x\".$i.\"C1\",$wire);\n\tif ( $char < 33 || $char > 126 ){\n\t    $presentation.= sprintf (\"\\\\%03u\" ,$char);\n\t}elsif ( $char == ord( \"\\\"\" )) {   \n\t    $presentation.= \"\\\\\\\"\";    \n\t}elsif ( $char == ord( \"\\$\" )) {   \n\t    $presentation.= \"\\\\\\$\";    \n\t}elsif ( $char == ord( \"(\" )) {   \n\t    $presentation.= \"\\\\(\";    \n\t}elsif ( $char == ord( \")\" )) {   \n\t    $presentation.= \"\\\\)\";    \n\t}elsif ( $char == ord( \";\" )) {   \n\t    $presentation.= \"\\\\;\";    \n\t}elsif ( $char == ord( \"@\" )) {   \n\t    $presentation.= \"\\\\@\";    \n\t}elsif ( $char == ord( \"\\\\\" )) {   \n\t    $presentation.= \"\\\\\\\\\" ; \n\t}elsif ( $char==ord (\".\") ){\n\t    $presentation.= \"\\\\.\" ; \n\t}else{\n\t    $presentation.=chr($char) \t;\n\t}\n\t$i++;\n    }\n\n    return $presentation;\n    \n}\n\n\n\n\nsub stripdot {\n\t# Code courtesy of JMEHNLE <JMEHNLE@cpan.org>  \n\t# rt.cpan.org #51009\n\n\t# Strips the final non-escaped dot from a domain name.  Note\n\t# that one could have a label that looks like \"foo\\\\\\\\\\.\\..\"\n\t# although not likely one wants to deal with that cracefully.\n\t# This utilizes 2 functions in the DNS module to deal with\n\t# thing cracefully.\n\n\treturn join('.', map(wire2presentation($_), name2labels(shift)));\n\n}\n\n\n\n# ($wire,$leftover)=presentation2wire($leftover);\n\n# Will parse the input presentation format and return everything before\n# the first non-escaped \".\" in the first element of the return array and\n# all that has not been parsed yet in the 2nd argument.\n\n\nsub presentation2wire {\n    my  $presentation=shift;\n    my  $wire=\"\";\n    my $length=length($presentation);\n    \n    my $i=0;\n    \n    while ($i < $length ){\n\tmy $char=unpack(\"x\".$i.\"C1\",$presentation);\n\tif (  $char == ord ('.')){\n\t    return ($wire,substr($presentation,$i+1));\n\t}\n\tif (  $char == ord ('\\\\')){\n\t    #backslash found\n\t    pos($presentation)=$i+1;\n\t    if ($presentation=~/\\G(\\d\\d\\d)/){\n\t\t$wire.=pack(\"C\",$1);\n\t\t$i+=3;\n\t    }elsif($presentation=~/\\Gx([0..9a..fA..F][0..9a..fA..F])/){\n\t\t$wire.=pack(\"H*\",$1);\n\t\t$i+=3;\n\t    }elsif($presentation=~/\\G\\./){\n\t\t$wire.=\"\\.\";\n\t\t$i+=1;\n\t    }elsif($presentation=~/\\G@/){\n\t\t$wire.=\"@\";\n\t\t$i+=1;\n\t    }elsif($presentation=~/\\G\\(/){\n\t\t$wire.=\"(\";\n\t\t$i+=1;\n\t    }elsif($presentation=~/\\G\\)/){\n\t\t$wire.=\")\";\n\t\t$i+=1;\n           }elsif($presentation=~/\\G\\\\/){\n               $wire.=\"\\\\\"; \n               $i+=1;\n\t    }\n\t}else{\n\t    $wire .=  pack(\"C\",$char);  \n        }\n\t$i++;\n    }\n    \n    return $wire;\n}\n\n\n\n\n\nsub rrsort {\n    my ($rrtype,$attribute,@rr_array)=@_;\n    unless (exists($Net::DNS::typesbyname{uc($rrtype)})){\n\t# unvalid error type\n\treturn();\n    }\n    unless (defined($attribute)){\n\t# no second argument... hence no array.\n\treturn();\n    }\n\n    # attribute is empty or not specified.\n    \n    if( ref($attribute)=~/^Net::DNS::RR::.*/){\n\t# push the attribute back on the array.\n\tpush @rr_array,$attribute;\n\tundef($attribute);\n\n    }\n\n    my @extracted_rr;\n    foreach my $rr (@rr_array){\n\tpush( @extracted_rr, $rr )if (uc($rr->type) eq uc($rrtype));\n    }\n    return () unless  @extracted_rr;\n    my $func=(\"Net::DNS::RR::\".$rrtype)->get_rrsort_func($attribute);\n    my @sorted=sort $func  @extracted_rr;\n    return @sorted; \n    \n}\n\n\n\n\n\n\n\n\n\n1;\n__END__\n\n=head1 NAME\n\nNet::DNS - Perl interface to the DNS resolver\n\n=head1 SYNOPSIS\n\nC<use Net::DNS;>\n\n=head1 DESCRIPTION\n\nNet::DNS is a collection of Perl modules that act as a Domain\nName System (DNS) resolver.  It allows the programmer to perform\nDNS queries that are beyond the capabilities of C<gethostbyname>\nand C<gethostbyaddr>.\n\nThe programmer should be somewhat familiar with the format of\na DNS packet and its various sections.  See RFC 1035 or\nI<DNS and BIND> (Albitz & Liu) for details.\n\n=head2 Resolver Objects\n\nA resolver object is an instance of the\nL<Net::DNS::Resolver|Net::DNS::Resolver> class. A program can have\nmultiple resolver objects, each maintaining its own state information\nsuch as the nameservers to be queried, whether recursion is desired,\netc.\n\n=head2 Packet Objects\n\nL<Net::DNS::Resolver|Net::DNS::Resolver> queries return\nL<Net::DNS::Packet|Net::DNS::Packet> objects.  Packet objects have five\nsections:\n\n=over 3\n\n=item *\n\nThe header section, a L<Net::DNS::Header|Net::DNS::Header> object.\n\n=item *\n\nThe question section, a list of L<Net::DNS::Question|Net::DNS::Question>\nobjects.\n\n=item *\n\nThe answer section, a list of L<Net::DNS::RR|Net::DNS::RR> objects.\n\n=item *\n\nThe authority section, a list of L<Net::DNS::RR|Net::DNS::RR> objects.\n\n=item *\n\nThe additional section, a list of L<Net::DNS::RR|Net::DNS::RR> objects.\n\n=back\n\n=head2 Update Objects\n\nThe L<Net::DNS::Update|Net::DNS::Upd", 8192) = 8192
09:01:57.321673 lseek(8, 14966, SEEK_SET) = 14966
09:01:57.321721 lseek(8, 0, SEEK_CUR)   = 14966
09:01:57.321765 close(8)                = 0
09:01:57.322534 brk(0x17df000)          = 0x17df000
09:01:57.322910 read(7, "s_response');\n\n  # Save the socket for pre-emptive shutdown.\n  $req->{resolver_socket} = $resolver_socket;\n}\n\n# A resolver query timed out.  Keep trying until we run out of time.\n# Also, if the top nameserver is the one we tried, then cycle the\n# nameservers.\n\nsub _dns_default {\n  my ($self, $kernel, $event, $args) = @_[OBJECT, KERNEL, ARG0, ARG1];\n  my $socket = $args->[0];\n\n  return unless defined($socket) and $event eq $socket;\n\n  my $req = delete $self->[SF_REQ_BY_SOCK]->{$socket};\n  return unless $req;\n\n  # Stop watching the socket.\n  $kernel->select_read($socket);\n\n  # No more time remaining?  We must time out.\n  my $remaining = $req->{ends} - time();\n  if ($remaining <= 0) {\n    _send_response(\n      %$req,\n      response => undef,\n      error    => \"timeout\",\n    );\n    return;\n  }\n\n  # There remains time.  Let's try again.\n\n  # The nameserver we tried has failed us.  If it's the top\n  # nameserver in Net::DNS's list, then send it to the back and retry.\n  # TODO - What happens if they all fail forever?\n\n  my @nameservers = @{ $req->{nameservers} };\n  push @nameservers, shift(@nameservers);\n  $self->[SF_RESOLVER]->nameservers(@nameservers);\n  $req->{nameservers} = \\@nameservers;\n\n  # Retry.\n  $kernel->yield(send_request => $req);\n\n  # Don't accidentally handle signals.\n  # Only meaningful for old POEs.\n  return;\n}\n\n# A resolver query generated a response.  Post the reply back.\n\nsub _dns_response {\n  my ($self, $kernel, $socket) = @_[OBJECT, KERNEL, ARG0];\n\n  my $req = delete $self->[SF_REQ_BY_SOCK]->{$socket};\n  return unless $req;\n\n  # Turn off the timeout for this request, and stop watching the\n  # resolver connection.\n  $kernel->delay($socket);\n  $kernel->select_read($socket);\n\n  my $handle = delete $req->{RES_REF};\n\n  # Read the DNS response.\n  my $packet = $self->[SF_RESOLVER]->bgread($handle);\n\n  # Set the packet's answerfrom field, if the packet was received ok\n  # and an answerfrom isn't already included.  This uses the\n  # documented peerhost() method\n\n  if (defined $packet and !defined $packet->answerfrom) {\n    my $answerfrom = getpeername($socket);\n    if (defined $answerfrom) {\n      $answerfrom = (unpack_sockaddr_in($answerfrom))[1];\n      $answerfrom = inet_ntoa($answerfrom);\n      $packet->answerfrom($answerfrom);\n    }\n  }\n\n  # Send the response.\n  _send_response(\n    %$req,\n    response => $packet,\n    error    => $self->[SF_RESOLVER]->errorstring(),\n  );\n}\n\nsub _dns_shutdown {\n  my ($self, $kernel) = @_[OBJECT, KERNEL];\n\n  # Clean up all pending socket timeouts and selects.\n  foreach my $socket (keys %{$self->[SF_REQ_BY_SOCK]}) {\n    DEBUG and warn \"SHT: Shutting down resolver socket $socket\";\n    my $req = delete $self->[SF_REQ_BY_SOCK]->{$socket};\n\n    $kernel->delay($socket);\n    $kernel->select($req->{resolver_socket});\n\n    # Let the client session go.\n    DEBUG and warn \"SHT: Releasing sender \", $req->{sender}->ID;\n    $poe_kernel->refcount_decrement($req->{sender}->ID, __PACKAGE__);\n  }\n\n  # Clean out our global timeout.\n  $kernel->delay(send_request => undef);\n\n  # Clean up our global alias.\n  DEBUG and warn \"SHT: Resolver removing alias $self->[SF_ALIAS]\";\n  $kernel->alias_remove($self->[SF_ALIAS]);\n\n  $self->[SF_SHUTDOWN] = 1;\n}\n\n# Send a response.  Fake a postback for older API versions.  Send a\n# nice, tidy hash for new ones.  Also decrement the reference count\n# that's keeping the requester session alive.\n\nsub _send_response {\n  my %args = @_;\n\n  # Simulate a postback for older API versions.\n\n  my $api_version = delete $args{api_ver};\n  if ($api_version < 3) {\n    $poe_kernel->post(\n      $args{sender}, $args{event},\n      [ $args{host}, $args{type}, $args{class}, @{$args{context}} ],\n      [ $args{response}, $args{error} ],\n    );\n  }\n\n  # New, fancy, shiny hash-based response.\n\n  else {\n    $poe_kernel->post(\n      $args{sender}, $args{event},\n      {\n        host     => $args{host},\n        type     => $args{type},\n        class    => $args{class},\n        context  => $args{context},\n        response => $args{response},\n        error    => $args{error},\n      }\n    );\n  }\n\n  # Let the client session go.\n  $poe_kernel->refcount_decrement($args{sender}->ID, __PACKAGE__);\n}\n\n### NOT A POE EVENT HANDLER\n\nsub _check_hosts_file {\n  my ($self, $host, $type) = @_;\n\n  # Use the hosts file that was specified, or find one.\n  my $use_hosts_file;\n  if (defined $self->[SF_HOSTS_FILE]) {\n    $use_hosts_file = $self->[SF_HOSTS_FILE];\n  }\n  else {\n    # Discard the hosts file name if it has disappeared.\n    $global_hosts_file = undef if (\n      $global_hosts_file and !-f $global_hosts_file\n    );\n\n    # Try to find a hosts file if one doesn't exist.\n    unless ($global_hosts_file) {\n      my @candidates = (\n        \"/etc/hosts\",\n      );\n\n      if ( $^O eq 'android' ) {\n        push @candidates, \"/system/etc/hosts\";\n      }\n      \n      if ($^O eq \"MSWin32\" or $^O eq \"Cygwin\") {\n        my $sys_dir;\n        $sys_dir = $ENV{SystemRoot} || \"c:\\\\Windows\";\n        push(\n          @candidates,\n          \"$sys_dir\\\\System32\\\\Drivers\\\\Etc\\\\hosts\",\n          \"$sys_dir\\\\System\\\\Drivers\\\\Etc\\\\hosts\",\n          \"$sys_dir\\\\hosts\",\n        );\n      }\n\n      foreach my $candidate (@candidates) {\n        next unless -f $candidate;\n        $global_hosts_file = $candidate;\n        $global_hosts_file =~ s/\\\\+/\\//g;\n        $self->[SF_HOSTS_MTIME] = 0;\n        $self->[SF_HOSTS_CTIME] = 0;\n        $self->[SF_HOSTS_INODE] = 0;\n        last;\n      }\n    }\n\n    # We use the global hosts file.\n    $use_hosts_file = $global_hosts_file;\n  }\n\n  # Still no hosts file?  Don't bother reading it, then.\n  return unless $use_hosts_file;\n\n  # Blow away our cache if the file doesn't exist.\n  $self->[SF_HOSTS_CACHE] = { } unless -f $use_hosts_file;\n\n  # Reload the hosts file if times have changed.\n  my ($inode, $bytes, $mtime, $ctime) = (stat $use_hosts_file)[1, 7, 9,10];\n  unless (\n    $self->[SF_HOSTS_MTIME] == ($mtime || -1) and\n    $self->[SF_HOSTS_CTIME] == ($ctime || -1) and\n    $self->[SF_HOSTS_INODE] == ($inode || -1) and\n    $self->[SF_HOSTS_BYTES] == ($bytes || -1)\n  ) {\n    return unless open(HOST, \"<\", $use_hosts_file);\n\n    my %cached_hosts;\n    while (<HOST>) {\n      next if /^\\s*\\#/; # skip all-comment lines\n      next if /^\\s*$/;  # skip empty lines\n      chomp;\n\n      # Bare split discards leading and trailing whitespace.\n      my ($address, @aliases) = split;\n      next unless defined $address;\n\n      my $type = ($address =~ /:/) ? \"AAAA\" : \"A\";\n      foreach my $alias (@aliases) {\n        $cached_hosts{$alias}{$type}{$address} = 1;\n      }\n    }\n    close HOST;\n\n    # Normalize our cached hosts.\n    while (my ($alias, $type_rec) = each %cached_hosts) {\n      while (my ($type, $address_rec) = each %$type_rec) {\n        $cached_hosts{$alias}{$type} = (keys %$address_rec)[0];\n      }\n    }\n\n    $self->[SF_HOSTS_CACHE] = \\%cached_hosts;\n    $self->[SF_HOSTS_MTIME] = $mtime;\n    $self->[SF_HOSTS_CTIME] = $ctime;\n    $self->[SF_HOSTS_INODE] = $inode;\n    $self->[SF_HOSTS_BYTES] = $bytes;\n  }\n\n  # Return whatever match we have.\n  return unless (\n    (exists $self->[SF_HOSTS_CACHE]{$host}) and\n    (exists $self->[SF_HOSTS_CACHE]{$host}{$type})\n  );\n  return $self->[SF_HOSTS_CACHE]{$host}{$type};\n}\n\n### NOT A POE EVENT HANDLER\n\nsub get_resolver {\n  my $self = shift;\n  return $self->[SF_RESOLVER];\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Client::DNS - non-blocking, parallel DNS client\n\n=head1 VERSION\n\nversion 1.054\n\n=head1 SYNOPSIS\n\n  use POE qw(Component::Client::DNS);\n\n  my $named = POE::Component::Client::DNS->spawn(\n    Alias => \"named\"\n  );\n\n  POE::Session->create(\n    inline_states  => {\n      _start   => \\&start_tests,\n      response => \\&got_response,\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\n  sub start_tests {\n    my $response = $named->resolve(\n      event   => \"response\",\n      host    => \"localhost\",\n      context => { },\n    );\n    if ($response) {\n      $_[KERNEL]->yield(response => $response);\n    }\n  }\n\n  sub got_response {\n    my $response = $_[ARG0];\n    my @answers = $response->{response}->answer();\n\n    foreach my $answer (@answers) {\n      print(\n        \"$response->{host} = \",\n        $answer->type(), \" \",\n    ", 8192) = 8192
09:01:57.323832 brk(0x1800000)          = 0x1800000
09:01:57.324109 lseek(7, 15542, SEEK_SET) = 15542
09:01:57.324157 lseek(7, 0, SEEK_CUR)   = 15542
09:01:57.324202 close(7)                = 0
09:01:57.324265 stat("modules/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324318 stat("modules/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324369 stat("modules/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324418 stat("modules/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324468 stat("/etc/perl/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324520 stat("/etc/perl/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324570 stat("/usr/local/lib/perl/5.14.2/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324621 stat("/usr/local/lib/perl/5.14.2/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324672 stat("/usr/local/share/perl/5.14.2/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324726 stat("/usr/local/share/perl/5.14.2/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324777 stat("/usr/lib/perl5/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324828 stat("/usr/lib/perl5/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324878 stat("/usr/share/perl5/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.324930 stat("/usr/share/perl5/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.324981 stat("/usr/lib/perl/5.14/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.325033 stat("/usr/lib/perl/5.14/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.325084 stat("/usr/share/perl/5.14/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.325140 stat("/usr/share/perl/5.14/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.325193 stat("/usr/local/lib/site_perl/POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.325244 stat("/usr/local/lib/site_perl/POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.325295 stat("./POE/Filter/Zlib/Stream.pmc", 0x7ffe1233bce0) = -1 ENOENT (No such file or directory)
09:01:57.325344 stat("./POE/Filter/Zlib/Stream.pm", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:01:57.325971 read(6, ">send_event(irc_raw => $ev->{raw_line} ) if $self->{raw};\n\n    # record our nickname\n    if ( $ev->{name} eq '001' ) {\n        $self->{INFO}{RealNick} = ( split / /, $ev->{raw_line} )[2];\n    }\n\n    $ev->{name} = 'irc_' . $ev->{name};\n    $self->send_event( $ev->{name}, @{$ev->{args}} );\n\n    if ($ev->{name} =~ /^irc_ctcp_(.+)$/) {\n        $self->send_event(irc_ctcp => $1 => @{$ev->{args}});\n    }\n\n    return;\n}\n\n# Internal function called when a socket is closed.\nsub _sock_down {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n\n    # Destroy the RW wheel for the socket.\n    delete $self->{socket};\n    delete $self->{localaddr};\n    $self->{connected} = 0;\n\n    # Stop any delayed sends.\n    $self->{send_queue} = [ ];\n    $self->{send_time}  = 0;\n    $kernel->delay( sl_delayed => undef );\n\n    # Reset the filters if necessary\n    $self->_compress_uplink( 0 );\n    $self->_compress_downlink( 0 );\n    $self->{ircd_compat}->chantypes( [ '#', '&' ] );\n    $self->{ircd_compat}->identifymsg(0);\n\n    # post a 'irc_disconnected' to each session that cares\n    $self->send_event(irc_disconnected => $self->{server} );\n    return;\n}\n\nsub disconnect {\n    my ($self) = @_;\n    $self->yield('_sock_down');\n    return;\n}\n\n# Internal function called when a socket fails to be properly opened.\nsub _sock_failed {\n    my ($self, $op, $errno, $errstr) = @_[OBJECT, ARG0..ARG2];\n\n    delete $self->{socketfactory};\n    $self->send_event(irc_socketerr => \"$op error $errno: $errstr\" );\n    return;\n}\n\n# Internal function called when a connection is established.\nsub _sock_up {\n    my ($kernel, $self, $session, $socket) = @_[KERNEL, OBJECT, SESSION, ARG0];\n\n    # We no longer need the SocketFactory wheel. Scrap it.\n    delete $self->{socketfactory};\n\n    # Remember what IP address we're connected through, for multihomed boxes.\n    my $localaddr;\n    if ($GOT_SOCKET6) {\n        eval {\n                $localaddr = (unpack_sockaddr_in6( getsockname $socket ))[1];\n                $localaddr = inet_ntop( AF_INET6, $localaddr );\n        };\n    }\n\n    if ( !$localaddr ) {\n        $localaddr = (unpack_sockaddr_in( getsockname $socket ))[1];\n        $localaddr = inet_ntoa($localaddr);\n    }\n\n    $self->{localaddr} = $localaddr;\n\n    if ( $self->{socks_proxy} ) {\n        $self->{socket} = POE::Wheel::ReadWrite->new(\n            Handle       => $socket,\n            Driver       => POE::Driver::SysRW->new(),\n            Filter       => POE::Filter::Stream->new(),\n            InputEvent   => '_socks_proxy_response',\n            ErrorEvent   => '_sock_down',\n        );\n\n        if ( !$self->{socket} ) {\n            $self->send_event(irc_socketerr =>\n                \"Couldn't create ReadWrite wheel for SOCKS socket\" );\n            return;\n        }\n\n        my $packet;\n        if ( _ip_is_ipv4( $self->{server} ) ) {\n            # SOCKS 4\n            $packet = pack ('CCn', 4, 1, $self->{port}) .\n            inet_aton($self->{server}) . ($self->{socks_id} || '') . (pack 'x');\n        }\n        else {\n            # SOCKS 4a\n            $packet = pack ('CCn', 4, 1, $self->{port}) .\n            inet_aton('0.0.0.1') . ($self->{socks_id} || '') . (pack 'x') .\n            $self->{server} . (pack 'x');\n        }\n\n        $self->{socket}->put( $packet );\n        return;\n    }\n\n    # ssl!\n    if ($GOT_SSL and $self->{usessl}) {\n        eval {\n            my ($ctx);\n\n            if( $self->{sslctx} )\n            {\n                $ctx = $self->{sslctx};\n            }\n            elsif( $self->{sslkey} && $self->{sslcert} )\n            {\n                $ctx = SSLify_ContextCreate( $self->{sslkey}, $self->{sslcert} );\n            }\n            else\n            {\n                $ctx = undef;\n            }\n\n            $socket = Client_SSLify($socket, undef, undef, $ctx);\n        };\n\n        if ($@) {\n         \tchomp $@;\n            warn \"Couldn't use an SSL socket: $@\\n\";\n            $self->{usessl} = 0;\n        }\n    }\n\n    if ( $self->{compress} ) {\n        $self->_compress_uplink(1);\n        $self->_compress_downlink(1);\n    }\n\n    # Create a new ReadWrite wheel for the connected socket.\n    $self->{socket} = POE::Wheel::ReadWrite->new(\n        Handle       => $socket,\n        Driver       => POE::Driver::SysRW->new(),\n        InputFilter  => $self->{srv_filter},\n        OutputFilter => $self->{out_filter},\n        InputEvent   => '_parseline',\n        ErrorEvent   => '_sock_down',\n    );\n\n    if ($self->{socket}) {\n        $self->{connected} = 1;\n    }\n    else {\n        $self->send_event(irc_socketerr => \"Couldn't create ReadWrite wheel for IRC socket\");\n        return;\n    }\n\n    # Post a 'irc_connected' event to each session that cares\n    $self->send_event(irc_connected => $self->{server} );\n\n    # CONNECT if we're using a proxy\n    if ($self->{proxy}) {\n        # The original proxy code, AFAIK, did not actually work\n        # with an HTTP proxy.\n        $self->call(\n            'sl_login',\n            'CONNECT ' . $self->{server} . ':' . $self->{port} . \" HTTP/1.0\\n\\n\",\n        );\n\n        # KLUDGE: Also, the original proxy code assumes the connection\n        # is instantaneous Since this is not always the case, mess with\n        # the queueing so that the sent text is delayed...\n        $self->{send_time} = time() + 10;\n    }\n\n    $kernel->yield('_send_login');\n    return;\n}\n\nsub _socks_proxy_response {\n    my ($kernel, $self, $session, $input) = @_[KERNEL, OBJECT, SESSION, ARG0];\n\n    if (length $input != 8) {\n        $self->send_event(\n            'irc_socks_failed',\n            'Mangled response from SOCKS proxy',\n            $input,\n        );\n        $self->disconnect();\n        return;\n    }\n\n    my @resp = unpack 'CCnN', $input;\n    if (@resp != 4 || $resp[0] ne '0' || $resp[1] !~ /^(?:90|91|92|93)$/) {\n        $self->send_event(\n            'irc_socks_failed',\n            'Mangled response from SOCKS proxy',\n            $input,\n        );\n        $self->disconnect();\n        return;\n    }\n\n    if ( $resp[1] eq '90' ) {\n        $kernel->call($session => '_socks_proxy_connect');\n        $self->{connected} = 1;\n        $self->send_event( 'irc_connected', $self->{server} );\n        $kernel->yield('_send_login');\n    }\n    else {\n        $self->send_event(\n            'irc_socks_rejected',\n            $resp[1],\n            $self->{socks_proxy},\n            $self->{socks_port},\n            $self->{socks_id},\n        );\n        $self->disconnect();\n    }\n\n    return;\n}\n\nsub _socks_proxy_connect {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    $self->{socket}->event( InputEvent => '_parseline' );\n    $self->{socket}->set_input_filter( $self->{srv_filter} );\n    $self->{socket}->set_output_filter( $self->{out_filter} );\n    return;\n}\n\nsub _send_login {\n    my ($kernel, $self, $session) = @_[KERNEL, OBJECT, SESSION];\n\n    # Now that we're connected, attempt to log into the server.\n\n    # for servers which support CAP, it's customary to start with that\n    $kernel->call($session, 'sl_login', 'CAP REQ :identify-msg');\n    $kernel->call($session, 'sl_login', 'CAP REQ :multi-prefix');\n    $kernel->call($session, 'sl_login', 'CAP LS');\n    $kernel->call($session, 'sl_login', 'CAP END');\n\n    if (defined $self->{password}) {\n        $kernel->call($session => sl_login => 'PASS ' . $self->{password});\n    }\n    $kernel->call($session => sl_login => 'NICK ' . $self->{nick});\n    $kernel->call(\n        $session,\n        'sl_login',\n        'USER ' .\n        join(' ', $self->{username},\n            (defined $self->{bitmode} ? $self->{bitmode} : 8),\n            '*',\n            ':' . $self->{ircname}\n        ),\n    );\n\n    # If we have queued data waiting, its flush loop has stopped\n    # while we were disconnected.  Start that up again.\n    $kernel->delay(sl_delayed => 0);\n\n    return;\n}\n\n# Set up the component's IRC session.\nsub syndicator_started {\n    my ($kernel, $session, $sender, $self, $alias)\n        = @_[KERNEL, SESSION, SENDER, OBJECT, ARG0, ARG1 .. $#_];\n\n    # Send queue is used to hold pending lines so we don't flood off.\n    # The count is used to track the number of lines sent at any time.\n    $self->{send_queue} = [ ];\n    $self->{send_time}  = 0;\n\n    $self->{ircd_filter} = POE::Fi", 8192) = 8192
09:01:57.326695 brk(0x1821000)          = 0x1821000
09:01:57.327160 read(6, "lter::IRCD->new(debug => $self->{debug});\n    $self->{ircd_compat} = POE::Filter::IRC::Compat->new(debug => $self->{debug});\n\n    my $srv_filters = [\n        POE::Filter::Line->new(\n            InputRegexp => '\\015?\\012',\n            OutputLiteral => '\\015\\012',\n        ),\n        $self->{ircd_filter},\n        $self->{ircd_compat},\n    ];\n\n    $self->{srv_filter} = POE::Filter::Stackable->new(Filters => $srv_filters);\n    $self->{out_filter} = POE::Filter::Stackable->new(Filters => [\n        POE::Filter::Line->new( OutputLiteral => \"\\015\\012\" ),\n    ]);\n\n    # Plugin 'irc_whois' and 'irc_whowas' support\n    $self->plugin_add('Whois_' . $self->session_id(),\n        POE::Component::IRC::Plugin::Whois->new()\n    );\n\n    $self->{isupport} = POE::Component::IRC::Plugin::ISupport->new();\n    $self->plugin_add('ISupport_' . $self->session_id(), $self->{isupport});\n    $self->{dcc} = POE::Component::IRC::Plugin::DCC->new();\n    $self->plugin_add('DCC_' . $self->session_id(), $self->{dcc});\n\n    return 1;\n}\n\n# The handler for commands which have N arguments, separated by commas.\nsub commasep {\n    my ($kernel, $self, $state, @args) = @_[KERNEL, OBJECT, STATE, ARG0 .. $#_];\n    my $args;\n\n    if ($state eq 'whois' and @args > 1 ) {\n        $args = shift @args;\n        $args .= ' ' . join ',', @args;\n    }\n    elsif ( $state eq 'part' and @args > 1 ) {\n        my $chantypes = join('', @{ $self->isupport('CHANTYPES') || ['#', '&']});\n        my $message;\n        if ($args[-1] =~ / +/ || $args[-1] !~ /^[$chantypes]/) {\n            $message = pop @args;\n        }\n        $args = join(',', @args);\n        $args .= \" :$message\" if defined $message;\n    }\n    else {\n        $args = join ',', @args;\n    }\n\n    my $pri = $self->{IRC_CMDS}->{$state}->[CMD_PRI];\n    $state = uc $state;\n    $state .= \" $args\" if defined $args;\n    $kernel->yield(sl_prioritized => $pri, $state );\n\n    return;\n}\n\n# Get variables in order for openning a connection\nsub connect {\n    my ($kernel, $self, $session, $sender, $args)\n        = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0];\n\n    if ($args) {\n        my %arg;\n        %arg = @{ $args } if ref $args eq 'ARRAY';\n        %arg = %{ $args } if ref $args eq 'HASH';\n        $arg{ lc $_ } = delete $arg{$_} for keys %arg;\n        $self->_configure( \\%arg );\n    }\n\n    if ( $self->{resolver} && $self->{res_addresses}\n        && @{ $self->{res_addresses} } ) {\n        push @{ $self->{res_addresses} }, $self->{server};\n        $self->{resolved_server} = shift @{ $self->{res_addresses} };\n    }\n\n    # try and use non-blocking resolver if needed\n    if ( $self->{resolver} && !_ip_get_version( $self->{server} )\n        && !$self->{nodns} ) {\n        $kernel->yield(\n            '_resolve_addresses',\n             $self->{server},\n             ( $self->{useipv6} && $GOT_SOCKET6 ? 'AAAA' : 'A' ),\n        );\n    }\n    else {\n        $kernel->yield('_do_connect');\n    }\n\n    $self->{INFO}{RealNick} = $self->{nick};\n    return;\n}\n\nsub _resolve_addresses {\n    my ($kernel, $self, $hostname, $type) = @_[KERNEL, OBJECT, ARG0 .. ARG1];\n\n    my $response = $self->{resolver}->resolve(\n        event => '_got_dns_response',\n        host => $hostname,\n        type => $type,\n        context => { },\n    );\n\n    $kernel->yield(_got_dns_response => $response) if $response;\n    return;\n}\n\n# open the connection\nsub _do_connect {\n    my ($kernel, $self, $session) = @_[KERNEL, OBJECT, SESSION];\n    my $domain = AF_INET;\n\n    # Disconnect if we're already logged into a server.\n    $kernel->call($session => 'quit') if $self->{socket};\n\n    if ($self->{socks_proxy} && !$self->{socks_port}) {\n        $self->{socks_port} = 1080;\n    }\n\n    for my $address (qw(socks_proxy proxy server resolved_server use_localaddr)) {\n        next if !$self->{$address} || !_ip_is_ipv6( $self->{$address} );\n        if (!$GOT_SOCKET6) {\n            warn \"IPv6 address specified for '$address' but Socket6 not found\\n\";\n            return;\n        }\n        $domain = AF_INET6;\n    }\n\n    $self->{socketfactory} = POE::Wheel::SocketFactory->new(\n        SocketDomain   => $domain,\n        SocketType     => SOCK_STREAM,\n        SocketProtocol => 'tcp',\n        RemoteAddress  => $self->{socks_proxy} || $self->{proxy} || $self->{resolved_server} || $self->{server},\n        RemotePort     => $self->{socks_port} || $self->{proxyport} || $self->{port},\n        SuccessEvent   => '_sock_up',\n        FailureEvent   => '_sock_failed',\n        ($self->{use_localaddr} ? (BindAddress => $self->{use_localaddr}) : ()),\n    );\n\n    return;\n}\n\n# got response from POE::Component::Client::DNS\nsub _got_dns_response {\n    my ($kernel, $self, $response) = @_[KERNEL, OBJECT, ARG0];\n\n    my $type = uc $response->{type};\n    my $net_dns_packet = $response->{response};\n    my $net_dns_errorstring = $response->{error};\n    $self->{res_addresses} = [ ];\n\n    if (!defined $net_dns_packet) {\n        $self->send_event(irc_socketerr => $net_dns_errorstring );\n        return;\n    }\n\n    my @net_dns_answers = $net_dns_packet->answer;\n\n    for my $net_dns_answer (@net_dns_answers) {\n        next if $net_dns_answer->type !~ /^A/;\n        push @{ $self->{res_addresses} }, $net_dns_answer->rdatastr;\n    }\n\n    if ( !@{ $self->{res_addresses} } && $type eq 'AAAA') {\n        $kernel->yield(_resolve_addresses => $self->{server}, 'A');\n        return;\n    }\n\n    if ( !@{ $self->{res_addresses} } ) {\n        $self->send_event(irc_socketerr => 'Unable to resolve ' . $self->{server});\n        return;\n      }\n\n    if ( my $address = shift @{ $self->{res_addresses} } ) {\n        $self->{resolved_server} = $address;\n        $kernel->yield('_do_connect');\n        return;\n    }\n\n    $self->send_event(irc_socketerr => 'Unable to resolve ' . $self->{server});\n    return;\n}\n\n# Send a CTCP query or reply, with the same syntax as a PRIVMSG event.\nsub ctcp {\n    my ($kernel, $state, $self, $to) = @_[KERNEL, STATE, OBJECT, ARG0];\n    my $message = join ' ', @_[ARG1 .. $#_];\n\n    if (!defined $to || !defined $message) {\n        warn \"The '$state' event requires two arguments\\n\";\n        return;\n    }\n\n    # CTCP-quote the message text.\n    ($message) = @{$self->{ircd_compat}->put([ $message ])};\n\n    # Should we send this as a CTCP request or reply?\n    $state = $state eq 'ctcpreply' ? 'notice' : 'privmsg';\n\n    $kernel->yield($state, $to, $message);\n    return;\n}\n\n# The way /notify is implemented in IRC clients.\nsub ison {\n    my ($kernel, @nicks) = @_[KERNEL, ARG0 .. $#_];\n    my $tmp = 'ISON';\n\n    if (!@nicks) {\n        warn \"The 'ison' event requires one or more nicknames\\n\";\n        return;\n    }\n\n    # We can pass as many nicks as we want, as long as it's shorter than\n    # the maximum command length (510). If the list we get is too long,\n    # w'll break it into multiple ISON commands.\n    while (@nicks) {\n        my $nick = shift @nicks;\n        if (length($tmp) + length($nick) >= 509) {\n            $kernel->yield(sl_high => $tmp);\n            $tmp = 'ISON';\n        }\n        $tmp .= \" $nick\";\n    }\n\n    $kernel->yield(sl_high => $tmp);\n    return;\n}\n\n# Tell the IRC server to forcibly remove a user from a channel.\nsub kick {\n    my ($kernel, $chan, $nick) = @_[KERNEL, ARG0, ARG1];\n    my $message = join '', @_[ARG2 .. $#_];\n\n    if (!defined $chan || !defined $nick) {\n        warn \"The 'kick' event requires at least two arguments\\n\";\n        return;\n    }\n\n    $nick .= \" :$message\" if defined $message;\n    $kernel->yield(sl_high => \"KICK $chan $nick\");\n    return;\n}\n\n# Tell the IRC server to forcibly remove a user from a channel. Freenode extension\nsub remove {\n    my ($kernel, $chan, $nick) = @_[KERNEL, ARG0, ARG1];\n    my $message = join '', @_[ARG2 .. $#_];\n\n    if (!defined $chan || !defined $nick) {\n        warn \"The 'remove' event requires at least two arguments\\n\";\n        return;\n    }\n\n    $nick .= \" :$message\" if defined $message;\n    $kernel->yield(sl_high => \"REMOVE $chan $nick\");\n    return;\n}\n\n# Interact with NickServ\nsub nickserv {\n    my ($kernel, $self, $state) = @_[KERNEL, OBJECT, STATE];\n    my $args = join ' ', @_[ARG0 .. $#_];\n\n    my $command = 'NICKSERV';\n    my $version = $self->server_version();\n    $command = 'NS' i", 8192) = 8192
09:01:57.327908 brk(0x1842000)          = 0x1842000
09:01:57.328486 read(6, "f defined $version && $version =~ /ratbox/i;\n    $command .= \" $args\" if defined $args;\n\n    $kernel->yield(sl_high => $command);\n    return;\n}\n\n# Set up a new IRC component. Deprecated.\nsub new {\n    my ($package, $alias) = splice @_, 0, 2;\n    croak \"$package options should be an even-sized list\" if @_ & 1;\n    my %options = @_;\n\n    if (!defined $alias) {\n        croak 'Not enough arguments to POE::Component::IRC::new()';\n    }\n\n    carp \"Use of ${package}->new() is deprecated, please use spawn()\";\n\n    my $self = $package->spawn ( alias => $alias, options => \\%options );\n    return $self;\n}\n\n# Set up a new IRC component. New interface.\nsub spawn {\n    my ($package) = shift;\n    croak \"$package requires an even number of arguments\" if @_ & 1;\n    my %params = @_;\n\n    $params{ lc $_ } = delete $params{$_} for keys %params;\n    delete $params{options} if ref $params{options} ne 'HASH';\n\n    my $self = bless { }, $package;\n    $self->_create();\n\n    if ($ENV{POCOIRC_DEBUG}) {\n        $params{debug} = 1;\n        $params{plugin_debug} = 1;\n    }\n\n    my $options      = delete $params{options};\n    my $alias        = delete $params{alias};\n    my $plugin_debug = delete $params{plugin_debug};\n\n    $self->_syndicator_init(\n        prefix          => 'irc_',\n        reg_prefix      => 'PCI_',\n        types           => [SERVER => 'S', USER => 'U'],\n        alias           => $alias,\n        register_signal => 'POCOIRC_REGISTER',\n        shutdown_signal => 'POCOIRC_SHUTDOWN',\n        object_states   => [\n            $self => delete $self->{OBJECT_STATES_HASHREF},\n            $self => delete $self->{OBJECT_STATES_ARRAYREF},\n        ],\n        ($plugin_debug ? (debug => 1) : () ),\n        (ref $options eq 'HASH' ? ( options => $options ) : ()),\n    );\n\n    $params{spawned} = 1;\n    $self->_configure(\\%params);\n\n    if (!$params{nodns} && $GOT_CLIENT_DNS && !$self->{resolver}) {\n        $self->{resolver} = POE::Component::Client::DNS->spawn(\n            Alias => 'resolver' . $self->session_id()\n        );\n        $self->{mydns} = 1;\n    }\n\n    return $self;\n}\n\n# The handler for all IRC commands that take no arguments.\nsub noargs {\n    my ($kernel, $state, $arg) = @_[KERNEL, STATE, ARG0];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    if (defined $arg) {\n        warn \"The '$state' event takes no arguments\\n\";\n        return;\n    }\n\n    $state = uc $state;\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# The handler for commands that take one required and two optional arguments.\nsub oneandtwoopt {\n    my ($kernel, $state) = @_[KERNEL, STATE];\n    my $arg = join '', @_[ARG0 .. $#_];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    $state = 'connect' if $state eq 'sconnect';\n    $state = uc $state;\n    if (defined $arg) {\n        $arg = ':' . $arg if $arg =~ /\\x20/;\n        $state .= \" $arg\";\n    }\n\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# The handler for commands that take at least one optional argument.\nsub oneoptarg {\n    my ($kernel, $state) = @_[KERNEL, STATE];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n    $state = uc $state;\n\n    if (defined $_[ARG0]) {\n        my $arg = join '', @_[ARG0 .. $#_];\n        $arg = ':' . $arg if $arg =~ /\\x20/;\n        $state .= \" $arg\";\n    }\n\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# The handler for commands which take one required and one optional argument.\nsub oneortwo {\n    my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];\n    my $two = join '', @_[ARG1 .. $#_];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    if (!defined $one) {\n        warn \"The '$state' event requires at least one argument\\n\";\n        return;\n    }\n\n    $state = uc( $state ) . \" $one\";\n    $state .= \" $two\" if defined $two;\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# Handler for commands that take exactly one argument.\nsub onlyonearg {\n    my ($kernel, $state) = @_[KERNEL, STATE];\n    my $arg = join '', @_[ARG0 .. $#_];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    if (!defined $arg) {\n        warn \"The '$state' event requires one argument\\n\";\n        return;\n    }\n\n    $state = uc $state;\n    $arg = ':' . $arg if $arg =~ /\\x20/;\n    $state .= \" $arg\";\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# Handler for commands that take exactly two arguments.\nsub onlytwoargs {\n    my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];\n    my ($two) = join '', @_[ARG1 .. $#_];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    if (!defined $one || !defined $two) {\n        warn \"The '$state' event requires two arguments\\n\";\n        return;\n    }\n\n    $state = uc $state;\n    $two = ':' . $two if $two =~ /\\x20/;\n    $state .= \" $one $two\";\n    $kernel->yield(sl_prioritized => $pri, $state);\n    return;\n}\n\n# Handler for privmsg or notice events.\nsub privandnotice {\n    my ($kernel, $state, $to, $msg) = @_[KERNEL, STATE, ARG0, ARG1];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    $state =~ s/privmsglo/privmsg/;\n    $state =~ s/privmsghi/privmsg/;\n    $state =~ s/noticelo/notice/;\n    $state =~ s/noticehi/notice/;\n\n    if (!defined $to || !defined $msg) {\n        warn \"The '$state' event requires two arguments\\n\";\n        return;\n    }\n\n    $to = join ',', @$to if ref $to eq 'ARRAY';\n    $state = uc $state;\n\n    $kernel->yield(sl_prioritized => $pri, \"$state $to :$msg\");\n    return;\n}\n\n# Tell the IRC session to go away.\nsub shutdown {\n    my ($kernel, $self, $sender, $session) = @_[KERNEL, OBJECT, SENDER, SESSION];\n    return if $self->{_shutdown};\n    $self->{_shutdown} = $sender->ID();\n\n    if ($self->logged_in()) {\n        my ($msg, $timeout) = @_[ARG0, ARG1];\n        $msg = '' if !defined $msg;\n        $timeout = 5 if !defined $timeout;\n        $msg = \":$msg\" if $msg =~ /\\x20/;\n        my $cmd = \"QUIT $msg\";\n        $kernel->call($session => sl_high => $cmd);\n        $kernel->delay('_quit_timeout', $timeout);\n        $self->{_waiting} = 1;\n    }\n    elsif ($self->connected()) {\n        $self->disconnect();\n    }\n    else {\n        $self->_shutdown();\n    }\n\n    return;\n}\n\nsub _quit_timeout {\n    my ($self) = $_[OBJECT];\n    $self->disconnect();\n    return;\n}\n\nsub _shutdown {\n    my ($self) = @_;\n\n    $self->_syndicator_destroy($self->{_shutdown});\n    delete $self->{$_} for qw(socketfactory dcc wheelmap);\n    $self->{resolver}->shutdown() if $self->{resolver} && $self->{mydns};\n    return;\n}\n\n# Send a line of login-priority IRC output.  These are things which\n# must go first.\nsub sl_login {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    my $arg = join ' ', @_[ARG0 .. $#_];\n    $kernel->yield(sl_prioritized => PRI_LOGIN, $arg );\n    return;\n}\n\n# Send a line of high-priority IRC output.  Things like channel/user\n# modes, kick messages, and whatever.\nsub sl_high {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    my $arg = join ' ', @_[ARG0 .. $#_];\n    $kernel->yield(sl_prioritized => PRI_HIGH, $arg );\n    return;\n}\n\n# Send a line of normal-priority IRC output to the server.  PRIVMSG\n# and other random chatter.  Uses sl() for compatibility with existing\n# code.\nsub sl {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n    my $arg = join ' ', @_[ARG0 .. $#_];\n    $kernel->yield(sl_prioritized => PRI_NORMAL, $arg );\n    return;\n}\n\n# Prioritized sl().  This keeps the queue ordered by priority, low to\n# high in the UNIX tradition.  It also throttles transmission\n# following the hybrid ircd's algorithm, so you can't accidentally\n# flood yourself off.  Thanks to Raistlin for explaining how ircd\n# throttles messages.\nsub sl_prioritized {\n    my ($kernel, $self, $priority, @args) = @_[KERNEL, OBJECT, ARG0, ARG1];\n\n    if (my ($event) = $args[0] =~ /^(\\w+)/ ) {\n        # Let the plugin system process this\n        return 1 if $self->send_user_event($event, \\@args) == PCI_EAT_ALL;\n    }\n    else {\n        warn \"Unable to extract the event name from '$args[0]'\\n\";\n    }\n\n    my $msg = $args[0];\n    my $now = time();\n    $self->{send_time} = $now if $self->{send_time} < $now;\n\n    # if we find a newline in the message, take that to", 8192) = 8192
09:01:57.329091 brk(0x1863000)          = 0x1863000
09:01:57.329883 brk(0x1884000)          = 0x1884000
09:01:57.329988 read(6, " be the end of it\n    $msg =~ s/[\\015\\012].*//s;\n\n    if (bytes::length($msg) > $self->{msg_length} - bytes::length($self->nick_name())) {\n        $msg = bytes::substr($msg, 0, $self->{msg_length} - bytes::length($self->nick_name()));\n    }\n\n    if (@{ $self->{send_queue} }) {\n        my $i = @{ $self->{send_queue} };\n        $i-- while ($i && $priority < $self->{send_queue}->[$i-1]->[MSG_PRI]);\n        splice( @{ $self->{send_queue} }, $i, 0, [ $priority, $msg ] );\n    }\n    elsif ( !$self->{flood} && $self->{send_time} - $now >= 10\n        || !defined $self->{socket} ) {\n        push( @{$self->{send_queue}}, [ $priority, $msg ] );\n        $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 );\n    }\n    else {\n        warn \">>> $msg\\n\" if $self->{debug};\n        $self->send_event(irc_raw_out => $msg) if $self->{raw};\n        $self->{send_time} += 2 + length($msg) / 120;\n        $self->{socket}->put($msg);\n    }\n\n    return;\n}\n\n# Send delayed lines to the ircd.  We manage a virtual \"send time\"\n# that progresses into the future based on hybrid ircd's rules every\n# time a message is sent.  Once we find it ten or more seconds into\n# the future, we wait for the realtime clock to catch up.\nsub sl_delayed {\n    my ($kernel, $self) = @_[KERNEL, OBJECT];\n\n    return if !defined $self->{socket};\n\n    my $now = time();\n    $self->{send_time} = $now if $self->{send_time} < $now;\n\n    while (@{ $self->{send_queue} } && ($self->{send_time} - $now < 10)) {\n        my $arg = (shift @{$self->{send_queue}})->[MSG_TEXT];\n        warn \">>> $arg\\n\" if $self->{debug};\n        $self->send_event(irc_raw_out => $arg) if $self->{raw};\n        $self->{send_time} += 2 + length($arg) / 120;\n        $self->{socket}->put($arg);\n    }\n\n    if (@{ $self->{send_queue} }) {\n        $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 );\n    }\n\n    return;\n}\n\n# The handler for commands which have N arguments, separated by spaces.\nsub spacesep {\n    my ($kernel, $state) = @_[KERNEL, STATE];\n    my $args = join ' ', @_[ARG0 .. $#_];\n    my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];\n\n    $state = uc $state;\n    $state .= \" $args\" if defined $args;\n    $kernel->yield(sl_prioritized => $pri, $state );\n    return;\n}\n\n# Set or query the current topic on a channel.\nsub topic {\n    my ($kernel, $chan, @args) = @_[KERNEL, ARG0..$#_];\n    my $topic;\n    $topic = join '', @args if @args;\n\n    if (defined $topic) {\n        $chan .= \" :\";\n        $chan .= $topic if length $topic;\n    }\n\n    $kernel->yield(sl_prioritized => PRI_NORMAL, \"TOPIC $chan\");\n    return;\n}\n\n# Asks the IRC server for some random information about particular nicks.\nsub userhost {\n    my ($kernel, @nicks) = @_[KERNEL, ARG0 .. $#_];\n\n    if (!@nicks) {\n        warn \"The 'userhost' event requires at least one nickname\\n\";\n        return;\n    }\n\n    # According to the RFC, you can only send 5 nicks at a time.\n    while (@nicks) {\n        $kernel->yield(\n            'sl_prioritized',\n            PRI_HIGH,\n            'USERHOST ' . join(' ', splice(@nicks, 0, 5)),\n        );\n    }\n\n    return;\n}\n\n# Non-event methods\n\nsub server {\n    my ($self) = @_;\n    return $self->{server};\n}\n\nsub port {\n    my ($self) = @_;\n    return $self->{port};\n}\n\nsub server_name {\n    my ($self) = @_;\n    return $self->{INFO}{ServerName};\n}\n\nsub server_version {\n    my ($self) = @_;\n    return $self->{INFO}{ServerVersion};\n}\n\nsub localaddr {\n    my ($self) = @_;\n    return $self->{localaddr};\n}\n\nsub nick_name {\n    my ($self) = @_;\n    return $self->{INFO}{RealNick};\n}\n\nsub send_queue {\n    my ($self) = @_;\n\n    if (defined $self->{send_queue} && ref $self->{send_queue} eq 'ARRAY' ) {\n        return scalar @{ $self->{send_queue} };\n    }\n    return;\n}\n\nsub raw_events {\n    my ($self, $value) = @_;\n    return $self->{raw} if !defined $value;\n    $self->{raw} = $value;\n    return;\n}\n\nsub connected {\n    my ($self) = @_;\n    return $self->{connected};\n}\n\nsub logged_in {\n    my ($self) = @_;\n    return 1 if $self->{INFO}{LoggedIn};\n    return;\n}\n\nsub _compress_uplink {\n    my ($self, $value) = @_;\n\n    return if !$GOT_ZLIB;\n    return $self->{uplink} if !defined $value;\n\n    if ($value) {\n        $self->{out_filter}->unshift( POE::Filter::Zlib::Stream->new() ) if !$self->{uplink};\n        $self->{uplink} = 1;\n    }\n    else {\n        $self->{out_filter}->shift() if $self->{uplink};\n        $self->{uplink} = 0;\n    }\n\n    return $self->{uplink};\n}\n\nsub _compress_downlink {\n    my ($self, $value) = @_;\n\n    return if !$GOT_ZLIB;\n    return $self->{downlink} if !defined $value;\n\n    if ($value) {\n        $self->{srv_filter}->unshift( POE::Filter::Zlib::Stream->new() ) if !$self->{downlink};\n        $self->{downlink} = 1;\n    }\n    else {\n        $self->{srv_filter}->shift() if $self->{uplink};\n        $self->{downlink} = 0;\n    }\n\n    return $self->{downlink};\n}\n\nsub S_001 {\n    my ($self, $irc) = splice @_, 0, 2;\n    $self->{INFO}{ServerName} = ${ $_[0] };\n    $self->{INFO}{LoggedIn}   = 1;\n    return PCI_EAT_NONE;\n}\n\nsub S_004 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $args = ${ $_[2] };\n    $self->{INFO}{ServerVersion} = $args->[1];\n    return PCI_EAT_NONE;\n}\n\nsub S_error {\n    my ($self, $irc) = splice @_, 0, 2;\n    $self->{INFO}{LoggedIn} = 0;\n    return PCI_EAT_NONE;\n}\n\nsub S_disconnected {\n    my ($self, $irc) = splice @_, 0, 2;\n    $self->{INFO}{LoggedIn} = 0;\n\n    if ($self->{_waiting}) {\n        $poe_kernel->delay('_quit_timeout');\n        delete $self->{_waiting};\n    }\n\n    $self->_shutdown() if $self->{_shutdown};\n    return PCI_EAT_NONE;\n}\n\nsub S_shutdown {\n    my ($self, $irc) = splice @_, 0, 2;\n    $self->{INFO}{LoggedIn} = 0;\n    return PCI_EAT_NONE;\n}\n\n# Automatically replies to a PING from the server. Do not confuse this\n# with CTCP PINGs, which are a wholly different animal that evolved\n# much later on the technological timeline.\nsub S_ping {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $arg = ${ $_[0] };\n    $irc->yield(sl_login => \"PONG :$arg\");\n    return PCI_EAT_NONE;\n}\n\n# NICK messages for the purposes of determining our current nickname\nsub S_nick {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $nick = ( split /!/, ${ $_[0] } )[0];\n    my $new = ${ $_[1] };\n    $self->{INFO}{RealNick} = $new if ( $nick eq $self->{INFO}{RealNick} );\n    return PCI_EAT_NONE;\n}\n\n# tell POE::Filter::IRC::Compat to handle IDENTIFY-MSG\nsub S_290 {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $text = ${ $_[1] };\n    $self->{ircd_compat}->identifymsg(1) if $text eq 'IDENTIFY-MSG';\n    return PCI_EAT_NONE;\n}\n\nsub S_cap {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $cmd = ${ $_[0] };\n\n    if ($cmd eq 'ACK') {\n        my $list = ${ $_[1] } eq '*' ? ${ $_[2] } : ${ $_[1] };\n        my @enabled = split / /, $list;\n\n        if (grep { $_ =~ /^=?identify-msg$/ } @enabled) {\n            $self->{ircd_compat}->identifymsg(1);\n        }\n        if (grep { $_ =~ /^-identify-msg$/ } @enabled) {\n            $self->{ircd_compat}->identifymsg(0);\n        }\n    }\n    return PCI_EAT_NONE;\n}\n\nsub S_isupport {\n    my ($self, $irc) = splice @_, 0, 2;\n    my $isupport = ${ $_[0] };\n    $self->{ircd_compat}->chantypes( $isupport->isupport('CHANTYPES') || [ '#', '&' ] );\n    $irc->yield(sl_login => 'CAPAB IDENTIFY-MSG') if $isupport->isupport('CAPAB');\n    $irc->yield(sl_login => 'PROTOCTL NAMESX') if $isupport->isupport('NAMESX');\n    $irc->yield(sl_login => 'PROTOCTL UHNAMES') if $isupport->isupport('UHNAMES');\n    return PCI_EAT_NONE;\n}\n\n# accesses the ISupport plugin\nsub isupport {\n    my ($self, @args) = @_;\n    return $self->{isupport}->isupport(@args);\n}\n\nsub isupport_dump_keys {\n    return $_[0]->{isupport}->isupport_dump_keys();\n}\n\nsub resolver {\n    return $_[0]->{resolver};\n}\n\nsub _ip_get_version {\n    my ($ip) = @_;\n    return if !defined $ip;\n\n    # If the address does not contain any ':', maybe it's IPv4\n    return 4 if $ip !~ /:/ && _ip_is_ipv4($ip);\n\n    # Is it IPv6 ?\n    return 6 if _ip_is_ipv6($ip);\n\n    return;\n}\n\nsub _ip_is_ipv4 {\n    my ($ip) = @_;\n    return if !defined $ip;\n\n    # Check for invalid chars\n    return if $ip !~ /^[\\d\\.]+$/;\n    return if $ip =~ /^\\./;\n    return if $ip =~ /\\.$/;\n\n    # Single", 8192) = 8192
09:01:57.331117 brk(0x18a5000)          = 0x18a5000
09:01:57.331586 read(6, " Numbers are considered to be IPv4\n    return 1 if $ip =~ /^(\\d+)$/ && $1 < 256;\n\n    # Count quads\n    my $n = ($ip =~ tr/\\./\\./);\n\n    # IPv4 must have from 1 to 4 quads\n    return if $n <= 0 || $n > 4;\n\n    # Check for empty quads\n    return if $ip =~ /\\.\\./;\n\n    for my $quad (split /\\./, $ip) {\n        # Check for invalid quads\n        return if $quad < 0 || $quad >= 256;\n    }\n    return 1;\n}\n\nsub _ip_is_ipv6 {\n    my ($ip) = @_;\n    return if !defined $ip;\n\n    # Count octets\n    my $n = ($ip =~ tr/:/:/);\n    return if ($n <= 0 || $n >= 8);\n\n    # $k is a counter\n    my $k;\n\n    for my $octet (split /:/, $ip) {\n        $k++;\n\n        # Empty octet ?\n        next if $octet eq '';\n\n        # Normal v6 octet ?\n        next if $octet =~ /^[a-f\\d]{1,4}$/i;\n\n        # Last octet - is it IPv4 ?\n        if ($k == $n + 1) {\n            next if (ip_is_ipv4($octet));\n        }\n\n        return;\n    }\n\n    # Does the IP address start with : ?\n    return if $ip =~ m/^:[^:]/;\n\n    # Does the IP address finish with : ?\n    return if $ip =~ m/[^:]:$/;\n\n    # Does the IP address have more than one '::' pattern ?\n    return if $ip =~ s/:(?=:)//g > 1;\n\n    return 1;\n}\n\n1;\n\n=encoding utf8\n\n=head1 NAME\n\nPOE::Component::IRC - A fully event-driven IRC client module\n\n=head1 SYNOPSIS\n\n # A simple Rot13 'encryption' bot\n\n use strict;\n use warnings;\n use POE qw(Component::IRC);\n\n my $nickname = 'Flibble' . $$;\n my $ircname  = 'Flibble the Sailor Bot';\n my $server   = 'irc.perl.org';\n\n my @channels = ('#Blah', '#Foo', '#Bar');\n\n # We create a new PoCo-IRC object\n my $irc = POE::Component::IRC->spawn(\n    nick => $nickname,\n    ircname => $ircname,\n    server  => $server,\n ) or die \"Oh noooo! $!\";\n\n POE::Session->create(\n     package_states => [\n         main => [ qw(_default _start irc_001 irc_public) ],\n     ],\n     heap => { irc => $irc },\n );\n\n $poe_kernel->run();\n\n sub _start {\n     my $heap = $_[HEAP];\n\n     # retrieve our component's object from the heap where we stashed it\n     my $irc = $heap->{irc};\n\n     $irc->yield( register => 'all' );\n     $irc->yield( connect => { } );\n     return;\n }\n\n sub irc_001 {\n     my $sender = $_[SENDER];\n\n     # Since this is an irc_* event, we can get the component's object by\n     # accessing the heap of the sender. Then we register and connect to the\n     # specified server.\n     my $irc = $sender->get_heap();\n\n     print \"Connected to \", $irc->server_name(), \"\\n\";\n\n     # we join our channels\n     $irc->yield( join => $_ ) for @channels;\n     return;\n }\n\n sub irc_public {\n     my ($sender, $who, $where, $what) = @_[SENDER, ARG0 .. ARG2];\n     my $nick = ( split /!/, $who )[0];\n     my $channel = $where->[0];\n\n     if ( my ($rot13) = $what =~ /^rot13 (.+)/ ) {\n         $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];\n         $irc->yield( privmsg => $channel => \"$nick: $rot13\" );\n     }\n     return;\n }\n\n # We registered for all events, this will produce some debug info.\n sub _default {\n     my ($event, $args) = @_[ARG0 .. $#_];\n     my @output = ( \"$event: \" );\n\n     for my $arg (@$args) {\n         if ( ref $arg eq 'ARRAY' ) {\n             push( @output, '[' . join(', ', @$arg ) . ']' );\n         }\n         else {\n             push ( @output, \"'$arg'\" );\n         }\n     }\n     print join ' ', @output, \"\\n\";\n     return;\n }\n\n=head1 DESCRIPTION\n\nPOE::Component::IRC is a POE component (who'd have guessed?) which\nacts as an easily controllable IRC client for your other POE\ncomponents and sessions. You create an IRC component and tell it what\nevents your session cares about and where to connect to, and it sends\nback interesting IRC events when they happen. You make the client do\nthings by sending it events. That's all there is to it. Cool, no?\n\n[Note that using this module requires some familiarity with the\ndetails of the IRC protocol. I'd advise you to read up on the gory\ndetails of RFC 1459 (L<http://www.faqs.org/rfcs/rfc1459.html>) before you\nget started. Keep the list of server numeric codes handy while you\nprogram. Needless to say, you'll also need a good working knowledge of\nPOE, or this document will be of very little use to you.]\n\nThe POE::Component::IRC distribution has a F<docs/> folder with a collection of\nsalient documentation including the pertinent RFCs.\n\nPOE::Component::IRC consists of a POE::Session that manages the IRC connection\nand dispatches C<irc_> prefixed events to interested sessions and\nan object that can be used to access additional information using methods.\n\nSessions register their interest in receiving C<irc_> events by sending\nL<C<register>|/register> to the component. One would usually do this in\nyour C<_start> handler. Your session will continue to receive events until\nyou L<C<unregister>|/unregister>. The component will continue to stay\naround until you tell it not to with L<C<shutdown>|/shutdown>.\n\nThe L<SYNOPSIS|/SYNOPSIS> demonstrates a fairly basic bot.\n\nSee L<POE::Component::IRC::Cookbook|POE::Component::IRC::Cookbook> for more\nexamples.\n\n=head2 Useful subclasses\n\nIncluded with POE::Component::IRC are a number of useful subclasses. As they\nare subclasses they support all the methods, etc. documented here and have\nadditional methods and quirks which are documented separately:\n\n=over 4\n\n=item * L<POE::Component::IRC::State|POE::Component::IRC::State>\n\nPOE::Component::IRC::State provides all the functionality of POE::Component::IRC\nbut also tracks IRC state entities such as nicks and channels.\n\n=item * L<POE::Component::IRC::Qnet|POE::Component::IRC::Qnet>\n\nPOE::Component::IRC::Qnet is POE::Component::IRC tweaked for use on Quakenet IRC\nnetwork.\n\n=item * L<POE::Component::IRC::Qnet::State|POE::Component::IRC::Qnet::State>\n\nPOE::Component::IRC::Qnet::State is a tweaked version of POE::Component::IRC::State\nfor use on the Quakenet IRC network.\n\n=back\n\n=head2 The Plugin system\n\nAs of 3.7, PoCo-IRC sports a plugin system. The documentation for it can be\nread by looking at L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>.\nThat is not a subclass, just a placeholder for documentation!\n\nA number of useful plugins have made their way into the core distribution:\n\n=over 4\n\n=item * L<POE::Component::IRC::Plugin::DCC|POE::Component::IRC::Plugin::DCC>\n\nProvides DCC support. Loaded by default.\n\n=item * L<POE::Component::IRC::Plugin::AutoJoin|POE::Component::IRC::Plugin::AutoJoin>\n\nKeeps you on your favorite channels throughout reconnects and even kicks.\n\n=item * L<POE::Component::IRC::Plugin::Connector|POE::Component::IRC::Plugin::Connector>\n\nGlues an irc bot to an IRC network, i.e. deals with maintaining ircd connections.\n\n=item * L<POE::Component::IRC::Plugin::BotTraffic|POE::Component::IRC::Plugin::BotTraffic>\n\nUnder normal circumstances irc bots do not normal the msgs and public msgs that\nthey generate themselves. This plugin enables you to handle those events.\n\n=item * L<POE::Component::IRC::Plugin::BotAddressed|POE::Component::IRC::Plugin::BotAddressed>\n\nGenerates C<irc_bot_addressed> / C<irc_bot_mentioned> / C<irc_bot_mentioned_action>\nevents whenever your bot's name comes up in channel discussion.\n\n=item * L<POE::Component::IRC::Plugin::BotCommand|POE::Component::IRC::Plugin::BotCommand>\n\nProvides an easy way to handle commands issued to your bot.\n\n=item * L<POE::Component::IRC::Plugin::Console|POE::Component::IRC::Plugin::Console>\n\nSee inside the component. See what events are being sent. Generate irc commands\nmanually. A TCP based console.\n\n=item * L<POE::Component::IRC::Plugin::FollowTail|POE::Component::IRC::Plugin::FollowTail>\n\nFollow the tail of an ever-growing file.\n\n=item * L<POE::Component::IRC::Plugin::Logger|POE::Component::IRC::Plugin::Logger>\n\nLog public and private messages to disk.\n\n=item * L<POE::Component::IRC::Plugin::NickServID|POE::Component::IRC::Plugin::NickServID>\n\nIdentify with NickServ when needed.\n\n=item * L<POE::Component::IRC::Plugin::Proxy|POE::Component::IRC::Plugin::Proxy>\n\nA lightweight IRC proxy/bouncer.\n\n=item * L<POE::Component::IRC::Plugin::CTCP|POE::Component::IRC::Plugin::CTCP>\n\nAutomagically generates replies to ctcp version, time and userinfo queries.\n\n=item * L<POE::Component::IRC::Plugin::PlugMan|POE::Component::IRC::Plugin::PlugMan>\n\nAn experimental Plug", 8192) = 8192
09:01:57.332185 read(6, "in Manager plugin.\n\n=item * L<POE::Component::IRC::Plugin::NickReclaim|POE::Component::IRC::Plugin::NickReclaim>\n\nAutomagically deals with your nickname being in use and reclaiming it.\n\n=item * L<POE::Component::IRC::Plugin::CycleEmpty|POE::Component::IRC::Plugin::CycleEmpty>\n\nCycles (parts and rejoins) channels if they become empty and opless, in order\nto gain ops.\n\n=back\n\n=head1 CONSTRUCTORS\n\nBoth constructors return an object. The object is also available within 'irc_'\nevent handlers by using C<< $_[SENDER]->get_heap() >>. See also\nL<C<register>|/register> and L<C<irc_registered>|/irc_registered>.\n\n=head2 C<spawn>\n\nTakes a number of arguments, all of which are optional. All the options\nbelow may be supplied to the L<C<connect>|/connect> input event as well,\nexcept for B<'alias'>, B<'options'>, B<'NoDNS'>, B<'debug'>, and\nB<'plugin_debug'>.\n\n=over 4\n\n=item * B<'alias'>, a name (kernel alias) that this instance will be known\nby;\n\n=item * B<'options'>, a hashref containing L<POE::Session|POE::Session>\noptions;\n\n=item * B<'Server'>, the server name;\n\n=item * B<'Port'>, the remote port number;\n\n=item * B<'Password'>, an optional password for restricted servers;\n\n=item * B<'Nick'>, your client's IRC nickname;\n\n=item * B<'Username'>, your client's username;\n\n=item * B<'Ircname'>, some cute comment or something.\n\n=item * B<'Bitmode'>, an integer representing your initial user modes set\nin the USER command. See RFC 2812. If you do not set this, C<8> (+i) will\nbe used.\n\n=item *  B<'UseSSL'>, set to some true value if you want to connect using\nSSL.\n\n=item *  B<'SSLCert'>, set to a SSL Certificate(PAM encoded) to connect using a client cert\n\n=item *  B<'SSLKey'>, set to a SSL Key(PAM encoded) to connect using a client cert\n\n=item *  B<'SSLCtx'>, set to a SSL Context to configure the SSL Connection\n\nThe B<'SSLCert'> and B<'SSLKey'> both need to be specified. The B<'SSLCtx'> takes precedence specified.\n\n=item * B<'Raw'>, set to some true value to enable the component to send\nL<C<irc_raw>|/irc_raw> and L<C<irc_raw_out>|/irc_raw_out> events.\n\n=item * B<'LocalAddr'>, which local IP address on a multihomed box to\nconnect as;\n\n=item * B<'LocalPort'>, the local TCP port to open your socket on;\n\n=item * B<'NoDNS'>, set this to 1 to disable DNS lookups using\nPoCo-Client-DNS. (See note below).\n\n=item * B<'Flood'>, when true, it disables the component's flood\nprotection algorithms, allowing it to send messages to an IRC server at\nfull speed. Disconnects and k-lines are some common side effects of\nflooding IRC servers, so care should be used when enabling this option.\nDefault is false.\n\nTwo new attributes are B<'Proxy'> and B<'ProxyPort'> for sending your\n=item * B<'Proxy'>, IP address or server name of a proxy server to use.\n\n=item * B<'ProxyPort'>, which tcp port on the proxy to connect to.\n\n=item * B<'NATAddr'>, what other clients see as your IP address.\n\n=item * B<'DCCPorts'>, an arrayref containing tcp ports that can be used\nfor DCC sends.\n\n=item * B<'Resolver'>, provide a L<POE::Component::Client::DNS|POE::Component::Client::DNS> object for the component to use.\n\n=item * B<'msg_length'>, the maximum length of IRC messages, in bytes.\nDefault is 450. The IRC component shortens all messages longer than this\nvalue minus the length of your current nickname. IRC only allows raw\nprotocol lines messages that are 512 bytes or shorter, including the\ntrailing \"\\r\\n\". This is most relevant to long PRIVMSGs. The IRC component\ncan't be sure how long your user@host mask will be every time you send a\nmessage, considering that most networks mangle the 'user' part and some\neven replace the whole string (think FreeNode cloaks). If you have an\nunusually long user@host mask you might want to decrease this value if\nyou're prone to sending long messages. Conversely, if you have an\nunusually short one, you can increase this value if you want to be able to\nsend as long a message as possible. Be careful though, increase it too\nmuch and the IRC server might disconnect you with a \"Request too long\"\nmessage when you try to send a message that's too long.\n\n=item * B<'debug'>, if set to a true value causes the IRC component to\nprint every message sent to and from the server, as well as print some\nwarnings when it receives malformed messages. This option will be enabled\nif the C<POCOIRC_DEBUG> environment variable is set to a true value.\n\n=item * B<'plugin_debug'>, set to some true value to print plugin debug\ninfo, default 0. Plugins are processed inside an eval. When you enable\nthis option, you will be notified when (and why) a plugin raises an\nexception. This option will be enabled if the C<POCOIRC_DEBUG> environment\nvariable is set to a true value.\n\n=item * B<'socks_proxy'>, specify a SOCKS4/SOCKS4a proxy to use.\n\n=item * B<'socks_port'>, the SOCKS port to use, defaults to 1080 if not\nspecified.\n\n=item * B<'socks_id'>, specify a SOCKS user_id. Default is none.\n\n=item * B<'useipv6'>, enable the use of IPv6 for connections.\n\n=back\n\nC<spawn> will supply reasonable defaults for any of these attributes\nwhich are missing, so don't feel obliged to write them all out.\n\nIf the component finds that L<POE::Component::Client::DNS|POE::Component::Client::DNS>\nis installed it will use that to resolve the server name passed. Disable\nthis behaviour if you like, by passing: C<< NoDNS => 1 >>.\n\nIRC traffic through a proxy server. B<'Proxy'>'s value should be the IP\naddress or server name of the proxy. B<'ProxyPort'>'s value should be the\nport on the proxy to connect to. L<C<connect>|/connect> will default\nto using the I<actual> IRC server's port if you provide a proxy but omit\nthe proxy's port. These are for HTTP Proxies. See B<'socks_proxy'> for\nSOCKS4 and SOCKS4a support.\n\nFor those people who run bots behind firewalls and/or Network Address\nTranslation there are two additional attributes for DCC. B<'DCCPorts'>,\nis an arrayref of ports to use when initiating DCC connections.\nB<'NATAddr'>, is the NAT'ed IP address that your bot is hidden behind,\nthis is sent whenever you do DCC.\n\nSSL support requires L<POE::Component::SSLify|POE::Component::SSLify>, as\nwell as an IRC server that supports SSL connections. If you're missing\nPOE::Component::SSLify, specifying B<'UseSSL'> will do nothing. The\ndefault is to not try to use SSL.\n\nB<'Resolver'>, requires a L<POE::Component::Client::DNS|POE::Component::Client::DNS>\nobject. Useful when spawning multiple poco-irc sessions, saves the\noverhead of multiple dns sessions.\n\nB<'NoDNS'> has different results depending on whether it is set with\nL<C<spawn>|/spawn> or L<C<connect>|/connect>. Setting it with\nC<spawn>, disables the creation of the POE::Component::Client::DNS\ncompletely. Setting it with L<C<connect>|/connect> on the other hand\nallows the PoCo-Client-DNS session to be spawned, but will disable\nany dns lookups using it.\n\nSOCKS4 proxy support is provided by B<'socks_proxy'>, B<'socks_port'> and\nB<'socks_id'> parameters. If something goes wrong with the SOCKS connection\nyou should get a warning on STDERR. This is fairly experimental currently.\n\nIPv6 support is available for connecting to IPv6 enabled ircds (it won't\nwork for DCC though). To enable it, specify B<'useipv6'>. Perl >=5.14 or\nL<Socket6|Socket6> (for older Perls) is required. If you that and\nL<POE::Component::Client::DNS|POE::Component::Client::DNS> installed and\nspecify a hostname that resolves to an IPv6 address then IPv6 will be used.\nIf you specify an ipv6 B<'localaddr'> then IPv6 will be used.\n\n=head2 C<new>\n\nThis method is deprecated. See the L<C<spawn>|/spawn> method instead.\nThe first argument should be a name (kernel alias) which this new\nconnection will be known by. Optionally takes more arguments (see\nL<C<spawn>|/spawn> as name/value pairs. Returns a POE::Component::IRC\nobject. :)\n\nB<Note:> Use of this method will generate a warning. There are currently no\nplans to make it die() >;]\n\n=head1 METHODS\n\n=head2 Information\n\n=head3 C<server>\n\nTakes no arguments. Returns the server host we are currently connected to\n(or trying to connect to).\n\n=head3 C<port>\n\nTakes no arguments. Returns the server port we are currently connected to\n(or trying to connect to).\n\n=head3 C<server_name>\n\nTakes no arg", 8192) = 8192
09:01:57.332609 read(6, "uments. Returns the name of the IRC server that the component\nis currently connected to.\n\n=head3 C<server_version>\n\nTakes no arguments. Returns the IRC server version.\n\n=head3 C<nick_name>\n\nTakes no arguments. Returns a scalar containing the current nickname that the\nbot is using.\n\n=head3 C<localaddr>\n\nTakes no arguments. Returns the IP address being used.\n\n=head3 C<send_queue>\n\nThe component provides anti-flood throttling. This method takes no arguments\nand returns a scalar representing the number of messages that are queued up\nwaiting for dispatch to the irc server.\n\n=head3 C<logged_in>\n\nTakes no arguments. Returns true or false depending on whether the IRC\ncomponent is logged into an IRC network.\n\n=head3 C<connected>\n\nTakes no arguments. Returns true or false depending on whether the component's\nsocket is currently connected.\n\n=head3 C<disconnect>\n\nTakes no arguments. Terminates the socket connection disgracefully >;o]\n\n=head3 C<isupport>\n\nTakes one argument, a server capability to query. Returns C<undef> on failure\nor a value representing the applicable capability. A full list of capabilities\nis available at L<http://www.irc.org/tech_docs/005.html>.\n\n=head3 C<isupport_dump_keys>\n\nTakes no arguments, returns a list of the available server capabilities keys,\nwhich can be used with L<C<isupport>|/isupport>.\n\n=head3 C<resolver>\n\nReturns a reference to the L<POE::Component::Client::DNS|POE::Component::Client::DNS>\nobject that is internally created by the component.\n\n=head2 Events\n\n=head3 C<session_id>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/session_id>>\n\nTakes no arguments. Returns the ID of the component's session. Ideal for posting\nevents to the component.\n\n $kernel->post($irc->session_id() => 'mode' => $channel => '+o' => $dude);\n\n=head3 C<session_alias>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/session_alias>>\n\nTakes no arguments. Returns the session alias that has been set through\nL<C<spawn>|/spawn>'s B<'alias'> argument.\n\n=head3 C<raw_events>\n\nWith no arguments, returns true or false depending on whether\nL<C<irc_raw>|/irc_raw> and L<C<irc_raw_out>|/irc_raw_out> events are being generated\nor not. Provide a true or false argument to enable or disable this feature\naccordingly.\n\n=head3 C<yield>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/yield>>\n\nThis method provides an alternative object based means of posting events to the\ncomponent. First argument is the event to post, following arguments are sent as\narguments to the resultant post.\n\n $irc->yield(mode => $channel => '+o' => $dude);\n\n=head3 C<call>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/call>>\n\nThis method provides an alternative object based means of calling events to the\ncomponent. First argument is the event to call, following arguments are sent as\narguments to the resultant\ncall.\n\n $irc->call(mode => $channel => '+o' => $dude);\n\n=head3 C<delay>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/delay>>\n\nThis method provides a way of posting delayed events to the component. The\nfirst argument is an arrayref consisting of the delayed command to post and\nany command arguments. The second argument is the time in seconds that one\nwishes to delay the command being posted.\n\n my $alarm_id = $irc->delay( [ mode => $channel => '+o' => $dude ], 60 );\n\nReturns an alarm ID that can be used with L<C<delay_remove>|/delay_remove>\nto cancel the delayed event. This will be undefined if something went wrong.\n\n=head3 C<delay_remove>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/delay_remove>>\n\nThis method removes a previously scheduled delayed event from the component.\nTakes one argument, the C<alarm_id> that was returned by a\nL<C<delay>|/delay> method call.\n\n my $arrayref = $irc->delay_remove( $alarm_id );\n\nReturns an arrayref that was originally requested to be delayed.\n\n=head3 C<send_event>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event>>\n\nSends an event through the component's event handling system. These will get\nprocessed by plugins then by registered sessions. First argument is the event\nname, followed by any parameters for that event.\n\n=head3 C<send_event_next>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event_next>>\n\nThis sends an event right after the one that's currently being processed.\nUseful if you want to generate some event which is directly related to\nanother event so you want them to appear together. This method can only be\ncalled when POE::Component::IRC is processing an event, e.g. from one of your\nevent handlers. Takes the same arguments as L<C<send_event>|/send_event>.\n\n=head3 C<send_event_now>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event_now>>\n\nThis will send an event to be processed immediately. This means that if an\nevent is currently being processed and there are plugins or sessions which\nwill receive it after you do, then an event sent with C<send_event_now> will\nbe received by those plugins/sessions I<before> the current event. Takes the\nsame arguments as L<C<send_event>|/send_event>.\n\n=head2 Plugins\n\n=head3 C<pipeline>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/pipeline>>\n\nReturns the L<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>\nobject.\n\n=head3 C<plugin_add>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_add>>\n\nAccepts two arguments:\n\n The alias for the plugin\n The actual plugin object\n Any number of extra arguments\n\nThe alias is there for the user to refer to it, as it is possible to have\nmultiple plugins of the same kind active in one Object::Pluggable object.\n\nThis method goes through the pipeline's C<push()> method, which will call\nC<< $plugin->plugin_register($pluggable, @args) >>.\n\nReturns the number of plugins now in the pipeline if plugin was initialized,\nC<undef>/an empty list if not.\n\n=head3 C<plugin_del>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_del>>\n\nAccepts the following arguments:\n\n The alias for the plugin or the plugin object itself\n Any number of extra arguments\n\nThis method goes through the pipeline's C<remove()> method, which will call\nC<< $plugin->plugin_unregister($pluggable, @args) >>.\n\nReturns the plugin object if the plugin was removed, C<undef>/an empty list\nif not.\n\n=head3 C<plugin_get>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_get>>\n\nAccepts the following arguments:\n\n The alias for the plugin\n\nThis method goes through the pipeline's C<get()> method.\n\nReturns the plugin object if it was found, C<undef>/an empty list if not.\n\n=head3 C<plugin_list>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_list>>\n\nTakes no arguments.\n\nReturns a hashref of plugin objects, keyed on alias, or an empty list if\nthere are no plugins loaded.\n\n=head3 C<plugin_order>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_order>>\n\nTakes no arguments.\n\nReturns an arrayref of plugin objects, in the order which they are\nencountered in the pipeline.\n\n=head3 C<plugin_register>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_register>>\n\nAccepts the following arguments:\n\n The plugin object\n The type of the hook (the hook types are specified with _pluggable_init()'s 'types')\n The event name[s] to watch\n\nThe event names can be as many as possible, or an arrayref. They correspond\nto the prefixed events and naturally, arbitrary events too.\n\nYou do not need to supply events with the prefix in front of them, just the\nnames.\n\nIt is possible to register for all events by specifying 'all' as an event.\n\nReturns 1 if everything checked out fine, C<undef>/an empty list if something\nis seriously wrong.\n\n=head3 C<plugin_unregister>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_unregister>>\n\nAccepts the following arguments:\n\n The plugin object\n The type of the hook (the hook types are specified with _pluggable_init()'s 'types')\n The event name[s] to unwatch\n\nThe event names can be as many as possible, or an arrayref. They correspond\nto the prefixed events and na", 8192) = 8192
09:01:57.333033 read(6, "turally, arbitrary events too.\n\nYou do not need to supply events with the prefix in front of them, just the\nnames.\n\nIt is possible to register for all events by specifying 'all' as an event.\n\nReturns 1 if all the event name[s] was unregistered, undef if some was not\nfound.\n\n=head1 INPUT EVENTS\n\nHow to talk to your new IRC component... here's the events we'll accept.\nThese are events that are posted to the component, either via\nC<< $poe_kernel->post() >> or via the object method L<C<yield>|/yield>.\n\nSo the following would be functionally equivalent:\n\n sub irc_001 {\n     my ($kernel,$sender) = @_[KERNEL,SENDER];\n     my $irc = $sender->get_heap(); # obtain the poco's object\n\n     $irc->yield( privmsg => 'foo' => 'Howdy!' );\n     $kernel->post( $sender => privmsg => 'foo' => 'Howdy!' );\n     $kernel->post( $irc->session_id() => privmsg => 'foo' => 'Howdy!' );\n     $kernel->post( $irc->session_alias() => privmsg => 'foo' => 'Howdy!' );\n\n     return;\n }\n\n=head2 Important Commands\n\n=head3 C<register>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/register>>\n\nTakes N arguments: a list of event names that your session wants to\nlisten for, minus the C<irc_> prefix. So, for instance, if you just\nwant a bot that keeps track of which people are on a channel, you'll\nneed to listen for JOINs, PARTs, QUITs, and KICKs to people on the\nchannel you're in. You'd tell POE::Component::IRC that you want those\nevents by saying this:\n\n $kernel->post('my client', 'register', qw(join part quit kick));\n\nThen, whenever people enter or leave a channel your bot is on (forcibly\nor not), your session will receive events with names like\nL<C<irc_join>|/irc_join>, L<C<irc_kick>|/irc_kick>, etc.,\nwhich you can use to update a list of people on the channel.\n\nRegistering for B<'all'> will cause it to send all IRC-related events to\nyou; this is the easiest way to handle it. See the test script for an\nexample.\n\nRegistering will generate an L<C<irc_registered>|/irc_registered>\nevent that your session can trap. C<ARG0> is the components object. Useful\nif you want to bolt PoCo-IRC's new features such as Plugins into a bot\ncoded to the older deprecated API. If you are using the new API, ignore this :)\n\nRegistering with multiple component sessions can be tricky, especially if\none wants to marry up sessions/objects, etc. Check the L<SIGNALS|/SIGNALS>\nsection for an alternative method of registering with multiple poco-ircs.\n\nStarting with version 4.96, if you spawn the component from inside another POE\nsession, the component will automatically register that session as wanting\nB<'all'> irc events. That session will receive an\nL<C<irc_registered>|/irc_registered> event indicating that the component\nis up and ready to go.\n\n=head3 C<unregister>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/unregister>>\n\nTakes N arguments: a list of event names which you I<don't> want to\nreceive. If you've previously done a L<C<register>|/register>\nfor a particular event which you no longer care about, this event will\ntell the IRC connection to stop sending them to you. (If you haven't, it just\nignores you. No big deal.)\n\nIf you have registered with 'all', attempting to unregister individual\nevents such as 'mode', etc. will not work. This is a 'feature'.\n\n=head3 C<connect>\n\nTakes one argument: a hash reference of attributes for the new connection,\nsee L<C<spawn>|/spawn> for details. This event tells the IRC client to\nconnect to a new/different server. If it has a connection already open, it'll\nclose it gracefully before reconnecting.\n\n=head3 C<ctcp> and C<ctcpreply>\n\nSends a CTCP query or response to the nick(s) or channel(s) which you\nspecify. Takes 2 arguments: the nick or channel to send a message to\n(use an array reference here to specify multiple recipients), and the\nplain text of the message to send (the CTCP quoting will be handled\nfor you). The \"/me\" command in popular IRC clients is actually a CTCP action.\n\n # Doing a /me\n $irc->yield(ctcp => $channel => 'ACTION dances.');\n\n=head3 C<join>\n\nTells your IRC client to join a single channel of your choice. Takes\nat least one arg: the channel name (required) and the channel key\n(optional, for password-protected channels).\n\n=head3 C<kick>\n\nTell the IRC server to forcibly evict a user from a particular\nchannel. Takes at least 2 arguments: a channel name, the nick of the\nuser to boot, and an optional witty message to show them as they sail\nout the door.\n\n=head3 C<remove>\n\nTell the IRC server to forcibly evict a user from a particular\nchannel. Takes at least 2 arguments: a channel name, the nick of the\nuser to boot, and an optional witty message to show them as they sail\nout the door. Similar to KICK but does an enforced PART instead. Not\nsupported by all servers.\n\n=head3 C<mode>\n\nRequest a mode change on a particular channel or user. Takes at least\none argument: the mode changes to effect, as a single string (e.g.\n\"#mychan +sm-p+o\"), and any number of optional operands to the mode changes\n(nicks, hostmasks, channel keys, whatever.) Or just pass them all as one\nbig string and it'll still work, whatever. I regret that I haven't the\npatience now to write a detailed explanation, but serious IRC users know\nthe details anyhow.\n\n=head3 C<nick>\n\nAllows you to change your nickname. Takes exactly one argument: the\nnew username that you'd like to be known as.\n\n=head3 C<nickserv>\n\nTalks to NickServ, on networks which have it. Takes any number of\narguments.\n\n=head3 C<notice>\n\nSends a NOTICE message to the nick(s) or channel(s) which you\nspecify. Takes 2 arguments: the nick or channel to send a notice to\n(use an array reference here to specify multiple recipients), and the\ntext of the notice to send.\n\n=head3 C<part>\n\nTell your IRC client to leave the channels which you pass to it. Takes\nany number of arguments: channel names to depart from. If the last argument\ndoesn't begin with a channel name identifier or contains a space character,\nit will be treated as a PART message and dealt with accordingly.\n\n=head3 C<privmsg>\n\nSends a public or private message to the nick(s) or channel(s) which\nyou specify. Takes 2 arguments: the nick or channel to send a message\nto (use an array reference here to specify multiple recipients), and\nthe text of the message to send.\n\nHave a look at the constants in L<IRC::Utils|IRC::Utils> if you would\nlike to use formatting and color codes in your messages.\n\n $irc->yield('primvsg', '#mychannel', 'Hello there');\n\n # same, but with a green Hello\n use IRC::Utils qw(GREEN NORMAL);\n $irc->yield('primvsg', '#mychannel', GREEN.'Hello'.NORMAL.' there');\n\n=head3 C<quit>\n\nTells the IRC server to disconnect you. Takes one optional argument:\nsome clever, witty string that other users in your channels will see\nas you leave. You can expect to get an\nL<C<irc_disconnected>|/irc_disconnected> event shortly after sending this.\n\n=head3 C<shutdown>\n\nBy default, POE::Component::IRC sessions never go away. Even after\nthey're disconnected, they're still sitting around in the background,\nwaiting for you to call L<C<connect>|/connect> on them again to\nreconnect. (Whether this behavior is the Right Thing is doubtful, but I\ndon't want to break backwards compatibility at this point.) You can send\nthe IRC session a C<shutdown> event manually to make it delete itself.\n\nIf you are logged into an IRC server, C<shutdown> first will send a quit\nmessage and wait to be disconnected. It will wait for up to 5 seconds before\nforcibly disconnecting from the IRC server. If you provide an argument, that\nwill be used as the QUIT message. If you provide two arguments, the second\none will be used as the timeout (in seconds).\n\nTerminating multiple components can be tricky. Check the L<SIGNALS|/SIGNALS>\nsection for a method of shutting down multiple poco-ircs.\n\n=head3 C<topic>\n\nRetrieves or sets the topic for particular channel. If called with just\nthe channel name as an argument, it will ask the server to return the\ncurrent topic. If called with the channel name and a string, it will\nset the channel topic to that string. Supply an empty string to unset a\nchannel topic.\n\n=head3 C<debug>\n\nTakes one argument: 0 to turn debugging off or 1 ", 8192) = 8192
09:01:57.333459 read(6, "to turn debugging on.\nThis flips the debugging flag in L<POE::Filter::IRCD|POE::Filter::IRCD>,\nL<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat>, and\nPOE::Component::IRC. This has the same effect as setting Debug in\nL<C<spawn>|/spawn> or L<C<connect>|/connect>.\n\n=head2 Not-So-Important Commands\n\n=head3 C<admin>\n\nAsks your server who your friendly neighborhood server administrators\nare. If you prefer, you can pass it a server name to query, instead of\nasking the server you're currently on.\n\n=head3 C<away>\n\nWhen sent with an argument (a message describig where you went), the\nserver will note that you're now away from your machine or otherwise\npreoccupied, and pass your message along to anyone who tries to\ncommunicate with you. When sent without arguments, it tells the server\nthat you're back and paying attention.\n\n=head3 C<cap>\n\nUsed to query/enable/disable IRC protocol capabilities. Takes any number of\narguments.\n\n=head3 C<dcc*>\n\nSee the L<DCC plugin|POE::Component::IRC::Plugin/COMMANDS> (loaded by default)\ndocumentation for DCC-related commands.\n\n=head3 C<info>\n\nBasically the same as the L<C<version>|/version> command, except that the\nserver is permitted to return any information about itself that it thinks is\nrelevant. There's some nice, specific standards-writing for ya, eh?\n\n=head3 C<invite>\n\nInvites another user onto an invite-only channel. Takes 2 arguments:\nthe nick of the user you wish to admit, and the name of the channel to\ninvite them to.\n\n=head3 C<ison>\n\nAsks the IRC server which users out of a list of nicknames are\ncurrently online. Takes any number of arguments: a list of nicknames\nto query the IRC server about.\n\n=head3 C<links>\n\nAsks the server for a list of servers connected to the IRC\nnetwork. Takes two optional arguments, which I'm too lazy to document\nhere, so all you would-be linklooker writers should probably go dig up\nthe RFC.\n\n=head3 C<list>\n\nAsks the server for a list of visible channels and their topics. Takes\nany number of optional arguments: names of channels to get topic\ninformation for. If called without any channel names, it'll list every\nvisible channel on the IRC network. This is usually a really big list,\nso don't do this often.\n\n=head3 C<motd>\n\nRequest the server's \"Message of the Day\", a document which typically\ncontains stuff like the server's acceptable use policy and admin\ncontact email addresses, et cetera. Normally you'll automatically\nreceive this when you log into a server, but if you want it again,\nhere's how to do it. If you'd like to get the MOTD for a server other\nthan the one you're logged into, pass it the server's hostname as an\nargument; otherwise, no arguments.\n\n=head3 C<names>\n\nAsks the server for a list of nicknames on particular channels. Takes\nany number of arguments: names of channels to get lists of users\nfor. If called without any channel names, it'll tell you the nicks of\neveryone on the IRC network. This is a really big list, so don't do\nthis much.\n\n=head3 C<quote>\n\nSends a raw line of text to the server. Takes one argument: a string\nof a raw IRC command to send to the server. It is more optimal to use\nthe events this module supplies instead of writing raw IRC commands\nyourself.\n\n=head3 C<stats>\n\nReturns some information about a server. Kinda complicated and not\nterribly commonly used, so look it up in the RFC if you're\ncurious. Takes as many arguments as you please.\n\n=head3 C<time>\n\nAsks the server what time it thinks it is, which it will return in a\nhuman-readable form. Takes one optional argument: a server name to\nquery. If not supplied, defaults to current server.\n\n=head3 C<trace>\n\nIf you pass a server name or nick along with this request, it asks the\nserver for the list of servers in between you and the thing you\nmentioned. If sent with no arguments, it will show you all the servers\nwhich are connected to your current server.\n\n=head3 C<users>\n\nAsks the server how many users are logged into it. Defaults to the\nserver you're currently logged into; however, you can pass a server\nname as the first argument to query some other machine instead.\n\n=head3 C<version>\n\nAsks the server about the version of ircd that it's running. Takes one\noptional argument: a server name to query. If not supplied, defaults\nto current server.\n\n=head3 C<who>\n\nLists the logged-on users matching a particular channel name, hostname,\nnickname, or what-have-you. Takes one optional argument: a string for\nit to search for. Wildcards are allowed; in the absence of this\nargument, it will return everyone who's currently logged in (bad\nmove). Tack an \"o\" on the end if you want to list only IRCops, as per\nthe RFC.\n\n=head3 C<whois>\n\nQueries the IRC server for detailed information about a particular\nuser. Takes any number of arguments: nicknames or hostmasks to ask for\ninformation about. As of version 3.2, you will receive an\nL<C<irc_whois>|/irc_whois> event in addition to the usual numeric\nresponses. See below for details.\n\n=head3 C<whowas>\n\nAsks the server for information about nickname which is no longer\nconnected. Takes at least one argument: a nickname to look up (no\nwildcards allowed), the optional maximum number of history entries to\nreturn, and the optional server hostname to query. As of version 3.2,\nyou will receive an L<C<irc_whowas>|/irc_whowas> event in addition\nto the usual numeric responses. See below for details.\n\n=head3 C<ping> and C<pong>\n\nIncluded for completeness sake. The component will deal with ponging to\npings automatically. Don't worry about it.\n\n=head2 Purely Esoteric Commands\n\n=head3 C<die>\n\nTells the IRC server you're connect to, to terminate. Only useful for\nIRCops, thank goodness. Takes no arguments.\n\n=head3 C<locops>\n\nOpers-only command. This one sends a message to all currently\nlogged-on local-opers (+l). This option is specific to EFNet.\n\n=head3 C<oper>\n\nIn the exceedingly unlikely event that you happen to be an IRC\noperator, you can use this command to authenticate with your IRC\nserver. Takes 2 arguments: your username and your password.\n\n=head3 C<operwall>\n\nOpers-only command. This one sends a message to all currently\nlogged-on global opers. This option is specific to EFNet.\n\n=head3 C<rehash>\n\nTells the IRC server you're connected to, to rehash its configuration\nfiles. Only useful for IRCops. Takes no arguments.\n\n=head3 C<restart>\n\nTells the IRC server you're connected to, to shut down and restart itself.\nOnly useful for IRCops, thank goodness. Takes no arguments.\n\n=head3 C<sconnect>\n\nTells one IRC server (which you have operator status on) to connect to\nanother. This is actually the CONNECT command, but I already had an\nevent called L<C<connect>|/connect>, so too bad. Takes the args\nyou'd expect: a server to connect to, an optional port to connect on,\nand an optional remote server to connect with, instead of the one you're\ncurrently on.\n\n=head3 C<squit>\n\nOperator-only command used to disconnect server links. Takes two arguments,\nthe server to disconnect and a message explaining your action.\n\n=head3 C<summon>\n\nDon't even ask.\n\n=head3 C<servlist>\n\nLists the currently connected services on the network that are visible to you.\nTakes two optional arguments, a mask for matching service names against, and\na service type.\n\n=head3 C<squery>\n\nSends a message to a service. Takes the same arguments as\nL<C<privmsg>|/privmsg>.\n\n=head3 C<userhost>\n\nAsks the IRC server for information about particular nicknames. (The\nRFC doesn't define exactly what this is supposed to return.) Takes any\nnumber of arguments: the nicknames to look up.\n\n=head3 C<wallops>\n\nAnother opers-only command. This one sends a message to all currently\nlogged-on opers (and +w users); sort of a mass PA system for the IRC\nserver administrators. Takes one argument: some clever, witty message\nto send.\n\n=head1 OUTPUT EVENTS\n\nThe events you will receive (or can ask to receive) from your running\nIRC component. Note that all incoming event names your session will\nreceive are prefixed by C<irc_>, to inhibit event namespace pollution.\n\nIf you wish, you can ask the client to send you every event it\ngenerates. Simply register for the event name \"all\". This is a lot\neasier than writing a huge list of things you specifically want to\nlisten", 8192) = 8192
09:01:57.333877 read(6, " for.\n\nFIXME: I'd really like to classify these somewhat (\"basic\", \"oper\", \"ctcp\",\n\"dcc\", \"raw\" or some such), and I'd welcome suggestions for ways to make\nthis easier on the user, if you can think of some.\n\nIn your event handlers, C<$_[SENDER]> is the particular component session that\nsent you the event. C<< $_[SENDER]->get_heap() >> will retrieve the component's\nobject. Useful if you want on-the-fly access to the object and its methods.\n\n=head2 Important Events\n\n=head3 C<irc_registered>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_registered>>\n\nSent once to the requesting session on registration (see\nL<C<register>|/register>). C<ARG0> is a reference tothe component's object.\n\n=head3 C<irc_shutdown>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_shutdown>>\n\nSent to all registered sessions when the component has been asked to\nL<C<shutdown>|/shutdown>. C<ARG0> will be the session ID of the requesting\nsession.\n\n=head3 C<irc_connected>\n\nThe IRC component will send an C<irc_connected> event as soon as it\nestablishes a connection to an IRC server, before attempting to log\nin. C<ARG0> is the server name.\n\nB<NOTE:> When you get an C<irc_connected> event, this doesn't mean you\ncan start sending commands to the server yet. Wait until you receive\nan L<C<irc_001>|/All numeric events> event (the server welcome message)\nbefore actually sending anything back to the server.\n\n=head3 C<irc_ctcp>\n\nC<irc_ctcp> events are generated upon receipt of CTCP messages, in addition to\nthe C<irc_ctcp_*> events mentioned below. They are identical in every way to\nthese, with one difference: instead of the * being in the method name, it\nis prepended to the argument list. For example, if someone types C</ctcp\nFlibble foo bar>, an C<irc_ctcp> event will be sent with B<'foo'> as C<ARG0>,\nand the rest as given below.\n\nIt is not recommended that you register for both C<irc_ctcp> and C<irc_ctcp_*>\nevents, since they will both be fired and presumably cause duplication.\n\n=head3 C<irc_ctcp_*>\n\nC<irc_ctcp_whatever> events are generated upon receipt of CTCP messages.\nFor instance, receiving a CTCP PING request generates an C<irc_ctcp_ping>\nevent, CTCP ACTION (produced by typing \"/me\" in most IRC clients)\ngenerates an C<irc_ctcp_action> event, blah blah, so on and so forth. C<ARG0>\nis the nick!hostmask of the sender. C<ARG1> is the channel/recipient\nname(s). C<ARG2> is the text of the CTCP message. On servers supporting the\nIDENTIFY-MSG feature (e.g. FreeNode), CTCP ACTIONs will have C<ARG3>, which\nwill be C<1> if the sender has identified with NickServ, C<0> otherwise.\n\nNote that DCCs are handled separately -- see the\nL<DCC plugin|POE::Component::IRC::Plugin::DCC>.\n\n=head3 C<irc_ctcpreply_*>\n\nC<irc_ctcpreply_whatever> messages are just like C<irc_ctcp_whatever>\nmessages, described above, except that they're generated when a response\nto one of your CTCP queries comes back. They have the same arguments and\nsuch as C<irc_ctcp_*> events.\n\n=head3 C<irc_disconnected>\n\nThe counterpart to L<C<irc_connected>|/irc_connected>, sent whenever\na socket connection to an IRC server closes down (whether intentionally or\nunintentionally). C<ARG0> is the server name.\n\n=head3 C<irc_error>\n\nYou get this whenever the server sends you an ERROR message. Expect\nthis to usually be accompanied by the sudden dropping of your\nconnection. C<ARG0> is the server's explanation of the error.\n\n=head3 C<irc_join>\n\nSent whenever someone joins a channel that you're on. C<ARG0> is the\nperson's nick!hostmask. C<ARG1> is the channel name.\n\n=head3 C<irc_invite>\n\nSent whenever someone offers you an invitation to another channel. C<ARG0>\nis the person's nick!hostmask. C<ARG1> is the name of the channel they want\nyou to join.\n\n=head3 C<irc_kick>\n\nSent whenever someone gets booted off a channel that you're on. C<ARG0>\nis the kicker's nick!hostmask. C<ARG1> is the channel name. C<ARG2> is the\nnick of the unfortunate kickee. C<ARG3> is the explanation string for the\nkick.\n\n=head3 C<irc_mode>\n\nSent whenever someone changes a channel mode in your presence, or when\nyou change your own user mode. C<ARG0> is the nick!hostmask of that\nsomeone. C<ARG1> is the channel it affects (or your nick, if it's a user\nmode change). C<ARG2> is the mode string (i.e., \"+o-b\"). The rest of the\nargs (C<ARG3 .. $#_>) are the operands to the mode string (nicks,\nhostmasks, channel keys, whatever).\n\n=head3 C<irc_msg>\n\nSent whenever you receive a PRIVMSG command that was addressed to you\nprivately. C<ARG0> is the nick!hostmask of the sender. C<ARG1> is an array\nreference containing the nick(s) of the recipients. C<ARG2> is the text\nof the message. On servers supporting the IDENTIFY-MSG feature (e.g.\nFreeNode), there will be an additional argument, C<ARG3>, which will be\nC<1> if the sender has identified with NickServ, C<0> otherwise.\n\n=head3 C<irc_nick>\n\nSent whenever you, or someone around you, changes nicks. C<ARG0> is the\nnick!hostmask of the changer. C<ARG1> is the new nick that they changed\nto.\n\n=head3 C<irc_notice>\n\nSent whenever you receive a NOTICE command. C<ARG0> is the nick!hostmask\nof the sender. C<ARG1> is an array reference containing the nick(s) or\nchannel name(s) of the recipients. C<ARG2> is the text of the NOTICE\nmessage.\n\n=head3 C<irc_part>\n\nSent whenever someone leaves a channel that you're on. C<ARG0> is the\nperson's nick!hostmask. C<ARG1> is the channel name. C<ARG2> is the part\nmessage.\n\n=head3 C<irc_public>\n\nSent whenever you receive a PRIVMSG command that was sent to a channel.\nC<ARG0> is the nick!hostmask of the sender. C<ARG1> is an array\nreference containing the channel name(s) of the recipients. C<ARG2> is the\ntext of the message. On servers supporting the IDENTIFY-MSG feature (e.g.\nFreeNode), there will be an additional argument, C<ARG3>, which will be\nC<1> if the sender has identified with NickServ, C<0> otherwise.\n\n=head3 C<irc_quit>\n\nSent whenever someone on a channel with you quits IRC (or gets\nKILLed). C<ARG0> is the nick!hostmask of the person in question. C<ARG1> is\nthe clever, witty message they left behind on the way out.\n\n=head3 C<irc_socketerr>\n\nSent when a connection couldn't be established to the IRC server. C<ARG0>\nis probably some vague and/or misleading reason for what failed.\n\n=head3 C<irc_topic>\n\nSent when a channel topic is set or unset. C<ARG0> is the nick!hostmask of the\nsender. C<ARG1> is the channel affected. C<ARG2> will be either: a string if the\ntopic is being set; or a zero-length string (i.e. '') if the topic is being\nunset. Note: replies to queries about what a channel topic *is*\n(i.e. TOPIC #channel), are returned as numerics, not with this event.\n\n=head3 C<irc_whois>\n\nSent in response to a WHOIS query. C<ARG0> is a hashref, with the following\nkeys:\n\n=over 4\n\n=item * B<'nick'>, the users nickname;\n\n=item * B<'user'>, the users username;\n\n=item * B<'host'>, their hostname;\n\n=item * B<'real'>, their real name;\n\n=item * B<'idle'>, their idle time in seconds;\n\n=item * B<'signon'>, the epoch time they signed on (will be undef if ircd\ndoes not support this);\n\n=item * B<'channels'>, an arrayref listing visible channels they are on,\nthe channel is prefixed with '@','+','%' depending on whether they have\n+o +v or +h;\n\n=item * B<'server'>, their server (might not be useful on some networks);\n\n=item * B<'oper'>, whether they are an IRCop, contains the IRC operator\nstring if they are, undef if they aren't.\n\n=item * B<'actually'>, some ircds report the user's actual ip address,\nthat'll be here;\n\n=item * B<'identified'>. if the user has identified with NICKSERV\n(ircu, seven, Plexus)\n\n=item * B<'modes'>, a string describing the user's modes (Rizon)\n\n=back\n\n=head3 C<irc_whowas>\n\nSimilar to the above, except some keys will be missing.\n\n=head3 C<irc_raw>\n\nEnabled by passing C<< Raw => 1 >> to L<C<spawn>|/spawn> or\nL<C<connect>|/connect>, or by calling L<C<raw_events>|/raw_events> with\na true argument. C<ARG0> is the raw IRC string received by the component from\nthe IRC server, before it has been mangled by filters and such like.\n\n=head3 C<irc_raw_out>\n\nEnabled by passing C<< Raw => 1 >> to L<C<spawn>|/spawn> or\nL<C<connect>|/connect>, ", 8192) = 8192
09:01:57.334335 read(6, "or by calling L<C<raw_events>|/raw_events> with\na true argument. C<ARG0> is the raw IRC string sent by the component to the\nthe IRC server.\n\n=head3 C<irc_isupport>\n\nEmitted by the first event after an L<C<irc_005>|/All numeric events>, to\nindicate that isupport information has been gathered. C<ARG0> is the\nL<POE::Component::IRC::Plugin::ISupport|POE::Component::IRC::Plugin::ISupport>\nobject.\n\n=head3 C<irc_socks_failed>\n\nEmitted whenever we fail to connect successfully to a SOCKS server or the\nSOCKS server is not actually a SOCKS server. C<ARG0> will be some vague reason\nas to what went wrong. Hopefully.\n\n=head3 C<irc_socks_rejected>\n\nEmitted whenever a SOCKS connection is rejected by a SOCKS server. C<ARG0> is\nthe SOCKS code, C<ARG1> the SOCKS server address, C<ARG2> the SOCKS port and\nC<ARG3> the SOCKS user id (if defined).\n\n=head3 C<irc_plugin_add>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>\n\nEmitted whenever a new plugin is added to the pipeline. C<ARG0> is the\nplugin alias. C<ARG1> is the plugin object.\n\n=head3 C<irc_plugin_del>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>\n\nEmitted whenever a plugin is removed from the pipeline. C<ARG0> is the\nplugin alias. C<ARG1> is the plugin object.\n\n=head3 C<irc_plugin_error>\n\nI<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>\n\nEmitted when an error occurs while executing a plugin handler. C<ARG0> is\nthe error message. C<ARG1> is the plugin alias. C<ARG2> is the plugin object.\n\n=head2 Somewhat Less Important Events\n\n=head3 C<irc_cap>\n\nA reply from the server regarding protocol capabilities. C<ARG0> is the\nCAP subcommand (e.g. 'LS'). C<ARG1> is the result of the subcommand, unless\nthis is a multi-part reply, in which case C<ARG1> is '*' and C<ARG2> contains\nthe result.\n\n=head3 C<irc_dcc_*>\n\nSee the L<DCC plugin|POE::Component::IRC::Plugin/OUTPUT> (loaded by default)\ndocumentation for DCC-related events.\n\n=head3 C<irc_ping>\n\nAn event sent whenever the server sends a PING query to the\nclient. (Don't confuse this with a CTCP PING, which is another beast\nentirely. If unclear, read the RFC.) Note that POE::Component::IRC will\nautomatically take care of sending the PONG response back to the\nserver for you, although you can still register to catch the event for\ninformational purposes.\n\n=head3 C<irc_snotice>\n\nA weird, non-RFC-compliant message from an IRC server. Usually sent during\nto you during an authentication phase right after you connect, while the\nserver does a hostname lookup or similar tasks. C<ARG0> is the text of the\nserver's message. C<ARG1> is the target, which could be B<'*'> or B<'AUTH'>\nor whatever. Servers vary as to whether these notices include a server name\nas the sender, or no sender at all. C<ARG1> is the sender, if any.\n\n=head3 C<irc_delay_set>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_delay_set>>\n\nEmitted on a successful addition of a delayed event using the\nL<C<delay>|/delay> method. C<ARG0> will be the alarm_id which can be used\nlater with L<C<delay_remove>|/delay_remove>. Subsequent parameters are\nthe arguments that were passed to L<C<delay>|/delay>.\n\n=head3 C<irc_delay_removed>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_delay_removed>>\n\nEmitted when a delayed command is successfully removed. C<ARG0> will be the\nalarm_id that was removed. Subsequent parameters are the arguments that were\npassed to L<C<delay>|/delay>.\n\n=head2 All numeric events\n\nMost messages from IRC servers are identified only by three-digit\nnumeric codes with undescriptive constant names like RPL_UMODEIS and\nERR_NOTOPLEVEL. (Actually, the list of codes in the RFC is kind of\nout-of-date... the list in the back of Net::IRC::Event.pm is more\ncomplete, and different IRC networks have different and incompatible\nlists. Ack!) As an example, say you wanted to handle event 376\n(RPL_ENDOFMOTD, which signals the end of the MOTD message). You'd\nregister for '376', and listen for C<irc_376> events. Simple, no? C<ARG0>\nis the name of the server which sent the message. C<ARG1> is the text of\nthe message. C<ARG2> is an array reference of the parsed message, so there\nis no need to parse C<ARG1> yourself.\n\n=head1 SIGNALS\n\nThe component will handle a number of custom signals that you may send using\nL<POE::Kernel|POE::Kernel>'s C<signal> method.\n\n=head2 C<POCOIRC_REGISTER>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/SYNDICATOR_REGISTER>>\n\nRegistering with multiple PoCo-IRC components has been a pita. Well, no more,\nusing the power of L<POE::Kernel|POE::Kernel> signals.\n\nIf the component receives a C<POCOIRC_REGISTER> signal it'll register the\nrequesting session and trigger an L<C<irc_registered>|/irc_registered>\nevent. From that event one can get all the information necessary such as the\npoco-irc object and the SENDER session to do whatever one needs to build a\npoco-irc dispatch table.\n\nThe way the signal handler in PoCo-IRC is written also supports sending the\nC<POCOIRC_REGISTER> to multiple sessions simultaneously, by sending the signal\nto the POE Kernel itself.\n\nPass the signal your session, session ID or alias, and the IRC events (as\nspecified to L<C<register>|/register>).\n\nTo register with multiple PoCo-IRCs one can do the following in your session's\n_start handler:\n\n sub _start {\n     my ($kernel, $session) = @_[KERNEL, SESSION];\n\n     # Registering with multiple pocoircs for 'all' IRC events\n     $kernel->signal($kernel, 'POCOIRC_REGISTER', $session->ID(), 'all');\n\n     return:\n }\n\nEach poco-irc will send your session an\nL<C<irc_registered>|/irc_registered> event:\n\n sub irc_registered {\n     my ($kernel, $sender, $heap, $irc_object) = @_[KERNEL, SENDER, HEAP, ARG0];\n\n     # Get the poco-irc session ID\n     my $sender_id = $sender->ID();\n\n     # Or it's alias\n     my $poco_alias = $irc_object->session_alias();\n\n     # Store it in our heap maybe\n     $heap->{irc_objects}->{ $sender_id } = $irc_object;\n\n     # Make the poco connect\n     $irc_object->yield(connect => { });\n\n     return;\n }\n\n=head2 C<POCOIRC_SHUTDOWN>\n\nI<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/SYNDICATOR_SHUTDOWN>>\n\nTelling multiple poco-ircs to shutdown was a pita as well. The same principle as\nwith registering applies to shutdown too.\n\nSend a C<POCOIRC_SHUTDOWN> to the POE Kernel to terminate all the active\npoco-ircs simultaneously.\n\n $poe_kernel->signal($poe_kernel, 'POCOIRC_SHUTDOWN');\n\nAny additional parameters passed to the signal will become your quit messages\non each IRC network.\n\n=head1 ENCODING\n\nThis can be an issue. Take a look at L<IRC::Utils' section|IRC::Utils/ENCODING>\non it.\n\n=head1 BUGS\n\nA few have turned up in the past and they are sure to again. Please use\nL<http://rt.cpan.org/> to report any. Alternatively, email the current\nmaintainer.\n\n=head1 DEVELOPMENT\n\nYou can find the latest source on github:\nL<http://github.com/bingos/poe-component-irc>\n\nThe project's developers usually hang out in the C<#poe> IRC channel on\nirc.perl.org. Do drop us a line.\n\n=head1 MAINTAINERS\n\nChris C<BinGOs> Williams <chris@bingosnet.co.uk>\n\nHinrik E<Ouml>rn SigurE<eth>sson <hinrik.sig@gmail.com>\n\n=head1 AUTHOR\n\nDennis Taylor.\n\n=head1 LICENCE\n\nCopyright (c) Dennis Taylor, Chris Williams and Hinrik E<Ouml>rn SigurE<eth>sson\n\nThis module may be used, modified, and distributed under the same\nterms as Perl itself. Please see the license that came with your Perl\ndistribution for details.\n\n=head1 MAD PROPS\n\nThe maddest of mad props go out to Rocco \"dngor\" Caputo\n<troc@netrus.net>, for inventing something as mind-bogglingly\ncool as POE, and to Kevin \"oznoid\" Lenzo E<lt>lenzo@cs.cmu.eduE<gt>,\nfor being the attentive parent of our precocious little infobot on\n#perl.\n\nFurther props to a few of the studly bughunters who made this module not\nsuck: Abys <abys@web1-2-3.com>, Addi <addi@umich.edu>, ResDev\n<ben@reser.org>, and Roderick <roderick@argon.org>. Woohoo!\n\nKudos to Apocalypse, <apocal@cpan.org>, for the plugin system and to\nJeff 'japhy' Pinyan, <japhy@perlmonk.org>, for Pipeline.\n\nThanks to the merry band of POE pixies from #PoE @ irc.perl.org,", 8192) = 8192
09:01:57.334780 read(6, "\nincluding ( but not limited to ), ketas, ct, dec, integral, webfox,\nimmute, perigrin, paulv, alias.\n\nIP functions are shamelessly 'borrowed' from L<Net::IP|Net::IP> by Manuel\nValente\n\nCheck out the Changes file for further contributors.\n\n=head1 SEE ALSO\n\nRFC 1459 L<http://www.faqs.org/rfcs/rfc1459.html>\n\nL<http://www.irchelp.org/>,\n\nL<http://poe.perl.org/>,\n\nL<http://www.infobot.org/>,\n\nSome good examples reside in the POE cookbook which has a whole section\ndevoted to IRC programming L<http://poe.perl.org/?POE_Cookbook>.\n\nThe examples/ folder of this distribution.\n\n=cut\n", 8192) = 578
09:01:57.334857 read(6, "", 8192)       = 0
09:01:57.334905 close(6)                = 0
09:01:57.334999 stat("modules/MiggyIRCBot/ConfigFile.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:57.335055 stat("modules/MiggyIRCBot/ConfigFile.pm", {st_mode=S_IFREG|0600, st_size=2742, ...}) = 0
09:01:57.335116 open("modules/MiggyIRCBot/ConfigFile.pm", O_RDONLY) = 6
09:01:57.335168 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bfa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.335215 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.335271 read(6, "package MiggyIRCBot::ConfigFile;\n\nour %config = (\n  'nickname' => 'Cmdr^Jameson',\n  'ircname' => 'Commander Jameson - *the* original commander',\n  'channel' => '#elite-dangerous',\n  'ircserver' => 'irc.quakenet.org',\n  'ircport' => 6667,\n  'connect_delay' => 60,\n  'console_port' => 3337,\n  'console_password' => 'UnwindLamps',\n  'seen_filestore' => 'seen_filestore.db',\n  'rss_url' => 'http://www.miggy.org/games/elite-dangerous/devtracker/ed-dev-posts.rss',\n  'rss_filestore' => 'rss.db',\n  'rss_check_time' => 300,\n  'qauth' => '',\n  'qpass' => '',\n  'youtube_api_key' => '',\n  'imgur_clientid' => '',\n  'imgur_clientsecret' => '',\n);\n\nsub new {\n  my ($class, %args) = @_;\n\tmy $self = bless {}, $class;\n  my $file = $args{'file'};\n\n\tif (!open(CF, \"<$file\")) {\n    printf STDERR \"Failed to open file '%s' to read config\\n\", $file;\n    return undef;\n  }\n  my $line = 0;\n  while (<CF>) {\n    $line++;\n    chomp;\n    if (/^\\#/) {\n      next;\n    } elsif (/^nickname:\\s+(.*)$/i) {\n      $config{'nickname'} = $1;\n    } elsif (/^ircname:\\s+(.*)$/i) {\n      $config{'ircname'} = $1;\n    } elsif (/^channel:\\s+(.*)$/i) {\n      $config{'channel'} = $1;\n    } elsif (/^ircserver:\\s+(.*)$/i) {\n      $config{'ircserver'} = $1;\n    } elsif (/^ircport:\\s+(.*)$/i) {\n      $config{'ircport'} = $1;\n    } elsif (/^connect_delay:\\s+(.*)$/i) {\n      $config{'connect_delay'} = $1;\n    } elsif (/^console_port:\\s+(.*)$/i) {\n      $config{'console_port'} = $1;\n    } elsif (/^console_password:\\s+(.*)$/i) {\n      $config{'console_password'} = $1;\n    } elsif (/^seen_filestore:\\s+(.*)$/i) {\n      $config{'seen_filestore'} = $1;\n    } elsif (/^crowdfund_funds_check_time:\\s+(.*)$/i) {\n      $config{'crowdfund_funds_check_time'} = $1;\n    } elsif (/^crowdfund_url:\\s+(.*)$/i) {\n      $config{'crowdfund_url'} = $1;\n    } elsif (/^rss_url:\\s+(.*)$/i) {\n      $config{'rss_url'} = $1;\n    } elsif (/^rss_filestore:\\s+(.*)$/i) {\n      $config{'rss_filestore'} = $1;\n    } elsif (/^rss_check_time:\\s+(.*)$/i) {\n      $config{'rss_check_time'} = $1;\n    } elsif (/^qauth:\\s+(.*)$/i) {\n      $config{'qauth'} = $1;\n    } elsif (/^qpass:\\s+(.*)$/i) {\n      $config{'qpass'} = $1;\n    } elsif (/^youtube_api_key:\\s+(.*)$/i) {\n      $config{'youtube_api_key'} = $1;\n    } elsif (/^imgur_clientid:\\s+(.*)$/i) {\n      $config{'imgur_clientid'} = $1;\n    } elsif (/^imgur_clientsecret:\\s+(.*)$/i) {\n      $config{'imgur_clientsecret'} = $1;\n    } else {\n      printf STDERR \"Unknown field in config file '%s', line %d : %s\\n\", $file, $line, $_;\n    }\n  }\n  close(CF);\n\n\treturn $self;\n}\n\nsub getconf {\n  my $self = shift;\n  my $field = shift;\n\n  #printf STDERR \"ConfigFile::getconf: field = '%s', which is: %s\\n\", $field, $config{$field};\n  return $config{$field};\n}\n\n1;\n", 8192) = 2742
09:01:57.335697 brk(0x18c6000)          = 0x18c6000
09:01:57.335889 read(6, "", 8192)       = 0
09:01:57.335938 close(6)                = 0
09:01:57.336019 stat("modules/MiggyIRCBot/URLParse.pmc", 0x7ffe1233c2c0) = -1 ENOENT (No such file or directory)
09:01:57.336072 stat("modules/MiggyIRCBot/URLParse.pm", {st_mode=S_IFREG|0600, st_size=22417, ...}) = 0
09:01:57.336131 open("modules/MiggyIRCBot/URLParse.pm", O_RDONLY) = 6
09:01:57.336183 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bfa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.336229 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.336288 read(6, "package MiggyIRCBot::URLParse;\n\nuse strict;\nuse warnings;\nuse POSIX;\nuse Data::Dumper;\nuse POE;\nuse HTTP::Request;\nuse POE::Component::Client::HTTP;\nuse POE::Component::IRC::Plugin qw(:ALL);\nuse HTML::TreeBuilder;\nuse JSON;\nuse Date::Parse;\n\nmy $youtube_api_key;\nmy ($imgur_clientid, $imgur_clientsecret);\nmy %sites = (\n  '^http(s)?:\\/\\/www\\.youtube\\.com\\/watch\\?v=' => {get => \\&get_youtube_com, parse => \\&parse_youtube_com},\n  '^http(s)?:\\/\\/www\\.youtube\\.com\\/user\\/.+\\/live' => {get => \\&get_youtube_com, parse => \\&parse_youtube_com},\n  '^http(s)?:\\/\\/(i\\.)?imgur\\.com\\/([^\\.\\/]+)(\\..+)?$' => {get => \\&get_imgur_image, parse => \\&parse_imgur_image},\n  '^http(s)?:\\/\\/imgur\\.com\\/a\\/([^\\.\\/]+)$' => {get => \\&get_imgur_album, parse => \\&parse_imgur_album},\n  '^http(s)?:\\/\\/community\\.elitedangerous\\.com\\/galnet\\/uid\\/[a-f0-9]+$' => {get => undef, parse => \\&parse_community_elitedangeros_com_galnet_uid },\n);\n\nsub new {\n  my ($class, %args) = @_;\n\tmy $self = bless {}, $class;\n\n  $youtube_api_key = $args{'youtube_api_key'};\n  ($imgur_clientid, $imgur_clientsecret) = ($args{'imgur_clientid'}, $args{'imgur_clientsecret'});\n\n\treturn $self;\n}\n\nsub PCI_register {\n  my ($self,$irc) = @_;\n  $self->{irc} = $irc;\n  $irc->plugin_register( $self, 'SERVER', qw(spoof) );\n\n  unless ( $self->{http_alias} ) {\n    $self->{http_alias} = join('-', 'ua-miggyselfbot', $irc->session_id() );\n    $self->{follow_redirects} ||= 2;\n    POE::Component::Client::HTTP->spawn(\n      Alias           => $self->{http_alias},\n      Agent           => 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',\n      FollowRedirects => $self->{follow_redirects},\n    );\n  }\n\n  $self->{session_id} = POE::Session->create(\n    object_states => [\n      $self => [ qw(_shutdown _start _get_url get_generic _parse_url parse_youtube_api parse_imgur_image parse_imgur_album ) ],\n    ],\n  )->ID();\n  $poe_kernel->state( 'get_url', $self );\n  return 1;\n}\n\nsub PCI_unregister {\n  my ($self,$irc) = splice @_, 0, 2;\n  $poe_kernel->state( 'get_url' );\n  $poe_kernel->call( $self->{session_id} => '_shutdown' );\n  delete $self->{irc};\n  return 1;\n}\n\nsub _start {\n  my ($kernel,$self) = @_[KERNEL,OBJECT];\n  $self->{session_id} = $_[SESSION]->ID();\n  $kernel->refcount_increment( $self->{session_id}, __PACKAGE__ );\n  undef;\n}\n\nsub _shutdown {\n  my ($kernel,$self) = @_[KERNEL,OBJECT];\n  $kernel->alarm_remove_all();\n  $kernel->refcount_decrement( $self->{session_id}, __PACKAGE__ );\n  $kernel->call( $self->{http_alias} => 'shutdown' );\n  undef;\n}\n\nsub get_url {\n  my ($kernel,$self,$session) = @_[KERNEL,OBJECT,SESSION];\n#printf STDERR \"GET_URL\\n\";\n  $kernel->post( $self->{session_id}, '_get_url', @_[ARG0..$#_] );\n  undef;\n}\n\nsub _get_url {\n  my ($kernel, $self) = @_[KERNEL, OBJECT];\n  my %args;\n#printf STDERR \"_GET_URL\\n\";\n  if ( ref $_[ARG0] eq 'HASH' ) {\n     %args = %{ $_[ARG0] };\n  } else {\n     %args = @_[ARG0..$#_];\n  }\n  $args{lc $_} = delete $args{$_} for grep { !/^_/ } keys %args;\n\nprintf STDERR \"_GET_URL: URL '%s'\\n\", $args{'url'};\n  my $done;\n  foreach my $site (keys(%sites)) {\n#printf STDERR \"_GET_URL: Checking site '%s'\\n\", $site;\n    if ($args{'url'} =~ $site and ${$sites{$site}}{'get'}) {\nprintf STDERR \"_GET_URL: Recognised a %s site...\\n\", $site; #\\t%s\\n\", $site, Dumper(${sites}{$site});\n      $sites{$site}->{'get'}->($kernel, $self, \\%args);\n      $done = 1;\n      last;\n    }\n  }\n\n  if (! $done) {\n#printf STDERR \"_GET_URL: posting to get_generic\\n\";\n    $kernel->post( $self->{session_id}, 'get_generic', @_[ARG0..$#_] );\n  }\n\n  undef;\n}\n\nsub get_generic {\n  my ($kernel, $self) = @_[KERNEL, OBJECT];\n  my %args;\n#printf STDERR \"_GET_GENERIC\\n\";\n  if ( ref $_[ARG0] eq 'HASH' ) {\n     %args = %{ $_[ARG0] };\n  } else {\n     %args = @_[ARG0..$#_];\n  }\n  $args{lc $_} = delete $args{$_} for grep { !/^_/ } keys %args;\n\n  # If you don't add the 'Connection: close' header than a HTTP/1.1 server\n  # with a long persistent connection timeout will mean you don't actually\n  # get your full response until it closes the connection.\n  my $req = HTTP::Request->new('GET', $args{'url'}); #, ['Connection' => 'close']);\nmylog(\"_GET_GENERIC: '\", $args{'url'}, \"'\");\n  $kernel->post( $self->{http_alias}, 'request', '_parse_url', $req, \\%args );\n}\n\nsub _parse_url {\n  my ($kernel, $self, $request, $response) = @_[KERNEL, OBJECT, ARG0, ARG1];\n  my $args = $request->[1];\n  my @params;\n\n#printf STDERR \"_PARSE_URL\\n\";\n  push @params, $args->{session};\n  my $res = $response->[0];\n\n  if (! $res->is_success) {\nprintf STDERR \"_PARSE_URL: res != success: $res->status_line\\n\";\nprintf STDERR \"_PARSE_URL: X-PCCH-Errmsg: %s\\n\", $res->header('X-PCCH-Errmsg');\n    my $error =  \"Failed to retrieve URL - \";\n    if (defined($res->header('X-PCCH-Errmsg')) and $res->header('X-PCCH-Errmsg') =~ /Connection to .* failed: [^\\s]+ error (?<errornum>\\?\\?|[0-9]]+): (?<errorstr>.*)$/) {\n      $error .= $+{'errornum'} . \": \" . $+{'errorstr'};\n    } else {\n      $error .=  $res->status_line;\n    }\n    push @params, 'irc_miggybot_url_error', $args, $error;\n  } else {\n#printf STDERR \"_PARSE_URL: res == success\\n\";\n    # Check if it's a site we have a special handler for\n#printf STDERR \"_PARSE_URL: args->{url} = '%s'\\n\", $args->{'url'};\n    my ($host) = $args->{'url'} =~ /^http[s]?:\\/\\/([^\\/:]+)(:[0-9]+)?\\//;\n    my $done;\n    foreach my $site (keys(%sites)) {\n      if ($args->{'url'} =~ $site) {\nprintf STDERR \"_PARSE_URL: Recognised a %s site...\\n\", $site;\n        my $blurb = $sites{$site}->{'parse'}($res, $args);\n        if (defined($blurb)) {\n          push @params, 'irc_miggybot_url_success', $args, $blurb;\n        } else {\n          push @params, 'irc_miggybot_url_error', $args, \"'$args->{'url'} confused me!\";\n        }\n        $done = 1;\n        last;\n      }\n    }\n\n    if (!defined($done)) {\n      # Use generic parsing\n      if ($res->header('Content-Type') =~ /^text\\/(ht|x)ml/) {\n        my $tree = HTML::TreeBuilder->new;\n        $tree->parse($res->decoded_content);\n        $tree->eof();\n        my $title = $tree->look_down('_tag', 'title');\n        if ($title) {\n          push @params, 'irc_miggybot_url_success', $args, \"[ \" . $title->as_text . \" ] - \" . $host;\n        } else {\n          push @params, 'irc_miggybot_url_error', $args, \"No <title> found in URL content\";\n        }\n      # } elsif (image) {\n      } else {\n        $args->{'quiet'} = 1;\n        push @params, 'irc_miggybot_url_success', $args, \"That was not an HTML page\";\n      }\n    }\n  }\n\n#for my $p (@params) { printf STDERR \" param = $p\\n\"; }\n  $kernel->post(@params);\n  undef;\n}\n\nsub parse_imgur_com {\n  my ($res, $args) = @_;\n\n# imgur.com is a PITA, fills in <title> etc after the fact with javascript\n# waste of time to respond with the generic page title\n## 16:25:35 <bigp3rm-> NASA just released an image of the new planet 168:http://imgur.com/yfTAqXq\n## 16:25:36 <EDBot> [ New images of Planet 9 worrying for scientists. - Imgur ] - imgur.com\n  return \"\";\n}\n\n###########################################################################\n# www.youtube.com parsing for video URLs\n###########################################################################\nsub get_youtube_com {\n  my ($kernel, $self, $args) = @_;\n\n  my (undef, $video_id) = $args->{'url'} =~ /^http(s)?:\\/\\/www\\.youtube\\.com\\/watch\\?v=([^\\?&]+)/;\n#printf STDERR \"GET_YOUTUBE_COM: video_id = %s\\n\", $video_id;\n  if ($youtube_api_key and $video_id) {\nprintf STDERR \"GET_YOUTUBE_COM, using API for '%s'\\n\", $args->{'url'};\n    my $req = HTTP::Request->new('GET', \"https://www.googleapis.com/youtube/v3/videos?part=contentDetails%2Cstatistics%2Csnippet&id=\" . $video_id . \"&key=\" . $youtube_api_key, ['Connection' => 'close']);\n    $kernel->post( $self->{http_alias}, 'request', 'parse_youtube_api', $req, $args );\n  } else {\nprintf STDERR \"GET_YOUTUBE_COM, using scraping for '%s'\\n\", $args->{'url'};\n    # If not a specific video\n    my $req = HTTP::Request->new('GET', $args->{'url'}, ['Connection' => 'close']);\n    $kernel->post( $self->{http_alias}, 'request', '_parse_url', $req, $args );\n  }\n}\n\nsub parse_youtube_api {\n  my ($kernel, $self, $request, $response) = @_[KERNEL, OBJECT, ARG0, ARG1", 8192) = 8192
09:01:57.337119 brk(0x18e7000)          = 0x18e7000
09:01:57.337910 stat("modules/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.337964 stat("modules/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338013 stat("modules/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338075 stat("modules/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338126 stat("/etc/perl/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338182 stat("/etc/perl/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338233 stat("/usr/local/lib/perl/5.14.2/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338284 stat("/usr/local/lib/perl/5.14.2/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338335 stat("/usr/local/share/perl/5.14.2/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338387 stat("/usr/local/share/perl/5.14.2/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338437 stat("/usr/lib/perl5/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338487 stat("/usr/lib/perl5/HTTP/Request.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.338537 stat("/usr/share/perl5/HTTP/Request.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.338589 stat("/usr/share/perl5/HTTP/Request.pm", {st_mode=S_IFREG|0644, st_size=5560, ...}) = 0
09:01:57.338648 open("/usr/share/perl5/HTTP/Request.pm", O_RDONLY) = 7
09:01:57.338701 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.338747 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.338806 read(7, "package HTTP::Request;\n\nrequire HTTP::Message;\n@ISA = qw(HTTP::Message);\n$VERSION = \"6.00\";\n\nuse strict;\n\n\n\nsub new\n{\n    my($class, $method, $uri, $header, $content) = @_;\n    my $self = $class->SUPER::new($header, $content);\n    $self->method($method);\n    $self->uri($uri);\n    $self;\n}\n\n\nsub parse\n{\n    my($class, $str) = @_;\n    my $request_line;\n    if ($str =~ s/^(.*)\\n//) {\n\t$request_line = $1;\n    }\n    else {\n\t$request_line = $str;\n\t$str = \"\";\n    }\n\n    my $self = $class->SUPER::parse($str);\n    my($method, $uri, $protocol) = split(' ', $request_line);\n    $self->method($method) if defined($method);\n    $self->uri($uri) if defined($uri);\n    $self->protocol($protocol) if $protocol;\n    $self;\n}\n\n\nsub clone\n{\n    my $self = shift;\n    my $clone = bless $self->SUPER::clone, ref($self);\n    $clone->method($self->method);\n    $clone->uri($self->uri);\n    $clone;\n}\n\n\nsub method\n{\n    shift->_elem('_method', @_);\n}\n\n\nsub uri\n{\n    my $self = shift;\n    my $old = $self->{'_uri'};\n    if (@_) {\n\tmy $uri = shift;\n\tif (!defined $uri) {\n\t    # that's ok\n\t}\n\telsif (ref $uri) {\n\t    Carp::croak(\"A URI can't be a \" . ref($uri) . \" reference\")\n\t\tif ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';\n\t    Carp::croak(\"Can't use a \" . ref($uri) . \" object as a URI\")\n\t\tunless $uri->can('scheme');\n\t    $uri = $uri->clone;\n\t    unless ($HTTP::URI_CLASS eq \"URI\") {\n\t\t# Argh!! Hate this... old LWP legacy!\n\t\teval { local $SIG{__DIE__}; $uri = $uri->abs; };\n\t\tdie $@ if $@ && $@ !~ /Missing base argument/;\n\t    }\n\t}\n\telse {\n\t    $uri = $HTTP::URI_CLASS->new($uri);\n\t}\n\t$self->{'_uri'} = $uri;\n        delete $self->{'_uri_canonical'};\n    }\n    $old;\n}\n\n*url = \\&uri;  # legacy\n\nsub uri_canonical\n{\n    my $self = shift;\n    return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;\n}\n\n\nsub accept_decodable\n{\n    my $self = shift;\n    $self->header(\"Accept-Encoding\", scalar($self->decodable));\n}\n\nsub as_string\n{\n    my $self = shift;\n    my($eol) = @_;\n    $eol = \"\\n\" unless defined $eol;\n\n    my $req_line = $self->method || \"-\";\n    my $uri = $self->uri;\n    $uri = (defined $uri) ? $uri->as_string : \"-\";\n    $req_line .= \" $uri\";\n    my $proto = $self->protocol;\n    $req_line .= \" $proto\" if $proto;\n\n    return join($eol, $req_line, $self->SUPER::as_string(@_));\n}\n\nsub dump\n{\n    my $self = shift;\n    my @pre = ($self->method || \"-\", $self->uri || \"-\");\n    if (my $prot = $self->protocol) {\n\tpush(@pre, $prot);\n    }\n\n    return $self->SUPER::dump(\n        preheader => join(\" \", @pre),\n\t@_,\n    );\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nHTTP::Request - HTTP style request message\n\n=head1 SYNOPSIS\n\n require HTTP::Request;\n $request = HTTP::Request->new(GET => 'http://www.example.com/');\n\nand usually used like this:\n\n $ua = LWP::UserAgent->new;\n $response = $ua->request($request);\n\n=head1 DESCRIPTION\n\nC<HTTP::Request> is a class encapsulating HTTP style requests,\nconsisting of a request line, some headers, and a content body. Note\nthat the LWP library uses HTTP style requests even for non-HTTP\nprotocols.  Instances of this class are usually passed to the\nrequest() method of an C<LWP::UserAgent> object.\n\nC<HTTP::Request> is a subclass of C<HTTP::Message> and therefore\ninherits its methods.  The following additional methods are available:\n\n=over 4\n\n=item $r = HTTP::Request->new( $method, $uri )\n\n=item $r = HTTP::Request->new( $method, $uri, $header )\n\n=item $r = HTTP::Request->new( $method, $uri, $header, $content )\n\nConstructs a new C<HTTP::Request> object describing a request on the\nobject $uri using method $method.  The $method argument must be a\nstring.  The $uri argument can be either a string, or a reference to a\nC<URI> object.  The optional $header argument should be a reference to\nan C<HTTP::Headers> object or a plain array reference of key/value\npairs.  The optional $content argument should be a string of bytes.\n\n=item $r = HTTP::Request->parse( $str )\n\nThis constructs a new request object by parsing the given string.\n\n=item $r->method\n\n=item $r->method( $val )\n\nThis is used to get/set the method attribute.  The method should be a\nshort string like \"GET\", \"HEAD\", \"PUT\" or \"POST\".\n\n=item $r->uri\n\n=item $r->uri( $val )\n\nThis is used to get/set the uri attribute.  The $val can be a\nreference to a URI object or a plain string.  If a string is given,\nthen it should be parseable as an absolute URI.\n\n=item $r->header( $field )\n\n=item $r->header( $field => $value )\n\nThis is used to get/set header values and it is inherited from\nC<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for\ndetails and other similar methods that can be used to access the\nheaders.\n\n=item $r->accept_decodable\n\nThis will set the C<Accept-Encoding> header to the list of encodings\nthat decoded_content() can decode.\n\n=item $r->content\n\n=item $r->content( $bytes )\n\nThis is used to get/set the content and it is inherited from the\nC<HTTP::Message> base class.  See L<HTTP::Message> for details and\nother methods that can be used to access the content.\n\nNote that the content should be a string of bytes.  Strings in perl\ncan contain characters outside the range of a byte.  The C<Encode>\nmodule can be used to turn such strings into a string of bytes.\n\n=item $r->as_string\n\n=item $r->as_string( $eol )\n\nMethod returning a textual representation of the request.\n\n=back\n\n=head1 SEE ALSO\n\nL<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,\nL<HTTP::Response>\n\n=head1 COPYRIGHT\n\nCopyright 1995-2004 Gisle Aas.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n", 8192) = 5560
09:01:57.339455 lseek(7, 2539, SEEK_SET) = 2539
09:01:57.339503 lseek(7, 0, SEEK_CUR)   = 2539
09:01:57.339548 close(7)                = 0
09:01:57.339602 stat("modules/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.339652 stat("modules/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.339702 stat("modules/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.339751 stat("modules/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.339801 stat("/etc/perl/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.339854 stat("/etc/perl/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.339905 stat("/usr/local/lib/perl/5.14.2/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.339956 stat("/usr/local/lib/perl/5.14.2/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.340011 stat("/usr/local/share/perl/5.14.2/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.340062 stat("/usr/local/share/perl/5.14.2/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.340112 stat("/usr/lib/perl5/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.340161 stat("/usr/lib/perl5/HTTP/Message.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.340211 stat("/usr/share/perl5/HTTP/Message.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.340261 stat("/usr/share/perl5/HTTP/Message.pm", {st_mode=S_IFREG|0644, st_size=30026, ...}) = 0
09:01:57.340320 open("/usr/share/perl5/HTTP/Message.pm", O_RDONLY) = 7
09:01:57.340373 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.340419 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.340478 read(7, "package HTTP::Message;\n\nuse strict;\nuse vars qw($VERSION $AUTOLOAD);\n$VERSION = \"6.03\";\n\nrequire HTTP::Headers;\nrequire Carp;\n\nmy $CRLF = \"\\015\\012\";   # \"\\r\\n\" is not portable\n$HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || \"URI\";\neval \"require $HTTP::URI_CLASS\"; die $@ if $@;\n\n*_utf8_downgrade = defined(&utf8::downgrade) ?\n    sub {\n        utf8::downgrade($_[0], 1) or\n            Carp::croak(\"HTTP::Message content must be bytes\")\n    }\n    :\n    sub {\n    };\n\nsub new\n{\n    my($class, $header, $content) = @_;\n    if (defined $header) {\n\tCarp::croak(\"Bad header argument\") unless ref $header;\n        if (ref($header) eq \"ARRAY\") {\n\t    $header = HTTP::Headers->new(@$header);\n\t}\n\telse {\n\t    $header = $header->clone;\n\t}\n    }\n    else {\n\t$header = HTTP::Headers->new;\n    }\n    if (defined $content) {\n        _utf8_downgrade($content);\n    }\n    else {\n        $content = '';\n    }\n\n    bless {\n\t'_headers' => $header,\n\t'_content' => $content,\n    }, $class;\n}\n\n\nsub parse\n{\n    my($class, $str) = @_;\n\n    my @hdr;\n    while (1) {\n\tif ($str =~ s/^([^\\s:]+)[ \\t]*: ?(.*)\\n?//) {\n\t    push(@hdr, $1, $2);\n\t    $hdr[-1] =~ s/\\r\\z//;\n\t}\n\telsif (@hdr && $str =~ s/^([ \\t].*)\\n?//) {\n\t    $hdr[-1] .= \"\\n$1\";\n\t    $hdr[-1] =~ s/\\r\\z//;\n\t}\n\telse {\n\t    $str =~ s/^\\r?\\n//;\n\t    last;\n\t}\n    }\n    local $HTTP::Headers::TRANSLATE_UNDERSCORE;\n    new($class, \\@hdr, $str);\n}\n\n\nsub clone\n{\n    my $self  = shift;\n    my $clone = HTTP::Message->new($self->headers,\n\t\t\t\t   $self->content);\n    $clone->protocol($self->protocol);\n    $clone;\n}\n\n\nsub clear {\n    my $self = shift;\n    $self->{_headers}->clear;\n    $self->content(\"\");\n    delete $self->{_parts};\n    return;\n}\n\n\nsub protocol {\n    shift->_elem('_protocol',  @_);\n}\n\nsub headers {\n    my $self = shift;\n\n    # recalculation of _content might change headers, so we\n    # need to force it now\n    $self->_content unless exists $self->{_content};\n\n    $self->{_headers};\n}\n\nsub headers_as_string {\n    shift->headers->as_string(@_);\n}\n\n\nsub content  {\n\n    my $self = $_[0];\n    if (defined(wantarray)) {\n\t$self->_content unless exists $self->{_content};\n\tmy $old = $self->{_content};\n\t$old = $$old if ref($old) eq \"SCALAR\";\n\t&_set_content if @_ > 1;\n\treturn $old;\n    }\n\n    if (@_ > 1) {\n\t&_set_content;\n    }\n    else {\n\tCarp::carp(\"Useless content call in void context\") if $^W;\n    }\n}\n\n\nsub _set_content {\n    my $self = $_[0];\n    _utf8_downgrade($_[1]);\n    if (!ref($_[1]) && ref($self->{_content}) eq \"SCALAR\") {\n\t${$self->{_content}} = $_[1];\n    }\n    else {\n\tdie \"Can't set content to be a scalar reference\" if ref($_[1]) eq \"SCALAR\";\n\t$self->{_content} = $_[1];\n\tdelete $self->{_content_ref};\n    }\n    delete $self->{_parts} unless $_[2];\n}\n\n\nsub add_content\n{\n    my $self = shift;\n    $self->_content unless exists $self->{_content};\n    my $chunkref = \\$_[0];\n    $chunkref = $$chunkref if ref($$chunkref);  # legacy\n\n    _utf8_downgrade($$chunkref);\n\n    my $ref = ref($self->{_content});\n    if (!$ref) {\n\t$self->{_content} .= $$chunkref;\n    }\n    elsif ($ref eq \"SCALAR\") {\n\t${$self->{_content}} .= $$chunkref;\n    }\n    else {\n\tCarp::croak(\"Can't append to $ref content\");\n    }\n    delete $self->{_parts};\n}\n\nsub add_content_utf8 {\n    my($self, $buf)  = @_;\n    utf8::upgrade($buf);\n    utf8::encode($buf);\n    $self->add_content($buf);\n}\n\nsub content_ref\n{\n    my $self = shift;\n    $self->_content unless exists $self->{_content};\n    delete $self->{_parts};\n    my $old = \\$self->{_content};\n    my $old_cref = $self->{_content_ref};\n    if (@_) {\n\tmy $new = shift;\n\tCarp::croak(\"Setting content_ref to a non-ref\") unless ref($new);\n\tdelete $self->{_content};  # avoid modifying $$old\n\t$self->{_content} = $new;\n\t$self->{_content_ref}++;\n    }\n    $old = $$old if $old_cref;\n    return $old;\n}\n\n\nsub content_charset\n{\n    my $self = shift;\n    if (my $charset = $self->content_type_charset) {\n\treturn $charset;\n    }\n\n    # time to start guessing\n    my $cref = $self->decoded_content(ref => 1, charset => \"none\");\n\n    # Unicode BOM\n    for ($$cref) {\n\treturn \"UTF-8\"     if /^\\xEF\\xBB\\xBF/;\n\treturn \"UTF-32-LE\" if /^\\xFF\\xFE\\x00\\x00/;\n\treturn \"UTF-32-BE\" if /^\\x00\\x00\\xFE\\xFF/;\n\treturn \"UTF-16-LE\" if /^\\xFF\\xFE/;\n\treturn \"UTF-16-BE\" if /^\\xFE\\xFF/;\n    }\n\n    if ($self->content_is_xml) {\n\t# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing\n\t# XML entity not accompanied by external encoding information and not\n\t# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,\n\t# in which the first characters must be '<?xml'\n\tfor ($$cref) {\n\t    return \"UTF-32-BE\" if /^\\x00\\x00\\x00</;\n\t    return \"UTF-32-LE\" if /^<\\x00\\x00\\x00/;\n\t    return \"UTF-16-BE\" if /^(?:\\x00\\s)*\\x00</;\n\t    return \"UTF-16-LE\" if /^(?:\\s\\x00)*<\\x00/;\n\t    if (/^\\s*(<\\?xml[^\\x00]*?\\?>)/) {\n\t\tif ($1 =~ /\\sencoding\\s*=\\s*([\"'])(.*?)\\1/) {\n\t\t    my $enc = $2;\n\t\t    $enc =~ s/^\\s+//; $enc =~ s/\\s+\\z//;\n\t\t    return $enc if $enc;\n\t\t}\n\t    }\n\t}\n\treturn \"UTF-8\";\n    }\n    elsif ($self->content_is_html) {\n\t# look for <META charset=\"...\"> or <META content=\"...\">\n\t# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding\n\tmy $charset;\n\trequire HTML::Parser;\n\tmy $p = HTML::Parser->new(\n\t    start_h => [sub {\n\t\tmy($tag, $attr, $self) = @_;\n\t\t$charset = $attr->{charset};\n\t\tunless ($charset) {\n\t\t    # look at $attr->{content} ...\n\t\t    if (my $c = $attr->{content}) {\n\t\t\trequire HTTP::Headers::Util;\n\t\t\tmy @v = HTTP::Headers::Util::split_header_words($c);\n\t\t\treturn unless @v;\n\t\t\tmy($ct, undef, %ct_param) = @{$v[0]};\n\t\t\t$charset = $ct_param{charset};\n\t\t    }\n\t\t    return unless $charset;\n\t\t}\n\t\tif ($charset =~ /^utf-?16/i) {\n\t\t    # converted document, assume UTF-8\n\t\t    $charset = \"UTF-8\";\n\t\t}\n\t\t$self->eof;\n\t    }, \"tagname, attr, self\"],\n\t    report_tags => [qw(meta)],\n\t    utf8_mode => 1,\n\t);\n\t$p->parse($$cref);\n\treturn $charset if $charset;\n    }\n    if ($self->content_type =~ /^text\\//) {\n\tfor ($$cref) {\n\t    if (length) {\n\t\treturn \"US-ASCII\" unless /[\\x80-\\xFF]/;\n\t\trequire Encode;\n\t\teval {\n\t\t    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());\n\t\t};\n\t\treturn \"UTF-8\" unless $@;\n\t\treturn \"ISO-8859-1\";\n\t    }\n\t}\n    }\n\n    return undef;\n}\n\n\nsub decoded_content\n{\n    my($self, %opt) = @_;\n    my $content_ref;\n    my $content_ref_iscopy;\n\n    eval {\n\t$content_ref = $self->content_ref;\n\tdie \"Can't decode ref content\" if ref($content_ref) ne \"SCALAR\";\n\n\tif (my $h = $self->header(\"Content-Encoding\")) {\n\t    $h =~ s/^\\s+//;\n\t    $h =~ s/\\s+$//;\n\t    for my $ce (reverse split(/\\s*,\\s*/, lc($h))) {\n\t\tnext unless $ce;\n\t\tnext if $ce eq \"identity\";\n\t\tif ($ce eq \"gzip\" || $ce eq \"x-gzip\") {\n\t\t    require IO::Uncompress::Gunzip;\n\t\t    my $output;\n\t\t    IO::Uncompress::Gunzip::gunzip($content_ref, \\$output, Transparent => 0)\n\t\t\tor die \"Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError\";\n\t\t    $content_ref = \\$output;\n\t\t    $content_ref_iscopy++;\n\t\t}\n\t\telsif ($ce eq \"x-bzip2\" or $ce eq \"bzip2\") {\n\t\t    require IO::Uncompress::Bunzip2;\n\t\t    my $output;\n\t\t    IO::Uncompress::Bunzip2::bunzip2($content_ref, \\$output, Transparent => 0)\n\t\t\tor die \"Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error\";\n\t\t    $content_ref = \\$output;\n\t\t    $content_ref_iscopy++;\n\t\t}\n\t\telsif ($ce eq \"deflate\") {\n\t\t    require IO::Uncompress::Inflate;\n\t\t    my $output;\n\t\t    my $status = IO::Uncompress::Inflate::inflate($content_ref, \\$output, Transparent => 0);\n\t\t    my $error = $IO::Uncompress::Inflate::InflateError;\n\t\t    unless ($status) {\n\t\t\t# \"Content-Encoding: deflate\" is supposed to mean the\n\t\t\t# \"zlib\" format of RFC 1950, but Microsoft got that\n\t\t\t# wrong, so some servers sends the raw compressed\n\t\t\t# \"deflate\" data.  This tries to inflate this format.\n\t\t\t$output = undef;\n\t\t\trequire IO::Uncompress::RawInflate;\n\t\t\tunless (IO::Uncompress::RawInflate::rawinflate($content_ref, \\$output)) {\n\t\t\t    $self->push_header(\"Client-Warning\" =>\n\t\t\t\t\"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError\");\n\t\t\t    $output = undef;\n\t\t\t}\n\t\t    }\n\t\t    die \"Can't inflate content: $error\" unless defined $output;\n\t\t    $content_ref = \\$output;\n\t\t    $content_ref_iscopy++;\n\t\t}\n\t\telsif ($ce eq \"compress\" || $ce eq \"x-compress\")", 8192) = 8192
09:01:57.341199 brk(0x1908000)          = 0x1908000
09:01:57.341987 read(7, " {\n\t\t    die \"Can't uncompress content\";\n\t\t}\n\t\telsif ($ce eq \"base64\") {  # not really C-T-E, but should be harmless\n\t\t    require MIME::Base64;\n\t\t    $content_ref = \\MIME::Base64::decode($$content_ref);\n\t\t    $content_ref_iscopy++;\n\t\t}\n\t\telsif ($ce eq \"quoted-printable\") { # not really C-T-E, but should be harmless\n\t\t    require MIME::QuotedPrint;\n\t\t    $content_ref = \\MIME::QuotedPrint::decode($$content_ref);\n\t\t    $content_ref_iscopy++;\n\t\t}\n\t\telse {\n\t\t    die \"Don't know how to decode Content-Encoding '$ce'\";\n\t\t}\n\t    }\n\t}\n\n\tif ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {\n\t    my $charset = lc(\n\t        $opt{charset} ||\n\t\t$self->content_type_charset ||\n\t\t$opt{default_charset} ||\n\t\t$self->content_charset ||\n\t\t\"ISO-8859-1\"\n\t    );\n\t    if ($charset eq \"none\") {\n\t\t# leave it asis\n\t    }\n\t    elsif ($charset eq \"us-ascii\" || $charset eq \"iso-8859-1\") {\n\t\tif ($$content_ref =~ /[^\\x00-\\x7F]/ && defined &utf8::upgrade) {\n\t\t    unless ($content_ref_iscopy) {\n\t\t\tmy $copy = $$content_ref;\n\t\t\t$content_ref = \\$copy;\n\t\t\t$content_ref_iscopy++;\n\t\t    }\n\t\t    utf8::upgrade($$content_ref);\n\t\t}\n\t    }\n\t    else {\n\t\trequire Encode;\n\t\teval {\n\t\t    $content_ref = \\Encode::decode($charset, $$content_ref,\n\t\t\t ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());\n\t\t};\n\t\tif ($@) {\n\t\t    my $retried;\n\t\t    if ($@ =~ /^Unknown encoding/) {\n\t\t\tmy $alt_charset = lc($opt{alt_charset} || \"\");\n\t\t\tif ($alt_charset && $charset ne $alt_charset) {\n\t\t\t    # Retry decoding with the alternative charset\n\t\t\t    $content_ref = \\Encode::decode($alt_charset, $$content_ref,\n\t\t\t\t ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())\n\t\t\t        unless $alt_charset eq \"none\";\n\t\t\t    $retried++;\n\t\t\t}\n\t\t    }\n\t\t    die unless $retried;\n\t\t}\n\t\tdie \"Encode::decode() returned undef improperly\" unless defined $$content_ref;\n\t\tif ($is_xml) {\n\t\t    # Get rid of the XML encoding declaration if present\n\t\t    $$content_ref =~ s/^\\x{FEFF}//;\n\t\t    if ($$content_ref =~ /^(\\s*<\\?xml[^\\x00]*?\\?>)/) {\n\t\t\tsubstr($$content_ref, 0, length($1)) =~ s/\\sencoding\\s*=\\s*([\"']).*?\\1//;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    };\n    if ($@) {\n\tCarp::croak($@) if $opt{raise_error};\n\treturn undef;\n    }\n\n    return $opt{ref} ? $content_ref : $$content_ref;\n}\n\n\nsub decodable\n{\n    # should match the Content-Encoding values that decoded_content can deal with\n    my $self = shift;\n    my @enc;\n    # XXX preferably we should determine if the modules are available without loading\n    # them here\n    eval {\n        require IO::Uncompress::Gunzip;\n        push(@enc, \"gzip\", \"x-gzip\");\n    };\n    eval {\n        require IO::Uncompress::Inflate;\n        require IO::Uncompress::RawInflate;\n        push(@enc, \"deflate\");\n    };\n    eval {\n        require IO::Uncompress::Bunzip2;\n        push(@enc, \"x-bzip2\");\n    };\n    # we don't care about announcing the 'identity', 'base64' and\n    # 'quoted-printable' stuff\n    return wantarray ? @enc : join(\", \", @enc);\n}\n\n\nsub decode\n{\n    my $self = shift;\n    return 1 unless $self->header(\"Content-Encoding\");\n    if (defined(my $content = $self->decoded_content(charset => \"none\"))) {\n\t$self->remove_header(\"Content-Encoding\", \"Content-Length\", \"Content-MD5\");\n\t$self->content($content);\n\treturn 1;\n    }\n    return 0;\n}\n\n\nsub encode\n{\n    my($self, @enc) = @_;\n\n    Carp::croak(\"Can't encode multipart/* messages\") if $self->content_type =~ m,^multipart/,;\n    Carp::croak(\"Can't encode message/* messages\") if $self->content_type =~ m,^message/,;\n\n    return 1 unless @enc;  # nothing to do\n\n    my $content = $self->content;\n    for my $encoding (@enc) {\n\tif ($encoding eq \"identity\") {\n\t    # nothing to do\n\t}\n\telsif ($encoding eq \"base64\") {\n\t    require MIME::Base64;\n\t    $content = MIME::Base64::encode($content);\n\t}\n\telsif ($encoding eq \"gzip\" || $encoding eq \"x-gzip\") {\n\t    require IO::Compress::Gzip;\n\t    my $output;\n\t    IO::Compress::Gzip::gzip(\\$content, \\$output, Minimal => 1)\n\t\tor die \"Can't gzip content: $IO::Compress::Gzip::GzipError\";\n\t    $content = $output;\n\t}\n\telsif ($encoding eq \"deflate\") {\n\t    require IO::Compress::Deflate;\n\t    my $output;\n\t    IO::Compress::Deflate::deflate(\\$content, \\$output)\n\t\tor die \"Can't deflate content: $IO::Compress::Deflate::DeflateError\";\n\t    $content = $output;\n\t}\n\telsif ($encoding eq \"x-bzip2\") {\n\t    require IO::Compress::Bzip2;\n\t    my $output;\n\t    IO::Compress::Bzip2::bzip2(\\$content, \\$output)\n\t\tor die \"Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error\";\n\t    $content = $output;\n\t}\n\telsif ($encoding eq \"rot13\") {  # for the fun of it\n\t    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;\n\t}\n\telse {\n\t    return 0;\n\t}\n    }\n    my $h = $self->header(\"Content-Encoding\");\n    unshift(@enc, $h) if $h;\n    $self->header(\"Content-Encoding\", join(\", \", @enc));\n    $self->remove_header(\"Content-Length\", \"Content-MD5\");\n    $self->content($content);\n    return 1;\n}\n\n\nsub as_string\n{\n    my($self, $eol) = @_;\n    $eol = \"\\n\" unless defined $eol;\n\n    # The calculation of content might update the headers\n    # so we need to do that first.\n    my $content = $self->content;\n\n    return join(\"\", $self->{'_headers'}->as_string($eol),\n\t\t    $eol,\n\t\t    $content,\n\t\t    (@_ == 1 && length($content) &&\n\t\t     $content !~ /\\n\\z/) ? \"\\n\" : \"\",\n\t\t);\n}\n\n\nsub dump\n{\n    my($self, %opt) = @_;\n    my $content = $self->content;\n    my $chopped = 0;\n    if (!ref($content)) {\n\tmy $maxlen = $opt{maxlength};\n\t$maxlen = 512 unless defined($maxlen);\n\tif ($maxlen && length($content) > $maxlen * 1.1 + 3) {\n\t    $chopped = length($content) - $maxlen;\n\t    $content = substr($content, 0, $maxlen) . \"...\";\n\t}\n\n\t$content =~ s/\\\\/\\\\\\\\/g;\n\t$content =~ s/\\t/\\\\t/g;\n\t$content =~ s/\\r/\\\\r/g;\n\n\t# no need for 3 digits in escape for these\n\t$content =~ s/([\\0-\\11\\13-\\037])(?!\\d)/sprintf('\\\\%o',ord($1))/eg;\n\n\t$content =~ s/([\\0-\\11\\13-\\037\\177-\\377])/sprintf('\\\\x%02X',ord($1))/eg;\n\t$content =~ s/([^\\12\\040-\\176])/sprintf('\\\\x{%X}',ord($1))/eg;\n\n\t# remaining whitespace\n\t$content =~ s/( +)\\n/(\"\\\\40\" x length($1)) . \"\\n\"/eg;\n\t$content =~ s/(\\n+)\\n/(\"\\\\n\" x length($1)) . \"\\n\"/eg;\n\t$content =~ s/\\n\\z/\\\\n/;\n\n\tmy $no_content = \"(no content)\";\n\tif ($content eq $no_content) {\n\t    # escape our $no_content marker\n\t    $content =~ s/^(.)/sprintf('\\\\x%02X',ord($1))/eg;\n\t}\n\telsif ($content eq \"\") {\n\t    $content = \"(no content)\";\n\t}\n    }\n\n    my @dump;\n    push(@dump, $opt{preheader}) if $opt{preheader};\n    push(@dump, $self->{_headers}->as_string, $content);\n    push(@dump, \"(+ $chopped more bytes not shown)\") if $chopped;\n\n    my $dump = join(\"\\n\", @dump, \"\");\n    $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};\n\n    print $dump unless defined wantarray;\n    return $dump;\n}\n\n\nsub parts {\n    my $self = shift;\n    if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq \"SCALAR\")) {\n\t$self->_parts;\n    }\n    my $old = $self->{_parts};\n    if (@_) {\n\tmy @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;\n\tmy $ct = $self->content_type || \"\";\n\tif ($ct =~ m,^message/,) {\n\t    Carp::croak(\"Only one part allowed for $ct content\")\n\t\tif @parts > 1;\n\t}\n\telsif ($ct !~ m,^multipart/,) {\n\t    $self->remove_content_headers;\n\t    $self->content_type(\"multipart/mixed\");\n\t}\n\t$self->{_parts} = \\@parts;\n\t_stale_content($self);\n    }\n    return @$old if wantarray;\n    return $old->[0];\n}\n\nsub add_part {\n    my $self = shift;\n    if (($self->content_type || \"\") !~ m,^multipart/,) {\n\tmy $p = HTTP::Message->new($self->remove_content_headers,\n\t\t\t\t   $self->content(\"\"));\n\t$self->content_type(\"multipart/mixed\");\n\t$self->{_parts} = [];\n        if ($p->headers->header_field_names || $p->content ne \"\") {\n            push(@{$self->{_parts}}, $p);\n        }\n    }\n    elsif (!exists $self->{_parts} || ref($self->{_content}) eq \"SCALAR\") {\n\t$self->_parts;\n    }\n\n    push(@{$self->{_parts}}, @_);\n    _stale_content($self);\n    return;\n}\n\nsub _stale_content {\n    my $self = shift;\n    if (ref($self->{_content}) eq \"SCALAR\") {\n\t# must recalculate now\n\t$self->_content;\n    }\n    else {\n\t# just invalidate cache\n\tdelete $self->{_content};\n\tdelete $self->{_content_ref};\n    }\n}\n\n\n# delegate all other method calls the the headers object.\nsub AUTOLOAD\n{\n    my $method = substr($A", 8192) = 8192
09:01:57.342484 brk(0x1929000)          = 0x1929000
09:01:57.343424 brk(0x194a000)          = 0x194a000
09:01:57.343517 read(7, "UTOLOAD, rindex($AUTOLOAD, '::')+2);\n\n    # We create the function here so that it will not need to be\n    # autoloaded the next time.\n    no strict 'refs';\n    *$method = sub { shift->headers->$method(@_) };\n    goto &$method;\n}\n\n\nsub DESTROY {}  # avoid AUTOLOADing it\n\n\n# Private method to access members in %$self\nsub _elem\n{\n    my $self = shift;\n    my $elem = shift;\n    my $old = $self->{$elem};\n    $self->{$elem} = $_[0] if @_;\n    return $old;\n}\n\n\n# Create private _parts attribute from current _content\nsub _parts {\n    my $self = shift;\n    my $ct = $self->content_type;\n    if ($ct =~ m,^multipart/,) {\n\trequire HTTP::Headers::Util;\n\tmy @h = HTTP::Headers::Util::split_header_words($self->header(\"Content-Type\"));\n\tdie \"Assert\" unless @h;\n\tmy %h = @{$h[0]};\n\tif (defined(my $b = $h{boundary})) {\n\t    my $str = $self->content;\n\t    $str =~ s/\\r?\\n--\\Q$b\\E--\\r?\\n.*//s;\n\t    if ($str =~ s/(^|.*?\\r?\\n)--\\Q$b\\E\\r?\\n//s) {\n\t\t$self->{_parts} = [map HTTP::Message->parse($_),\n\t\t\t\t   split(/\\r?\\n--\\Q$b\\E\\r?\\n/, $str)]\n\t    }\n\t}\n    }\n    elsif ($ct eq \"message/http\") {\n\trequire HTTP::Request;\n\trequire HTTP::Response;\n\tmy $content = $self->content;\n\tmy $class = ($content =~ m,^(HTTP/.*)\\n,) ?\n\t    \"HTTP::Response\" : \"HTTP::Request\";\n\t$self->{_parts} = [$class->parse($content)];\n    }\n    elsif ($ct =~ m,^message/,) {\n\t$self->{_parts} = [ HTTP::Message->parse($self->content) ];\n    }\n\n    $self->{_parts} ||= [];\n}\n\n\n# Create private _content attribute from current _parts\nsub _content {\n    my $self = shift;\n    my $ct = $self->{_headers}->header(\"Content-Type\") || \"multipart/mixed\";\n    if ($ct =~ m,^\\s*message/,i) {\n\t_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);\n\treturn;\n    }\n\n    require HTTP::Headers::Util;\n    my @v = HTTP::Headers::Util::split_header_words($ct);\n    Carp::carp(\"Multiple Content-Type headers\") if @v > 1;\n    @v = @{$v[0]};\n\n    my $boundary;\n    my $boundary_index;\n    for (my @tmp = @v; @tmp;) {\n\tmy($k, $v) = splice(@tmp, 0, 2);\n\tif ($k eq \"boundary\") {\n\t    $boundary = $v;\n\t    $boundary_index = @v - @tmp - 1;\n\t    last;\n\t}\n    }\n\n    my @parts = map $_->as_string($CRLF), @{$self->{_parts}};\n\n    my $bno = 0;\n    $boundary = _boundary() unless defined $boundary;\n CHECK_BOUNDARY:\n    {\n\tfor (@parts) {\n\t    if (index($_, $boundary) >= 0) {\n\t\t# must have a better boundary\n\t\t$boundary = _boundary(++$bno);\n\t\tredo CHECK_BOUNDARY;\n\t    }\n\t}\n    }\n\n    if ($boundary_index) {\n\t$v[$boundary_index] = $boundary;\n    }\n    else {\n\tpush(@v, boundary => $boundary);\n    }\n\n    $ct = HTTP::Headers::Util::join_header_words(@v);\n    $self->{_headers}->header(\"Content-Type\", $ct);\n\n    _set_content($self, \"--$boundary$CRLF\" .\n\t                join(\"$CRLF--$boundary$CRLF\", @parts) .\n\t\t\t\"$CRLF--$boundary--$CRLF\",\n                        1);\n}\n\n\nsub _boundary\n{\n    my $size = shift || return \"xYzZY\";\n    require MIME::Base64;\n    my $b = MIME::Base64::encode(join(\"\", map chr(rand(256)), 1..$size*3), \"\");\n    $b =~ s/[\\W]/X/g;  # ensure alnum only\n    $b;\n}\n\n\n1;\n\n\n__END__\n\n=head1 NAME\n\nHTTP::Message - HTTP style message (base class)\n\n=head1 SYNOPSIS\n\n use base 'HTTP::Message';\n\n=head1 DESCRIPTION\n\nAn C<HTTP::Message> object contains some headers and a content body.\nThe following methods are available:\n\n=over 4\n\n=item $mess = HTTP::Message->new\n\n=item $mess = HTTP::Message->new( $headers )\n\n=item $mess = HTTP::Message->new( $headers, $content )\n\nThis constructs a new message object.  Normally you would want\nconstruct C<HTTP::Request> or C<HTTP::Response> objects instead.\n\nThe optional $header argument should be a reference to an\nC<HTTP::Headers> object or a plain array reference of key/value pairs.\nIf an C<HTTP::Headers> object is provided then a copy of it will be\nembedded into the constructed message, i.e. it will not be owned and\ncan be modified afterwards without affecting the message.\n\nThe optional $content argument should be a string of bytes.\n\n=item $mess = HTTP::Message->parse( $str )\n\nThis constructs a new message object by parsing the given string.\n\n=item $mess->headers\n\nReturns the embedded C<HTTP::Headers> object.\n\n=item $mess->headers_as_string\n\n=item $mess->headers_as_string( $eol )\n\nCall the as_string() method for the headers in the\nmessage.  This will be the same as\n\n    $mess->headers->as_string\n\nbut it will make your program a whole character shorter :-)\n\n=item $mess->content\n\n=item $mess->content( $bytes )\n\nThe content() method sets the raw content if an argument is given.  If no\nargument is given the content is not touched.  In either case the\noriginal raw content is returned.\n\nNote that the content should be a string of bytes.  Strings in perl\ncan contain characters outside the range of a byte.  The C<Encode>\nmodule can be used to turn such strings into a string of bytes.\n\n=item $mess->add_content( $bytes )\n\nThe add_content() methods appends more data bytes to the end of the\ncurrent content buffer.\n\n=item $mess->add_content_utf8( $string )\n\nThe add_content_utf8() method appends the UTF-8 bytes representing the\nstring to the end of the current content buffer.\n\n=item $mess->content_ref\n\n=item $mess->content_ref( \\$bytes )\n\nThe content_ref() method will return a reference to content buffer string.\nIt can be more efficient to access the content this way if the content\nis huge, and it can even be used for direct manipulation of the content,\nfor instance:\n\n  ${$res->content_ref} =~ s/\\bfoo\\b/bar/g;\n\nThis example would modify the content buffer in-place.\n\nIf an argument is passed it will setup the content to reference some\nexternal source.  The content() and add_content() methods\nwill automatically dereference scalar references passed this way.  For\nother references content() will return the reference itself and\nadd_content() will refuse to do anything.\n\n=item $mess->content_charset\n\nThis returns the charset used by the content in the message.  The\ncharset is either found as the charset attribute of the\nC<Content-Type> header or by guessing.\n\nSee L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>\nfor details about how charset is determined.\n\n=item $mess->decoded_content( %options )\n\nReturns the content with any C<Content-Encoding> undone and for textual content\nthe raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>\nor C<charset> of the message is unknown this method will fail by returning\nC<undef>.\n\nThe following options can be specified.\n\n=over\n\n=item C<charset>\n\nThis override the charset parameter for text content.  The value\nC<none> can used to suppress decoding of the charset.\n\n=item C<default_charset>\n\nThis override the default charset guessed by content_charset() or\nif that fails \"ISO-8859-1\".\n\n=item C<alt_charset>\n\nIf decoding fails because the charset specified in the Content-Type header\nisn't recognized by Perl's Encode module, then try decoding using this charset\ninstead of failing.  The C<alt_charset> might be specified as C<none> to simply\nreturn the string without any decoding of charset as alternative.\n\n=item C<charset_strict>\n\nAbort decoding if malformed characters is found in the content.  By\ndefault you get the substitution character (\"\\x{FFFD}\") in place of\nmalformed characters.\n\n=item C<raise_error>\n\nIf TRUE then raise an exception if not able to decode content.  Reason\nmight be that the specified C<Content-Encoding> or C<charset> is not\nsupported.  If this option is FALSE, then decoded_content() will return\nC<undef> on errors, but will still set $@.\n\n=item C<ref>\n\nIf TRUE then a reference to decoded content is returned.  This might\nbe more efficient in cases where the decoded content is identical to\nthe raw content as no data copying is required in this case.\n\n=back\n\n=item $mess->decodable\n\n=item HTTP::Message::decodable()\n\nThis returns the encoding identifiers that decoded_content() can\nprocess.  In scalar context returns a comma separated string of\nidentifiers.\n\nThis value is suitable for initializing the C<Accept-Encoding> request\nheader field.\n\n=item $mess->decode\n\nThis method tries to replace the content of the message with the\ndecoded version and removes the C<Content-Encoding> header.  Returns\nTRUE if successful and FALSE if not.\n\nIf the message does ", 8192) = 8192
09:01:57.344348 lseek(7, 19418, SEEK_SET) = 19418
09:01:57.344396 lseek(7, 0, SEEK_CUR)   = 19418
09:01:57.344441 close(7)                = 0
09:01:57.344496 stat("modules/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.344547 stat("modules/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.344597 stat("modules/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.344646 stat("modules/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.344695 stat("/etc/perl/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.344744 stat("/etc/perl/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.344794 stat("/usr/local/lib/perl/5.14.2/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.344850 stat("/usr/local/lib/perl/5.14.2/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.344901 stat("/usr/local/share/perl/5.14.2/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.344951 stat("/usr/local/share/perl/5.14.2/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.345002 stat("/usr/lib/perl5/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.345051 stat("/usr/lib/perl5/HTTP/Headers.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.345100 stat("/usr/share/perl5/HTTP/Headers.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.345154 stat("/usr/share/perl5/HTTP/Headers.pm", {st_mode=S_IFREG|0644, st_size=24243, ...}) = 0
09:01:57.345213 open("/usr/share/perl5/HTTP/Headers.pm", O_RDONLY) = 7
09:01:57.345266 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.345312 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.345372 read(7, "package HTTP::Headers;\n\nuse strict;\nuse Carp ();\n\nuse vars qw($VERSION $TRANSLATE_UNDERSCORE);\n$VERSION = \"6.00\";\n\n# The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used\n# as a replacement for '-' in header field names.\n$TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;\n\n# \"Good Practice\" order of HTTP message headers:\n#    - General-Headers\n#    - Request-Headers\n#    - Response-Headers\n#    - Entity-Headers\n\nmy @general_headers = qw(\n    Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade\n    Via Warning\n);\n\nmy @request_headers = qw(\n    Accept Accept-Charset Accept-Encoding Accept-Language\n    Authorization Expect From Host\n    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since\n    Max-Forwards Proxy-Authorization Range Referer TE User-Agent\n);\n\nmy @response_headers = qw(\n    Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server\n    Vary WWW-Authenticate\n);\n\nmy @entity_headers = qw(\n    Allow Content-Encoding Content-Language Content-Length Content-Location\n    Content-MD5 Content-Range Content-Type Expires Last-Modified\n);\n\nmy %entity_header = map { lc($_) => 1 } @entity_headers;\n\nmy @header_order = (\n    @general_headers,\n    @request_headers,\n    @response_headers,\n    @entity_headers,\n);\n\n# Make alternative representations of @header_order.  This is used\n# for sorting and case matching.\nmy %header_order;\nmy %standard_case;\n\n{\n    my $i = 0;\n    for (@header_order) {\n\tmy $lc = lc $_;\n\t$header_order{$lc} = ++$i;\n\t$standard_case{$lc} = $_;\n    }\n}\n\n\n\nsub new\n{\n    my($class) = shift;\n    my $self = bless {}, $class;\n    $self->header(@_) if @_; # set up initial headers\n    $self;\n}\n\n\nsub header\n{\n    my $self = shift;\n    Carp::croak('Usage: $h->header($field, ...)') unless @_;\n    my(@old);\n    my %seen;\n    while (@_) {\n\tmy $field = shift;\n        my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';\n\t@old = $self->_header($field, shift, $op);\n    }\n    return @old if wantarray;\n    return $old[0] if @old <= 1;\n    join(\", \", @old);\n}\n\nsub clear\n{\n    my $self = shift;\n    %$self = ();\n}\n\n\nsub push_header\n{\n    my $self = shift;\n    return $self->_header(@_, 'PUSH_H') if @_ == 2;\n    while (@_) {\n\t$self->_header(splice(@_, 0, 2), 'PUSH_H');\n    }\n}\n\n\nsub init_header\n{\n    Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;\n    shift->_header(@_, 'INIT');\n}\n\n\nsub remove_header\n{\n    my($self, @fields) = @_;\n    my $field;\n    my @values;\n    foreach $field (@fields) {\n\t$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;\n\tmy $v = delete $self->{lc $field};\n\tpush(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;\n    }\n    return @values;\n}\n\nsub remove_content_headers\n{\n    my $self = shift;\n    unless (defined(wantarray)) {\n\t# fast branch that does not create return object\n\tdelete @$self{grep $entity_header{$_} || /^content-/, keys %$self};\n\treturn;\n    }\n\n    my $c = ref($self)->new;\n    for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {\n\t$c->{$f} = delete $self->{$f};\n    }\n    $c;\n}\n\n\nsub _header\n{\n    my($self, $field, $val, $op) = @_;\n\n    unless ($field =~ /^:/) {\n\t$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;\n\tmy $old = $field;\n\t$field = lc $field;\n\tunless(defined $standard_case{$field}) {\n\t    # generate a %standard_case entry for this field\n\t    $old =~ s/\\b(\\w)/\\u$1/g;\n\t    $standard_case{$field} = $old;\n\t}\n    }\n\n    $op ||= defined($val) ? 'SET' : 'GET';\n    if ($op eq 'PUSH_H') {\n\t# Like PUSH but where we don't care about the return value\n\tif (exists $self->{$field}) {\n\t    my $h = $self->{$field};\n\t    if (ref($h) eq 'ARRAY') {\n\t\tpush(@$h, ref($val) eq \"ARRAY\" ? @$val : $val);\n\t    }\n\t    else {\n\t\t$self->{$field} = [$h, ref($val) eq \"ARRAY\" ? @$val : $val]\n\t    }\n\t    return;\n\t}\n\t$self->{$field} = $val;\n\treturn;\n    }\n\n    my $h = $self->{$field};\n    my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());\n\n    unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {\n\tif (defined($val)) {\n\t    my @new = ($op eq 'PUSH') ? @old : ();\n\t    if (ref($val) ne 'ARRAY') {\n\t\tpush(@new, $val);\n\t    }\n\t    else {\n\t\tpush(@new, @$val);\n\t    }\n\t    $self->{$field} = @new > 1 ? \\@new : $new[0];\n\t}\n\telsif ($op ne 'PUSH') {\n\t    delete $self->{$field};\n\t}\n    }\n    @old;\n}\n\n\nsub _sorted_field_names\n{\n    my $self = shift;\n    return [ sort {\n        ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||\n         $a cmp $b\n    } keys %$self ];\n}\n\n\nsub header_field_names {\n    my $self = shift;\n    return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },\n\tif wantarray;\n    return keys %$self;\n}\n\n\nsub scan\n{\n    my($self, $sub) = @_;\n    my $key;\n    for $key (@{ $self->_sorted_field_names }) {\n\tnext if substr($key, 0, 1) eq '_';\n\tmy $vals = $self->{$key};\n\tif (ref($vals) eq 'ARRAY') {\n\t    my $val;\n\t    for $val (@$vals) {\n\t\t$sub->($standard_case{$key} || $key, $val);\n\t    }\n\t}\n\telse {\n\t    $sub->($standard_case{$key} || $key, $vals);\n\t}\n    }\n}\n\n\nsub as_string\n{\n    my($self, $endl) = @_;\n    $endl = \"\\n\" unless defined $endl;\n\n    my @result = ();\n    for my $key (@{ $self->_sorted_field_names }) {\n\tnext if index($key, '_') == 0;\n\tmy $vals = $self->{$key};\n\tif ( ref($vals) eq 'ARRAY' ) {\n\t    for my $val (@$vals) {\n\t\tmy $field = $standard_case{$key} || $key;\n\t\t$field =~ s/^://;\n\t\tif ( index($val, \"\\n\") >= 0 ) {\n\t\t    $val = _process_newline($val, $endl);\n\t\t}\n\t\tpush @result, $field . ': ' . $val;\n\t    }\n\t}\n\telse {\n\t    my $field = $standard_case{$key} || $key;\n\t    $field =~ s/^://;\n\t    if ( index($vals, \"\\n\") >= 0 ) {\n\t\t$vals = _process_newline($vals, $endl);\n\t    }\n\t    push @result, $field . ': ' . $vals;\n\t}\n    }\n\n    join($endl, @result, '');\n}\n\nsub _process_newline {\n    local $_ = shift;\n    my $endl = shift;\n    # must handle header values with embedded newlines with care\n    s/\\s+$//;        # trailing newlines and space must go\n    s/\\n(\\x0d?\\n)+/\\n/g;     # no empty lines\n    s/\\n([^\\040\\t])/\\n $1/g; # intial space for continuation\n    s/\\n/$endl/g;    # substitute with requested line ending\n    $_;\n}\n\n\n\nif (eval { require Storable; 1 }) {\n    *clone = \\&Storable::dclone;\n} else {\n    *clone = sub {\n\tmy $self = shift;\n\tmy $clone = HTTP::Headers->new;\n\t$self->scan(sub { $clone->push_header(@_);} );\n\t$clone;\n    };\n}\n\n\nsub _date_header\n{\n    require HTTP::Date;\n    my($self, $header, $time) = @_;\n    my($old) = $self->_header($header);\n    if (defined $time) {\n\t$self->_header($header, HTTP::Date::time2str($time));\n    }\n    $old =~ s/;.*// if defined($old);\n    HTTP::Date::str2time($old);\n}\n\n\nsub date                { shift->_date_header('Date',                @_); }\nsub expires             { shift->_date_header('Expires',             @_); }\nsub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }\nsub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }\nsub last_modified       { shift->_date_header('Last-Modified',       @_); }\n\n# This is used as a private LWP extension.  The Client-Date header is\n# added as a timestamp to a response when it has been received.\nsub client_date         { shift->_date_header('Client-Date',         @_); }\n\n# The retry_after field is dual format (can also be a expressed as\n# number of seconds from now), so we don't provide an easy way to\n# access it until we have know how both these interfaces can be\n# addressed.  One possibility is to return a negative value for\n# relative seconds and a positive value for epoch based time values.\n#sub retry_after       { shift->_date_header('Retry-After',       @_); }\n\nsub content_type      {\n    my $self = shift;\n    my $ct = $self->{'content-type'};\n    $self->{'content-type'} = shift if @_;\n    $ct = $ct->[0] if ref($ct) eq 'ARRAY';\n    return '' unless defined($ct) && length($ct);\n    my @ct = split(/;\\s*/, $ct, 2);\n    for ($ct[0]) {\n\ts/\\s+//g;\n\t$_ = lc($_);\n    }\n    wantarray ? @ct : $ct[0];\n}\n\nsub content_type_charset {\n    my $self = shift;\n    require HTTP::Headers::Util;\n    my $h = $self->{'content-type'};\n    $h = $h->[0] if ref($h);\n    $h = \"\" unless defined $h;\n    my @v = HTTP::Headers::Util::split_header_words($h);\n    if (@v) {\n\tmy($ct, undef, %ct_param) = @{$v", 8192) = 8192
09:01:57.346132 brk(0x196b000)          = 0x196b000
09:01:57.346857 read(7, "[0]};\n\tmy $charset = $ct_param{charset};\n\tif ($ct) {\n\t    $ct = lc($ct);\n\t    $ct =~ s/\\s+//;\n\t}\n\tif ($charset) {\n\t    $charset = uc($charset);\n\t    $charset =~ s/^\\s+//;  $charset =~ s/\\s+\\z//;\n\t    undef($charset) if $charset eq \"\";\n\t}\n\treturn $ct, $charset if wantarray;\n\treturn $charset;\n    }\n    return undef, undef if wantarray;\n    return undef;\n}\n\nsub content_is_text {\n    my $self = shift;\n    return $self->content_type =~ m,^text/,;\n}\n\nsub content_is_html {\n    my $self = shift;\n    return $self->content_type eq 'text/html' || $self->content_is_xhtml;\n}\n\nsub content_is_xhtml {\n    my $ct = shift->content_type;\n    return $ct eq \"application/xhtml+xml\" ||\n           $ct eq \"application/vnd.wap.xhtml+xml\";\n}\n\nsub content_is_xml {\n    my $ct = shift->content_type;\n    return 1 if $ct eq \"text/xml\";\n    return 1 if $ct eq \"application/xml\";\n    return 1 if $ct =~ /\\+xml$/;\n    return 0;\n}\n\nsub referer           {\n    my $self = shift;\n    if (@_ && $_[0] =~ /#/) {\n\t# Strip fragment per RFC 2616, section 14.36.\n\tmy $uri = shift;\n\tif (ref($uri)) {\n\t    $uri = $uri->clone;\n\t    $uri->fragment(undef);\n\t}\n\telse {\n\t    $uri =~ s/\\#.*//;\n\t}\n\tunshift @_, $uri;\n    }\n    ($self->_header('Referer', @_))[0];\n}\n*referrer = \\&referer;  # on tchrist's request\n\nsub title             { (shift->_header('Title',            @_))[0] }\nsub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }\nsub content_language  { (shift->_header('Content-Language', @_))[0] }\nsub content_length    { (shift->_header('Content-Length',   @_))[0] }\n\nsub user_agent        { (shift->_header('User-Agent',       @_))[0] }\nsub server            { (shift->_header('Server',           @_))[0] }\n\nsub from              { (shift->_header('From',             @_))[0] }\nsub warning           { (shift->_header('Warning',          @_))[0] }\n\nsub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }\nsub authorization     { (shift->_header('Authorization',    @_))[0] }\n\nsub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }\nsub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }\n\nsub authorization_basic       { shift->_basic_auth(\"Authorization\",       @_) }\nsub proxy_authorization_basic { shift->_basic_auth(\"Proxy-Authorization\", @_) }\n\nsub _basic_auth {\n    require MIME::Base64;\n    my($self, $h, $user, $passwd) = @_;\n    my($old) = $self->_header($h);\n    if (defined $user) {\n\tCarp::croak(\"Basic authorization user name can't contain ':'\")\n\t  if $user =~ /:/;\n\t$passwd = '' unless defined $passwd;\n\t$self->_header($h => 'Basic ' .\n                             MIME::Base64::encode(\"$user:$passwd\", ''));\n    }\n    if (defined $old && $old =~ s/^\\s*Basic\\s+//) {\n\tmy $val = MIME::Base64::decode($old);\n\treturn $val unless wantarray;\n\treturn split(/:/, $val, 2);\n    }\n    return;\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nHTTP::Headers - Class encapsulating HTTP Message headers\n\n=head1 SYNOPSIS\n\n require HTTP::Headers;\n $h = HTTP::Headers->new;\n\n $h->header('Content-Type' => 'text/plain');  # set\n $ct = $h->header('Content-Type');            # get\n $h->remove_header('Content-Type');           # delete\n\n=head1 DESCRIPTION\n\nThe C<HTTP::Headers> class encapsulates HTTP-style message headers.\nThe headers consist of attribute-value pairs also called fields, which\nmay be repeated, and which are printed in a particular order.  The\nfield names are cases insensitive.\n\nInstances of this class are usually created as member variables of the\nC<HTTP::Request> and C<HTTP::Response> classes, internal to the\nlibrary.\n\nThe following methods are available:\n\n=over 4\n\n=item $h = HTTP::Headers->new\n\nConstructs a new C<HTTP::Headers> object.  You might pass some initial\nattribute-value pairs as parameters to the constructor.  I<E.g.>:\n\n $h = HTTP::Headers->new(\n       Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',\n       Content_Type => 'text/html; version=3.2',\n       Content_Base => 'http://www.perl.org/');\n\nThe constructor arguments are passed to the C<header> method which is\ndescribed below.\n\n=item $h->clone\n\nReturns a copy of this C<HTTP::Headers> object.\n\n=item $h->header( $field )\n\n=item $h->header( $field => $value )\n\n=item $h->header( $f1 => $v1, $f2 => $v2, ... )\n\nGet or set the value of one or more header fields.  The header field\nname ($field) is not case sensitive.  To make the life easier for perl\nusers who wants to avoid quoting before the => operator, you can use\n'_' as a replacement for '-' in header names.\n\nThe header() method accepts multiple ($field => $value) pairs, which\nmeans that you can update several fields with a single invocation.\n\nThe $value argument may be a plain string or a reference to an array\nof strings for a multi-valued field. If the $value is provided as\nC<undef> then the field is removed.  If the $value is not given, then\nthat header field will remain unchanged.\n\nThe old value (or values) of the last of the header fields is returned.\nIf no such field exists C<undef> will be returned.\n\nA multi-valued field will be returned as separate values in list\ncontext and will be concatenated with \", \" as separator in scalar\ncontext.  The HTTP spec (RFC 2616) promise that joining multiple\nvalues in this way will not change the semantic of a header field, but\nin practice there are cases like old-style Netscape cookies (see\nL<HTTP::Cookies>) where \",\" is used as part of the syntax of a single\nfield value.\n\nExamples:\n\n $header->header(MIME_Version => '1.0',\n\t\t User_Agent   => 'My-Web-Client/0.01');\n $header->header(Accept => \"text/html, text/plain, image/*\");\n $header->header(Accept => [qw(text/html text/plain image/*)]);\n @accepts = $header->header('Accept');  # get multiple values\n $accepts = $header->header('Accept');  # get values as a single string\n\n=item $h->push_header( $field => $value )\n\n=item $h->push_header( $f1 => $v1, $f2 => $v2, ... )\n\nAdd a new field value for the specified header field.  Previous values\nfor the same field are retained.\n\nAs for the header() method, the field name ($field) is not case\nsensitive and '_' can be used as a replacement for '-'.\n\nThe $value argument may be a scalar or a reference to a list of\nscalars.\n\n $header->push_header(Accept => 'image/jpeg');\n $header->push_header(Accept => [map \"image/$_\", qw(gif png tiff)]);\n\n=item $h->init_header( $field => $value )\n\nSet the specified header to the given value, but only if no previous\nvalue for that field is set.\n\nThe header field name ($field) is not case sensitive and '_'\ncan be used as a replacement for '-'.\n\nThe $value argument may be a scalar or a reference to a list of\nscalars.\n\n=item $h->remove_header( $field, ... )\n\nThis function removes the header fields with the specified names.\n\nThe header field names ($field) are not case sensitive and '_'\ncan be used as a replacement for '-'.\n\nThe return value is the values of the fields removed.  In scalar\ncontext the number of fields removed is returned.\n\nNote that if you pass in multiple field names then it is generally not\npossible to tell which of the returned values belonged to which field.\n\n=item $h->remove_content_headers\n\nThis will remove all the header fields used to describe the content of\na message.  All header field names prefixed with C<Content-> fall\ninto this category, as well as C<Allow>, C<Expires> and\nC<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header\nFields>.\n\nThe return value is a new C<HTTP::Headers> object that contains the\nremoved headers only.\n\n=item $h->clear\n\nThis will remove all header fields.\n\n=item $h->header_field_names\n\nReturns the list of distinct names for the fields present in the\nheader.  The field names have case as suggested by HTTP spec, and the\nnames are returned in the recommended \"Good Practice\" order.\n\nIn scalar context return the number of distinct field names.\n\n=item $h->scan( \\&process_header_field )\n\nApply a subroutine to each header field in turn.  The callback routine\nis called with two parameters; the name of the field and a single\nvalue (a string).  If a header field is multi-valued, then the\nroutine is called once for each value.  The field name passed to the\ncallback routine has case as suggested by HTTP spec, and the headers\nwill be visited in", 8192) = 8192
09:01:57.347331 brk(0x198c000)          = 0x198c000
09:01:57.347733 lseek(7, 11043, SEEK_SET) = 11043
09:01:57.347780 lseek(7, 0, SEEK_CUR)   = 11043
09:01:57.347824 close(7)                = 0
09:01:57.347944 stat("modules/Storable.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.347995 stat("modules/Storable.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.348045 stat("modules/Storable.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.348094 stat("modules/Storable.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.348142 stat("/etc/perl/Storable.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.348192 stat("/etc/perl/Storable.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.348243 stat("/usr/local/lib/perl/5.14.2/Storable.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.348293 stat("/usr/local/lib/perl/5.14.2/Storable.pm", {st_mode=S_IFREG|0444, st_size=43139, ...}) = 0
09:01:57.348352 open("/usr/local/lib/perl/5.14.2/Storable.pm", O_RDONLY) = 7
09:01:57.348405 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.348451 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.348511 read(7, "#\n#  Copyright (c) 1995-2001, Raphael Manfredi\n#  Copyright (c) 2002-2014 by the Perl 5 Porters\n#\n#  You may redistribute only under the same terms as Perl 5, as specified\n#  in the README file that comes with the distribution.\n#\n\nrequire XSLoader;\nrequire Exporter;\npackage Storable; @ISA = qw(Exporter);\n\n@EXPORT = qw(store retrieve);\n@EXPORT_OK = qw(\n\tnstore store_fd nstore_fd fd_retrieve\n\tfreeze nfreeze thaw\n\tdclone\n\tretrieve_fd\n\tlock_store lock_nstore lock_retrieve\n        file_magic read_magic\n);\n\nuse vars qw($canonical $forgive_me $VERSION);\n\n$VERSION = '2.51';\n\nBEGIN {\n    if (eval { local $SIG{__DIE__}; require Log::Agent; 1 }) {\n        Log::Agent->import;\n    }\n    #\n    # Use of Log::Agent is optional. If it hasn't imported these subs then\n    # provide a fallback implementation.\n    #\n    unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {\n        require Carp;\n        *logcroak = sub {\n            Carp::croak(@_);\n        };\n    }\n    unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {\n\trequire Carp;\n        *logcarp = sub {\n          Carp::carp(@_);\n        };\n    }\n}\n\n#\n# They might miss :flock in Fcntl\n#\n\nBEGIN {\n\tif (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {\n\t\tFcntl->import(':flock');\n\t} else {\n\t\teval q{\n\t\t\tsub LOCK_SH ()\t{1}\n\t\t\tsub LOCK_EX ()\t{2}\n\t\t};\n\t}\n}\n\nsub CLONE {\n    # clone context under threads\n    Storable::init_perinterp();\n}\n\n# By default restricted hashes are downgraded on earlier perls.\n\n$Storable::downgrade_restricted = 1;\n$Storable::accept_future_minor = 1;\n\nXSLoader::load('Storable', $Storable::VERSION);\n\n#\n# Determine whether locking is possible, but only when needed.\n#\n\nsub CAN_FLOCK; my $CAN_FLOCK; sub CAN_FLOCK {\n\treturn $CAN_FLOCK if defined $CAN_FLOCK;\n\trequire Config; import Config;\n\treturn $CAN_FLOCK =\n\t\t$Config{'d_flock'} ||\n\t\t$Config{'d_fcntl_can_lock'} ||\n\t\t$Config{'d_lockf'};\n}\n\nsub show_file_magic {\n    print <<EOM;\n#\n# To recognize the data files of the Perl module Storable,\n# the following lines need to be added to the local magic(5) file,\n# usually either /usr/share/misc/magic or /etc/magic.\n#\n0\tstring\tperl-store\tperl Storable(v0.6) data\n>4\tbyte\t>0\t(net-order %d)\n>>4\tbyte\t&01\t(network-ordered)\n>>4\tbyte\t=3\t(major 1)\n>>4\tbyte\t=2\t(major 1)\n\n0\tstring\tpst0\tperl Storable(v0.7) data\n>4\tbyte\t>0\n>>4\tbyte\t&01\t(network-ordered)\n>>4\tbyte\t=5\t(major 2)\n>>4\tbyte\t=4\t(major 2)\n>>5\tbyte\t>0\t(minor %d)\nEOM\n}\n\nsub file_magic {\n    require IO::File;\n\n    my $file = shift;\n    my $fh = IO::File->new;\n    open($fh, \"<\". $file) || die \"Can't open '$file': $!\";\n    binmode($fh);\n    defined(sysread($fh, my $buf, 32)) || die \"Can't read from '$file': $!\";\n    close($fh);\n\n    $file = \"./$file\" unless $file;  # ensure TRUE value\n\n    return read_magic($buf, $file);\n}\n\nsub read_magic {\n    my($buf, $file) = @_;\n    my %info;\n\n    my $buflen = length($buf);\n    my $magic;\n    if ($buf =~ s/^(pst0|perl-store)//) {\n\t$magic = $1;\n\t$info{file} = $file || 1;\n    }\n    else {\n\treturn undef if $file;\n\t$magic = \"\";\n    }\n\n    return undef unless length($buf);\n\n    my $net_order;\n    if ($magic eq \"perl-store\" && ord(substr($buf, 0, 1)) > 1) {\n\t$info{version} = -1;\n\t$net_order = 0;\n    }\n    else {\n\t$buf =~ s/(.)//s;\n\tmy $major = (ord $1) >> 1;\n\treturn undef if $major > 4; # sanity (assuming we never go that high)\n\t$info{major} = $major;\n\t$net_order = (ord $1) & 0x01;\n\tif ($major > 1) {\n\t    return undef unless $buf =~ s/(.)//s;\n\t    my $minor = ord $1;\n\t    $info{minor} = $minor;\n\t    $info{version} = \"$major.$minor\";\n\t    $info{version_nv} = sprintf \"%d.%03d\", $major, $minor;\n\t}\n\telse {\n\t    $info{version} = $major;\n\t}\n    }\n    $info{version_nv} ||= $info{version};\n    $info{netorder} = $net_order;\n\n    unless ($net_order) {\n\treturn undef unless $buf =~ s/(.)//s;\n\tmy $len = ord $1;\n\treturn undef unless length($buf) >= $len;\n\treturn undef unless $len == 4 || $len == 8;  # sanity\n\t@info{qw(byteorder intsize longsize ptrsize)}\n\t    = unpack \"a${len}CCC\", $buf;\n\t(substr $buf, 0, $len + 3) = '';\n\tif ($info{version_nv} >= 2.002) {\n\t    return undef unless $buf =~ s/(.)//s;\n\t    $info{nvsize} = ord $1;\n\t}\n    }\n    $info{hdrsize} = $buflen - length($buf);\n\n    return \\%info;\n}\n\nsub BIN_VERSION_NV {\n    sprintf \"%d.%03d\", BIN_MAJOR(), BIN_MINOR();\n}\n\nsub BIN_WRITE_VERSION_NV {\n    sprintf \"%d.%03d\", BIN_MAJOR(), BIN_WRITE_MINOR();\n}\n\n#\n# store\n#\n# Store target object hierarchy, identified by a reference to its root.\n# The stored object tree may later be retrieved to memory via retrieve.\n# Returns undef if an I/O error occurred, in which case the file is\n# removed.\n#\nsub store {\n\treturn _store(\\&pstore, @_, 0);\n}\n\n#\n# nstore\n#\n# Same as store, but in network order.\n#\nsub nstore {\n\treturn _store(\\&net_pstore, @_, 0);\n}\n\n#\n# lock_store\n#\n# Same as store, but flock the file first (advisory locking).\n#\nsub lock_store {\n\treturn _store(\\&pstore, @_, 1);\n}\n\n#\n# lock_nstore\n#\n# Same as nstore, but flock the file first (advisory locking).\n#\nsub lock_nstore {\n\treturn _store(\\&net_pstore, @_, 1);\n}\n\n# Internal store to file routine\nsub _store {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tmy ($file, $use_locking) = @_;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"wrong argument number\" unless @_ == 2;\t# No @foo in arglist\n\tlocal *FILE;\n\tif ($use_locking) {\n\t\topen(FILE, \">>$file\") || logcroak \"can't write into $file: $!\";\n\t\tunless (&CAN_FLOCK) {\n\t\t\tlogcarp\n\t\t\t\t\"Storable::lock_store: fcntl/flock emulation broken on $^O\";\n\t\t\treturn undef;\n\t\t}\n\t\tflock(FILE, LOCK_EX) ||\n\t\t\tlogcroak \"can't get exclusive lock on $file: $!\";\n\t\ttruncate FILE, 0;\n\t\t# Unlocking will happen when FILE is closed\n\t} else {\n\t\topen(FILE, \">$file\") || logcroak \"can't create $file: $!\";\n\t}\n\tbinmode FILE;\t\t\t\t# Archaic systems...\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine nstore or pstore, depending on network order\n\teval { $ret = &$xsptr(*FILE, $self) };\n\t# close will return true on success, so the or short-circuits, the ()\n\t# expression is true, and for that case the block will only be entered\n\t# if $@ is true (ie eval failed)\n\t# if close fails, it returns false, $ret is altered, *that* is (also)\n\t# false, so the () expression is false, !() is true, and the block is\n\t# entered.\n\tif (!(close(FILE) or undef $ret) || $@) {\n\t\tunlink($file) or warn \"Can't unlink $file: $!\\n\";\n\t}\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $ret;\n}\n\n#\n# store_fd\n#\n# Same as store, but perform on an already opened file descriptor instead.\n# Returns undef if an I/O error occurred.\n#\nsub store_fd {\n\treturn _store_fd(\\&pstore, @_);\n}\n\n#\n# nstore_fd\n#\n# Same as store_fd, but in network order.\n#\nsub nstore_fd {\n\tmy ($self, $file) = @_;\n\treturn _store_fd(\\&net_pstore, @_);\n}\n\n# Internal store routine on opened file descriptor\nsub _store_fd {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tmy ($file) = @_;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"too many arguments\" unless @_ == 1;\t# No @foo in arglist\n\tmy $fd = fileno($file);\n\tlogcroak \"not a valid file descriptor\" unless defined $fd;\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine nstore or pstore, depending on network order\n\teval { $ret = &$xsptr($file, $self) };\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\tlocal $\\; print $file '';\t# Autoflush the file if wanted\n\t$@ = $da;\n\treturn $ret;\n}\n\n#\n# freeze\n#\n# Store object and its hierarchy in memory and return a scalar\n# containing the result.\n#\nsub freeze {\n\t_freeze(\\&mstore, @_);\n}\n\n#\n# nfreeze\n#\n# Same as freeze but in network order.\n#\nsub nfreeze {\n\t_freeze(\\&net_mstore, @_);\n}\n\n# Internal freeze routine\nsub _freeze {\n\tmy $xsptr = shift;\n\tmy $self = shift;\n\tlogcroak \"not a reference\" unless ref($self);\n\tlogcroak \"too many arguments\" unless @_ == 0;\t# No @foo in arglist\n\tmy $da = $@;\t\t\t\t# Don't mess if called from exception handler\n\tmy $ret;\n\t# Call C routine mstore or net_mstore, depending on network order\n\teval { $ret = &$xsptr($self) };\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $ret ? $ret : undef;\n}\n\n#\n# retrieve\n#\n# Retrieve object hierarchy from disk, returning a reference to the root\n# object of that tree.\n#\nsub retrieve {\n\t_retr", 8192) = 8192
09:01:57.349053 stat("modules/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349105 stat("modules/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349164 stat("modules/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349213 stat("modules/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349262 stat("/etc/perl/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349311 stat("/etc/perl/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349360 stat("/usr/local/lib/perl/5.14.2/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349414 stat("/usr/local/lib/perl/5.14.2/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349465 stat("/usr/local/share/perl/5.14.2/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349516 stat("/usr/local/share/perl/5.14.2/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349567 stat("/usr/lib/perl5/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349617 stat("/usr/lib/perl5/Log/Agent.pm", 0x7ffe1233b600) = -1 ENOENT (No such file or directory)
09:01:57.349670 stat("/usr/share/perl5/Log/Agent.pmc", 0x7ffe1233b6b0) = -1 ENOENT (No such file or directory)
09:01:57.349721 stat("/usr/share/perl5/Log/Agent.pm", {st_mode=S_IFREG|0644, st_size=23745, ...}) = 0
09:01:57.349779 open("/usr/share/perl5/Log/Agent.pm", O_RDONLY) = 8
09:01:57.349831 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b390) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.349876 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.349935 read(8, "###########################################################################\n# $Id: Agent.pm,v 1.11 2005/10/02 16:57:17 wendigo Exp $\n###########################################################################\n#\n# Log::Agent\n#\n# RCS Revision: $Revision: 1.11 $\n# Date: $Date: 2005/10/02 16:57:17 $\n#\n# Copyright (C) 1999 Raphael Manfredi.\n# Copyright (C) 2002-2003,2005 Mark Rogaski, mrogaski@cpan.org;\n# all rights reserved.\n#\n# See the README file included with the\n# distribution for license information.\n#\n###########################################################################\n\nuse strict;\nrequire Exporter;\n\n########################################################################\npackage Log::Agent;\n\nuse vars qw($VERSION $Driver $Prefix $Trace $Debug $Confess\n\t$OS_Error $AUTOLOAD $Caller $Priorities $Tags $DATUM %prio_cache);\n\nuse AutoLoader;\nuse vars qw(@ISA @EXPORT @EXPORT_OK);\n\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tlogconfig\n\tlogconfess logcroak logcarp logxcroak logxcarp\n\tlogsay logerr logwarn logdie logtrc logdbg\n);\n@EXPORT_OK = qw(\n\tlogwrite logtags\n);\n\nuse Log::Agent::Priorities qw(:LEVELS priority_level level_from_prio);\nuse Log::Agent::Formatting qw(tag_format_args);\n\n$VERSION = '0.307';\n\n$Trace = NOTICE;\t# Default tracing\n$OS_Error = '';         # Data stash for the $! value\n\nsub AUTOLOAD {\n    ${Log::Agent::OS_Error} = $!;       # for safe-keeping, the braces\n                                        # prevent CVS substitution\n    $AutoLoader::AUTOLOAD = $AUTOLOAD;\n    goto &AutoLoader::AUTOLOAD;\n}\n\n1;\n__END__\n\n#\n# logconfig\n#\n# Configure the logging system at the application level. By default, logging\n# uses the Log::Agent::Driver::Default driver.\n#\n# Available options (case insensitive):\n#\n#   -PREFIX   => string           logging prefix/tag to use, for Default agent\n#   -DRIVER   => object           object heir of Log::Agent::Driver\n#   -TRACE    => level            trace level\n#   -DEBUG    => level            debug level\n#   -LEVEL    => level            specifies common trace/debug level\n#   -CONFESS  => flag             whether to automatically confess on logdie\n#   -CALLER   => listref          info from caller to add and where\n#   -PRIORITY => listref          message priority information to add\n#   -TAGS     => listref          list of user-defined tags to add\n#\n# Notes:\n#   -CALLER   allowed keys documented in Log::Agent::Tag::Caller's make()\n#   -PRIORITY allowed keys documented in Log::Agent::Tag::Priority's make()\n#   -TAGS     supplies list of Log::Agent::Tag objects\n#\nsub logconfig {\n\tmy (%args) = @_;\n\tmy ($calldef, $priodef, $tags);\n\n\tmy %set = (\n\t\t-prefix\t\t\t=> \\$Prefix,\t\t# Only for Default init\n\t\t-driver\t\t\t=> \\$Driver,\n\t\t-trace\t\t\t=> \\$Trace,\n\t\t-debug\t\t\t=> \\$Debug,\n\t\t-level\t\t\t=> [\\$Trace, \\$Debug],\n\t\t-confess\t\t=> \\$Confess,\n\t\t-caller\t\t\t=> \\$calldef,\n\t\t-priority\t\t=> \\$priodef,\n\t\t-tags\t\t\t=> \\$tags,\n\t);\n\n\twhile (my ($arg, $val) = each %args) {\n\t\tmy $vset = $set{lc($arg)};\n\t\tunless (ref $vset) {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Unknown switch $arg\");\n\t\t}\n\t\tif\t\t(ref $vset eq 'SCALAR')\t\t{ $$vset = $val }\n\t\telsif\t(ref $vset eq 'ARRAY')\t\t{ map { $$_ = $val } @$vset }\n\t\telsif\t(ref $vset eq 'REF')\t\t{ $$vset = $val }\n\t\telse\t\t\t\t\t\t\t\t{ die \"bug in logconfig\" }\n\t}\n\n\tunless (defined $Driver) {\n\t\trequire Log::Agent::Driver::Default;\n\t\t# Keep only basename for default prefix\n\t\t$Prefix =~ s|^.*/(.*)|$1| if defined $Prefix;\n\t\t$Driver = Log::Agent::Driver::Default->make($Prefix);\n\t}\n\n\t$Prefix = $Driver->prefix;\n\t$Trace = level_from_prio($Trace) if defined $Trace && $Trace =~ /^\\D+/;\n\t$Debug = level_from_prio($Debug) if defined $Debug && $Debug =~ /^\\D+/;\n\n\t#\n\t# Handle -caller => [ <options for Log::Agent::Tag::Caller's make> ]\n\t#\n\n\tif (defined $calldef) {\n\t\tunless (ref $calldef eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -caller must supply an array ref\");\n\t\t}\n\t\trequire Log::Agent::Tag::Caller;\n\t\t$Caller = Log::Agent::Tag::Caller->make(-offset => 3, @{$calldef});\n\t};\n\n\t#\n\t# Handle -priority => [ <options for Log::Agent::Tag::Priority's make> ]\n\t#\n\n\tif (defined $priodef) {\n\t\tunless (ref $priodef eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -priority must supply an array ref\");\n\t\t}\n\t\t$Priorities = $priodef;\t\t# Objects created via prio_tag()\n\t};\n\n\t#\n\t# Handle -tags => [ <list of Log::Agent::Tag objects> ]\n\t#\n\n\tif (defined $tags) {\n\t\tunless (ref $tags eq 'ARRAY') {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -tags must supply an array ref\");\n\t\t}\n\t\tmy $type = \"Log::Agent::Tag\";\n\t\tif (grep { !ref $_ || !$_->isa($type) } @$tags) {\n\t\t\trequire Carp;\n\t\t\tCarp::croak(\"Argument -tags must supply list of $type objects\");\n\t\t}\n\t\tif (@$tags) {\n\t\t\trequire Log::Agent::Tag_List;\n\t\t\t$Tags = Log::Agent::Tag_List->make(@$tags);\n\t\t} else {\n\t\t\tundef $Tags;\n\t\t}\n\t}\n\n\t# Install interceptor if needed\n\tDATUM_is_here() if defined $DATUM && $DATUM;\n}\n\n#\n# inited\n#\n# Returns whether Log::Agent was inited.\n# NOT exported, must be called as Log::Agent::inited().\n#\nsub inited {\n\treturn 0 unless defined $Driver;\n\treturn ref $Driver ? 1 : 0;\n}\n\n#\n# DATUM_is_here\t\t-- undocumented, but for Carp::Datum\n#\n# Tell Log::Agent that the Carp::Datum package was loaded and configured\n# for debug.\n#\n# If there is a driver configured already, install the interceptor.\n# Otherwise, record that DATUM is here and the interceptor will be installed\n# by logconfig().\n#\n# NOT exported, must be called as Log::Agent::DATUM_is_here().\n#\nsub DATUM_is_here {\n\t$DATUM = 1;\n\treturn unless defined $Driver;\n\treturn if ref $Driver eq 'Log::Agent::Driver::Datum';\n\n\t#\n\t# Install the interceptor.\n\t#\n\n\trequire Log::Agent::Driver::Datum;\n\t$Driver = Log::Agent::Driver::Datum->make($Driver);\n}\n\n#\n# log_default\n#\n# Initialize a default logging driver.\n#\nsub log_default {\n\treturn if defined $Driver;\n\tlogconfig();\n}\n\n#\n# logconfess\n#\n# Die with a full stack trace\n#\nsub logconfess {\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logconfess($str);\n\tbug(\"back from logconfess in driver $Driver\\n\");\n}\n\n#\n# logcroak\n#\n# Fatal error, from the perspective of our caller\n# Error is logged, and then we die.\n#\nsub logcroak {\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcroak(0, $str);\n\tbug(\"back from logxcroak in driver $Driver\\n\");\n}\n\n#\n# logxcroak\n#\n# Same a logcroak, but with a specific additional offset.\n#\nsub logxcroak {\n\tmy $offset = shift;\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcroak($offset, $str);\n\tbug(\"back from logxcroak in driver $Driver\\n\");\n}\n\n#\n# logdie\n#\n# Fatal error\n# Error is logged, and then we die.\n#\nsub logdie {\n\tgoto &logconfess if $Confess;\t\t# Redirected when -confess\n\tmy $ptag = prio_tag(priority_level(CRIT)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logdie($str);\n\tbug(\"back from logdie in driver $Driver\\n\");\n}\n\n#\n# logerr\n#\n# Log error, at the \"error\" level.\n#\nsub logerr {\n\treturn if $Trace < ERROR;\n\tmy $ptag = prio_tag(priority_level(ERROR)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logerr($str);\n}\n\n#\n# logcarp\n#\n# Warning, from the perspective of our caller (at the \"warning\" level)\n#\nsub logcarp {\n\treturn if $Trace < WARN;\n\tmy $ptag = prio_tag(priority_level(WARN)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Driver->logxcarp(0, $str);\n}\n\n#\n# logxcarp\n#\n# Same a logcarp, but with a specific additional offset.\n#\nsub logxcarp {\n\treturn if $Trace < WARN;\n\tmy $offset = shift;\n\tmy $ptag = prio_tag(priority_level(WARN)) if defined $Priorities;\n\tmy $str = tag_format_args($Caller, $ptag, $Tags, \\@_);\n\t&log_default unless defined $Driver;\n\t$Dr", 8192) = 8192
09:01:57.350382 brk(0x19ad000)          = 0x19ad000
09:01:57.350532 stat("/usr/share/perl5/auto/Log/Agent/autosplit.ix", {st_mode=S_IFREG|0644, st_size=404, ...}) = 0
09:01:57.350597 open("/usr/share/perl5/auto/Log/Agent/autosplit.ix", O_RDONLY) = 9
09:01:57.350651 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.350698 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.350758 read(9, "# Index created by AutoSplit for blib/lib/Log/Agent.pm\n#    (file acts as timestamp)\npackage Log::Agent;\nsub logconfig  ;\nsub inited  ;\nsub DATUM_is_here  ;\nsub log_default  ;\nsub logconfess  ;\nsub logcroak  ;\nsub logxcroak  ;\nsub logdie  ;\nsub logerr  ;\nsub logcarp  ;\nsub logxcarp  ;\nsub logwarn  ;\nsub logsay  ;\nsub logtrc  ;\nsub logdbg  ;\nsub logtags  ;\nsub logwrite  ;\nsub bug  ;\nsub prio_tag  ;\n1;\n", 8192) = 404
09:01:57.350873 read(9, "", 8192)       = 0
09:01:57.350920 close(9)                = 0
09:01:57.351033 stat("modules/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351084 stat("modules/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351134 stat("modules/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351183 stat("modules/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351232 stat("/etc/perl/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351281 stat("/etc/perl/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351331 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351382 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351439 stat("/usr/local/share/perl/5.14.2/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351491 stat("/usr/local/share/perl/5.14.2/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351542 stat("/usr/lib/perl5/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351592 stat("/usr/lib/perl5/Log/Agent/Priorities.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.351642 stat("/usr/share/perl5/Log/Agent/Priorities.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.351693 stat("/usr/share/perl5/Log/Agent/Priorities.pm", {st_mode=S_IFREG|0644, st_size=5086, ...}) = 0
09:01:57.351753 open("/usr/share/perl5/Log/Agent/Priorities.pm", O_RDONLY) = 9
09:01:57.351806 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.351855 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.351914 read(9, "#\n# $Id: Priorities.pm,v 1.1 2002/03/09 16:01:37 wendigo Exp $\n#\n#  Copyright (c) 1999, Raphael Manfredi\n#  \n#  You may redistribute only under the terms of the Artistic License,\n#  as specified in the README file that comes with the distribution.\n#\n# HISTORY\n# $Log: Priorities.pm,v $\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.3  2001/04/11 15:51:55  ram\n# patch8: routines are now auto-loaded\n#\n# Revision 0.2.1.2  2001/03/31 10:02:04  ram\n# patch7: fixed off-by-one error in prio_from_level()\n#\n# Revision 0.2.1.1  2000/11/12 14:46:52  ram\n# patch1: fixed indentation\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n# $EndLog$\n#\n\nuse strict;\n\n########################################################################\npackage Log::Agent::Priorities;\n\nrequire Exporter;\nuse AutoLoader 'AUTOLOAD';\nuse vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS @LEVELS);\n@ISA = qw(Exporter);\n\n@LEVELS = qw(NONE EMERG ALERT CRIT ERROR WARN NOTICE INFO DEBUG);\n\n@EXPORT = qw(priority_level);\n@EXPORT_OK = qw(prio_from_level level_from_prio);\npush(@EXPORT_OK, @LEVELS);\n\n%EXPORT_TAGS = (LEVELS => \\@LEVELS);\n\nBEGIN {\n\tsub NONE ()\t\t{-1}\n\tsub EMERG ()\t {0}\n\tsub ALERT ()\t {1}\n\tsub CRIT ()\t\t {2}\n\tsub ERROR ()\t {3}\n\tsub WARN ()\t\t {4}\n\tsub NOTICE ()\t {6}\n\tsub INFO ()\t\t {8}\n\tsub DEBUG ()\t{10}\n}\n\nuse vars qw(@basic_prio %basic_level);\n\n@basic_prio = qw(\n\temergency\n\talert\n\tcritical\n\terror\n\twarning warning\n\tnotice notice\n\tinfo info);\n\n%basic_level = (\n\t'em'\t=> EMERG,\t\t# emergency\n\t'al'\t=> ALERT,\t\t# alert\n\t'cr'\t=> CRIT,\t\t# critical\n\t'er'\t=> ERROR,\t\t# error\n\t'wa'\t=> WARN,\t\t# warning\n\t'no'\t=> NOTICE,\t\t# notice\n\t'in'\t=> INFO,\t\t# info\n\t'de'\t=> DEBUG,\t\t# debug\n);\n\n1;\n__END__\n\n#\n# prio_from_level\n#\n# Given a level, compute suitable priority.\n#\nsub prio_from_level {\n\tmy ($level) = @_;\n\treturn 'none' if $level < 0;\n\treturn 'debug' if $level >= @basic_prio;\n\treturn $basic_prio[$level];\n}\n\n#\n# level_from_prio\n#\n# Given a syslog priority, compute suitable level.\n#\nsub level_from_prio {\n\tmy ($prio) = @_;\n\treturn -1 if lc($prio) eq 'none';\t\t# none & notice would look alike\n\tmy $canonical = lc(substr($prio, 0, 2));\n\treturn 10 unless exists $basic_level{$canonical};\n\treturn $basic_level{$canonical} || -1;\n}\n\n#\n# priority_level\n#\n# Decompiles priority which can be either a single digit, a \"priority\" string\n# or a \"priority:digit\" string. Returns the priority (computed if none) and\n# the level (computed if none).\n#\nsub priority_level {\n\tmy ($id) = @_;\n\treturn (prio_from_level($id), $id) if $id =~ /^\\d+$/;\n\treturn ($1, $2) if $id =~ /^([^:]+):(\\d+)$/;\n\treturn ($id, level_from_prio($id));\n}\n\n=head1 NAME\n\nLog::Agent::Priorities - conversion between syslog priorities and levels\n\n=head1 SYNOPSIS\n\n Not intended to be used directly\n\n=head1 DESCRIPTION\n\nThis package contains routines to convert between syslog priorities\nand logging levels: level_from_prio(\"crit\") yields 2, and\nprio_from_level(4) yields \"warning\", as does prio_from_level(5).\n\nHere are the known priorities (which may be abbreviated to the first\n2 letters, in a case-insensitive manner) and their corresponding\nlogging level:\n\n      Name    Level   Traditional    Export\n    --------- -----  --------------  ------\n    none       -1                    NONE    (special, see text)\n    emergency   0    (emerg, panic)  EMERG\n    alert       1                    ALERT\n    critical    2    (crit)          CRIT\n    error       3    (err)           ERROR\n    warning     4                    WARN\n    notice      6                    NOTICE\n    info        8                    INFO\n    debug       10                   DEBUG\n\nThe values between parenthesis show the traditional syslog priority tokens.\nThe missing levels (5, 7, 9) are there for possible extension.\nThey currently map to the level immediately below.\n\nThe Export column lists the symbolic constants defined by this package.\nThey can be imported selectively, or alltogether via the C<:LEVELS>\ntag, as in:\n\n    use Log::Agent::Priorities qw(:LEVELS);\n\nThe special token \"none\" may be used (and spelled out fully) on special\noccasions: it maps to -1, and is convenient when specifying a logging\nlevel, for instance: specifying \"none\" ensures that B<no logging> will\ntake place, even for emergency situations.\n\nAnywhere where a I<priority> is expected, one may specify a number taken\nas a logging level or a string taken as a priority. If the default\nmapping outlined above is not satisfactory, it can be redefined by\nspecifying, for instance C<\"notice:9\">. It will be taken as being of\nlevel 9, but with a C<notice> priority nonetheless, not C<info> as\nit would have been implicitely determined otherwise.\n\nThe routine priority_level() decompiles C<\"notice:9\"> into (\"notice\", 9),\nand otherwise uses prio_from_level() or level_from_prio() to compute the\nmissing informatin.  For instance, given \"critical\", priority_level()\nroutine will return the tuple (\"critical\", 2).\n\n=head1 AUTHOR\n\nRaphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>\n\n=head1 SEE ALSO\n\nLog::Agent(3), Log::Agent::Logger(3).\n\n=cut\n\n", 8192) = 5086
09:01:57.352237 stat("/usr/share/perl5/auto/Log/Agent/Priorities/autosplit.ix", {st_mode=S_IFREG|0644, st_size=199, ...}) = 0
09:01:57.352303 open("/usr/share/perl5/auto/Log/Agent/Priorities/autosplit.ix", O_RDONLY) = 10
09:01:57.352357 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a730) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.352404 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.352463 read(10, "# Index created by AutoSplit for blib/lib/Log/Agent/Priorities.pm\n#    (file acts as timestamp)\npackage Log::Agent::Priorities;\nsub prio_from_level  ;\nsub level_from_prio  ;\nsub priority_level  ;\n1;\n", 8192) = 199
09:01:57.352538 read(10, "", 8192)      = 0
09:01:57.352586 close(10)               = 0
09:01:57.352815 lseek(9, 1725, SEEK_SET) = 1725
09:01:57.352861 lseek(9, 0, SEEK_CUR)   = 1725
09:01:57.352906 close(9)                = 0
09:01:57.353081 stat("modules/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353136 stat("modules/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353187 stat("modules/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353236 stat("modules/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353285 stat("/etc/perl/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353335 stat("/etc/perl/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353384 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353436 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353492 stat("/usr/local/share/perl/5.14.2/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353543 stat("/usr/local/share/perl/5.14.2/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353593 stat("/usr/lib/perl5/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353643 stat("/usr/lib/perl5/Log/Agent/Formatting.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.353696 stat("/usr/share/perl5/Log/Agent/Formatting.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.353746 stat("/usr/share/perl5/Log/Agent/Formatting.pm", {st_mode=S_IFREG|0644, st_size=4232, ...}) = 0
09:01:57.353806 open("/usr/share/perl5/Log/Agent/Formatting.pm", O_RDONLY) = 9
09:01:57.353859 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.353906 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.353965 read(9, "###########################################################################\n# $Id: Formatting.pm,v 1.6 2005/10/02 16:47:36 wendigo Exp $\n###########################################################################\n#\n# Log::Agent::Formatting\n#\n# RCS Revision: $Revision: 1.6 $\n# Date: $Date: 2005/10/02 16:47:36 $\n#\n# Copyright (c) 1999 Raphael Manfredi\n# Copyright (c) 2002-2003,2005 Mark Rogaski, mrogaski@cpan.org;\n# all rights reserved.\n#\n# See the README file included with the\n# distribution for license information.\n#\n# $Log: Formatting.pm,v $\n# Revision 1.6  2005/10/02 16:47:36  wendigo\n# Fixed formatting behavior for strings that contain \"%%\" without any other\n# formating characters.\n#\n# Revision 1.5  2003/09/27 18:11:16  wendigo\n# Modified comments.\n#\n# Revision 1.4  2003/09/27 17:41:41  wendigo\n# Modified to use $Log::Agent::OS_Error for substitution of %m instead\n# of $!.\n#\n# Revision 1.3  2003/03/08 16:40:27  wendigo\n# Merged format and multiline carp changes\n#\n# Revision 1.2.2.1  2002/12/13 04:25:24  wendigo\n# Fixed logxxx() formatting to match sprintf semantics.\n#\n# Revision 1.2  2002/05/12 07:20:03  wendigo\n# Reduced format_args to adjust_msg\n# Added prechecks of sprintf() arguments\n#\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.1  2001/03/13 18:45:06  ram\n# patch2: renamed caller_format_args() as tag_format_args()\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n###########################################################################\n\nuse strict;\nrequire Exporter;\n\n########################################################################\npackage Log::Agent::Formatting;\n\nuse vars qw(@ISA @EXPORT_OK);\n\n@ISA = qw(Exporter);\n@EXPORT_OK = qw(format_args tag_format_args);\n\nrequire Log::Agent::Message;\n\n#\n# adjust_fmt\n# \n# We process syslog's %m macro as being the current error message ($!) in\n# the first argument only. Doing it at this level means it will be supported\n# independently from the driver they'll choose. It's also done BEFORE any\n# log-related system call, thus ensuring that $! retains its original value.\n#\nif ($] >= 5.005) {\n    eval q{     # if VERSION >= 5.005\n        # 5.005 and later version grok /(?<!)/\n        sub adjust_fmt {\n            my $fmt = shift;\n            $fmt =~ s/((?<!%)(?:%%)*)%m/$Log::Agent::OS_Error/g;\n            return $fmt;\n        }\n    }\n} else {\n    eval q{     # else /* VERSION < 5.005 */\n        # pre-5.005 does not grok /(?<!)/\n        sub adjust_fmt {\n            my $fmt = shift;\n            $fmt =~ s/%%/\\01/g;\n            $fmt =~ s/%m/$Log::Agent::OS_Error/g;\n            $fmt =~ s/\\01/%%/g;\n            return $fmt;\n        }\n    }\n}       # endif /* VERSION >= 5.005 */\n\n#\n# whine\n#\n# This is a local hack of carp \n#\nsub whine {\n    my $msg = shift;\n    unless (chomp $msg) {\n        my($package, $filename, $line) = caller 2;\n        $msg .= \" at $filename line $line.\";\n    }\n    warn \"$msg\\n\";\n}\n\n#\n# tag_format_args\n#\n# Arguments:\n#\n#   $caller     caller information, done firstly\n#   $priority   priority information, done secondly\n#   $tags       list of user-defined tags, done lastly\n#   $ary        arguments for sprintf()\n#\n# Returns a Log::Agent::Message object, which, when stringified, prints\n# the string itself.\n#\nsub tag_format_args {\n    my ($caller, $priority, $tags, $ary) = @_;\n    my $msg = adjust_fmt(shift @$ary);\n\n    # This bit of tomfoolery is intended to make debugging of\n    # programs a bit easier by prechecking input to sprintf() \n    # for errors.  I usually prefer lazy error checking, but \n    # this seems to be an appropriate exception.\n    if (my @arglist = $msg =~ /\\%[^\\%]*[csduoxefgXEGbpniDUOF]|\\%\\%/g) {\n        BEGIN { no warnings }\n        my $argcnt = grep !/\\%\\%/, @arglist;\n        if (grep {! defined} @$ary[0..($argcnt - 1)]) {\n            whine(\"Use of uninitialized value in sprintf\");\n        }\n        $msg = sprintf $msg, @$ary;\n    }\n\n    my $str = Log::Agent::Message->make($msg);\n    $caller->insert($str) if defined $caller;\n    $priority->insert($str) if defined $priority;\n    if (defined $tags) {\n        foreach my $tag (@$tags) {\n            $tag->insert($str);\n        }\n    }\n    return $str;\n}\n\n1;\n\n", 8192) = 4232
09:01:57.354477 read(9, "", 8192)       = 0
09:01:57.354528 close(9)                = 0
09:01:57.354589 stat("modules/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.354640 stat("modules/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.354690 stat("modules/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.354739 stat("modules/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.354788 stat("/etc/perl/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.354838 stat("/etc/perl/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.354888 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.354939 stat("/usr/local/lib/perl/5.14.2/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.354990 stat("/usr/local/share/perl/5.14.2/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.355041 stat("/usr/local/share/perl/5.14.2/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.355092 stat("/usr/lib/perl5/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.355142 stat("/usr/lib/perl5/Log/Agent/Message.pm", 0x7ffe1233afd0) = -1 ENOENT (No such file or directory)
09:01:57.355191 stat("/usr/share/perl5/Log/Agent/Message.pmc", 0x7ffe1233b080) = -1 ENOENT (No such file or directory)
09:01:57.355241 stat("/usr/share/perl5/Log/Agent/Message.pm", {st_mode=S_IFREG|0644, st_size=5491, ...}) = 0
09:01:57.355300 open("/usr/share/perl5/Log/Agent/Message.pm", O_RDONLY) = 9
09:01:57.355352 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad60) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.355399 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.355457 read(9, "#\n# $Id: Message.pm,v 1.1 2002/03/09 16:01:37 wendigo Exp $\n#\n#  Copyright (c) 1999, Raphael Manfredi\n#  \n#  You may redistribute only under the terms of the Artistic License,\n#  as specified in the README file that comes with the distribution.\n#\n# HISTORY\n# $Log: Message.pm,v $\n# Revision 1.1  2002/03/09 16:01:37  wendigo\n# New maintainer\n#\n# Revision 0.2.1.1  2001/03/31 10:01:22  ram\n# patch7: fixed =over to add explicit indent level\n#\n# Revision 0.2  2000/11/06 19:30:33  ram\n# Baseline for second Alpha release.\n#\n# $EndLog$\n#\n\nuse strict;\n\n########################################################################\npackage Log::Agent::Message;\n\nuse overload\n\tqw(\"\" stringify);\n\n#\n# ->make\n#\n# Creation routine.\n#\n# Attributes:\n#\tstr\t\t\t\tformatted message string coming from user\n#\tprepend_list\tlist of strings to prepend to `str'\n#\tappend_list\t\tlist of strings to append to `str'\n#\nsub make {\n\tmy $self = bless [], shift;\t\t# Array for minimal overhead\n\t$self->[0] = $_[0];\n\treturn $self;\n}\n\n#\n# Attribute access\n#\n\nsub str\t\t\t\t{ $_[0]->[0] }\nsub prepend_list\t{ $_[0]->[1] }\nsub append_list\t\t{ $_[0]->[2] }\n\n#\n# Attribute setting\n#\n\nsub set_str\t\t\t\t{ $_[0]->[0] = $_[1] }\nsub set_prepend_list\t{ $_[0]->[1] = $_[1] }\nsub set_append_list\t\t{ $_[0]->[2] = $_[1] }\n\n#\n# ->prepend\n#\n# Add string to the prepend list, at its TAIL.\n# (i.e. the first to prepend gets output first)\n#\nsub prepend {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->prepend_list;\n\t$array = $self->set_prepend_list([]) unless $array;\n\n\tpush(@{$array}, $str);\n}\n\n#\n# ->prepend_first\n#\n# Add string to the prepend list, at its HEAD.\n#\nsub prepend_first {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->prepend_list;\n\t$array = $self->set_prepend_list([]) unless $array;\n\n\tunshift(@{$array}, $str);\n}\n\n#\n# ->append\n#\n# Add string to the append list, at its HEAD.\n# (i.e. the first to append gets output last)\n#\nsub append {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->append_list;\n\t$array = $self->set_append_list([]) unless $array;\n\n\tunshift(@{$array}, $str);\n}\n\n#\n# ->append_last\n#\n# Add string to the append list, at its TAIL.\n#\nsub append_last {\n\tmy $self = shift;\n\tmy ($str) = @_;\n\n\tmy $array = $self->append_list;\n\t$array = $self->set_append_list([]) unless $array;\n\n\tpush(@{$array}, $str);\n}\n\n#\n# ->stringify\n# (stringify)\n#\n# Returns complete string, with all prepended strings first, then the\n# original string followed by all the appended strings.\n#\nsub stringify {\n\tmy $self = shift;\n\treturn $self->[0] if @{$self} == 1;\t\t# Optimize usual case\n\n\tmy $prepend = $self->prepend_list;\n\tmy $append = $self->append_list;\n\n\treturn\n\t\t($prepend ? join('', @{$prepend}) : '') .\n\t\t$self->str .\n\t\t($append ? join('', @{$append}) : '');\n}\n\n#\n# ->clone\n#\n# Clone object\n# (not a deep clone, but prepend and append lists are also shallow-cloned.)\n#\nsub clone {\n\tmy $self = shift;\n\tmy $other = bless [], ref $self;\n\t$other->[0] = $self->[0];\n\treturn $other if @{$self} == 1;\t\t\t# Optimize usual case\n\n\tif (defined $self->[1]) {\n\t\tmy @array = @{$self->[1]};\n\t\t$other->[1] = \\@array;\n\t}\n\tif (defined $self->[2]) {\n\t\tmy @array = @{$self->[2]};\n\t\t$other->[2] = \\@array;\n\t}\n\n\treturn $other;\n}\n\n1;\t# for require\n__END__\n\n=head1 NAME\n\nLog::Agent::Message - a log message\n\n=head1 SYNOPSIS\n\n require Log::Agent::Message;\n\n my $msg = Log::Agent::Message->make(\"string\");\n $msg->prepend(\"string\");\n $msg->append(\"string\");\n my $copy = $msg->clone;\n\n print \"Message is $msg\\n\";     # overloaded stringification\n\n=head1 DESCRIPTION\n\nThe Log::Agent::Message class represents an original log message\n(a string) to which one may prepend or append other strings, but with\nthe special property that prepended strings aggregate themselves\nin FIFO order, whilst appended strings aggregate themselves in LIFO\norder, which is counter-intuitive at first sight.\n\nIn plain words, this means that the last routine that prepends something\nto the message will get its prepended string right next to the original\nstring, regardless of what could have been prepended already. The behaviour\nis symetric for appending.\n\n=head1 INTERFACE\n\nThe following routines are available:\n\n=over 4\n\n=item append($str)\n\nAppend suppled string $str to the original string (given at creation\ntime), at the head of all existing appended strings.\n\n=item append_last($str)\n\nAppend suppled string $str to the original string (given at creation\ntime), at the tail of all existing appended strings.\n\n=item clone\n\nClone the message. This is not a shallow clone, because the list of\nprepended and appended strings is recreated. However it is not a deep\nclone, because the items held in those lists are merely copied (this would\nmatter only when other objects with overloaded stringification routines\nwere supplied to prepend() and append(), which is not the case today in\nthe basic Log::Agent framework).\n\n=item make($string)\n\nThis is the creation routine.\n\n=item prepend($str)\n\nPrepend supplied string $str to the original string (given at creation\ntime), at the tail of all existing prepended strings.\n\n=item prepend_first($str)\n\nPrepend supplied string $str to the original string (given at creation\ntime), at the head of all existing prepended strings.\n\n=item stringify\n\nThis is the overloaded \"\" operator, which returns the complete string\ncomposed of all the prepended strings, the original string, and all\nthe appended strings.\n\n=back\n\n=head1 AUTHOR\n\nRaphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>\n\n=head1 SEE ALSO\n\nLog::Agent(3).\n\n=cut\n", 8192) = 5491
09:01:57.356044 brk(0x19ce000)          = 0x19ce000
09:01:57.356138 lseek(9, 3208, SEEK_SET) = 3208
09:01:57.356184 lseek(9, 0, SEEK_CUR)   = 3208
09:01:57.356228 close(9)                = 0
09:01:57.356375 lseek(8, 1544, SEEK_SET) = 1544
09:01:57.356421 lseek(8, 0, SEEK_CUR)   = 1544
09:01:57.356466 close(8)                = 0
09:01:57.357416 read(7, "ieve($_[0], 0);\n}\n\n#\n# lock_retrieve\n#\n# Same as retrieve, but with advisory locking.\n#\nsub lock_retrieve {\n\t_retrieve($_[0], 1);\n}\n\n# Internal retrieve routine\nsub _retrieve {\n\tmy ($file, $use_locking) = @_;\n\tlocal *FILE;\n\topen(FILE, $file) || logcroak \"can't open $file: $!\";\n\tbinmode FILE;\t\t\t\t\t\t\t# Archaic systems...\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\tif ($use_locking) {\n\t\tunless (&CAN_FLOCK) {\n\t\t\tlogcarp\n\t\t\t\t\"Storable::lock_store: fcntl/flock emulation broken on $^O\";\n\t\t\treturn undef;\n\t\t}\n\t\tflock(FILE, LOCK_SH) || logcroak \"can't get shared lock on $file: $!\";\n\t\t# Unlocking will happen when FILE is closed\n\t}\n\teval { $self = pretrieve(*FILE) };\t\t# Call C routine\n\tclose(FILE);\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\n#\n# fd_retrieve\n#\n# Same as retrieve, but perform from an already opened file descriptor instead.\n#\nsub fd_retrieve {\n\tmy ($file) = @_;\n\tmy $fd = fileno($file);\n\tlogcroak \"not a valid file descriptor\" unless defined $fd;\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\teval { $self = pretrieve($file) };\t\t# Call C routine\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\nsub retrieve_fd { &fd_retrieve }\t\t# Backward compatibility\n\n#\n# thaw\n#\n# Recreate objects in memory from an existing frozen image created\n# by freeze.  If the frozen image passed is undef, return undef.\n#\nsub thaw {\n\tmy ($frozen) = @_;\n\treturn undef unless defined $frozen;\n\tmy $self;\n\tmy $da = $@;\t\t\t\t\t\t\t# Could be from exception handler\n\teval { $self = mretrieve($frozen) };\t# Call C routine\n\tlogcroak $@ if $@ =~ s/\\.?\\n$/,/;\n\t$@ = $da;\n\treturn $self;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nStorable - persistence for Perl data structures\n\n=head1 SYNOPSIS\n\n use Storable;\n store \\%table, 'file';\n $hashref = retrieve('file');\n\n use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);\n\n # Network order\n nstore \\%table, 'file';\n $hashref = retrieve('file');\t# There is NO nretrieve()\n\n # Storing to and retrieving from an already opened file\n store_fd \\@array, \\*STDOUT;\n nstore_fd \\%table, \\*STDOUT;\n $aryref = fd_retrieve(\\*SOCKET);\n $hashref = fd_retrieve(\\*SOCKET);\n\n # Serializing to memory\n $serialized = freeze \\%table;\n %table_clone = %{ thaw($serialized) };\n\n # Deep (recursive) cloning\n $cloneref = dclone($ref);\n\n # Advisory locking\n use Storable qw(lock_store lock_nstore lock_retrieve)\n lock_store \\%table, 'file';\n lock_nstore \\%table, 'file';\n $hashref = lock_retrieve('file');\n\n=head1 DESCRIPTION\n\nThe Storable package brings persistence to your Perl data structures\ncontaining SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be\nconveniently stored to disk and retrieved at a later time.\n\nIt can be used in the regular procedural way by calling C<store> with\na reference to the object to be stored, along with the file name where\nthe image should be written.\n\nThe routine returns C<undef> for I/O problems or other internal error,\na true value otherwise. Serious errors are propagated as a C<die> exception.\n\nTo retrieve data stored to disk, use C<retrieve> with a file name.\nThe objects stored into that file are recreated into memory for you,\nand a I<reference> to the root object is returned. In case an I/O error\noccurs while reading, C<undef> is returned instead. Other serious\nerrors are propagated via C<die>.\n\nSince storage is performed recursively, you might want to stuff references\nto objects that share a lot of common data into a single array or hash\ntable, and then store that object. That way, when you retrieve back the\nwhole thing, the objects will continue to share what they originally shared.\n\nAt the cost of a slight header overhead, you may store to an already\nopened file descriptor using the C<store_fd> routine, and retrieve\nfrom a file via C<fd_retrieve>. Those names aren't imported by default,\nso you will have to do that explicitly if you need those routines.\nThe file descriptor you supply must be already opened, for read\nif you're going to retrieve and for write if you wish to store.\n\n\tstore_fd(\\%table, *STDOUT) || die \"can't store to stdout\\n\";\n\t$hashref = fd_retrieve(*STDIN);\n\nYou can also store data in network order to allow easy sharing across\nmultiple platforms, or when storing on a socket known to be remotely\nconnected. The routines to call have an initial C<n> prefix for I<network>,\nas in C<nstore> and C<nstore_fd>. At retrieval time, your data will be\ncorrectly restored so you don't have to know whether you're restoring\nfrom native or network ordered data.  Double values are stored stringified\nto ensure portability as well, at the slight risk of loosing some precision\nin the last decimals.\n\nWhen using C<fd_retrieve>, objects are retrieved in sequence, one\nobject (i.e. one recursive tree) per associated C<store_fd>.\n\nIf you're more from the object-oriented camp, you can inherit from\nStorable and directly store your objects by invoking C<store> as\na method. The fact that the root of the to-be-stored tree is a\nblessed reference (i.e. an object) is special-cased so that the\nretrieve does not provide a reference to that object but rather the\nblessed object reference itself. (Otherwise, you'd get a reference\nto that blessed object).\n\n=head1 MEMORY STORE\n\nThe Storable engine can also store data into a Perl scalar instead, to\nlater retrieve them. This is mainly used to freeze a complex structure in\nsome safe compact memory place (where it can possibly be sent to another\nprocess via some IPC, since freezing the structure also serializes it in\neffect). Later on, and maybe somewhere else, you can thaw the Perl scalar\nout and recreate the original complex structure in memory.\n\nSurprisingly, the routines to be called are named C<freeze> and C<thaw>.\nIf you wish to send out the frozen scalar to another machine, use\nC<nfreeze> instead to get a portable image.\n\nNote that freezing an object structure and immediately thawing it\nactually achieves a deep cloning of that structure:\n\n    dclone(.) = thaw(freeze(.))\n\nStorable provides you with a C<dclone> interface which does not create\nthat intermediary scalar but instead freezes the structure in some\ninternal memory space and then immediately thaws it out.\n\n=head1 ADVISORY LOCKING\n\nThe C<lock_store> and C<lock_nstore> routine are equivalent to\nC<store> and C<nstore>, except that they get an exclusive lock on\nthe file before writing.  Likewise, C<lock_retrieve> does the same\nas C<retrieve>, but also gets a shared lock on the file before reading.\n\nAs with any advisory locking scheme, the protection only works if you\nsystematically use C<lock_store> and C<lock_retrieve>.  If one side of\nyour application uses C<store> whilst the other uses C<lock_retrieve>,\nyou will get no protection at all.\n\nThe internal advisory locking is implemented using Perl's flock()\nroutine.  If your system does not support any form of flock(), or if\nyou share your files across NFS, you might wish to use other forms\nof locking by using modules such as LockFile::Simple which lock a\nfile using a filesystem entry, instead of locking the file descriptor.\n\n=head1 SPEED\n\nThe heart of Storable is written in C for decent speed. Extra low-level\noptimizations have been made when manipulating perl internals, to\nsacrifice encapsulation for the benefit of greater speed.\n\n=head1 CANONICAL REPRESENTATION\n\nNormally, Storable stores elements of hashes in the order they are\nstored internally by Perl, i.e. pseudo-randomly.  If you set\nC<$Storable::canonical> to some C<TRUE> value, Storable will store\nhashes with the elements sorted by their key.  This allows you to\ncompare data structures by comparing their frozen representations (or\neven the compressed frozen representations), which can be useful for\ncreating lookup tables for complicated queries.\n\nCanonical order does not imply network order; those are two orthogonal\nsettings.\n\n=head1 CODE REFERENCES\n\nSince Storable version 2.05, CODE references may be serialized with\nthe help of L<B::Deparse>. To enable this feature, set\nC<$Storable::Deparse> to a true value. To enable deserialization,\nC<$Storable::Eval> should be set to a true value. Be aware that\ndeserialization is done through C<eval>, which is dangerous if the\nStorable fi", 8192) = 8192
09:01:57.358068 lseek(7, 9846, SEEK_SET) = 9846
09:01:57.358120 lseek(7, 0, SEEK_CUR)   = 9846
09:01:57.358165 close(7)                = 0
09:01:57.358258 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.bs", {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
09:01:57.358326 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.so", {st_mode=S_IFREG|0555, st_size=345692, ...}) = 0
09:01:57.358385 stat("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.bs", {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
09:01:57.358460 open("/usr/local/lib/perl/5.14.2/auto/Storable/Storable.so", O_RDONLY) = 7
09:01:57.358514 read(7, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\2400\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\32\5\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0%\0\"\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\254>\1\0\0\0\0\0\254>\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0@\1\0\0\0\0\0\0@!\0\0\0\0\0\0@!\0\0\0\0\0@\10\0\0\0\0\0\0H\10\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\210B\1\0\0\0\0\0\210B!\0\0\0\0\0\210B!\0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0x.\1\0\0\0\0\0x.\1\0\0\0\0\0x.\1\0\0\0\0\0,\2\0\0\0\0\0\0,\2\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0!\230\7\364\31\362\271 ;\244\255J\302\r\27\317?\355\366\10\0\0\0\0a\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\0\0\0\0o\0\0\0H\0\0\0\0\0\0\0T\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\36\0\0\0O\0\0\0r\0\0\0\25\0\0\0P\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0m\0\0\0^\0\0\0K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0A\0\0\0_\0\0\0F\0\0\0U\0\0\0q\0\0\0X\0\0\0!\0\0\0\0\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0I\0\0\0+\0\0\0c\0\0\0\20\0\0\0b\0\0\0J\0\0\0l\0\0\0;\0\0\0S\0\0\0\0\0\0\0\0\0\0\0[\0\0\0*\0\0\0\"\0\0\0d\0\0\0\30\0\0\0Q\0\0\0@\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0\21\0\0\0\v\0\0\0t\0\0\0:\0\0\0R\0\0\0\32\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0G\0\0\0<\0\0\0008\0\0\0&\0\0\0-\0\0\0\0\0\0\0?\0\0\0a\0\0\0\4\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\0\0C\0\0\0\0\0\0\0g\0\0\0V\0\0\0'\0\0\0", 832) = 832
09:01:57.358647 fstat(7, {st_mode=S_IFREG|0555, st_size=345692, ...}) = 0
09:01:57.358709 mmap(NULL, 2181192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 7, 0) = 0x7f74325a8000
09:01:57.358760 mprotect(0x7f74325bc000, 2097152, PROT_NONE) = 0
09:01:57.358809 mmap(0x7f74327bc000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 7, 0x14000) = 0x7f74327bc000
09:01:57.358864 close(7)                = 0
09:01:57.359039 stat("modules/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359092 stat("modules/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359141 stat("modules/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359189 stat("modules/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359238 stat("/etc/perl/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359287 stat("/etc/perl/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359336 stat("/usr/local/lib/perl/5.14.2/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359387 stat("/usr/local/lib/perl/5.14.2/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359437 stat("/usr/local/share/perl/5.14.2/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359488 stat("/usr/local/share/perl/5.14.2/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359539 stat("/usr/lib/perl5/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359587 stat("/usr/lib/perl5/URI.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.359637 stat("/usr/share/perl5/URI.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.359687 stat("/usr/share/perl5/URI.pm", {st_mode=S_IFREG|0644, st_size=33800, ...}) = 0
09:01:57.359745 open("/usr/share/perl5/URI.pm", O_RDONLY) = 7
09:01:57.359797 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.359847 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.359906 read(7, "package URI;\n\nuse strict;\nuse vars qw($VERSION);\n$VERSION = \"1.60\";\n\nuse vars qw($ABS_REMOTE_LEADING_DOTS $ABS_ALLOW_RELATIVE_SCHEME $DEFAULT_QUERY_FORM_DELIMITER);\n\nmy %implements;  # mapping from scheme to implementor class\n\n# Some \"official\" character classes\n\nuse vars qw($reserved $mark $unreserved $uric $scheme_re);\n$reserved   = q(;/?:@&=+$,[]);\n$mark       = q(-_.!~*'());                                    #'; emacs\n$unreserved = \"A-Za-z0-9\\Q$mark\\E\";\n$uric       = quotemeta($reserved) . $unreserved . \"%\";\n\n$scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\\-]*';\n\nuse Carp ();\nuse URI::Escape ();\n\nuse overload ('\"\"'     => sub { ${$_[0]} },\n              '=='     => sub { _obj_eq(@_) },\n              '!='     => sub { !_obj_eq(@_) },\n              fallback => 1,\n             );\n\n# Check if two objects are the same object\nsub _obj_eq {\n    return overload::StrVal($_[0]) eq overload::StrVal($_[1]);\n}\n\nsub new\n{\n    my($class, $uri, $scheme) = @_;\n\n    $uri = defined ($uri) ? \"$uri\" : \"\";   # stringify\n    # Get rid of potential wrapping\n    $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # \n    $uri =~ s/^\"(.*)\"$/$1/;\n    $uri =~ s/^\\s+//;\n    $uri =~ s/\\s+$//;\n\n    my $impclass;\n    if ($uri =~ m/^($scheme_re):/so) {\n\t$scheme = $1;\n    }\n    else {\n\tif (($impclass = ref($scheme))) {\n\t    $scheme = $scheme->scheme;\n\t}\n\telsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {\n\t    $scheme = $1;\n        }\n    }\n    $impclass ||= implementor($scheme) ||\n\tdo {\n\t    require URI::_foreign;\n\t    $impclass = 'URI::_foreign';\n\t};\n\n    return $impclass->_init($uri, $scheme);\n}\n\n\nsub new_abs\n{\n    my($class, $uri, $base) = @_;\n    $uri = $class->new($uri, $base);\n    $uri->abs($base);\n}\n\n\nsub _init\n{\n    my $class = shift;\n    my($str, $scheme) = @_;\n    # find all funny characters and encode the bytes.\n    $str = $class->_uric_escape($str);\n    $str = \"$scheme:$str\" unless $str =~ /^$scheme_re:/o ||\n                                 $class->_no_scheme_ok;\n    my $self = bless \\$str, $class;\n    $self;\n}\n\n\nsub _uric_escape\n{\n    my($class, $str) = @_;\n    $str =~ s*([^$uric\\#])* URI::Escape::escape_char($1) *ego;\n    utf8::downgrade($str);\n    return $str;\n}\n\n\nsub implementor\n{\n    my($scheme, $impclass) = @_;\n    if (!$scheme || $scheme !~ /\\A$scheme_re\\z/o) {\n\trequire URI::_generic;\n\treturn \"URI::_generic\";\n    }\n\n    $scheme = lc($scheme);\n\n    if ($impclass) {\n\t# Set the implementor class for a given scheme\n        my $old = $implements{$scheme};\n        $impclass->_init_implementor($scheme);\n        $implements{$scheme} = $impclass;\n        return $old;\n    }\n\n    my $ic = $implements{$scheme};\n    return $ic if $ic;\n\n    # scheme not yet known, look for internal or\n    # preloaded (with 'use') implementation\n    $ic = \"URI::$scheme\";  # default location\n\n    # turn scheme into a valid perl identifier by a simple transformation...\n    $ic =~ s/\\+/_P/g;\n    $ic =~ s/\\./_O/g;\n    $ic =~ s/\\-/_/g;\n\n    no strict 'refs';\n    # check we actually have one for the scheme:\n    unless (@{\"${ic}::ISA\"}) {\n        # Try to load it\n        eval \"require $ic\";\n        die $@ if $@ && $@ !~ /Can\\'t locate.*in \\@INC/;\n        return unless @{\"${ic}::ISA\"};\n    }\n\n    $ic->_init_implementor($scheme);\n    $implements{$scheme} = $ic;\n    $ic;\n}\n\n\nsub _init_implementor\n{\n    my($class, $scheme) = @_;\n    # Remember that one implementor class may actually\n    # serve to implement several URI schemes.\n}\n\n\nsub clone\n{\n    my $self = shift;\n    my $other = $$self;\n    bless \\$other, ref $self;\n}\n\n\nsub _no_scheme_ok { 0 }\n\nsub _scheme\n{\n    my $self = shift;\n\n    unless (@_) {\n\treturn unless $$self =~ /^($scheme_re):/o;\n\treturn $1;\n    }\n\n    my $old;\n    my $new = shift;\n    if (defined($new) && length($new)) {\n\tCarp::croak(\"Bad scheme '$new'\") unless $new =~ /^$scheme_re$/o;\n\t$old = $1 if $$self =~ s/^($scheme_re)://o;\n\tmy $newself = URI->new(\"$new:$$self\");\n\t$$self = $$newself; \n\tbless $self, ref($newself);\n    }\n    else {\n\tif ($self->_no_scheme_ok) {\n\t    $old = $1 if $$self =~ s/^($scheme_re)://o;\n\t    Carp::carp(\"Oops, opaque part now look like scheme\")\n\t\tif $^W && $$self =~ m/^$scheme_re:/o\n\t}\n\telse {\n\t    $old = $1 if $$self =~ m/^($scheme_re):/o;\n\t}\n    }\n\n    return $old;\n}\n\nsub scheme\n{\n    my $scheme = shift->_scheme(@_);\n    return unless defined $scheme;\n    lc($scheme);\n}\n\n\nsub opaque\n{\n    my $self = shift;\n\n    unless (@_) {\n\t$$self =~ /^(?:$scheme_re:)?([^\\#]*)/o or die;\n\treturn $1;\n    }\n\n    $$self =~ /^($scheme_re:)?    # optional scheme\n\t        ([^\\#]*)          # opaque\n                (\\#.*)?           # optional fragment\n              $/sx or die;\n\n    my $old_scheme = $1;\n    my $old_opaque = $2;\n    my $old_frag   = $3;\n\n    my $new_opaque = shift;\n    $new_opaque = \"\" unless defined $new_opaque;\n    $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;\n    utf8::downgrade($new_opaque);\n\n    $$self = defined($old_scheme) ? $old_scheme : \"\";\n    $$self .= $new_opaque;\n    $$self .= $old_frag if defined $old_frag;\n\n    $old_opaque;\n}\n\n*path = \\&opaque;  # alias\n\n\nsub fragment\n{\n    my $self = shift;\n    unless (@_) {\n\treturn unless $$self =~ /\\#(.*)/s;\n\treturn $1;\n    }\n\n    my $old;\n    $old = $1 if $$self =~ s/\\#(.*)//s;\n\n    my $new_frag = shift;\n    if (defined $new_frag) {\n\t$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;\n\tutf8::downgrade($new_frag);\n\t$$self .= \"#$new_frag\";\n    }\n    $old;\n}\n\n\nsub as_string\n{\n    my $self = shift;\n    $$self;\n}\n\n\nsub as_iri\n{\n    my $self = shift;\n    my $str = $$self;\n    if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {\n\t# All this crap because the more obvious:\n\t#\n\t#   Encode::decode(\"UTF-8\", $str, sub { sprintf \"%%%02X\", shift })\n\t#\n\t# doesn't work before Encode 2.39.  Wait for a standard release\n\t# to bundle that version.\n\n\trequire Encode;\n\tmy $enc = Encode::find_encoding(\"UTF-8\");\n\tmy $u = \"\";\n\twhile (length $str) {\n\t    $u .= $enc->decode($str, Encode::FB_QUIET());\n\t    if (length $str) {\n\t\t# escape next char\n\t\t$u .= URI::Escape::escape_char(substr($str, 0, 1, \"\"));\n\t    }\n\t}\n\t$str = $u;\n    }\n    return $str;\n}\n\n\nsub canonical\n{\n    # Make sure scheme is lowercased, that we don't escape unreserved chars,\n    # and that we use upcase escape sequences.\n\n    my $self = shift;\n    my $scheme = $self->_scheme || \"\";\n    my $uc_scheme = $scheme =~ /[A-Z]/;\n    my $esc = $$self =~ /%[a-fA-F0-9]{2}/;\n    return $self unless $uc_scheme || $esc;\n\n    my $other = $self->clone;\n    if ($uc_scheme) {\n\t$other->_scheme(lc $scheme);\n    }\n    if ($esc) {\n\t$$other =~ s{%([0-9a-fA-F]{2})}\n\t            { my $a = chr(hex($1));\n                      $a =~ /^[$unreserved]\\z/o ? $a : \"%\\U$1\"\n                    }ge;\n    }\n    return $other;\n}\n\n# Compare two URIs, subclasses will provide a more correct implementation\nsub eq {\n    my($self, $other) = @_;\n    $self  = URI->new($self, $other) unless ref $self;\n    $other = URI->new($other, $self) unless ref $other;\n    ref($self) eq ref($other) &&                # same class\n\t$self->canonical->as_string eq $other->canonical->as_string;\n}\n\n# generic-URI transformation methods\nsub abs { $_[0]; }\nsub rel { $_[0]; }\n\nsub secure { 0 }\n\n# help out Storable\nsub STORABLE_freeze {\n       my($self, $cloning) = @_;\n       return $$self;\n}\n\nsub STORABLE_thaw {\n       my($self, $cloning, $str) = @_;\n       $$self = $str;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nURI - Uniform Resource Identifiers (absolute and relative)\n\n=head1 SYNOPSIS\n\n $u1 = URI->new(\"http://www.perl.com\");\n $u2 = URI->new(\"foo\", \"http\");\n $u3 = $u2->abs($u1);\n $u4 = $u3->clone;\n $u5 = URI->new(\"HTTP://WWW.perl.com:80\")->canonical;\n\n $str = $u->as_string;\n $str = \"$u\";\n\n $scheme = $u->scheme;\n $opaque = $u->opaque;\n $path   = $u->path;\n $frag   = $u->fragment;\n\n $u->scheme(\"ftp\");\n $u->host(\"ftp.perl.com\");\n $u->path(\"cpan/\");\n\n=head1 DESCRIPTION\n\nThis module implements the C<URI> class.  Objects of this class\nrepresent \"Uniform Resource Identifier references\" as specified in RFC\n2396 (and updated by RFC 2732).\n\nA Uniform Resource Identifier is a compact string of characters that\nidentifies an abstract or physical resource.  A Uniform Resource\nIdentifier can be further classified as either a Uniform Resource Locator\n(UR", 8192) = 8192
09:01:57.360301 brk(0x19ef000)          = 0x19ef000
09:01:57.360499 stat("modules/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.360551 stat("modules/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.360600 stat("modules/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.360649 stat("modules/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.360698 stat("/etc/perl/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.360748 stat("/etc/perl/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.360808 stat("/usr/local/lib/perl/5.14.2/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.360860 stat("/usr/local/lib/perl/5.14.2/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.360911 stat("/usr/local/share/perl/5.14.2/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.360961 stat("/usr/local/share/perl/5.14.2/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.361012 stat("/usr/lib/perl5/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.361061 stat("/usr/lib/perl5/URI/Escape.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.361110 stat("/usr/share/perl5/URI/Escape.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.361171 stat("/usr/share/perl5/URI/Escape.pm", {st_mode=S_IFREG|0644, st_size=6644, ...}) = 0
09:01:57.361232 open("/usr/share/perl5/URI/Escape.pm", O_RDONLY) = 8
09:01:57.361286 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.361332 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.361391 read(8, "package URI::Escape;\nuse strict;\n\n=head1 NAME\n\nURI::Escape - Percent-encode and percent-decode unsafe characters\n\n=head1 SYNOPSIS\n\n use URI::Escape;\n $safe = uri_escape(\"10% is enough\\n\");\n $verysafe = uri_escape(\"foo\", \"\\0-\\377\");\n $str  = uri_unescape($safe);\n\n=head1 DESCRIPTION\n\nThis module provides functions to percent-encode and percent-decode URI strings as\ndefined by RFC 3986. Percent-encoding URI's is informally called \"URI escaping\".\nThis is the terminology used by this module, which predates the formalization of the\nterms by the RFC by several years.\n\nA URI consists of a restricted set of characters.  The restricted set\nof characters consists of digits, letters, and a few graphic symbols\nchosen from those common to most of the character encodings and input\nfacilities available to Internet users.  They are made up of the\n\"unreserved\" and \"reserved\" character sets as defined in RFC 3986.\n\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   reserved      = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n                   \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                 / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\nIn addition, any byte (octet) can be represented in a URI by an escape\nsequence: a triplet consisting of the character \"%\" followed by two\nhexadecimal digits.  A byte can also be represented directly by a\ncharacter, using the US-ASCII character for that octet.\n\nSome of the characters are I<reserved> for use as delimiters or as\npart of certain URI components.  These must be escaped if they are to\nbe treated as ordinary data.  Read RFC 3986 for further details.\n\nThe functions provided (and exported by default) from this module are:\n\n=over 4\n\n=item uri_escape( $string )\n\n=item uri_escape( $string, $unsafe )\n\nReplaces each unsafe character in the $string with the corresponding\nescape sequence and returns the result.  The $string argument should\nbe a string of bytes.  The uri_escape() function will croak if given a\ncharacters with code above 255.  Use uri_escape_utf8() if you know you\nhave such chars or/and want chars in the 128 .. 255 range treated as\nUTF-8.\n\nThe uri_escape() function takes an optional second argument that\noverrides the set of characters that are to be escaped.  The set is\nspecified as a string that can be used in a regular expression\ncharacter class (between [ ]).  E.g.:\n\n  \"\\x00-\\x1f\\x7f-\\xff\"          # all control and hi-bit characters\n  \"a-z\"                         # all lower case characters\n  \"^A-Za-z\"                     # everything not a letter\n\nThe default set of characters to be escaped is all those which are\nI<not> part of the C<unreserved> character class shown above as well\nas the reserved characters.  I.e. the default is:\n\n    \"^A-Za-z0-9\\-\\._~\"\n\n=item uri_escape_utf8( $string )\n\n=item uri_escape_utf8( $string, $unsafe )\n\nWorks like uri_escape(), but will encode chars as UTF-8 before\nescaping them.  This makes this function able to deal with characters\nwith code above 255 in $string.  Note that chars in the 128 .. 255\nrange will be escaped differently by this function compared to what\nuri_escape() would.  For chars in the 0 .. 127 range there is no\ndifference.\n\nEquivalent to:\n\n    utf8::encode($string);\n    my $uri = uri_escape($string);\n\nNote: JavaScript has a function called escape() that produces the\nsequence \"%uXXXX\" for chars in the 256 .. 65535 range.  This function\nhas really nothing to do with URI escaping but some folks got confused\nsince it \"does the right thing\" in the 0 .. 255 range.  Because of\nthis you sometimes see \"URIs\" with these kind of escapes.  The\nJavaScript encodeURIComponent() function is similar to uri_escape_utf8().\n\n=item uri_unescape($string,...)\n\nReturns a string with each %XX sequence replaced with the actual byte\n(octet).\n\nThis does the same as:\n\n   $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;\n\nbut does not modify the string in-place as this RE would.  Using the\nuri_unescape() function instead of the RE might make the code look\ncleaner and is a few characters less to type.\n\nIn a simple benchmark test I did,\ncalling the function (instead of the inline RE above) if a few chars\nwere unescaped was something like 40% slower, and something like 700% slower if none were.  If\nyou are going to unescape a lot of times it might be a good idea to\ninline the RE.\n\nIf the uri_unescape() function is passed multiple strings, then each\none is returned unescaped.\n\n=back\n\nThe module can also export the C<%escapes> hash, which contains the\nmapping from all 256 bytes to the corresponding escape codes.  Lookup\nin this hash is faster than evaluating C<sprintf(\"%%%02X\", ord($byte))>\neach time.\n\n=head1 SEE ALSO\n\nL<URI>\n\n\n=head1 COPYRIGHT\n\nCopyright 1995-2004 Gisle Aas.\n\nThis program is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=cut\n\nrequire Exporter;\nour @ISA = qw(Exporter);\nour %escapes;\nour @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);\nour @EXPORT_OK = qw(%escapes);\nour $VERSION = \"3.31\";\n\nuse Carp ();\n\n# Build a char->hex map\nfor (0..255) {\n    $escapes{chr($_)} = sprintf(\"%%%02X\", $_);\n}\n\nmy %subst;  # compiled patterns\n\nmy %Unsafe = (\n    RFC2732 => qr/[^A-Za-z0-9\\-_.!~*'()]/,\n    RFC3986 => qr/[^A-Za-z0-9\\-\\._~]/,\n);\n\nsub uri_escape {\n    my($text, $patn) = @_;\n    return undef unless defined $text;\n    if (defined $patn){\n        unless (exists  $subst{$patn}) {\n            # Because we can't compile the regex we fake it with a cached sub\n            (my $tmp = $patn) =~ s,/,\\\\/,g;\n            eval \"\\$subst{\\$patn} = sub {\\$_[0] =~ s/([$tmp])/\\$escapes{\\$1} || _fail_hi(\\$1)/ge; }\";\n            Carp::croak(\"uri_escape: $@\") if $@;\n        }\n        &{$subst{$patn}}($text);\n    } else {\n        $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;\n    }\n    $text;\n}\n\nsub _fail_hi {\n    my $chr = shift;\n    Carp::croak(sprintf \"Can't escape \\\\x{%04X}, try uri_escape_utf8() instead\", ord($chr));\n}\n\nsub uri_escape_utf8 {\n    my $text = shift;\n    utf8::encode($text);\n    return uri_escape($text, @_);\n}\n\nsub uri_unescape {\n    # Note from RFC1630:  \"Sequences which start with a percent sign\n    # but are not followed by two hexadecimal characters are reserved\n    # for future extension\"\n    my $str = shift;\n    if (@_ && wantarray) {\n        # not executed for the common case of a single argument\n        my @str = ($str, @_);  # need to copy\n        for (@str) {\n            s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;\n        }\n        return @str;\n    }\n    $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;\n    $str;\n}\n\nsub escape_char {\n    return join '', @URI::Escape::escapes{$_[0] =~ /(\\C)/g};\n}\n\n1;\n", 8192) = 6644
09:01:57.362016 read(8, "", 8192)       = 0
09:01:57.362077 close(8)                = 0
09:01:57.362831 brk(0x1a10000)          = 0x1a10000
09:01:57.363280 lseek(7, 7335, SEEK_SET) = 7335
09:01:57.363327 lseek(7, 0, SEEK_CUR)   = 7335
09:01:57.363372 close(7)                = 0
09:01:57.363469 stat("modules/POE/Component/Client/HTTP.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.363523 stat("modules/POE/Component/Client/HTTP.pm", {st_mode=S_IFREG|0600, st_size=49581, ...}) = 0
09:01:57.363583 open("modules/POE/Component/Client/HTTP.pm", O_RDONLY) = 7
09:01:57.363636 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.363682 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.363744 read(7, "package POE::Component::Client::HTTP;\n# vim: ts=2 sw=2 expandtab\n$POE::Component::Client::HTTP::VERSION = '0.949';\nuse strict;\n#use bytes; # for utf8 compatibility\n\nuse constant DEBUG      => 0;\nuse constant DEBUG_DATA => 0;\n\nuse Carp qw(croak carp);\nuse HTTP::Response;\nuse Net::HTTP::Methods;\nuse Socket qw(\n  sockaddr_in inet_ntoa\n  getnameinfo NI_NUMERICHOST NI_NUMERICSERV\n);\n\nuse POE::Component::Client::HTTP::RequestFactory;\nuse POE::Component::Client::HTTP::Request qw(:states :fields);\n\nBEGIN {\n  local $SIG{'__DIE__'} = 'DEFAULT';\n\n  #TODO: move this to Client::Keepalive?\n  # Allow more finely grained timeouts if Time::HiRes is available.\n  eval {\n    require Time::HiRes;\n    Time::HiRes->import(\"time\");\n  };\n}\n\nuse POE qw(\n  Driver::SysRW Filter::Stream\n  Filter::HTTPHead Filter::HTTPChunk\n  Component::Client::Keepalive\n);\n\n# The Internet Assigned Numbers Authority (IANA) acts as a registry\n# for transfer-coding value tokens. Initially, the registry contains\n# the following tokens: \"chunked\" (section 3.6.1), \"identity\" (section\n# 3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and\n# \"deflate\" (section 3.5).\n\n# FIXME - Haven't been able to test the compression options.\n# Comments for each filter are what HTTP::Message use.  Methods\n# without packages are from Compress::Zlib.\n\n# FIXME - Is it okay to be mixing content and transfer encodings in\n# this one table?\n\nmy %te_possible_filters = (\n  'chunked'  => 'POE::Filter::HTTPChunk',\n  'identity' => 'POE::Filter::Stream',\n#  'gzip'     => 'POE::Filter::Zlib::Stream',  # Zlib: memGunzip\n#  'x-gzip'   => 'POE::Filter::Zlib::Stream',  # Zlib: memGunzip\n#  'x-bzip2'  => 'POE::Filter::Bzip2',         # Compress::BZip2::decompress\n#  'deflate'  => 'POE::Filter::Zlib::Stream',  # Zlib: uncompress / inflate\n#  'compress' => 'POE::Filter::LZW',           # unsupported\n  # FIXME - base64 = MIME::Base64::decode\n  # FIXME - quoted-printable = Mime::QuotedPrint::decode\n);\n\nmy %te_filters;\n\nwhile (my ($encoding, $filter) = each %te_possible_filters) {\n  eval \"use $filter\";\n  next if $@;\n  $te_filters{$encoding} = $filter;\n}\n\n# The following defaults to 'chunked,identity' which is technically\n# correct but arguably useless.  It also stomps on gzip'd transport\n# because in the World Wild Web, Accept-Encoding is used to indicate\n# gzip readiness, but the server responds with 'Content-Encoding:\n# gzip', completely outside of TE encoding.\n#\n# Done this way so they appear in order of preference.\n# FIXME - Is the order important here?\n\n#my $accept_encoding = join(\n#  \",\",\n#  grep { exists $te_filters{$_} }\n#  qw(x-bzip2 gzip x-gzip deflate compress chunked identity)\n#);\n\nmy %supported_schemes = (\n  http  => 1,\n  https => 1,\n);\n\n\n#------------------------------------------------------------------------------\n# Spawn a new PoCo::Client::HTTP session.  This basically is a\n# constructor, but it isn't named \"new\" because it doesn't create a\n# usable object.  Instead, it spawns the object off as a separate\n# session.\n\nsub spawn {\n  my $type = shift;\n\n  croak \"$type requires an even number of parameters\" if @_ % 2;\n\n  my %params = @_;\n\n  my $alias = delete $params{Alias};\n  $alias = 'weeble' unless defined $alias and length $alias;\n\n  my $bind_addr = delete $params{BindAddr};\n  my $cm = delete $params{ConnectionManager};\n\n  my $request_factory = POE::Component::Client::HTTP::RequestFactory->new(\n    \\%params\n  );\n\n  croak(\n    \"$type doesn't know these parameters: \",\n    join(', ', sort keys %params)\n  ) if scalar keys %params;\n\n  POE::Session->create(\n    inline_states => {\n      _start  => \\&_poco_weeble_start,\n      _stop   => \\&_poco_weeble_stop,\n      _child  => sub { },\n\n      # Public interface.\n      request                => \\&_poco_weeble_request,\n      pending_requests_count => \\&_poco_weeble_pending_requests_count,\n      'shutdown'             => \\&_poco_weeble_shutdown,\n      cancel                 => \\&_poco_weeble_cancel,\n\n      # Client::Keepalive interface.\n      got_connect_done  => \\&_poco_weeble_connect_done,\n\n      # ReadWrite interface.\n      got_socket_input  => \\&_poco_weeble_io_read,\n      got_socket_flush  => \\&_poco_weeble_io_flushed,\n      got_socket_error  => \\&_poco_weeble_io_error,\n\n      # I/O timeout.\n      got_timeout       => \\&_poco_weeble_timeout,\n      remove_request    => \\&_poco_weeble_remove_request,\n    },\n    heap => {\n      alias        => $alias,\n      factory      => $request_factory,\n      cm           => $cm,\n      is_shut_down => 0,\n      bind_addr    => $bind_addr,\n    },\n  );\n\n  undef;\n}\n\n\nsub _poco_weeble_start {\n  my ($kernel, $heap) = @_[KERNEL, HEAP];\n\n  $kernel->alias_set($heap->{alias});\n\n  # have to do this here because it wants a current_session\n  $heap->{cm} = POE::Component::Client::Keepalive->new(\n    timeout => $heap->{factory}->timeout,\n    ($heap->{bind_addr} ? (bind_address => $heap->{bind_addr}) : ()),\n  ) unless ($heap->{cm});\n}\n\n\nsub _poco_weeble_stop {\n  my $heap = $_[HEAP];\n  my $request = delete $heap->{request};\n\n  foreach my $request_rec (values %$request) {\n    $request_rec->remove_timeout();\n    delete $heap->{ext_request_to_int_id}->{$request_rec->[REQ_HTTP_REQUEST]};\n  }\n\n  DEBUG and warn \"Client::HTTP (alias=$heap->{alias}) stopped.\";\n}\n\n\nsub _poco_weeble_pending_requests_count {\n  my ($heap) = $_[HEAP];\n  my $r = $heap->{request} || {};\n  return scalar keys %$r;\n}\n\n\nsub _poco_weeble_request {\n  my (\n    $kernel, $heap, $sender,\n    $response_event, $http_request, $tag, $progress_event,\n    $proxy_override\n  ) = @_[KERNEL, HEAP, SENDER, ARG0, ARG1, ARG2, ARG3, ARG4];\n\n  my $scheme = $http_request->uri->scheme;\n  unless (\n    defined($scheme) and\n    exists $supported_schemes{$scheme}\n  ) {\n    my $rsp = HTTP::Response->new(\n       400 => 'Bad Request', [],\n       \"<html>\\n\"\n       . \"<HEAD><TITLE>Error: Bad Request</TITLE></HEAD>\\n\"\n       . \"<BODY>\\n\"\n       . \"<H1>Error: Bad Request</H1>\\n\"\n       . \"Unsupported URI scheme: '$scheme'\\n\"\n       . \"</BODY>\\n\"\n       . \"</HTML>\\n\"\n    );\n    $rsp->request($http_request);\n    if (ref($response_event) eq 'POE::Component::Client::HTTP::Request') {\n      # This happens during redirect.\n      $response_event->postback->($rsp);\n    } else {\n      $kernel->post($sender, $response_event, [$http_request, $tag], [$rsp]);\n    }\n    return;\n  }\n\n  my $host = $http_request->uri->host;\n  unless (defined $host and length $host) {\n    my $rsp = HTTP::Response->new(\n       400 => 'Bad Request', [],\n       \"<html>\\n\"\n       . \"<HEAD><TITLE>Error: Bad Request</TITLE></HEAD>\\n\"\n       . \"<BODY>\\n\"\n       . \"<H1>Error: Bad Request</H1>\\n\"\n       . \"URI contains no discernable host.\\n\"\n       . \"</BODY>\\n\"\n       . \"</HTML>\\n\"\n    );\n    $rsp->request($http_request);\n    if (ref($response_event) eq 'POE::Component::Client::HTTP::Request') {\n      $response_event->postback->($rsp);\n    } else {\n      $kernel->post($sender, $response_event, [$http_request, $tag], [$rsp]);\n    }\n    return;\n  }\n\n  if ($heap->{is_shut_down}) {\n    my $rsp = HTTP::Response->new(\n       408 => 'Request timed out (component shut down)', [],\n       \"<html>\\n\"\n       . \"<HEAD><TITLE>Error: Request timed out (component shut down)\"\n       . \"</TITLE></HEAD>\\n\"\n       . \"<BODY>\\n\"\n       . \"<H1>Error: Request Timeout</H1>\\n\"\n       . \"Request timed out (component shut down)\\n\"\n       . \"</BODY>\\n\"\n       . \"</HTML>\\n\"\n      );\n    $rsp->request($http_request);\n    if (ref($response_event) eq 'POE::Component::Client::HTTP::Request') {\n      $response_event->postback->($rsp);\n    } else {\n      $kernel->post($sender, $response_event, [$http_request, $tag], [$rsp]);\n    }\n    return;\n  }\n\n  if (defined $proxy_override) {\n    POE::Component::Client::HTTP::RequestFactory->parse_proxy($proxy_override);\n  }\n\n  my $request = $heap->{factory}->create_request(\n    $http_request, $response_event, $tag, $progress_event,\n    $proxy_override, $sender\n  );\n  $heap->{request}->{$request->ID} = $request;\n  $heap->{ext_request_to_int_id}->{$http_request} = $request->ID;\n\n  my @timeout;\n  if ($heap->{factory}->timeout()) {\n    @timeout = (\n      timeout => $heap->{factory}->timeout()\n    );\n  }\n\n  eval {\n    # get a connection from Client::Keepaliv", 8192) = 8192
09:01:57.364252 stat("modules/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364305 stat("modules/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364355 stat("modules/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364404 stat("modules/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364454 stat("/etc/perl/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364503 stat("/etc/perl/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364552 stat("/usr/local/lib/perl/5.14.2/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364603 stat("/usr/local/lib/perl/5.14.2/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364654 stat("/usr/local/share/perl/5.14.2/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364704 stat("/usr/local/share/perl/5.14.2/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364754 stat("/usr/lib/perl5/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364803 stat("/usr/lib/perl5/HTTP/Response.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.364853 stat("/usr/share/perl5/HTTP/Response.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.364905 stat("/usr/share/perl5/HTTP/Response.pm", {st_mode=S_IFREG|0644, st_size=16291, ...}) = 0
09:01:57.364964 open("/usr/share/perl5/HTTP/Response.pm", O_RDONLY) = 8
09:01:57.365017 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.365063 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.365123 read(8, "package HTTP::Response;\n\nrequire HTTP::Message;\n@ISA = qw(HTTP::Message);\n$VERSION = \"6.03\";\n\nuse strict;\nuse HTTP::Status ();\n\n\n\nsub new\n{\n    my($class, $rc, $msg, $header, $content) = @_;\n    my $self = $class->SUPER::new($header, $content);\n    $self->code($rc);\n    $self->message($msg);\n    $self;\n}\n\n\nsub parse\n{\n    my($class, $str) = @_;\n    my $status_line;\n    if ($str =~ s/^(.*)\\n//) {\n\t$status_line = $1;\n    }\n    else {\n\t$status_line = $str;\n\t$str = \"\";\n    }\n\n    my $self = $class->SUPER::parse($str);\n    my($protocol, $code, $message);\n    if ($status_line =~ /^\\d{3} /) {\n       # Looks like a response created by HTTP::Response->new\n       ($code, $message) = split(' ', $status_line, 2);\n    } else {\n       ($protocol, $code, $message) = split(' ', $status_line, 3);\n    }\n    $self->protocol($protocol) if $protocol;\n    $self->code($code) if defined($code);\n    $self->message($message) if defined($message);\n    $self;\n}\n\n\nsub clone\n{\n    my $self = shift;\n    my $clone = bless $self->SUPER::clone, ref($self);\n    $clone->code($self->code);\n    $clone->message($self->message);\n    $clone->request($self->request->clone) if $self->request;\n    # we don't clone previous\n    $clone;\n}\n\n\nsub code      { shift->_elem('_rc',      @_); }\nsub message   { shift->_elem('_msg',     @_); }\nsub previous  { shift->_elem('_previous',@_); }\nsub request   { shift->_elem('_request', @_); }\n\n\nsub status_line\n{\n    my $self = shift;\n    my $code = $self->{'_rc'}  || \"000\";\n    my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || \"Unknown code\";\n    return \"$code $mess\";\n}\n\n\nsub base\n{\n    my $self = shift;\n    my $base = (\n\t$self->header('Content-Base'),        # used to be HTTP/1.1\n\t$self->header('Content-Location'),    # HTTP/1.1\n\t$self->header('Base'),                # HTTP/1.0\n    )[0];\n    if ($base && $base =~ /^$URI::scheme_re:/o) {\n\t# already absolute\n\treturn $HTTP::URI_CLASS->new($base);\n    }\n\n    my $req = $self->request;\n    if ($req) {\n        # if $base is undef here, the return value is effectively\n        # just a copy of $self->request->uri.\n        return $HTTP::URI_CLASS->new_abs($base, $req->uri);\n    }\n\n    # can't find an absolute base\n    return undef;\n}\n\n\nsub redirects {\n    my $self = shift;\n    my @r;\n    my $r = $self;\n    while (my $p = $r->previous) {\n        push(@r, $p);\n        $r = $p;\n    }\n    return @r unless wantarray;\n    return reverse @r;\n}\n\n\nsub filename\n{\n    my $self = shift;\n    my $file;\n\n    my $cd = $self->header('Content-Disposition');\n    if ($cd) {\n\trequire HTTP::Headers::Util;\n\tif (my @cd = HTTP::Headers::Util::split_header_words($cd)) {\n\t    my ($disposition, undef, %cd_param) = @{$cd[-1]};\n\t    $file = $cd_param{filename};\n\n\t    # RFC 2047 encoded?\n\t    if ($file && $file =~ /^=\\?(.+?)\\?(.+?)\\?(.+)\\?=$/) {\n\t\tmy $charset = $1;\n\t\tmy $encoding = uc($2);\n\t\tmy $encfile = $3;\n\n\t\tif ($encoding eq 'Q' || $encoding eq 'B') {\n\t\t    local($SIG{__DIE__});\n\t\t    eval {\n\t\t\tif ($encoding eq 'Q') {\n\t\t\t    $encfile =~ s/_/ /g;\n\t\t\t    require MIME::QuotedPrint;\n\t\t\t    $encfile = MIME::QuotedPrint::decode($encfile);\n\t\t\t}\n\t\t\telse { # $encoding eq 'B'\n\t\t\t    require MIME::Base64;\n\t\t\t    $encfile = MIME::Base64::decode($encfile);\n\t\t\t}\n\n\t\t\trequire Encode;\n\t\t\trequire Encode::Locale;\n\t\t\tEncode::from_to($encfile, $charset, \"locale_fs\");\n\t\t    };\n\n\t\t    $file = $encfile unless $@;\n\t\t}\n\t    }\n\t}\n    }\n\n    unless (defined($file) && length($file)) {\n\tmy $uri;\n\tif (my $cl = $self->header('Content-Location')) {\n\t    $uri = URI->new($cl);\n\t}\n\telsif (my $request = $self->request) {\n\t    $uri = $request->uri;\n\t}\n\n\tif ($uri) {\n\t    $file = ($uri->path_segments)[-1];\n\t}\n    }\n\n    if ($file) {\n\t$file =~ s,.*[\\\\/],,;  # basename\n    }\n\n    if ($file && !length($file)) {\n\t$file = undef;\n    }\n\n    $file;\n}\n\n\nsub as_string\n{\n    require HTTP::Status;\n    my $self = shift;\n    my($eol) = @_;\n    $eol = \"\\n\" unless defined $eol;\n\n    my $status_line = $self->status_line;\n    my $proto = $self->protocol;\n    $status_line = \"$proto $status_line\" if $proto;\n\n    return join($eol, $status_line, $self->SUPER::as_string(@_));\n}\n\n\nsub dump\n{\n    my $self = shift;\n\n    my $status_line = $self->status_line;\n    my $proto = $self->protocol;\n    $status_line = \"$proto $status_line\" if $proto;\n\n    return $self->SUPER::dump(\n\tpreheader => $status_line,\n        @_,\n    );\n}\n\n\nsub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }\nsub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }\nsub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }\nsub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }\n\n\nsub error_as_HTML\n{\n    my $self = shift;\n    my $title = 'An Error Occurred';\n    my $body  = $self->status_line;\n    $body =~ s/&/&amp;/g;\n    $body =~ s/</&lt;/g;\n    return <<EOM;\n<html>\n<head><title>$title</title></head>\n<body>\n<h1>$title</h1>\n<p>$body</p>\n</body>\n</html>\nEOM\n}\n\n\nsub current_age\n{\n    my $self = shift;\n    my $time = shift;\n\n    # Implementation of RFC 2616 section 13.2.3\n    # (age calculations)\n    my $response_time = $self->client_date;\n    my $date = $self->date;\n\n    my $age = 0;\n    if ($response_time && $date) {\n\t$age = $response_time - $date;  # apparent_age\n\t$age = 0 if $age < 0;\n    }\n\n    my $age_v = $self->header('Age');\n    if ($age_v && $age_v > $age) {\n\t$age = $age_v;   # corrected_received_age\n    }\n\n    if ($response_time) {\n\tmy $request = $self->request;\n\tif ($request) {\n\t    my $request_time = $request->date;\n\t    if ($request_time && $request_time < $response_time) {\n\t\t# Add response_delay to age to get 'corrected_initial_age'\n\t\t$age += $response_time - $request_time;\n\t    }\n\t}\n\t$age += ($time || time) - $response_time;\n    }\n    return $age;\n}\n\n\nsub freshness_lifetime\n{\n    my($self, %opt) = @_;\n\n    # First look for the Cache-Control: max-age=n header\n    for my $cc ($self->header('Cache-Control')) {\n\tfor my $cc_dir (split(/\\s*,\\s*/, $cc)) {\n\t    return $1 if $cc_dir =~ /^max-age\\s*=\\s*(\\d+)/i;\n\t}\n    }\n\n    # Next possibility is to look at the \"Expires\" header\n    my $date = $self->date || $self->client_date || $opt{time} || time;\n    if (my $expires = $self->expires) {\n\treturn $expires - $date;\n    }\n\n    # Must apply heuristic expiration\n    return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};\n\n    # Default heuristic expiration parameters\n    $opt{h_min} ||= 60;\n    $opt{h_max} ||= 24 * 3600;\n    $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616\n    $opt{h_default} ||= 3600;\n\n    # Should give a warning if more than 24 hours according to\n    # RFC 2616 section 13.2.4.  Here we just make this the default\n    # maximum value.\n\n    if (my $last_modified = $self->last_modified) {\n\tmy $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};\n\treturn $opt{h_min} if $h_exp < $opt{h_min};\n\treturn $opt{h_max} if $h_exp > $opt{h_max};\n\treturn $h_exp;\n    }\n\n    # default when all else fails\n    return $opt{h_min} if $opt{h_min} > $opt{h_default};\n    return $opt{h_default};\n}\n\n\nsub is_fresh\n{\n    my($self, %opt) = @_;\n    $opt{time} ||= time;\n    my $f = $self->freshness_lifetime(%opt);\n    return undef unless defined($f);\n    return $f > $self->current_age($opt{time});\n}\n\n\nsub fresh_until\n{\n    my($self, %opt) = @_;\n    $opt{time} ||= time;\n    my $f = $self->freshness_lifetime(%opt);\n    return undef unless defined($f);\n    return $f - $self->current_age($opt{time}) + $opt{time};\n}\n\n1;\n\n\n__END__\n\n=head1 NAME\n\nHTTP::Response - HTTP style response message\n\n=head1 SYNOPSIS\n\nResponse objects are returned by the request() method of the C<LWP::UserAgent>:\n\n    # ...\n    $response = $ua->request($request)\n    if ($response->is_success) {\n        print $response->decoded_content;\n    }\n    else {\n        print STDERR $response->status_line, \"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<HTTP::Response> class encapsulates HTTP style responses.  A\nresponse consists of a response line, some headers, and a content\nbody. Note that the LWP library uses HTTP style responses even for\nnon-HTTP protocol schemes.  Instances of this class are usually\ncreated and returned by the request() method of an C<LWP::UserAgent>\nobject.\n\nC<HTTP::Respons", 8192) = 8192
09:01:57.365565 stat("modules/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.365618 stat("modules/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.365671 stat("modules/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.365719 stat("modules/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.365768 stat("/etc/perl/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.365817 stat("/etc/perl/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.365865 stat("/usr/local/lib/perl/5.14.2/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.365915 stat("/usr/local/lib/perl/5.14.2/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.365964 stat("/usr/local/share/perl/5.14.2/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.366013 stat("/usr/local/share/perl/5.14.2/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.366080 stat("/usr/lib/perl5/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.366131 stat("/usr/lib/perl5/HTTP/Status.pm", 0x7ffe1233af80) = -1 ENOENT (No such file or directory)
09:01:57.366180 stat("/usr/share/perl5/HTTP/Status.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.366236 stat("/usr/share/perl5/HTTP/Status.pm", {st_mode=S_IFREG|0644, st_size=9029, ...}) = 0
09:01:57.366294 open("/usr/share/perl5/HTTP/Status.pm", O_RDONLY) = 9
09:01:57.366347 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.366393 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.366454 read(9, "package HTTP::Status;\n\nuse strict;\nrequire 5.002;   # because we use prototypes\n\nuse vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(is_info is_success is_redirect is_error status_message);\n@EXPORT_OK = qw(is_client_error is_server_error);\n$VERSION = \"6.03\";\n\n# Note also addition of mnemonics to @EXPORT below\n\n# Unmarked codes are from RFC 2616\n# See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n\nmy %StatusCode = (\n    100 => 'Continue',\n    101 => 'Switching Protocols',\n    102 => 'Processing',                      # RFC 2518 (WebDAV)\n    200 => 'OK',\n    201 => 'Created',\n    202 => 'Accepted',\n    203 => 'Non-Authoritative Information',\n    204 => 'No Content',\n    205 => 'Reset Content',\n    206 => 'Partial Content',\n    207 => 'Multi-Status',                    # RFC 2518 (WebDAV)\n    208 => 'Already Reported',\t\t      # RFC 5842\n    300 => 'Multiple Choices',\n    301 => 'Moved Permanently',\n    302 => 'Found',\n    303 => 'See Other',\n    304 => 'Not Modified',\n    305 => 'Use Proxy',\n    307 => 'Temporary Redirect',\n    400 => 'Bad Request',\n    401 => 'Unauthorized',\n    402 => 'Payment Required',\n    403 => 'Forbidden',\n    404 => 'Not Found',\n    405 => 'Method Not Allowed',\n    406 => 'Not Acceptable',\n    407 => 'Proxy Authentication Required',\n    408 => 'Request Timeout',\n    409 => 'Conflict',\n    410 => 'Gone',\n    411 => 'Length Required',\n    412 => 'Precondition Failed',\n    413 => 'Request Entity Too Large',\n    414 => 'Request-URI Too Large',\n    415 => 'Unsupported Media Type',\n    416 => 'Request Range Not Satisfiable',\n    417 => 'Expectation Failed',\n    418 => 'I\\'m a teapot',\t\t      # RFC 2324\n    422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)\n    423 => 'Locked',                          # RFC 2518 (WebDAV)\n    424 => 'Failed Dependency',               # RFC 2518 (WebDAV)\n    425 => 'No code',                         # WebDAV Advanced Collections\n    426 => 'Upgrade Required',                # RFC 2817\n    428 => 'Precondition Required',\n    429 => 'Too Many Requests',\n    431 => 'Request Header Fields Too Large',\n    449 => 'Retry with',                      # unofficial Microsoft\n    500 => 'Internal Server Error',\n    501 => 'Not Implemented',\n    502 => 'Bad Gateway',\n    503 => 'Service Unavailable',\n    504 => 'Gateway Timeout',\n    505 => 'HTTP Version Not Supported',\n    506 => 'Variant Also Negotiates',         # RFC 2295\n    507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)\n    509 => 'Bandwidth Limit Exceeded',        # unofficial\n    510 => 'Not Extended',                    # RFC 2774\n    511 => 'Network Authentication Required',\n);\n\nmy $mnemonicCode = '';\nmy ($code, $message);\nwhile (($code, $message) = each %StatusCode) {\n    # create mnemonic subroutines\n    $message =~ s/I'm/I am/;\n    $message =~ tr/a-z \\-/A-Z__/;\n    $mnemonicCode .= \"sub HTTP_$message () { $code }\\n\";\n    $mnemonicCode .= \"*RC_$message = \\\\&HTTP_$message;\\n\";  # legacy\n    $mnemonicCode .= \"push(\\@EXPORT_OK, 'HTTP_$message');\\n\";\n    $mnemonicCode .= \"push(\\@EXPORT, 'RC_$message');\\n\";\n}\neval $mnemonicCode; # only one eval for speed\ndie if $@;\n\n# backwards compatibility\n*RC_MOVED_TEMPORARILY = \\&RC_FOUND;  # 302 was renamed in the standard\npush(@EXPORT, \"RC_MOVED_TEMPORARILY\");\n\n%EXPORT_TAGS = (\n   constants => [grep /^HTTP_/, @EXPORT_OK],\n   is => [grep /^is_/, @EXPORT, @EXPORT_OK],\n);\n\n\nsub status_message  ($) { $StatusCode{$_[0]}; }\n\nsub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }\nsub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }\nsub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }\nsub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }\nsub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }\nsub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }\n\n1;\n\n\n__END__\n\n=head1 NAME\n\nHTTP::Status - HTTP Status code processing\n\n=head1 SYNOPSIS\n\n use HTTP::Status qw(:constants :is status_message);\n\n if ($rc != HTTP_OK) {\n     print status_message($rc), \"\\n\";\n }\n\n if (is_success($rc)) { ... }\n if (is_error($rc)) { ... }\n if (is_redirect($rc)) { ... }\n\n=head1 DESCRIPTION\n\nI<HTTP::Status> is a library of routines for defining and\nclassifying HTTP status codes for libwww-perl.  Status codes are\nused to encode the overall outcome of an HTTP response message.  Codes\ncorrespond to those defined in RFC 2616 and RFC 2518.\n\n=head1 CONSTANTS\n\nThe following constant functions can be used as mnemonic status code\nnames.  None of these are exported by default.  Use the C<:constants>\ntag to import them all.\n\n   HTTP_CONTINUE                        (100)\n   HTTP_SWITCHING_PROTOCOLS             (101)\n   HTTP_PROCESSING                      (102)\n\n   HTTP_OK                              (200)\n   HTTP_CREATED                         (201)\n   HTTP_ACCEPTED                        (202)\n   HTTP_NON_AUTHORITATIVE_INFORMATION   (203)\n   HTTP_NO_CONTENT                      (204)\n   HTTP_RESET_CONTENT                   (205)\n   HTTP_PARTIAL_CONTENT                 (206)\n   HTTP_MULTI_STATUS                    (207)\n   HTTP_ALREADY_REPORTED\t\t(208)\n\n   HTTP_MULTIPLE_CHOICES                (300)\n   HTTP_MOVED_PERMANENTLY               (301)\n   HTTP_FOUND                           (302)\n   HTTP_SEE_OTHER                       (303)\n   HTTP_NOT_MODIFIED                    (304)\n   HTTP_USE_PROXY                       (305)\n   HTTP_TEMPORARY_REDIRECT              (307)\n\n   HTTP_BAD_REQUEST                     (400)\n   HTTP_UNAUTHORIZED                    (401)\n   HTTP_PAYMENT_REQUIRED                (402)\n   HTTP_FORBIDDEN                       (403)\n   HTTP_NOT_FOUND                       (404)\n   HTTP_METHOD_NOT_ALLOWED              (405)\n   HTTP_NOT_ACCEPTABLE                  (406)\n   HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)\n   HTTP_REQUEST_TIMEOUT                 (408)\n   HTTP_CONFLICT                        (409)\n   HTTP_GONE                            (410)\n   HTTP_LENGTH_REQUIRED                 (411)\n   HTTP_PRECONDITION_FAILED             (412)\n   HTTP_REQUEST_ENTITY_TOO_LARGE        (413)\n   HTTP_REQUEST_URI_TOO_LARGE           (414)\n   HTTP_UNSUPPORTED_MEDIA_TYPE          (415)\n   HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)\n   HTTP_EXPECTATION_FAILED              (417)\n   HTTP_I_AM_A_TEAPOT\t\t\t(418)\n   HTTP_UNPROCESSABLE_ENTITY            (422)\n   HTTP_LOCKED                          (423)\n   HTTP_FAILED_DEPENDENCY               (424)\n   HTTP_NO_CODE                         (425)\n   HTTP_UPGRADE_REQUIRED                (426)\n   HTTP_PRECONDITION_REQUIRED\t\t(428)\n   HTTP_TOO_MANY_REQUESTS\t\t(429)\n   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)\n   HTTP_RETRY_WITH                      (449)\n\n   HTTP_INTERNAL_SERVER_ERROR           (500)\n   HTTP_NOT_IMPLEMENTED                 (501)\n   HTTP_BAD_GATEWAY                     (502)\n   HTTP_SERVICE_UNAVAILABLE             (503)\n   HTTP_GATEWAY_TIMEOUT                 (504)\n   HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)\n   HTTP_VARIANT_ALSO_NEGOTIATES         (506)\n   HTTP_INSUFFICIENT_STORAGE            (507)\n   HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)\n   HTTP_NOT_EXTENDED                    (510)\n   HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)\n\n=head1 FUNCTIONS\n\nThe following additional functions are provided.  Most of them are\nexported by default.  The C<:is> import tag can be used to import all\nthe classification functions.\n\n=over 4\n\n=item status_message( $code )\n\nThe status_message() function will translate status codes to human\nreadable strings. The string is the same as found in the constant\nnames above.  If the $code is unknown, then C<undef> is returned.\n\n=item is_info( $code )\n\nReturn TRUE if C<$code> is an I<Informational> status code (1xx).  This\nclass of status code indicates a provisional response which can't have\nany content.\n\n=item is_success( $code )\n\nReturn TRUE if C<$code> is a I<Successful> status code (2xx).\n\n=item is_redirect( $code )\n\nReturn TRUE if C<$code> is a I<Redirection> status code (3xx). This class of\nstatus code indicates that further action needs to be taken by the\nuser agent in order to fulfill the request.\n\n=item is_error( $code )\n\nReturn TRUE if C<$code> is ", 8192) = 8192
09:01:57.367109 brk(0x1a31000)          = 0x1a31000
09:01:57.367201 lseek(9, 3870, SEEK_SET) = 3870
09:01:57.367246 lseek(9, 0, SEEK_CUR)   = 3870
09:01:57.367290 close(9)                = 0
09:01:57.368038 brk(0x1a52000)          = 0x1a52000
09:01:57.369444 lseek(8, 7459, SEEK_SET) = 7459
09:01:57.369491 lseek(8, 0, SEEK_CUR)   = 7459
09:01:57.369535 close(8)                = 0
09:01:57.369614 stat("modules/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.369702 stat("modules/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.369758 stat("modules/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.369806 stat("modules/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.369855 stat("/etc/perl/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.369906 stat("/etc/perl/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.369956 stat("/usr/local/lib/perl/5.14.2/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.370007 stat("/usr/local/lib/perl/5.14.2/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.370077 stat("/usr/local/share/perl/5.14.2/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.370131 stat("/usr/local/share/perl/5.14.2/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.370182 stat("/usr/lib/perl5/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.370233 stat("/usr/lib/perl5/Net/HTTP/Methods.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.370283 stat("/usr/share/perl5/Net/HTTP/Methods.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.370334 stat("/usr/share/perl5/Net/HTTP/Methods.pm", {st_mode=S_IFREG|0644, st_size=14755, ...}) = 0
09:01:57.370394 open("/usr/share/perl5/Net/HTTP/Methods.pm", O_RDONLY) = 8
09:01:57.370448 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.370494 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.370554 read(8, "package Net::HTTP::Methods;\n\nrequire 5.005;  # 4-arg substr\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \"6.00\";\n\nmy $CRLF = \"\\015\\012\";   # \"\\r\\n\" is not portable\n\n*_bytes = defined(&utf8::downgrade) ?\n    sub {\n        unless (utf8::downgrade($_[0], 1)) {\n            require Carp;\n            Carp::croak(\"Wide character in HTTP request (bytes required)\");\n        }\n        return $_[0];\n    }\n    :\n    sub {\n        return $_[0];\n    };\n\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Host\") if @_ == 1;\n    my %cnf = @_;\n    require Symbol;\n    my $self = bless Symbol::gensym(), $class;\n    return $self->http_configure(\\%cnf);\n}\n\nsub http_configure {\n    my($self, $cnf) = @_;\n\n    die \"Listen option not allowed\" if $cnf->{Listen};\n    my $explict_host = (exists $cnf->{Host});\n    my $host = delete $cnf->{Host};\n    my $peer = $cnf->{PeerAddr} || $cnf->{PeerHost};\n    if (!$peer) {\n\tdie \"No Host option provided\" unless $host;\n\t$cnf->{PeerAddr} = $peer = $host;\n    }\n\n    if ($peer =~ s,:(\\d+)$,,) {\n\t$cnf->{PeerPort} = int($1);  # always override\n    }\n    if (!$cnf->{PeerPort}) {\n\t$cnf->{PeerPort} = $self->http_default_port;\n    }\n\n    if (!$explict_host) {\n\t$host = $peer;\n\t$host =~ s/:.*//;\n    }\n    if ($host && $host !~ /:/) {\n\tmy $p = $cnf->{PeerPort};\n\t$host .= \":$p\" if $p != $self->http_default_port;\n    }\n\n    $cnf->{Proto} = 'tcp';\n\n    my $keep_alive = delete $cnf->{KeepAlive};\n    my $http_version = delete $cnf->{HTTPVersion};\n    $http_version = \"1.1\" unless defined $http_version;\n    my $peer_http_version = delete $cnf->{PeerHTTPVersion};\n    $peer_http_version = \"1.0\" unless defined $peer_http_version;\n    my $send_te = delete $cnf->{SendTE};\n    my $max_line_length = delete $cnf->{MaxLineLength};\n    $max_line_length = 8*1024 unless defined $max_line_length;\n    my $max_header_lines = delete $cnf->{MaxHeaderLines};\n    $max_header_lines = 128 unless defined $max_header_lines;\n\n    return undef unless $self->http_connect($cnf);\n\n    $self->host($host);\n    $self->keep_alive($keep_alive);\n    $self->send_te($send_te);\n    $self->http_version($http_version);\n    $self->peer_http_version($peer_http_version);\n    $self->max_line_length($max_line_length);\n    $self->max_header_lines($max_header_lines);\n\n    ${*$self}{'http_buf'} = \"\";\n\n    return $self;\n}\n\nsub http_default_port {\n    80;\n}\n\n# set up property accessors\nfor my $method (qw(host keep_alive send_te max_line_length max_header_lines peer_http_version)) {\n    my $prop_name = \"http_\" . $method;\n    no strict 'refs';\n    *$method = sub {\n\tmy $self = shift;\n\tmy $old = ${*$self}{$prop_name};\n\t${*$self}{$prop_name} = shift if @_;\n\treturn $old;\n    };\n}\n\n# we want this one to be a bit smarter\nsub http_version {\n    my $self = shift;\n    my $old = ${*$self}{'http_version'};\n    if (@_) {\n\tmy $v = shift;\n\t$v = \"1.0\" if $v eq \"1\";  # float\n\tunless ($v eq \"1.0\" or $v eq \"1.1\") {\n\t    require Carp;\n\t    Carp::croak(\"Unsupported HTTP version '$v'\");\n\t}\n\t${*$self}{'http_version'} = $v;\n    }\n    $old;\n}\n\nsub format_request {\n    my $self = shift;\n    my $method = shift;\n    my $uri = shift;\n\n    my $content = (@_ % 2) ? pop : \"\";\n\n    for ($method, $uri) {\n\trequire Carp;\n\tCarp::croak(\"Bad method or uri\") if /\\s/ || !length;\n    }\n\n    push(@{${*$self}{'http_request_method'}}, $method);\n    my $ver = ${*$self}{'http_version'};\n    my $peer_ver = ${*$self}{'http_peer_http_version'} || \"1.0\";\n\n    my @h;\n    my @connection;\n    my %given = (host => 0, \"content-length\" => 0, \"te\" => 0);\n    while (@_) {\n\tmy($k, $v) = splice(@_, 0, 2);\n\tmy $lc_k = lc($k);\n\tif ($lc_k eq \"connection\") {\n\t    $v =~ s/^\\s+//;\n\t    $v =~ s/\\s+$//;\n\t    push(@connection, split(/\\s*,\\s*/, $v));\n\t    next;\n\t}\n\tif (exists $given{$lc_k}) {\n\t    $given{$lc_k}++;\n\t}\n\tpush(@h, \"$k: $v\");\n    }\n\n    if (length($content) && !$given{'content-length'}) {\n\tpush(@h, \"Content-Length: \" . length($content));\n    }\n\n    my @h2;\n    if ($given{te}) {\n\tpush(@connection, \"TE\") unless grep lc($_) eq \"te\", @connection;\n    }\n    elsif ($self->send_te && gunzip_ok()) {\n\t# gzip is less wanted since the IO::Uncompress::Gunzip interface for\n\t# it does not really allow chunked decoding to take place easily.\n\tpush(@h2, \"TE: deflate,gzip;q=0.3\");\n\tpush(@connection, \"TE\");\n    }\n\n    unless (grep lc($_) eq \"close\", @connection) {\n\tif ($self->keep_alive) {\n\t    if ($peer_ver eq \"1.0\") {\n\t\t# from looking at Netscape's headers\n\t\tpush(@h2, \"Keep-Alive: 300\");\n\t\tunshift(@connection, \"Keep-Alive\");\n\t    }\n\t}\n\telse {\n\t    push(@connection, \"close\") if $ver ge \"1.1\";\n\t}\n    }\n    push(@h2, \"Connection: \" . join(\", \", @connection)) if @connection;\n    unless ($given{host}) {\n\tmy $h = ${*$self}{'http_host'};\n\tpush(@h2, \"Host: $h\") if $h;\n    }\n\n    return _bytes(join($CRLF, \"$method $uri HTTP/$ver\", @h2, @h, \"\", $content));\n}\n\n\nsub write_request {\n    my $self = shift;\n    $self->print($self->format_request(@_));\n}\n\nsub format_chunk {\n    my $self = shift;\n    return $_[0] unless defined($_[0]) && length($_[0]);\n    return _bytes(sprintf(\"%x\", length($_[0])) . $CRLF . $_[0] . $CRLF);\n}\n\nsub write_chunk {\n    my $self = shift;\n    return 1 unless defined($_[0]) && length($_[0]);\n    $self->print(_bytes(sprintf(\"%x\", length($_[0])) . $CRLF . $_[0] . $CRLF));\n}\n\nsub format_chunk_eof {\n    my $self = shift;\n    my @h;\n    while (@_) {\n\tpush(@h, sprintf \"%s: %s$CRLF\", splice(@_, 0, 2));\n    }\n    return _bytes(join(\"\", \"0$CRLF\", @h, $CRLF));\n}\n\nsub write_chunk_eof {\n    my $self = shift;\n    $self->print($self->format_chunk_eof(@_));\n}\n\n\nsub my_read {\n    die if @_ > 3;\n    my $self = shift;\n    my $len = $_[1];\n    for (${*$self}{'http_buf'}) {\n\tif (length) {\n\t    $_[0] = substr($_, 0, $len, \"\");\n\t    return length($_[0]);\n\t}\n\telse {\n\t    return $self->sysread($_[0], $len);\n\t}\n    }\n}\n\n\nsub my_readline {\n    my $self = shift;\n    my $what = shift;\n    for (${*$self}{'http_buf'}) {\n\tmy $max_line_length = ${*$self}{'http_max_line_length'};\n\tmy $pos;\n\twhile (1) {\n\t    # find line ending\n\t    $pos = index($_, \"\\012\");\n\t    last if $pos >= 0;\n\t    die \"$what line too long (limit is $max_line_length)\"\n\t\tif $max_line_length && length($_) > $max_line_length;\n\n\t    # need to read more data to find a line ending\n          READ:\n            {\n                my $n = $self->sysread($_, 1024, length);\n                unless (defined $n) {\n                    redo READ if $!{EINTR};\n                    if ($!{EAGAIN}) {\n                        # Hmm, we must be reading from a non-blocking socket\n                        # XXX Should really wait until this socket is readable,...\n                        select(undef, undef, undef, 0.1);  # but this will do for now\n                        redo READ;\n                    }\n                    # if we have already accumulated some data let's at least\n                    # return that as a line\n                    die \"$what read failed: $!\" unless length;\n                }\n                unless ($n) {\n                    return undef unless length;\n                    return substr($_, 0, length, \"\");\n                }\n            }\n\t}\n\tdie \"$what line too long ($pos; limit is $max_line_length)\"\n\t    if $max_line_length && $pos > $max_line_length;\n\n\tmy $line = substr($_, 0, $pos+1, \"\");\n\t$line =~ s/(\\015?\\012)\\z// || die \"Assert\";\n\treturn wantarray ? ($line, $1) : $line;\n    }\n}\n\n\nsub _rbuf {\n    my $self = shift;\n    if (@_) {\n\tfor (${*$self}{'http_buf'}) {\n\t    my $old;\n\t    $old = $_ if defined wantarray;\n\t    $_ = shift;\n\t    return $old;\n\t}\n    }\n    else {\n\treturn ${*$self}{'http_buf'};\n    }\n}\n\nsub _rbuf_length {\n    my $self = shift;\n    return length ${*$self}{'http_buf'};\n}\n\n\nsub _read_header_lines {\n    my $self = shift;\n    my $junk_out = shift;\n\n    my @headers;\n    my $line_count = 0;\n    my $max_header_lines = ${*$self}{'http_max_header_lines'};\n    while (my $line = my_readline($self, 'Header')) {\n\tif ($line =~ /^(\\S+?)\\s*:\\s*(.*)/s) {\n\t    push(@headers, $1, $2);\n\t}\n\telsif (@headers && $line =~ s/^\\s+//) {\n\t    $headers[-1] .= \" \" . $line;\n\t}\n\telsif ($junk_out) {\n\t    push(@$junk_out, $line);\n\t}\n\telse {\n\t    die \"Bad header: '$line'\\n\";\n\t}\n\tif ($max_header_lines) {\n\t    $line_count++;\n\t    if ($line", 8192) = 8192
09:01:57.371534 brk(0x1a73000)          = 0x1a73000
09:01:57.372120 read(8, "_count >= $max_header_lines) {\n\t\tdie \"Too many header lines (limit is $max_header_lines)\";\n\t    }\n\t}\n    }\n    return @headers;\n}\n\n\nsub read_response_headers {\n    my($self, %opt) = @_;\n    my $laxed = $opt{laxed};\n\n    my($status, $eol) = my_readline($self, 'Status');\n    unless (defined $status) {\n\tdie \"Server closed connection without sending any data back\";\n    }\n\n    my($peer_ver, $code, $message) = split(/\\s+/, $status, 3);\n    if (!$peer_ver || $peer_ver !~ s,^HTTP/,, || $code !~ /^[1-5]\\d\\d$/) {\n\tdie \"Bad response status line: '$status'\" unless $laxed;\n\t# assume HTTP/0.9\n\t${*$self}{'http_peer_http_version'} = \"0.9\";\n\t${*$self}{'http_status'} = \"200\";\n\tsubstr(${*$self}{'http_buf'}, 0, 0) = $status . ($eol || \"\");\n\treturn 200 unless wantarray;\n\treturn (200, \"Assumed OK\");\n    };\n\n    ${*$self}{'http_peer_http_version'} = $peer_ver;\n    ${*$self}{'http_status'} = $code;\n\n    my $junk_out;\n    if ($laxed) {\n\t$junk_out = $opt{junk_out} || [];\n    }\n    my @headers = $self->_read_header_lines($junk_out);\n\n    # pick out headers that read_entity_body might need\n    my @te;\n    my $content_length;\n    for (my $i = 0; $i < @headers; $i += 2) {\n\tmy $h = lc($headers[$i]);\n\tif ($h eq 'transfer-encoding') {\n\t    my $te = $headers[$i+1];\n\t    $te =~ s/^\\s+//;\n\t    $te =~ s/\\s+$//;\n\t    push(@te, $te) if length($te);\n\t}\n\telsif ($h eq 'content-length') {\n\t    # ignore bogus and overflow values\n\t    if ($headers[$i+1] =~ /^\\s*(\\d{1,15})(?:\\s|$)/) {\n\t\t$content_length = $1;\n\t    }\n\t}\n    }\n    ${*$self}{'http_te'} = join(\",\", @te);\n    ${*$self}{'http_content_length'} = $content_length;\n    ${*$self}{'http_first_body'}++;\n    delete ${*$self}{'http_trailers'};\n    return $code unless wantarray;\n    return ($code, $message, @headers);\n}\n\n\nsub read_entity_body {\n    my $self = shift;\n    my $buf_ref = \\$_[0];\n    my $size = $_[1];\n    die \"Offset not supported yet\" if $_[2];\n\n    my $chunked;\n    my $bytes;\n\n    if (${*$self}{'http_first_body'}) {\n\t${*$self}{'http_first_body'} = 0;\n\tdelete ${*$self}{'http_chunked'};\n\tdelete ${*$self}{'http_bytes'};\n\tmy $method = shift(@{${*$self}{'http_request_method'}});\n\tmy $status = ${*$self}{'http_status'};\n\tif ($method eq \"HEAD\") {\n\t    # this response is always empty regardless of other headers\n\t    $bytes = 0;\n\t}\n\telsif (my $te = ${*$self}{'http_te'}) {\n\t    my @te = split(/\\s*,\\s*/, lc($te));\n\t    die \"Chunked must be last Transfer-Encoding '$te'\"\n\t\tunless pop(@te) eq \"chunked\";\n\n\t    for (@te) {\n\t\tif ($_ eq \"deflate\" && inflate_ok()) {\n\t\t    #require Compress::Raw::Zlib;\n\t\t    my ($i, $status) = Compress::Raw::Zlib::Inflate->new();\n\t\t    die \"Can't make inflator: $status\" unless $i;\n\t\t    $_ = sub { my $out; $i->inflate($_[0], \\$out); $out }\n\t\t}\n\t\telsif ($_ eq \"gzip\" && gunzip_ok()) {\n\t\t    #require IO::Uncompress::Gunzip;\n\t\t    my @buf;\n\t\t    $_ = sub {\n\t\t\tpush(@buf, $_[0]);\n\t\t\treturn \"\" unless $_[1];\n\t\t\tmy $input = join(\"\", @buf);\n\t\t\tmy $output;\n\t\t\tIO::Uncompress::Gunzip::gunzip(\\$input, \\$output, Transparent => 0)\n\t\t\t    or die \"Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError\";\n\t\t\treturn \\$output;\n\t\t    };\n\t\t}\n\t\telsif ($_ eq \"identity\") {\n\t\t    $_ = sub { $_[0] };\n\t\t}\n\t\telse {\n\t\t    die \"Can't handle transfer encoding '$te'\";\n\t\t}\n\t    }\n\n\t    @te = reverse(@te);\n\n\t    ${*$self}{'http_te2'} = @te ? \\@te : \"\";\n\t    $chunked = -1;\n\t}\n\telsif (defined(my $content_length = ${*$self}{'http_content_length'})) {\n\t    $bytes = $content_length;\n\t}\n        elsif ($status =~ /^(?:1|[23]04)/) {\n            # RFC 2616 says that these responses should always be empty\n            # but that does not appear to be true in practice [RT#17907]\n            $bytes = 0;\n        }\n\telse {\n\t    # XXX Multi-Part types are self delimiting, but RFC 2616 says we\n\t    # only has to deal with 'multipart/byteranges'\n\n\t    # Read until EOF\n\t}\n    }\n    else {\n\t$chunked = ${*$self}{'http_chunked'};\n\t$bytes   = ${*$self}{'http_bytes'};\n    }\n\n    if (defined $chunked) {\n\t# The state encoded in $chunked is:\n\t#   $chunked == 0:   read CRLF after chunk, then chunk header\n        #   $chunked == -1:  read chunk header\n\t#   $chunked > 0:    bytes left in current chunk to read\n\n\tif ($chunked <= 0) {\n\t    my $line = my_readline($self, 'Entity body');\n\t    if ($chunked == 0) {\n\t\tdie \"Missing newline after chunk data: '$line'\"\n\t\t    if !defined($line) || $line ne \"\";\n\t\t$line = my_readline($self, 'Entity body');\n\t    }\n\t    die \"EOF when chunk header expected\" unless defined($line);\n\t    my $chunk_len = $line;\n\t    $chunk_len =~ s/;.*//;  # ignore potential chunk parameters\n\t    unless ($chunk_len =~ /^([\\da-fA-F]+)\\s*$/) {\n\t\tdie \"Bad chunk-size in HTTP response: $line\";\n\t    }\n\t    ${*$self}{'http_chunked'} = $chunked = hex($1);\n\t    if ($chunked == 0) {\n\t\t${*$self}{'http_trailers'} = [$self->_read_header_lines];\n\t\t$$buf_ref = \"\";\n\n\t\tmy $n = 0;\n\t\tif (my $transforms = delete ${*$self}{'http_te2'}) {\n\t\t    for (@$transforms) {\n\t\t\t$$buf_ref = &$_($$buf_ref, 1);\n\t\t    }\n\t\t    $n = length($$buf_ref);\n\t\t}\n\n\t\t# in case somebody tries to read more, make sure we continue\n\t\t# to return EOF\n\t\tdelete ${*$self}{'http_chunked'};\n\t\t${*$self}{'http_bytes'} = 0;\n\n\t\treturn $n;\n\t    }\n\t}\n\n\tmy $n = $chunked;\n\t$n = $size if $size && $size < $n;\n\t$n = my_read($self, $$buf_ref, $n);\n\treturn undef unless defined $n;\n\n\t${*$self}{'http_chunked'} = $chunked - $n;\n\n\tif ($n > 0) {\n\t    if (my $transforms = ${*$self}{'http_te2'}) {\n\t\tfor (@$transforms) {\n\t\t    $$buf_ref = &$_($$buf_ref, 0);\n\t\t}\n\t\t$n = length($$buf_ref);\n\t\t$n = -1 if $n == 0;\n\t    }\n\t}\n\treturn $n;\n    }\n    elsif (defined $bytes) {\n\tunless ($bytes) {\n\t    $$buf_ref = \"\";\n\t    return 0;\n\t}\n\tmy $n = $bytes;\n\t$n = $size if $size && $size < $n;\n\t$n = my_read($self, $$buf_ref, $n);\n\treturn undef unless defined $n;\n\t${*$self}{'http_bytes'} = $bytes - $n;\n\treturn $n;\n    }\n    else {\n\t# read until eof\n\t$size ||= 8*1024;\n\treturn my_read($self, $$buf_ref, $size);\n    }\n}\n\nsub get_trailers {\n    my $self = shift;\n    @{${*$self}{'http_trailers'} || []};\n}\n\nBEGIN {\nmy $gunzip_ok;\nmy $inflate_ok;\n\nsub gunzip_ok {\n    return $gunzip_ok if defined $gunzip_ok;\n\n    # Try to load IO::Uncompress::Gunzip.\n    local $@;\n    local $SIG{__DIE__};\n    $gunzip_ok = 0;\n\n    eval {\n\trequire IO::Uncompress::Gunzip;\n\t$gunzip_ok++;\n    };\n\n    return $gunzip_ok;\n}\n\nsub inflate_ok {\n    return $inflate_ok if defined $inflate_ok;\n\n    # Try to load Compress::Raw::Zlib.\n    local $@;\n    local $SIG{__DIE__};\n    $inflate_ok = 0;\n\n    eval {\n\trequire Compress::Raw::Zlib;\n\t$inflate_ok++;\n    };\n\n    return $inflate_ok;\n}\n\n} # BEGIN\n\n1;\n", 8192) = 6563
09:01:57.372694 brk(0x1a94000)          = 0x1a94000
09:01:57.373308 read(8, "", 8192)       = 0
09:01:57.373358 close(8)                = 0
09:01:57.373516 stat("modules/POE/Component/Client/HTTP/RequestFactory.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.373572 stat("modules/POE/Component/Client/HTTP/RequestFactory.pm", {st_mode=S_IFREG|0600, st_size=10020, ...}) = 0
09:01:57.373632 open("modules/POE/Component/Client/HTTP/RequestFactory.pm", O_RDONLY) = 8
09:01:57.373688 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.373735 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.373797 read(8, "package POE::Component::Client::HTTP::RequestFactory;\n# vim: ts=2 sw=2 expandtab\n$POE::Component::Client::HTTP::RequestFactory::VERSION = '0.949';\nuse strict;\nuse warnings;\n\nuse Carp;\nuse POE::Component::Client::HTTP::Request;\nuse POE::Component::Client::HTTP;\n\nuse constant {\n  FCT_AGENT           => 0,\n  FCT_STREAMING       => 1,\n  FCT_MAXSIZE         => 2,\n  FCT_PROTOCOL        => 3,\n  FCT_COOKIEJAR       => 4,\n  FCT_FROM            => 5,\n  FCT_NOPROXY         => 6,\n  FCT_HTTP_PROXY      => 7,\n  FCT_FOLLOWREDIRECTS => 8,\n  FCT_TIMEOUT         => 9,\n};\n\nuse constant DEBUG => 0;\n\nuse constant DEFAULT_BLOCK_SIZE  => 4096;\n\n\n=head1 NAME\n\nPOE::Component::Client::HTTP::RequestFactory - an HTTP request factory object\n\n=head1 VERSION\n\nversion 0.949\n\n=head1 SYNOPSIS\n\n  # Used internally by POE::Component::Client::HTTP\n\n=head1 CONSTRUCTOR\n\n=head2 new\n\nCreate a new request factory object. It expects its parameters in a\nhashref.\n\nThe following parameters are accepted.  They are explained in detail\nin L<POE::Component::Client::HTTP>.\n\n=over 4\n\n=item \n\nAgent\n\n=item\n\nMaxSize\n\n=item\n\nStreaming\n\n=item\n\nProtocol\n\n=item\n\nFrom\n\n=item\n\nCookieJar\n\n=item\n\nNoProxy\n\n=item\n\nProxy\n\n=item\n\nFollowRedirects\n\n=item\n\nTimeout\n\n=back\n\n=cut\n\n\nsub new {\n  my ($class, $params) = @_;\n\n  croak __PACKAGE__ . \"expects its arguments in a hashref\"\n    unless (!defined ($params) or ref($params) eq 'HASH');\n\n  # Accept an agent, or a reference to a list of agents.\n  my $agent = delete $params->{Agent};\n  $agent = [] unless defined $agent;\n  $agent = [ $agent ] unless ref($agent);\n  unless (ref($agent) eq \"ARRAY\") {\n    croak \"Agent must be a scalar or a reference to a list of agent strings\";\n  }\n\n  my $v = $POE::Component::Client::HTTP::VERSION;\n  $v = \"0.000\" unless defined $v;\n\n  push(\n    @$agent,\n    sprintf(\n      'POE-Component-Client-HTTP/%s (perl; N; POE; en; rv:%f)',\n      $v, $v\n    )\n  ) unless @$agent;\n\n  my $max_size = delete $params->{MaxSize};\n\n  my $streaming = delete $params->{Streaming};\n\n  my $protocol = delete $params->{Protocol};\n  $protocol = 'HTTP/1.1' unless defined $protocol and length $protocol;\n\n  my $cookie_jar       = delete $params->{CookieJar};\n  my $from             = delete $params->{From};\n  my $no_proxy         = delete $params->{NoProxy};\n  my $proxy            = delete $params->{Proxy};\n  my $follow_redirects = delete $params->{FollowRedirects} || 0;\n  my $timeout          = delete $params->{Timeout};\n\n  # Process HTTP_PROXY and NO_PROXY environment variables.\n\n  $proxy    = $ENV{HTTP_PROXY} || $ENV{http_proxy} unless defined $proxy;\n  $no_proxy = $ENV{NO_PROXY}   || $ENV{no_proxy}   unless defined $no_proxy;\n\n  # Translate environment variable formats into internal versions.\n\n  $class->parse_proxy($proxy) if defined $proxy;\n\n  if (defined $no_proxy) {\n    unless (ref($no_proxy) eq 'ARRAY') {\n      $no_proxy = [ split(/\\s*\\,\\s*/, $no_proxy) ];\n    }\n  }\n\n  $timeout = 180 unless (defined $timeout and $timeout > 0);\n\n  my $self = [\n    $agent,            # FCT_AGENT\n    $streaming,        # FCT_STREAMING\n    $max_size,         # FCT_MAXSIZE\n    $protocol,         # FCT_PROTOCOL\n    $cookie_jar,       # FCT_COOKIEJAR\n    $from,             # FCT_FROM\n    $no_proxy,         # FCT_NOPROXY\n    $proxy,            # FCT_HTTP_PROXY\n    $follow_redirects, # FCT_FOLLOWREDIRECTS\n    $timeout,          # FCT_TIMEOUT\n  ];\n\n  return bless $self, $class;\n}\n\n\n=head1 METHODS\n\n=head2 timeout [$timeout]\n\nMethod that lets you query and/or change the timeout value for requests\ncreated by this factory.\n\n=cut\n\n\nsub timeout {\n  my ($self, $timeout) = @_;\n\n  if (defined $timeout) {\n    $self->[FCT_TIMEOUT] = $timeout;\n  }\n  return $self->[FCT_TIMEOUT];\n}\n\n\n=head2 is_streaming\n\nAccessor for the Streaming parameter\n\n=cut\n\n\nsub is_streaming {\n  my ($self) = @_;\n\n  DEBUG and warn(\n    \"FCT: this is \"\n    . ($self->[FCT_STREAMING] ? \"\" : \"not \")\n    . \"streaming\"\n  );\n  return $self->[FCT_STREAMING];\n}\n\n\n=head2 agent\n\nAccessor to the Agent parameter\n\n=cut\n\n\nsub agent {\n  my ($self) = @_;\n\n  return $self->[FCT_AGENT]->[rand @{$self->[FCT_AGENT]}];\n}\n\n\n=head2 from\n\ngetter/setter for the From parameter\n\n=cut\n\n\nsub from {\n  my ($self) = @_;\n\n  if (defined $self->[FCT_FROM] and length $self->[FCT_FROM]) {\n    return $self->[FCT_FROM];\n  }\n  return undef;\n}\n\n\n=head2 create_request\n\nCreates a new L<POE::Component::Client::HTTP::Request>\n\n=cut\n\n\nsub create_request {\n  my ($self, $http_request, $response_event, $tag,\n      $progress_event, $proxy_override, $sender) =  @_;\n\n  # Add a protocol if one isn't included.\n  $http_request->protocol( $self->[FCT_PROTOCOL] ) unless (\n    defined $http_request->protocol()\n    and length $http_request->protocol()\n  );\n\n  # Add the User-Agent: header if one isn't included.\n  unless (defined $http_request->user_agent()) {\n    $http_request->user_agent($self->agent);\n  }\n\n  # Add a From: header if one isn't included.\n  if (defined $self->from) {\n    my $req_from = $http_request->from();\n    unless (defined $req_from and length $req_from) {\n      $http_request->from( $self->from );\n    }\n  }\n\n  # Add a Content-Length header if this request has content but\n  # doesn't have a Content-Length header already.  Also, don't do it\n  # if the content is a reference, as this means we're streaming via\n  # callback.\n  if (\n    length($http_request->content()) and\n    !ref($http_request->content()) and\n    !$http_request->content_length()\n  ) {\n    use bytes;\n    $http_request->content_length(length($http_request->content()));\n  }\n\n  my ($last_request, $postback);\n  if (ref($response_event) eq 'POE::Component::Client::HTTP::Request') {\n    $last_request = $response_event;\n    $postback = $last_request->postback;\n  }\n  else {\n    $postback = $sender->postback( $response_event, $http_request, $tag );\n  }\n  # Create a progress postback if requested.\n  my $progress_postback;\n  if (defined $progress_event) {\n    if (ref $progress_event) {\n      # The given progress event appears to already\n      # be a postback, so use it.  This is needed to\n      # propagate the postback through redirects.\n      $progress_postback = $progress_event;\n    }\n    else {\n      $progress_postback = $sender->postback(\n        $progress_event,\n        $http_request,\n        $tag\n      );\n    }\n  }\n\n  # If we have a cookie jar, have it add the appropriate headers.\n  # LWP rocks!\n\n  if (defined $self->[FCT_COOKIEJAR]) {\n    $self->[FCT_COOKIEJAR]->add_cookie_header($http_request);\n  }\n\n  # MEXNIX 2002-06-01: If we have a proxy set, and the request URI is\n  # not in our no_proxy, then use the proxy.  Otherwise use the\n  # request URI.\n  #\n  # RCAPUTO 2006-03-23: We only support http proxying right now.\n  # Avoid proxying if this isn't an http request.\n\n  # TODO CONNECT - Create a PCCH::Request object in https-CONNECT mode\n  # if we're using https and there's an appropriate proxy.\n\n  my $proxy = $proxy_override;\n  if ($http_request->uri->scheme() eq \"http\") {\n    $proxy ||= $self->[FCT_HTTP_PROXY];\n  }\n\n  if (defined $proxy) {\n  # This request qualifies for proxying.  Replace the host and port\n  # with the proxy's host and port.  This comes after the Host:\n  # header is set, so it doesn't break the request object.\n    my $host = $http_request->uri->host;\n\n    undef $proxy if (\n      !defined($host) or\n      _in_no_proxy ($host, $self->[FCT_NOPROXY])\n    );\n  }\n\n  my $request = POE::Component::Client::HTTP::Request->new (\n    Request => $http_request,\n    Proxy => $proxy,\n    Postback => $postback,\n    #Tag => $tag, # TODO - Is this needed for anything?\n    Progress => $progress_postback,\n    Factory => $self,\n  );\n\n  if (defined $last_request) {\n    $request->does_redirect($last_request);\n  }\n  return $request;\n}\n\n\n# Determine whether a host is in a no-proxy list.\n\nsub _in_no_proxy {\n  my ($host, $no_proxy) = @_;\n\n  foreach my $no_proxy_domain (@$no_proxy) {\n    return 1 if $host =~ /\\Q$no_proxy_domain\\E$/i;\n  }\n  return 0;\n}\n\n\n=head2 max_response_size\n\nMethod to retrieve the maximum size of a response, as set by the\nC<MaxSize> parameter to L<Client::HTTP>'s C<spawn()> method.\n\n=cut\n\n\nsub max_response_size {\n  my ($self) = @_;\n\n  return $self->[FCT_MAXSIZE];\n}\n\n\n=head2 block_size\n\nAccessor for", 8192) = 8192
09:01:57.374289 stat("modules/POE/Component/Client/HTTP/Request.pmc", 0x7ffe1233b030) = -1 ENOENT (No such file or directory)
09:01:57.374344 stat("modules/POE/Component/Client/HTTP/Request.pm", {st_mode=S_IFREG|0600, st_size=21341, ...}) = 0
09:01:57.374404 open("modules/POE/Component/Client/HTTP/Request.pm", O_RDONLY) = 9
09:01:57.374457 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.374503 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.374569 read(9, "package POE::Component::Client::HTTP::Request;\n# vim: ts=2 sw=2 expandtab\n$POE::Component::Client::HTTP::Request::VERSION = '0.949';\nuse strict;\nuse warnings;\n\nuse POE;\n\nuse Carp;\nuse HTTP::Status;\nuse Errno qw(ETIMEDOUT);\n\nBEGIN {\n  local $SIG{'__DIE__'} = 'DEFAULT';\n  # Allow more finely grained timeouts if Time::HiRes is available.\n  # This code is also in POE::Component::Client::HTTP\n  eval {\n    require Time::HiRes;\n    Time::HiRes->import(\"time\");\n  };\n}\n\n# Unique request ID, independent of wheel and timer IDs.\nmy $request_seq = 0;\n\nuse constant DEBUG => 0;\n\n# TODO CONNECT - Add a flag to indicate whether to generate an HTTP\n# CONNECT request for proxying, or to return REQ_HTTP_REQUEST.  Add a\n# method to update that flag.\n\nuse constant {\n  REQ_ID            =>  0,\n  REQ_POSTBACK      =>  1,\n  REQ_CONNECTION    =>  2,\n  REQ_HTTP_REQUEST  =>  3,\n  REQ_STATE         =>  4,\n  REQ_RESPONSE      =>  5,\n  REQ_BUFFER        =>  6,\n  REQ_OCTETS_GOT    =>  8,\n  REQ_TIMER         =>  9,\n  REQ_PROG_POSTBACK => 10,\n  REQ_USING_PROXY   => 11,\n  REQ_HOST          => 12,\n  REQ_PORT          => 13,\n  REQ_HISTORY       => 14,\n  REQ_START_TIME    => 15,\n  REQ_FACTORY       => 16,\n  REQ_CONN_ID       => 17,\n  REQ_PEERNAME      => 18,\n};\n\nuse constant {\n  RS_CONNECT        => 0x01, # establishing a connection\n  RS_SENDING        => 0x02, # sending request to server\n  RS_IN_HEAD        => 0x04, # waiting for or receiving headers\n  RS_REDIRECTED     => 0x08, # request has been redirected\n  RS_IN_CONTENT     => 0x20, # waiting for or receiving content\n  RS_DONE           => 0x40, # received full content\n  RS_POSTED         => 0x80, # we have posted back a response\n};\n\n\nsub import {\n  my ($class) = shift;\n\n  my $package = caller();\n\n  foreach my $tag (@_) {\n    if ($tag eq ':fields') {\n      foreach my $sub (\n        qw(\n          REQ_ID REQ_POSTBACK REQ_CONNECTION REQ_HTTP_REQUEST REQ_STATE\n          REQ_RESPONSE REQ_BUFFER REQ_OCTETS_GOT REQ_TIMER\n          REQ_PROG_POSTBACK REQ_USING_PROXY REQ_HOST REQ_PORT\n          REQ_HISTORY REQ_START_TIME REQ_CONN_ID REQ_PEERNAME\n        )\n      ) {\n        no strict 'refs';\n        *{$package . \"::$sub\"} = \\&$sub;\n      }\n    }\n\n    if ($tag eq ':states') {\n      foreach my $sub (\n        qw(\n          RS_CONNECT RS_SENDING RS_IN_HEAD RS_REDIRECTED\n          RS_IN_CONTENT RS_DONE RS_POSTED\n        )\n      ) {\n        no strict 'refs';\n        *{$package . \"::$sub\"} = \\&$sub;\n      }\n    }\n  }\n}\n\n\nsub ID { return $_[0][REQ_ID] }\n\n\nsub new {\n  my $class = shift;\n\n  croak __PACKAGE__ . \"expects its arguments to be key/value pairs\" if @_ & 1;\n  my %params = @_;\n\n  croak \"need a Request parameter\" unless (defined $params{'Request'});\n  croak \"Request must be a HTTP::Request object\"\n    unless (UNIVERSAL::isa ($params{'Request'}, \"HTTP::Request\"));\n\n  croak \"need a Factory parameter\" unless (defined $params{'Factory'});\n\n  my ($http_request, $postback, $progress, $factory) =\n    @params{qw(Request Postback Progress Factory)};\n\n  my $request_id = ++$request_seq;\n  DEBUG and warn \"REQ: creating a request ($request_id)\";\n\n  # Get the host and port from the request object.\n  my ($host, $port, $scheme, $using_proxy);\n\n  eval {\n    $host   = $http_request->uri()->host();\n    $port   = $http_request->uri()->port();\n    $scheme = $http_request->uri()->scheme();\n  };\n  croak \"Not a usable Request: $@\" if ($@);\n\n  # Add a host header if one isn't included.  Must do this before\n  # we reset the $host for the proxy!\n  unless (\n    defined $http_request->header('Host') and\n    length $http_request->header('Host')\n  ) {\n    my $error = _set_host_header($http_request);\n    croak \"Can't set Host header: $error\" if $error;\n  }\n\n  if (defined $params{Proxy}) {\n    # This request qualifies for proxying.  Replace the host and port\n    # with the proxy's host and port.  This comes after the Host:\n    # header is set, so it doesn't break the request object.\n    ($host, $port) = @{$params{Proxy}->[rand @{$params{Proxy}}]};\n\n    $using_proxy = 1;\n  }\n  else {\n    $using_proxy = 0;\n  }\n\n  # Build the request.\n  my $self = [\n    $request_id,        # REQ_ID\n    $postback,          # REQ_POSTBACK\n    undef,              # REQ_CONNECTION\n    $http_request,      # REQ_HTTP_REQUEST\n    RS_CONNECT,         # REQ_STATE\n    undef,              # REQ_RESPONSE\n    '',                 # REQ_BUFFER\n    undef,              # unused\n    0,                  # REQ_OCTETS_GOT\n    undef,              # REQ_TIMER\n    $progress,          # REQ_PROG_POSTBACK\n    $using_proxy,       # REQ_USING_PROXY\n    $host,              # REQ_HOST\n    $port,              # REQ_PORT\n    undef,              # REQ_HISTORY\n    time(),             # REQ_START_TIME\n    $factory,           # REQ_FACTORY\n    undef,              # REQ_CONN_ID\n    undef,              # REQ_PEERNAME\n  ];\n  return bless $self, $class;\n}\n\n\nsub return_response {\n  my ($self) = @_;\n\n  DEBUG and warn \"in return_response \", sprintf (\"0x%02X\", $self->[REQ_STATE]);\n  return if ($self->[REQ_STATE] & RS_POSTED);\n  my $response = $self->[REQ_RESPONSE];\n\n  # If we have a cookie jar, have it frob our headers.  LWP rocks!\n  $self->[REQ_FACTORY]->frob_cookies ($response);\n\n  # If we're done, send back the HTTP::Response object, which\n  # is filled with content if we aren't streaming, or empty\n  # if we are. that there's no ARG1 lets the client know we're done\n  # with the content in the latter case\n  if ($self->[REQ_STATE] & RS_DONE) {\n    DEBUG and warn \"done; returning $response for \", $self->[REQ_ID];\n    $self->[REQ_POSTBACK]->($self->[REQ_RESPONSE]);\n    $self->[REQ_STATE] |= RS_POSTED;\n    #warn \"state is now \", $self->[REQ_STATE];\n  }\n  elsif ($self->[REQ_STATE] & RS_IN_CONTENT) {\n    # If we are streaming, send the chunk back to the client session.\n    # Otherwise add the new octets to the response's content.\n    # This should only add up to content-length octets total!\n    if ($self->[REQ_FACTORY]->is_streaming) {\n      DEBUG and warn \"returning partial $response\";\n      $self->[REQ_POSTBACK]->($self->[REQ_RESPONSE], $self->[REQ_BUFFER]);\n    }\n    else {\n      DEBUG and warn \"adding to $response\";\n      $self->[REQ_RESPONSE]->add_content($self->[REQ_BUFFER]);\n    }\n  }\n  $self->[REQ_BUFFER] = '';\n}\n\n\nsub add_eof {\n  my ($self) = @_;\n\n  return if ($self->[REQ_STATE] & RS_POSTED);\n\n  unless (defined $self->[REQ_RESPONSE]) {\n    # XXX I don't know if this is actually used\n    $self->error(400, \"incomplete response a \" . $self->[REQ_ID]);\n    return;\n  }\n\n  # RFC 2616: \"If a message is received with both a Transfer-Encoding\n  # header field and a Content-Length header field, the latter MUST be\n  # ignored.\"\n  #\n  # Google returns a Content-Length header with its HEAD request,\n  # generating \"incomplete response\" errors.  Added a special case to\n  # ignore content for HEAD requests.  This may thwart keep-alive,\n  # however.\n\n  if (\n    $self->[REQ_HTTP_REQUEST]->method() ne \"HEAD\" and\n    defined $self->[REQ_RESPONSE]->content_length and\n    not defined $self->[REQ_RESPONSE]->header(\"Transfer-Encoding\") and\n    $self->[REQ_OCTETS_GOT] < $self->[REQ_RESPONSE]->content_length\n  ) {\n    DEBUG and warn(\n      \"got \" . $self->[REQ_OCTETS_GOT] . \" of \" .\n      $self->[REQ_RESPONSE]->content_length\n    );\n\n    $self->error(\n      400,\n      \"incomplete response b \" . $self->[REQ_ID] . \".  Wanted \" .\n      $self->[REQ_RESPONSE]->content_length() . \" octets.  Got \" .\n      $self->[REQ_OCTETS_GOT] . \".\"\n    );\n  }\n  else {\n    $self->[REQ_STATE] |= RS_DONE;\n    $self->return_response();\n  }\n}\n\n\nsub add_content {\n  my ($self, $data) = @_;\n\n  if (ref $data) {\n    $self->[REQ_STATE] = RS_DONE;\n    $data->scan (sub {$self->[REQ_RESPONSE]->header (@_) });\n    return 1;\n  }\n\n  $self->[REQ_BUFFER] .= $data;\n\n  # Count how many octets we've received.  -><- This may fail on\n  # perl 5.8 if the input has been identified as Unicode.  Then\n  # again, the C<use bytes> in Driver::SysRW may have untainted the\n  # data... or it may have just changed the semantics of length()\n  # therein.  If it's done the former, then we're safe.  Otherwise\n  # we also need to C<use bytes>.\n  # TODO: write test(s) for this.\n\n  my $this_chunk_length = lengt", 8192) = 8192
09:01:57.374984 brk(0x1ab5000)          = 0x1ab5000
09:01:57.376246 read(9, "h($self->[REQ_BUFFER]);\n  $self->[REQ_OCTETS_GOT] += $this_chunk_length;\n\n  my $max = $self->[REQ_FACTORY]->max_response_size();\n\n  DEBUG and warn(\n    \"REQ: request \", $self->ID,\n    \" received $self->[REQ_OCTETS_GOT] bytes; maximum is $max\"\n  );\n\n  # Fail if we've gone over the maximum content size to return.\n  if (defined $max and $self->[REQ_OCTETS_GOT] > $max) {\n    $self->error(\n      406,\n      \"Response content is longer than specified MaxSize of $max.  \" .\n      \"Use range requests to retrieve specific amounts of content.\"\n    );\n\n    $self->[REQ_STATE] |= RS_DONE;\n    $self->[REQ_STATE] &= ~RS_IN_CONTENT;\n    return 1;\n  }\n\n  # keep this for the progress callback (it gets cleared in return_response\n  # as I say below, this needs to go away.\n  my $buffer = $self->[REQ_BUFFER];\n\n  $self->return_response;\n  DEBUG and do {\n    warn(\n      \"REQ: request \", $self->ID,\n      \" got $this_chunk_length octets of content...\"\n    );\n\n    warn(\n      \"REQ: request \", $self->ID, \" has $self->[REQ_OCTETS_GOT]\",\n      (\n        $self->[REQ_RESPONSE]->content_length()\n        ? ( \" out of \" . $self->[REQ_RESPONSE]->content_length() )\n        : \"\"\n      ),\n      \" octets\"\n    );\n  };\n\n  if ($self->[REQ_RESPONSE]->content_length) {\n\n    # Report back progress\n    $self->[REQ_PROG_POSTBACK]->(\n      $self->[REQ_OCTETS_GOT],\n      $self->[REQ_RESPONSE]->content_length,\n      #TODO: ugh. this is stupid. Must remove/deprecate!\n      $buffer,\n    ) if ($self->[REQ_PROG_POSTBACK]);\n\n    # Stop reading when we have enough content.  -><- Should never be\n    # greater than our content length.\n    if ($self->[REQ_OCTETS_GOT] >= $self->[REQ_RESPONSE]->content_length) {\n      DEBUG and warn(\n        \"REQ: request \", $self->ID, \" has a full response... moving to done.\"\n      );\n      $self->[REQ_STATE] |= RS_DONE;\n      $self->[REQ_STATE] &= ~RS_IN_CONTENT;\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n\n### Methods to manage the request's timer.\n\n\nsub timer {\n  my ($self, $timer) = @_;\n\n  # do it this way so we can set REQ_TIMER to undef\n  if (@_ == 2) {\n    die \"overwriting timer $self->[REQ_TIMER]\" if $self->[REQ_TIMER];\n    $self->[REQ_TIMER] = $timer;\n  }\n  return $self->[REQ_TIMER];\n}\n\n\nsub create_timer {\n  my ($self, $timeout) = @_;\n\n  # remove old timeout first\n  my $kernel = $POE::Kernel::poe_kernel;\n\n  my $seconds = $timeout - (time() - $self->[REQ_START_TIME]);\n  $self->[REQ_TIMER] = $kernel->delay_set(\n    got_timeout => $seconds, $self->ID\n  );\n  DEBUG and warn(\n    \"TKO: request \", $self->ID,\n    \" has timer $self->[REQ_TIMER] going off in $seconds seconds\\n\"\n  );\n}\n\n\nsub remove_timeout {\n  my ($self) = @_;\n\n  my $alarm_id = $self->[REQ_TIMER];\n  if (defined $alarm_id) {\n    my $kernel = $POE::Kernel::poe_kernel;\n    DEBUG and warn \"REQ: Removing timer $alarm_id\";\n    $kernel->alarm_remove($alarm_id);\n    $self->[REQ_TIMER] = undef;\n  }\n}\n\n\nsub postback {\n  my ($self, $postback) = @_;\n\n  if (defined $postback) {\n    DEBUG and warn \"REQ: modifying postback\";\n    $self->[REQ_POSTBACK] = $postback;\n  }\n  return $self->[REQ_POSTBACK];\n}\n\n\nsub _set_host_header {\n  my ($request) = @_;\n  my $uri = $request->uri;\n\n  my ($new_host, $new_port);\n  eval {\n    $new_host = $uri->host();\n    $new_port = $uri->port();\n    # Only include the port if it's nonstandard.\n    if ($new_port == 80 || $new_port == 443) {\n      $request->header( Host => $new_host );\n    }\n    else {\n      $request->header( Host => \"$new_host:$new_port\" );\n    }\n  };\n\n  # Return Boolean state of the eval.\n  return $@;\n}\n\n\nsub does_redirect {\n  my ($self, $last) = @_;\n\n  if (defined $last) {\n    $self->[REQ_HISTORY] = $last;\n    # delete OLD timeout\n    #my $alarm_id = $last->[REQ_TIMEOUT];\n    #DEBUG and warn \"RED: Removing old timeout $alarm_id\\n\";\n    #$POE::Kernel::poe_kernel->alarm_remove ($alarm_id);\n  }\n\n  return defined $self->[REQ_HISTORY];\n}\n\n\nsub check_redirect {\n  my ($self) = @_;\n\n  my $max = $self->[REQ_FACTORY]->max_redirect_count;\n\n  if (defined $self->[REQ_HISTORY]) {\n    $self->[REQ_RESPONSE]->previous($self->[REQ_HISTORY]->[REQ_RESPONSE]);\n  }\n\n  return undef unless ($self->[REQ_RESPONSE]->is_redirect);\n\n  # Make sure to frob any cookies set.  Redirect cookies are cookies, too!\n  $self->[REQ_FACTORY]->frob_cookies($self->[REQ_RESPONSE]);\n\n  my $location_uri = $self->[REQ_RESPONSE]->header('Location');\n\n  DEBUG and warn \"REQ: Preparing redirect to $location_uri\";\n  my $base = $self->[REQ_RESPONSE]->base();\n  $location_uri = URI->new($location_uri, $base)->abs($base);\n  DEBUG and warn \"RED: Actual redirect uri is $location_uri\";\n\n  my $prev = $self;\n  my $history = 0;\n  while ($prev = $prev->[REQ_HISTORY]) {\n    last if ++$history > $max;\n  }\n\n  if ($history >= $max) {\n    #$self->[REQ_STATE] |= RS_DONE;\n    DEBUG and warn \"RED: Too much redirection\";\n  }\n  else { # All fine, yield new request and mark this disabled.\n    my $newrequest = $self->[REQ_HTTP_REQUEST]->clone();\n\n    # Sanitize new request per rt #30400.\n    # TODO - What other headers are security risks?\n    $newrequest->remove_header('Cookie');\n\n    DEBUG and warn \"RED: new request $newrequest\";\n    $newrequest->uri($location_uri);\n\n    # Don't change the Host header on a relative redirect.  This\n    # allows the HTTP::Request's Host to remain intact, per\n    # rt.cpan.org #63990.\n    if (defined $location_uri->scheme()) {\n      DEBUG and warn \"RED: redirecting to absolute location $location_uri\";\n      _set_host_header($newrequest);\n    }\n    else {\n      DEBUG and warn \"RED: no new Host for relative redirect to $location_uri\";\n    }\n\n    $self->[REQ_STATE] = RS_REDIRECTED;\n    DEBUG and warn \"RED: new request $newrequest\";\n    return $newrequest;\n  }\n  return undef;\n}\n\n\nsub send_to_wheel {\n  my ($self) = @_;\n\n  $self->[REQ_STATE] = RS_SENDING;\n\n  my $http_request = $self->[REQ_HTTP_REQUEST];\n\n  # MEXNIX 2002-06-01: Check for proxy.  Request query is a bit\n  # different...\n\n  my $request_uri;\n  if ($self->[REQ_USING_PROXY]) {\n    $request_uri = $http_request->uri()->canonical();\n  }\n  else {\n    $request_uri = $http_request->uri()->canonical()->path_query();\n  }\n\n  my $request_string = (\n    $http_request->method() . ' ' .\n    $request_uri . ' ' .\n    $http_request->protocol() . \"\\x0D\\x0A\" .\n    $http_request->headers_as_string(\"\\x0D\\x0A\") . \"\\x0D\\x0A\"\n  );\n \n  if ( !ref $http_request->content() ) {\n    $request_string .= $http_request->content(); # . \"\\x0D\\x0A\"\n  }\n\n  DEBUG and do {\n    my $formatted_request_string = $request_string;\n    $formatted_request_string =~ s/([^\\n])$/$1\\n/;\n    $formatted_request_string =~ s/^/| /mg;\n    warn \",----- SENDING REQUEST \", '-' x 56, \"\\n\";\n    warn $formatted_request_string;\n    warn \"`\", '-' x 78, \"\\n\";\n  };\n\n  $self->[REQ_CONNECTION]->wheel->put ($request_string);\n}\n\n\nsub wheel {\n  my ($self) = @_;\n\n  # FIXME - We don't support older versions of POE.  Remove this chunk\n  # of code when we're not fixing something else.\n  #\n  #if (defined $new_wheel) {\n  #   Switch wheels.  This is cumbersome, but it works around a bug in\n  #   older versions of POE.\n  #  $self->[REQ_WHEEL] = undef;\n  #  $self->[REQ_WHEEL] = $new_wheel;\n  #}\n\n  return unless $self->[REQ_CONNECTION];\n  return $self->[REQ_CONNECTION]->wheel;\n}\n\n\nsub error {\n  my ($self, $code, $message) = @_;\n\n  my $nl = \"\\n\";\n\n  my $http_msg = status_message($code);\n  my $r = HTTP::Response->new($code, $http_msg, [ 'X-PCCH-Errmsg', $message ]);\n  my $m = (\n    \"<html>$nl\"\n    . \"<HEAD><TITLE>Error: $http_msg</TITLE></HEAD>$nl\"\n    . \"<BODY>$nl\"\n    . \"<H1>Error: $http_msg</H1>$nl\"\n    . \"$message$nl\"\n    . \"<small>This is a client error, not a server error.</small>$nl\"\n    . \"</BODY>$nl\"\n    . \"</HTML>$nl\"\n  );\n\n  $r->content($m);\n  $r->request($self->[REQ_HTTP_REQUEST]);\n  $self->[REQ_POSTBACK]->($r);\n  $self->[REQ_STATE] |= RS_POSTED;\n}\n\n\nsub connect_error {\n  my ($self, $operation, $errnum, $errstr) = @_;\n\n  my $host = $self->[REQ_HOST];\n  my $port = $self->[REQ_PORT];\n\n  if ($operation eq \"connect\" and $errnum == ETIMEDOUT) {\n    $self->error(408, \"Connection to $host:$port failed: timeout\");\n  }\n  else {\n    $self->error(\n      RC_INTERNAL_SERVER_ERROR,\n      \"Connection to $host:$port failed: $operation error $errnum: ", 8192) = 8192
09:01:57.376928 brk(0x1ad6000)          = 0x1ad6000
09:01:57.377658 read(9, "$errstr\"\n    );\n  }\n\n  return;\n}\n\n\nsub host { $_[0][REQ_HOST] }\n\n\nsub port { $_[0][REQ_PORT] }\n\n\nsub close_connection {\n  my ($self) = @_;\n  return unless defined $self->[REQ_CONNECTION];\n  $self->[REQ_CONNECTION]->close();\n  $self->[REQ_CONNECTION] = undef;\n}\n\n\nsub scheme {\n  my $self = shift;\n\n  $self->[REQ_USING_PROXY] ? 'http' : $self->[REQ_HTTP_REQUEST]->uri->scheme;\n}\n\n\nsub DESTROY {\n  my ($self) = @_;\n\n  delete $self->[REQ_CONNECTION];\n  delete $self->[REQ_FACTORY];\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Client::HTTP::Request - an HTTP request class\n\n=head1 VERSION\n\nversion 0.949\n\n=head1 SYNOPSIS\n\n  # Used internally by POE::Component::Client::HTTP\n\n=head1 DESCRIPTION\n\nPOE::Component::Client::HTTP::Request encapsulates the state of\nrequests POE::Component::Client::HTTP requests throughout their life\ncycles.  There turns out to be a lot of state to manage.\n\n=head1 CONSTRUCTOR\n\n=head2 new NAMED_PARAMETERS\n\nCreate a POE::Component::Client::HTTP object to manage a request.  The\nconstructor takes several named parameters:\n\n=over 2\n\n=item Request => HTTP_REQUEST\n\nA POE::Component::Client::HTTP::Request object encapsulates a plain\nHTTP::Request.  Required.\n\n=item Factory => POE_COMPONENT_CLIENT_HTTP_REQUESTFACTORY\n\nThe request may create additional requests during its lifetime, for\nexample when following redirects.  The Factory parameter specifies the\nPOE::Component::Client::HTTP::RequestFactory that may be used to\ncreate them.  Required.\n\n=item Postback => RESPONSE_POSTBACK\n\nPOE::Component::Client::HTTP creates a postback that will be used to\nsend responses to the requesting session.  Required.\n\n=item Progress => PROGRESS_POSTBACK\n\nSets the progress notification if the user has requested progress\nevents.  Optional.\n\n=item Proxy\n\nSets the proxy used for this request, if requested by the user.\nOptional.\n\n=back\n\n=head1 METHODS\n\n=head2 ID\n\nReturn the request's unique ID.\n\n=head2 return_response\n\nSends a response back to the user's session.  Called by\nPOE::Component::Client::HTTP when a complete response has arrived.\n\n=head2 add_eof\n\nCalled by POE::Component::Client::HTTP to indicate EOF has arrived.\n\n=head2 add_content PARSED_DATA\n\nCalled by POE::Component::Client::HTTP to add content data to an\nincrementally built response.  If PARSED_DATA is an object, it is\ntreated like an HTTP::Headers object and its headers are assimilated\ninto the response being built by the request.  Otherwise the\nPARSED_DATA is appended to the response's content.\n\n=head2 timer TIMER\n\nAccessor to manipulate the request's timeout timer.  Sets the\nrequest's timer if TIMER is specified, otherwise merely fetches the\none currently associated with the request.\n\n=head2 create_timer TIMEOUT\n\nCreates and sets a timer for this request.  TIMEOUT is the number of\nseconds this request may live.\n\n=head2 remove_timeout\n\nTurn off the timer associated with this request, and discard it.\n\n=head2 postback POSTBACK\n\nAccessor to manipulate the postback associated with this request.\nSets the postback if POSTBACK is defined, otherwise merely fetches it.\n\n=head2 does_redirect SOMETHING\n\nFIXME - Not sure what this accessor does.\n\n=head2 check_redirect\n\nCheck whether the last response is a redirect, the request is\npermitted to follow redirects, and the maximum number of redirects has\nnot been met.  Initiate a redirect if all conditions are favorable.\n\n=head2 close_connection\n\nEach active request object contains an internal connection.  This\nmethod closes it.\n\n=head2 send_to_wheel\n\nTransmit the request to the socket associated with this request.\n\n=head2 wheel\n\nAn accessor to return the wheel associated with this request.\n\n=head2 error ERROR_CODE, ERROR_MESSAGE\n\nGenerate an error response, and post it back to the user's session.\n\n=head2 connect_error CONNECT_FAILURE_MESSAGE\n\nGenerate a connection error response, and post it back to the user's\nsession.\n\n=head2 host\n\nReturn the host this request is attempting to work with.\n\n=head2 port\n\nReturn the port this request is attempting to work with.\n\n=head2 scheme\n\nReturn the scheme for this request.\n\n=head1 SEE ALSO\n\nL<POE::Component::Client::HTTP>\nL<POE>\n\n=head1 BUGS\n\nNone are currently known.\n\n=head1 AUTHOR & COPYRIGHTS\n\nPOE::Component::Client::HTTP::Request is\n\n=over 2\n\n=item\n\nCopyright 2004-2005 Martijn van Beers\n\n=item\n\nCopyright 2006 Rocco Caputo\n\n=back\n\nAll rights are reserved.  POE::Component::Client::HTTP::Request is\nfree software; you may redistribute it and/or modify it under the same\nterms as Perl itself.\n\n=head1 CONTRIBUTORS\n\nYour name could be here.\n\n=head1 CONTACT\n\nRocco may be contacted by e-mail via L<mailto:rcaputo@cpan.org>, and\nMartijn may be contacted by email via L<mailto:martijn@cpan.org>.\n\nThe preferred way to report bugs or requests is through RT though.\nSee L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=POE-Component-Client-HTTP>\nor mail L<mailto:bug-POE-Component-Client-HTTP@rt.cpan.org>\n\nFor questions, try the L<POE> mailing list (poe@perl.org)\n\n=cut\n", 8192) = 4957
09:01:57.378070 lseek(9, 16877, SEEK_SET) = 16877
09:01:57.378120 lseek(9, 0, SEEK_CUR)   = 16877
09:01:57.378165 close(9)                = 0
09:01:57.378666 brk(0x1af7000)          = 0x1af7000
09:01:57.378932 read(8, " the Streaming parameter\n\n=cut\n\n\nsub block_size {\n  my ($self) = @_;\n\n  my $block_size = $self->[FCT_STREAMING] || DEFAULT_BLOCK_SIZE;\n  $block_size = DEFAULT_BLOCK_SIZE if $block_size < 1;\n\n  return $block_size;\n}\n\n\n=head2 frob_cookies $response\n\nStore the cookies from the L<HTTP::Response> parameter passed into\nour cookie jar\n\n=cut\n\n\nsub frob_cookies {\n  my ($self, $response) = @_;\n\n  if (defined $self->[FCT_COOKIEJAR]) {\n    $self->[FCT_COOKIEJAR] ->extract_cookies($response);\n  }\n}\n\n\n=head2 max_redirect_count [$count]\n\nFunction to get/set the maximum number of redirects to follow\nautomatically. This allows you to retrieve or modify the value\nyou passed with the FollowRedirects parameter to L<Client::HTTP>'s\nC<spawn> method.\n\n=cut\n\n\nsub max_redirect_count {\n  my ($self, $count) = @_;\n\n  if (defined $count) {\n    $self->[FCT_FOLLOWREDIRECTS] = $count;\n  }\n  return $self->[FCT_FOLLOWREDIRECTS];\n}\n\n\n=head2 parse_proxy $proxy\n\nThis static method is used for parsing proxies. The $proxy can be\narray reference like [host, port] or comma separated string like\n\"http://1.2.3.4:80/,http://2.3.4.5:80/\".\n\nparse_proxy() returns an array reference of two-element tuples (also\narray ferences), each containing a host and a port:\n\n  [ [ host1, port1 ],\n    [ host2, port2 ],\n    ...\n  ]\n\n=cut\n\n\nsub parse_proxy {\n  my $proxy = $_[1];\n\n  if (ref($proxy) eq 'ARRAY') {\n    croak \"Proxy must contain [HOST,PORT]\" unless @$proxy == 2;\n    $proxy = [ $proxy ];\n  } else {\n    my @proxies = split /\\s*\\,\\s*/, $proxy;\n    foreach (@proxies) {\n      s/^http:\\/+//;\n      s/\\/+$//;\n      croak \"Proxy must contain host:port\" unless /^(.+):(\\d+)$/;\n      $_ = [ $1, $2 ];\n    }\n    if (@proxies) {\n      $proxy = \\@proxies;\n    } else {\n      undef $proxy; # Empty proxy list means not to use proxy\n    }\n  }\n\n  $_[1] = $proxy;\n}\n\n1;\n", 8192) = 1828
09:01:57.379242 read(8, "", 8192)       = 0
09:01:57.379292 close(8)                = 0
09:01:57.379605 stat("modules/POE/Filter/HTTPHead.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.379658 stat("modules/POE/Filter/HTTPHead.pm", {st_mode=S_IFREG|0600, st_size=7192, ...}) = 0
09:01:57.379717 open("modules/POE/Filter/HTTPHead.pm", O_RDONLY) = 8
09:01:57.379769 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.379815 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.379890 read(8, "package POE::Filter::HTTPHead_Line;\n# vim: ts=2 sw=2 expandtab\n$POE::Filter::HTTPHead_Line::VERSION = '0.949';\nuse warnings;\nuse strict;\n\nuse base 'POE::Filter';\n\nuse HTTP::Response;\n\nuse constant {\n  FRAMING_BUFFER   => 0,\n  CURRENT_STATE    => 1,\n  WORK_RESPONSE    => 2,\n  PROTOCOL_VERSION => 3,\n};\n\nuse constant {\n  STATE_STATUS => 0x01,  # waiting for a status line\n  STATE_HEADER => 0x02,  # gotten status, looking for header or end\n};\n\nuse constant DEBUG => 0;\n\nsub new {\n  my $type = shift;\n\n  my $self = bless [\n    [],           # FRAMING_BUFFER\n    STATE_STATUS, # CURRENT_STATE\n    undef,        # WORK_RESPONSE\n    \"0.9\",        # PROTOCOL_VERSION\n  ], $type;\n\n  $self;\n}\n\nsub get_one_start {\n  my ($self, $chunks) = @_;\n\n  # We're receiving newline-terminated lines.  Strip off any carriage\n  # returns that might be left over.\n  s/\\x0D$// foreach @$chunks;\n  s/^\\x0D// foreach @$chunks;\n\n  push (@{$self->[FRAMING_BUFFER]}, @$chunks);\n  #warn \"now got \", scalar @{$self->[FRAMING_BUFFER]}, \" lines\";\n}\n\nsub get_one {\n  my $self = shift;\n\n  # Process lines while we have them.\n  LINE: while (@{$self->[FRAMING_BUFFER]}) {\n    my $line = shift @{$self->[FRAMING_BUFFER]};\n\n    # Waiting for a status line.\n    if ($self->[CURRENT_STATE] == STATE_STATUS) {\n      DEBUG and warn \"----- Waiting for a status line.\\n\";\n\n      # Does the line look like a status line?\n      if ($line =~ m!^(\\d{3})\\s+(.+?)\\s+HTTP/(\\d+\\.\\d+)$!) {\n        $self->[PROTOCOL_VERSION] = $3;\n        $self->[WORK_RESPONSE] = HTTP::Response->new($1, $2);\n        $self->[WORK_RESPONSE]->protocol('HTTP/' . $self->[PROTOCOL_VERSION]);\n        $self->[CURRENT_STATE] = STATE_HEADER;\n        DEBUG and warn \"Got a status line\";\n        next LINE;\n      }\n      elsif ($line =~ m!^(\\d{3})\\s+(.+?)$!) {\n        $self->[PROTOCOL_VERSION] = 0.9;\n        $self->[WORK_RESPONSE] = HTTP::Response->new($1, $2);\n        $self->[WORK_RESPONSE]->protocol('HTTP/' . $self->[PROTOCOL_VERSION]);\n        $self->[CURRENT_STATE] = STATE_HEADER;\n        DEBUG and warn \"Got a status line\";\n        next LINE;\n      }\n      elsif ($line =~ m!^(\\d{3})$!) {\n        $self->[PROTOCOL_VERSION] = 0.9;\n        $self->[WORK_RESPONSE] = HTTP::Response->new($1);\n        $self->[WORK_RESPONSE]->protocol('HTTP/' . $self->[PROTOCOL_VERSION]);\n        $self->[CURRENT_STATE] = STATE_HEADER;\n        DEBUG and warn \"Got a status line\";\n        next LINE;\n      }\n      elsif ($line =~ m!^HTTP/(\\d+\\.\\d+)\\s+(\\d{3})\\s+(.*?)\\s*$!) {\n        $self->[PROTOCOL_VERSION] = $1;\n        $self->[WORK_RESPONSE] = HTTP::Response->new($2, $3);\n        $self->[WORK_RESPONSE]->protocol('HTTP/' . $self->[PROTOCOL_VERSION]);\n        $self->[CURRENT_STATE] = STATE_HEADER;\n        DEBUG and warn \"Got a status line\";\n        next LINE;\n      }\n      elsif ($line =~ m!^HTTP/(\\d+\\.\\d+)\\s+(\\d{3})\\s*$!) {\n        $self->[PROTOCOL_VERSION] = $1;\n        $self->[WORK_RESPONSE] = HTTP::Response->new($2);\n        $self->[WORK_RESPONSE]->protocol('HTTP/' . $self->[PROTOCOL_VERSION]);\n        $self->[CURRENT_STATE] = STATE_HEADER;\n        DEBUG and warn \"Got a status line\";\n        next LINE;\n      }\n\n      # We have a line, but it doesn't look like a HTTP/1.1 status\n      # line.  Assume it's an HTTP/0.9 response and fabricate headers.\n      # Also, put the line back.  It's part of the content.\n      DEBUG and warn \"Faking HTTP/0.9 headers (first line not status).\\n\";\n      my $resp = HTTP::Response->new (\n        '200', 'OK', ['Content-Type' => 'text/html'], $line\n      );\n      $resp->protocol('HTTP/0.9');\n      #unshift @{$self->[FRAMING_BUFFER]}, $line;\n      return [ $resp ];\n    }\n\n    # A blank line signals the end of headers.\n    if ($line =~ /^\\s*$/) {\n      DEBUG and warn \"Got a blank line.  End of headers.\\n\";\n      $self->[CURRENT_STATE] = STATE_STATUS;\n      return [$self->[WORK_RESPONSE]];\n    }\n\n    # We have a potential header line.  Try to identify it's end.\n    my $i = 0;\n    CONTINUATION: while ($i < @{$self->[FRAMING_BUFFER]}) {\n      # Forward-looking line begins with whitespace.  It's a\n      # continuation of the previous line.\n      $i++, next CONTINUATION if $self->[FRAMING_BUFFER]->[$i] =~ /^\\s+\\S/;\n\n      DEBUG and warn \"Found end of header ($i)\\n\";\n\n      # Forward-looking line isn't a continuation line.  All buffer\n      # lines before it are part of the current header.\n      if ($i) {\n        $line .= $_ foreach (\n          map { s/^\\s+//; $_ }\n          splice(@{$self->[FRAMING_BUFFER]}, 0, $i)\n        );\n      }\n\n      DEBUG and warn \"Full header read: $line\\n\";\n\n      # And parse the line.\n      if (\n        $line =~ m{\n          ^\n          ([^\\x00-\\x19()<>@,;:\\\\\"\"\\/\\[\\]\\?={}\\x20\\t]+):\n          \\s*([^\\x00-\\x07\\x09-\\x19]+)\n          $\n        }x\n      ) {\n        DEBUG and warn \"  header($1) value($2)\\n\";\n        $self->[WORK_RESPONSE]->push_header($1, $2)\n      }\n\n      next LINE;\n    }\n\n    # We didn't find a complete header.  Put the line back, and wait\n    # for more input.\n    DEBUG and warn \"Incomplete header. Waiting for more.\\n\";\n    unshift @{$self->[FRAMING_BUFFER]}, $line;\n    return [];\n  }\n\n  # Didn't return anything else, so we don't have anything.\n  return [];\n}\n\n#=for future\n#\n#sub put {\n#  my ($self, $responses) = @_;\n#  my $out;\n#\n#  foreach my $response (@$responses) {\n#    $out = $response->as_string\n#  }\n#\n#  $out;\n#}\n#\n#=cut\n\nsub get_pending {\n  my $self = shift;\n  return $self->[FRAMING_BUFFER];\n}\n\npackage POE::Filter::HTTPHead;\n$POE::Filter::HTTPHead::VERSION = '0.949';\nuse strict;\n\n=head1 NAME\n\nPOE::Filter::HTTPHead - filter data as HTTP::Response objects\n\n=head1 VERSION\n\nversion 0.949\n\n=head1 SYNOPSYS\n\n  $filter = POE::Filter::HTTPHead->new();\n  $arrayref_of_response_objects =\n    $filter->get($arrayref_of_raw_chunks_from_driver);\n\n  $arrayref_of_leftovers = $filter->get_pending();\n\n=head1 DESCRIPTION\n\nThe HTTPHead filter turns stream data that has the appropriate format\ninto a HTTP::Response object. In an all-POE world, this would sit on\nthe other end of a connection as L<POE::Filter::HTTPD>\n\n=cut\n\nuse base qw(POE::Filter::Stackable);\nuse POE::Filter::Line;\n\n=head2 new\n\nCreates a new filter to parse HTTP headers.  Takes no parameters, and\nreturns a shiny new POE::Filter::HTTPHead object.\n\n=cut\n\nsub new {\n  my $type = shift;\n\n  # Look for EOL defined as linefeed.  We'll strip off possible\n  # carriage returns in HTTPHead_Line's get_one_start().\n\n  my $self = $type->SUPER::new(\n    Filters => [\n      POE::Filter::Line->new(Literal => \"\\x0A\"),\n      POE::Filter::HTTPHead_Line->new,\n    ],\n  );\n\n  return bless $self, $type;\n}\n\n=head1 METHODS\n\nSee L<POE::Filter> for documentation of the public API.\n\n=head2 get_pending\n\nReturns unparsed data pending in this filter's input buffer.  It's\nused by POE::Wheel objects to seamlessly switch between filters.\n\nDetails may be found in the POE::Filter documentation.\n\n=cut\n\nsub get_pending {\n  my $self = shift;\n\n  my @pending = map {\"$_\\n\"} @{$self->[0]->[1]->get_pending};\n  my $lines = $self->[0]->[0]->get_pending;\n  push (@pending, @$lines) if (defined $lines);\n\n  return \\@pending;\n}\n\n#=for future?\n#\n#sub put {\n#  my $self = shift;\n#  return $self->[0]->[1]->put (@_);\n#}\n#\n#=cut\n\n1;\n", 8192) = 7192
09:01:57.380935 brk(0x1b18000)          = 0x1b18000
09:01:57.381269 read(8, "", 8192)       = 0
09:01:57.381319 close(8)                = 0
09:01:57.381406 stat("modules/POE/Filter/HTTPChunk.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.381459 stat("modules/POE/Filter/HTTPChunk.pm", {st_mode=S_IFREG|0600, st_size=8251, ...}) = 0
09:01:57.381518 open("modules/POE/Filter/HTTPChunk.pm", O_RDONLY) = 8
09:01:57.381571 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.381617 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.381678 read(8, "package POE::Filter::HTTPChunk;\n# vim: ts=2 sw=2 expandtab\n$POE::Filter::HTTPChunk::VERSION = '0.949';\nuse warnings;\nuse strict;\n\nuse Carp;\nuse bytes;\nuse base 'POE::Filter';\n\nuse HTTP::Response;\n\nuse constant {\n  FRAMING_BUFFER  => 0,\n  CURRENT_STATE   => 1,\n  CHUNK_SIZE      => 2,\n  CHUNK_BUFFER    => 3,\n  TRAILER_HEADERS => 4,\n};\n\nuse constant {\n  STATE_SIZE      => 0x01,  # waiting for a status line\n  STATE_DATA      => 0x02,  # received status, looking for header or end\n  STATE_TRAILER   => 0x04,  # received status, looking for header or end\n};\n\nuse constant DEBUG => 0;\n\nmy $HEX = qr/[\\dA-Fa-f]/o;\n\n\nsub new {\n  my ($class) = @_;\n\n  my $self = bless [\n    [],         # FRAMING_BUFFER\n    STATE_SIZE, # CURRENT_STATE\n    0,          # CHUNK_SIZE\n    '',         # CHUNK_BUFFER\n    undef,      # TRAILER_HEADERS\n  ], $class;\n\n  return $self;\n}\n\n\n=for later\n\nmy $TEXT = qr/[^[:cntrl:]]/o;\nmy $qdtext = qr/[^[:cntrl:]\\\"]/o; #<any TEXT except <\">>\nmy $quoted_pair = qr/\\\\[[:ascii:]]/o;\nmy $quoted_string = qr/\\\"(?:$qdtext|$quoted_pair)\\\"/o;\nmy $separators = \"[^()<>@,;:\\\\\"\\/\\[\\]\\?={} \\t\";\nmy $notoken = qr/(?:[[:cntrl:]$separators]/o;\n\nmy $chunk_ext_name = $token;\nmy $chunk_ext_val = qr/(?:$token|$quoted_string)/o;\n\nmy $chunk_extension = qr/(?:;$chunk_ext_name(?:$chunk_ext_val)?)/o;\n\n=cut\n\n\nsub get_one_start {\n  my ($self, $chunks) = @_;\n\n  #warn \"GOT MORE DATA\";\n  push (@{$self->[FRAMING_BUFFER]}, @$chunks);\n  #warn \"NUMBER OF CHUNKS is now \", scalar @{$self->[FRAMING_BUFFER]};\n}\n\n\nsub get_one {\n  my $self = shift;\n\n  my $retval = [];\n  while (defined (my $chunk = shift (@{$self->[FRAMING_BUFFER]}))) {\n    #warn \"CHUNK IS SIZE \", length($chunk);\n    #warn join(\n    #  \",\", map {sprintf(\"%02X\", ord($_))} split (//, substr ($chunk, 0, 10))\n    #);\n    #warn \"NUMBER OF CHUNKS is \", scalar @{$self->[FRAMING_BUFFER]};\n    DEBUG and warn \"STATE is \", $self->[CURRENT_STATE];\n\n    # if we're not in STATE_DATA, we need to have a newline sequence\n    # in our hunk of content to find out how far we are.\n    unless ($self->[CURRENT_STATE] & STATE_DATA) {\n      if ($chunk !~ /.\\015?\\012/s) {\n        #warn \"SPECIAL CASE\";\n        if (@{$self->[FRAMING_BUFFER]} == 0) {\n          #warn \"pushing $chunk back\";\n          unshift (@{$self->[FRAMING_BUFFER]}, $chunk);\n          return $retval;\n        }\n        else {\n          $chunk .= shift (@{$self->[FRAMING_BUFFER]});\n          #warn \"added to $chunk\";\n        }\n      }\n    }\n\n    if ($self->[CURRENT_STATE] & STATE_SIZE) {\n      DEBUG and warn \"Finding chunk length marker\";\n      if (\n        $chunk =~ s/^($HEX+)[^\\S\\015\\012]*(?:;.*?)?[^\\S\\015\\012]*\\015?\\012//s\n      ) {\n        my $length = hex($1);\n        DEBUG and warn \"Chunk should be $length bytes\";\n        $self->[CHUNK_SIZE] = $length;\n        if ($length == 0) {\n          $self->[TRAILER_HEADERS] = HTTP::Headers->new;\n          $self->[CURRENT_STATE] = STATE_TRAILER;\n        }\n        else {\n          $self->[CURRENT_STATE] = STATE_DATA;\n        }\n      }\n      else {\n        # ok, this is a hack. skip to the next line if we\n        # don't find the chunk length, it might just be an extra\n        # line or something, and the chunk length always is on\n        # a line of it's own, so this seems the only way to recover\n        # somewhat.\n        #TODO: after discussing on IRC, the concensus was to return\n        #an error Response here, and have the client shut down the\n        #connection.\n        DEBUG and warn \"DIDN'T FIND CHUNK LENGTH $chunk\";\n        my $replaceN = $chunk =~ s/.*?\\015?\\012//s;\n        unshift (@{$self->[FRAMING_BUFFER]}, $chunk) if ($replaceN == 1);\n        return $retval;\n      }\n    }\n\n    if ($self->[CURRENT_STATE] & STATE_DATA) {\n      my $len = $self->[CHUNK_SIZE] - length ($self->[CHUNK_BUFFER]);\n      DEBUG and\n        warn \"going for length \", $self->[CHUNK_SIZE], \" (need $len more)\";\n      my $newchunk = $self->[CHUNK_BUFFER];\n      $self->[CHUNK_BUFFER] = \"\";\n      $newchunk .= substr ($chunk, 0, $len, '');\n      #warn \"got \" . length($newchunk) . \" bytes of data\";\n      if (length $newchunk != $self->[CHUNK_SIZE]) {\n        #smaller, so wait\n        $self->[CHUNK_BUFFER] = $newchunk;\n        next;\n      }\n      $self->[CURRENT_STATE] = STATE_SIZE;\n      #warn \"BACK TO FINDING CHUNK SIZE $chunk\";\n      if (length ($chunk) > 0) {\n        DEBUG and warn \"we still have a bit $chunk \", length($chunk);\n        #warn \"'\", substr ($chunk, 0, 10), \"'\";\n        $chunk =~ s/^\\015?\\012//s;\n        #warn \"'\", substr ($chunk, 0, 10), \"'\";\n        unshift (@{$self->[FRAMING_BUFFER]}, $chunk);\n      }\n      push @$retval, $newchunk;\n      #return [$newchunk];\n    }\n\n    if ($self->[CURRENT_STATE] & STATE_TRAILER) {\n      while ($chunk =~ s/^([-\\w]+):\\s*(.*?)\\015?\\012//s) {\n        DEBUG and warn \"add trailer header $1\";\n        $self->[TRAILER_HEADERS]->push_header ($1, $2);\n      }\n      #warn \"leftover: \", $chunk;\n      #warn join (\n      #  \",\",\n      #  map {sprintf(\"%02X\", ord($_))} split (//, substr ($chunk, 0, 10))\n      #), \"\\n\";\n      if ($chunk =~ s/^\\015?\\012//s) {\n        my $headers = delete $self->[TRAILER_HEADERS];\n\n        push (@$retval, $headers);\n        DEBUG and warn \"returning \", scalar @$retval, \"responses\";\n        unshift (@{$self->[FRAMING_BUFFER]}, $chunk) if (length $chunk);\n        return $retval;\n      }\n      if (@{$self->[FRAMING_BUFFER]}) {\n          $self->[FRAMING_BUFFER]->[0] = $chunk . $self->[FRAMING_BUFFER]->[0];\n      } else {\n          unshift (@{$self->[FRAMING_BUFFER]}, $chunk);\n          return $retval;\n      }\n    }\n  }\n  return $retval;\n}\n\n\n=for future\n\nsub put {\n  die \"not implemented yet\";\n}\n\n=cut\n\n\nsub get_pending {\n  my $self = shift;\n  return $self->[FRAMING_BUFFER] if @{$self->[FRAMING_BUFFER]};\n  return undef;\n}\n\n\n__END__\n\n=head1 NAME\n\nPOE::Filter::HTTPChunk - Non-blocking incremental HTTP chunk parser.\n\n=head1 VERSION\n\nversion 0.949\n\n=head1 SYNOPSIS\n\n  # Not a complete program.\n  use POE::Filter::HTTPChunk;\n  use POE::Wheel::ReadWrite;\n  sub setup_io {\n    $_[HEAP]->{io_wheel} = POE::Wheel::ReadWrite->new(\n      Filter => POE::Filter::HTTPChunk->new(),\n      # See POE::Wheel::ReadWrite for other required parameters.\n    );\n  }\n\n=head1 DESCRIPTION\n\nThis filter parses HTTP chunks from a data stream.  It's used by\nPOE::Component::Client::HTTP to do the bulk of the low-level HTTP\nparsing.\n\n=head1 CONSTRUCTOR\n\n=head2 new\n\nC<new> takes no parameters and returns a shiny new\nPOE::Filter::HTTPChunk object ready to use.\n\n=head1 METHODS\n\nPOE::Filter::HTTPChunk supports the following methods.  Most of them\nadhere to the standard POE::Filter API.  The documentation for\nPOE::Filter explains the API in more detail.\n\n=head2 get_one_start ARRAYREF\n\nAccept an arrayref containing zero or more raw data chunks.  They are\nadded to the filter's input buffer.  The filter will attempt to parse\nthat data when get_one() is called.\n\n  $filter_httpchunk->get_one_start(\\@stream_data);\n\n=head2 get_one\n\nParse a single HTTP chunk from the filter's input buffer.  Data is\nentered into the buffer by the get_one_start() method.  Returns an\narrayref containing zero or one parsed HTTP chunk.\n\n  $ret_arrayref = $filter_httpchunk->get_one();\n\n=head2 get_pending\n\nReturns an arrayref of stream data currently pending parsing.  It's\nused to seamlessly transfer unparsed data between an old and a new\nfilter when a wheel's filter is changed.\n\n  $pending_arrayref = $filter_httpchunk->get_pending();\n\n=head1 SEE ALSO\n\nL<POE::Filter>, L<POE>.\n\n=head1 BUGS\n\nNone are known at this time.\n\n=head1 AUTHOR & COPYRIGHTS\n\nPOE::Filter::HTTPChunk is...\n\n=over 2\n\n=item\n\nCopyright 2005-2006 Martijn van Beers\n\n=item\n\nCopyright 2006 Rocco Caputo\n\n=back\n\nAll rights are reserved.  POE::Filter::HTTPChunk is free software; you\nmay redistribute it and/or modify it under the same terms as Perl\nitself.\n\n=head1 CONTACT\n\nRocco may be contacted by e-mail via L<mailto:rcaputo@cpan.org>, and\nMartijn may be contacted by email via L<mailto:martijn@cpan.org>.\n\nThe preferred way to report bugs or requests is through RT though.\nSee\nL<http://rt.cpan.org/NoAuth/Bugs.html?Dist=POE-Component-Client-HTTP>\nor mail L<mailto:bug-POE-Component-Client-HTTP@rt.cpan.org>\n\nFor q", 8192) = 8192
09:01:57.382882 lseek(8, 5783, SEEK_SET) = 5783
09:01:57.382932 lseek(8, 0, SEEK_CUR)   = 5783
09:01:57.382978 close(8)                = 0
09:01:57.383069 stat("modules/POE/Component/Client/Keepalive.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.383122 stat("modules/POE/Component/Client/Keepalive.pm", {st_mode=S_IFREG|0600, st_size=45081, ...}) = 0
09:01:57.383181 open("modules/POE/Component/Client/Keepalive.pm", O_RDONLY) = 8
09:01:57.383234 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.383280 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.383338 read(8, "package POE::Component::Client::Keepalive;\n# vim: ts=2 sw=2 expandtab\n$POE::Component::Client::Keepalive::VERSION = '0.272';\nuse warnings;\nuse strict;\n\nuse Carp qw(croak);\nuse Errno qw(ETIMEDOUT EBADF);\nuse Socket qw(SOL_SOCKET SO_LINGER);\n\nuse POE;\nuse POE::Wheel::SocketFactory;\nuse POE::Component::Connection::Keepalive;\nuse POE::Component::Resolver;\nuse Net::IP::Minimal qw(ip_is_ipv4);\n\nmy $ssl_available;\neval {\n  require POE::Component::SSLify;\n  $ssl_available = 1;\n};\n\nuse constant DEBUG => 0;\n\nuse constant {\n  DEBUG_DNS        => (DEBUG || 0),\n  DEBUG_DEALLOCATE => (DEBUG || 0),\n};\n\nuse constant TCP_PROTO => scalar(getprotobyname \"tcp\") || (\n  die \"getprotobyname('tcp') failed: $!\"\n);\n\n# Manage connection request IDs.\n\nmy $current_id = 0;\nmy %active_req_ids;\n\nsub _allocate_req_id {\n  while (1) {\n    last unless exists $active_req_ids{++$current_id};\n  }\n  return $active_req_ids{$current_id} = $current_id;\n}\n\nsub _free_req_id {\n  my $id = shift;\n  delete $active_req_ids{$id};\n}\n\nmy $default_resolver;\nmy $instances = 0;\n\n# The connection manager uses a number of data structures, most of\n# them arrays.  These constants define offsets into those arrays, and\n# the comments document them.\n\nuse constant {         # @$self = (\n  SF_POOL       => 0,  #   \\%socket_pool,\n  SF_QUEUE      => 1,  #   \\@request_queue,\n  SF_USED       => 2,  #   \\%sockets_in_use,\n  SF_WHEELS     => 3,  #   \\%wheels_by_id,\n  SF_USED_EACH  => 4,  #   \\%count_by_triple,\n  SF_MAX_OPEN   => 5,  #   $max_open_count,\n  SF_MAX_HOST   => 6,  #   $max_per_host,\n  SF_SOCKETS    => 7,  #   \\%socket_xref,\n  SF_KEEPALIVE  => 8,  #   $keep_alive_secs,\n  SF_TIMEOUT    => 9,  #   $default_request_timeout,\n  SF_RESOLVER   => 10, #   $poco_client_dns_object,\n  SF_SHUTDOWN   => 11, #   $shutdown_flag,\n  SF_REQ_INDEX  => 12, #   \\%request_id_to_wheel_id,\n  SF_BIND_ADDR  => 13, #   $bind_address,\n  SF_ALIAS      => 14, #   $embedded_session_alias\n};                     # );\n\nuse constant {       # $socket_xref{$socket} = [\n  SK_KEY       => 0, #   $conn_key,\n  SK_TIMER     => 1, #   $idle_timer,\n};                   # ];\n\n# $count_by_triple{$conn_key} = $conn_count;\n\nuse constant {        # $wheels_by_id{$wheel_id} = [\n  WHEEL_WHEEL   => 0, #   $wheel_object,\n  WHEEL_REQUEST => 1, #   $request,\n};                    # ];\n\n# $socket_pool{$conn_key}{$socket} = $socket;\n\nuse constant {      # $sockets_in_use{$socket} = (\n  USED_SOCKET => 0, #   $socket_handle,\n  USED_TIME   => 1, #   $allocation_time,\n  USED_KEY    => 2, #   $conn_key,\n};                  # );\n\n# @request_queue = (\n#   $request,\n#   $request,\n#   ....\n# );\n\nuse constant {          # $request = [\n  RQ_SESSION     => 0,  #   $request_session,\n  RQ_EVENT       => 1,  #   $request_event,\n  RQ_SCHEME      => 2,  #   $request_scheme,\n  RQ_ADDRESS     => 3,  #   $request_address,\n  RQ_IP          => 4,  #   $request_ip,\n  RQ_PORT        => 5,  #   $request_port,\n  RQ_CONN_KEY    => 6,  #   $request_connection_key,\n  RQ_CONTEXT     => 7,  #   $request_context,\n  RQ_TIMEOUT     => 8,  #   $request_timeout,\n  RQ_START       => 9,  #   $request_start_time,\n  RQ_TIMER_ID    => 10, #   $request_timer_id,\n  RQ_WHEEL_ID    => 11, #   $request_wheel_id,\n  RQ_ACTIVE      => 12, #   $request_is_active,\n  RQ_ID          => 13, #   $request_id,\n  RQ_ADDR_FAM    => 14, #   $request_address_family,\n  RQ_FOR_SCHEME  => 15, #   $...\n  RQ_FOR_ADDRESS => 16, #   $...\n  RQ_FOR_PORT    => 17, #   $...\n  RQ_RESOLVER_ID => 18, #   $resolver_request_id,\n};                      # ];\n\n# Create a connection manager.\n\nsub new {\n  my $class = shift;\n  croak \"new() needs an even number of parameters\" if @_ % 2;\n  my %args = @_;\n\n  my $max_per_host = delete($args{max_per_host}) || 4;\n  my $max_open     = delete($args{max_open})     || 128;\n  my $keep_alive   = delete($args{keep_alive})   || 15;\n  my $timeout      = delete($args{timeout})      || 120;\n  my $resolver     = delete($args{resolver});\n  my $bind_address = delete($args{bind_address});\n\n  my @unknown = sort keys %args;\n  if (@unknown) {\n    croak \"new() doesn't accept: @unknown\";\n  }\n\n  my $alias = \"POE::Component::Client::Keepalive::\" . ++$current_id;\n\n  my $self = bless [\n    { },                # SF_POOL\n    [ ],                # SF_QUEUE\n    { },                # SF_USED\n    { },                # SF_WHEELS\n    { },                # SF_USED_EACH\n    $max_open,          # SF_MAX_OPEN\n    $max_per_host,      # SF_MAX_HOST\n    { },                # SF_SOCKETS\n    $keep_alive,        # SF_KEEPALIVE\n    $timeout,           # SF_TIMEOUT\n    undef,              # SF_RESOLVER\n    undef,              # SF_SHUTDOWN\n    undef,              # SF_REQ_INDEX\n    $bind_address,      # SF_BIND_ADDR\n    undef,              # SF_ALIAS\n  ], $class;\n\n  $default_resolver = $resolver if (\n    $resolver and eval { $resolver->isa('POE::Component::Resolver') }\n  );\n\n  $self->[SF_RESOLVER] = (\n    $default_resolver ||= POE::Component::Resolver->new()\n  );\n\n  my $session = POE::Session->create(\n    object_states => [\n      $self => {\n        _start                 => \"_ka_initialize\",\n        _stop                  => \"_ka_stopped\",\n        ka_add_to_queue        => \"_ka_add_to_queue\",\n        ka_cancel_dns_response => \"_ka_cancel_dns_response\",\n        ka_conn_failure        => \"_ka_conn_failure\",\n        ka_conn_success        => \"_ka_conn_success\",\n        ka_deallocate          => \"_ka_deallocate\",\n        ka_dns_response        => \"_ka_dns_response\",\n        ka_keepalive_timeout   => \"_ka_keepalive_timeout\",\n        ka_reclaim_socket      => \"_ka_reclaim_socket\",\n        ka_relinquish_socket   => \"_ka_relinquish_socket\",\n        ka_request_timeout     => \"_ka_request_timeout\",\n        ka_resolve_request     => \"_ka_resolve_request\",\n        ka_set_timeout         => \"_ka_set_timeout\",\n        ka_shutdown            => \"_ka_shutdown\",\n        ka_socket_activity     => \"_ka_socket_activity\",\n        ka_wake_up             => \"_ka_wake_up\",\n      },\n    ],\n  );\n\n  $self->[SF_ALIAS] = ref($self) . \"::\" . $session->ID();\n\n  return $self;\n}\n\n# Initialize the hidden session behind this component.\n# Rendezvous with the object via a mutually agreed upon alias.\n\nsub _ka_initialize {\n  my ($object, $kernel, $heap) = @_[OBJECT, KERNEL, HEAP];\n  $instances++;\n  $heap->{dns_requests} = { };\n  $kernel->alias_set(ref($object) . \"::\" . $_[SESSION]->ID());\n}\n\n# When programs crash, the session may stop in a non-shutdown state.\n# _ka_stopped and DESTROY catch this either way the death occurs.\n\nsub _ka_stopped {\n  $_[OBJECT][SF_SHUTDOWN] = 1;\n}\n\nsub DESTROY {\n  $_[0]->shutdown();\n}\n\n# Request to wake up.  This should only happen during the edge\n# condition where the component's request queue goes from empty to\n# having one item.\n#\n# It also happens during free(), to see if there are more sockets to\n# deal with.\n#\n# TODO - Make the _ka_wake_up stuff smart enough not to post duplicate\n# messages to the queue.\n\nsub _ka_wake_up {\n  my ($self, $kernel) = @_[OBJECT, KERNEL];\n\n  # Scan the list of requests, until we find one that can be met.\n  # Fire off POE::Wheel::SocketFactory to begin the connection\n  # process.\n\n  my $request_index  = 0;\n  my $currently_open = keys(%{$self->[SF_USED]}) + keys(%{$self->[SF_SOCKETS]});\n  my @splice_list;\n\n  QUEUED:\n  foreach my $request (@{$self->[SF_QUEUE]}) {\n    DEBUG and warn \"WAKEUP: checking for $request->[RQ_CONN_KEY]\";\n\n    # Sweep away inactive requests.\n\n    unless ($request->[RQ_ACTIVE]) {\n      push @splice_list, $request_index;\n      next;\n    }\n\n    # Skip this request if its scheme/address/port triple is maxed\n    # out.\n\n    my $req_key = $request->[RQ_CONN_KEY];\n    next if (\n      ($self->[SF_USED_EACH]{$req_key} || 0) >= $self->[SF_MAX_HOST]\n    );\n\n    # Honor the request from the free pool, if possible.  The\n    # currently open socket count does not increase.\n\n    my $existing_connection = $self->_check_free_pool($req_key);\n    if ($existing_connection) {\n      push @splice_list, $request_index;\n\n      _respond(\n        $request, {\n          connection => $existing_connection,\n          from_cache => \"deferred\",\n        }\n      );\n\n      # Remove the wheel-to-request index.\n      delete $", 8192) = 8192
09:01:57.383967 stat("modules/POE/Component/Connection/Keepalive.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.384024 stat("modules/POE/Component/Connection/Keepalive.pm", {st_mode=S_IFREG|0600, st_size=5295, ...}) = 0
09:01:57.384083 open("modules/POE/Component/Connection/Keepalive.pm", O_RDONLY) = 9
09:01:57.384137 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.384182 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.384243 read(9, "# This is a proxy object for a socket.  Its most important feature is\n# that it passes the socket back to POE::Component::Client::Keepalive\n# when it's destroyed.\n\npackage POE::Component::Connection::Keepalive;\n$POE::Component::Connection::Keepalive::VERSION = '0.272';\nuse warnings;\nuse strict;\n\nuse Carp qw(croak);\nuse POE::Wheel::ReadWrite;\n\nuse constant DEBUG => 0;\n\nuse constant CK_SOCKET  => 0;  # The socket we're hiding.\nuse constant CK_MANAGER => 1;  # The connection manager that owns the socket.\nuse constant CK_WHEEL   => 2;  # The wheel we're hiding.\n\n# Assimilate a socket on construction, and the keep-alive connection\n# so that free() may be called at destruction time.\n\nsub new {\n  my ($class, %args) = @_;\n\n  my $self = bless [\n    $args{socket},      # CK_SOCKET\n    $args{manager},     # CK_MANAGER\n    undef,              # CK_WHEEL\n  ], $class;\n\n  return $self;\n}\n\n# Free the socket on destruction.\n\nsub DESTROY {\n  my $self = shift;\n  $self->[CK_WHEEL] = undef;\n  $self->[CK_MANAGER] and $self->[CK_MANAGER]->free($self->[CK_SOCKET]);\n}\n\n# Start a Read/Write wheel on the hidden socket.\n\nsub start {\n  my $self = shift;\n  croak \"Must call start() with an even number of parameters\" if @_ % 2;\n  my %args = @_;\n\n  # Override the read/write handle with our own.\n  $args{Handle} = $self->[CK_SOCKET];\n\n  $self->[CK_WHEEL] = POE::Wheel::ReadWrite->new(%args);\n}\n\n# Wheel accessor, for modifying the wheel directly.\n\nsub wheel {\n  my $self = shift;\n  return $self->[CK_WHEEL];\n}\n\n\n# For getting rid of the connection prematurely\n\nsub close {\n  my $self = shift;\n\n  DEBUG and warn \"closing $self ($self->[CK_WHEEL]) ($self->[CK_SOCKET])\";\n  if (defined $self->wheel) {\n    $self->wheel->shutdown_input();\n    $self->wheel->shutdown_output();\n    $self->[CK_WHEEL] = undef;\n  }\n\n  DEBUG and warn \"about to close potentially tied socket/ tied = \", (\n    tied(*{$self->[CK_SOCKET]}) || 'no'\n  );\n  close $self->[CK_SOCKET];\n\n  my $is_tied = defined tied(*{$self->[CK_SOCKET]});\n  # this is necessary so defined fileno() does the right thing\n  # on SSLified sockets\n  if ($is_tied) {\n    DEBUG and warn \"about to untie\";\n    untie(*{$self->[CK_SOCKET]});\n  }\n\n  if (DEBUG) {\n    if (defined(fileno($self->[CK_SOCKET]))) {\n      warn \"*** BUG: fileno still defined: \" . fileno($self->[CK_SOCKET]);\n    }\n  }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Connection::Keepalive - a wheel wrapper around a kept-alive socket\n\n=head1 VERSION\n\nversion 0.272\n\n=head1 SYNOPSIS\n\n  See the SYNOPSIS for POE::Component::Client::Keepalive for a\n  complete working example.\n\n  my $connection = $response->{connection};\n  $heap->{connection} = $connection;\n\n  $connection->start( InputEvent => \"got_input\" );\n\n  delete $heap->{connection};  # When done with it.\n\n=head1 DESCRIPTION\n\nPOE::Component::Connection::Keepalive is a helper class for\nPOE::Component::Client::Keepalive.  It wraps managed sockets,\nproviding a few extra features.\n\nConnection objects free their underlying sockets when they are\nDESTROYed.  This eliminates the need to explicitly free sockets when\nyou are done with them.\n\nConnection objects manage POE::Wheel::ReadWrite objects internally,\nsaving a bit of effort.\n\n=over 2\n\n=item new\n\nCreates a new POE::Component::Connection::Keepalive instance.  It\naccepts two parameters: A socket handle (socket) and a reference to a\nPOE::Component::Client::Keepalive object to manage the socket when the\nconnection is destroyed.\n\n  my $conn = POE::Component::Connection::Keepalive->new(\n    socket  => $socket_handle,\n    manager => $poe_component_client_keepalive,\n  );\n\nnew() is usually called by a POE::Component::Client::Keepalive object.\n\n=item start\n\nStarts a POE::Wheel::ReadWrite object.  All parameters except Handle\nfor start() are passed directly to POE::Wheel::ReadWrite's\nconstructor.  Handle is provided by the connection object.  start()\nreturns a reference to the new POE::Wheel::ReadWrite object, but it is\nnot necessary to save a copy of that wheel.  The connection object\nkeeps a copy of the reference internally, so the wheel will persist as\nlong as the connection does.  The POE::Wheel::ReadWrite object will be\nDESTROYed when the connection object is.\n\n  # Asynchronous connection from Client::Keepalive.\n  sub handle_connection {\n    my $connection_info = $_[ARG0];\n    $_[HEAP]->{connection} = $connection_info->{connection};\n\n    $heap->{connection}->start(\n      InputEvent => \"got_input\",\n      ErrorEvent => \"got_error\",\n    );\n  }\n\n  # Stop the connection (and the wheel) when an error occurs.\n  sub handle_error {\n    delete $_[HEAP]->{connection};\n  }\n\n=item wheel\n\nReturns a reference to the internal POE::Wheel::ReadWrite object, so\nthat methods may be called upon it.\n\n  $heap->{connection}->wheel()->pause_input();\n\n=item close\n\nCloses the connection immediately. Calls shutdown_input() and\nshutdown_output() on the wheel also.\n\n=back\n\n=head1 SEE ALSO\n\nL<POE>\nL<POE::Component::Client::Keepalive>\nL<POE::Wheel::ReadWrite>\n\n=head1 BUGS\n\nNone known.\n\n=head1 LICENSE\n\nThis distribution is copyright 2004-2009 by Rocco Caputo.  All rights\nare reserved.  This distribution is free software; you may\nredistribute it and/or modify it under the same terms as Perl itself.\n\n=head1 AUTHOR\n\nRocco Caputo <rcaputo@cpan.org>\n\nSpecial thanks to Rob Bloodgood.\n\n=cut\n", 8192) = 5295
09:01:57.384628 brk(0x1b39000)          = 0x1b39000
09:01:57.384972 lseek(9, 2335, SEEK_SET) = 2335
09:01:57.385018 lseek(9, 0, SEEK_CUR)   = 2335
09:01:57.385062 close(9)                = 0
09:01:57.385134 stat("modules/POE/Component/Resolver.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.385186 stat("modules/POE/Component/Resolver.pm", {st_mode=S_IFREG|0600, st_size=23126, ...}) = 0
09:01:57.385245 open("modules/POE/Component/Resolver.pm", O_RDONLY) = 9
09:01:57.385297 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.385343 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.385401 read(9, "package POE::Component::Resolver;\n{\n  $POE::Component::Resolver::VERSION = '0.921';\n}\n\nuse warnings;\nuse strict;\n\nuse POE qw(Wheel::Run Filter::Reference);\nuse Carp qw(croak carp);\nuse Time::HiRes qw(time);\nuse Socket qw(\n\tunpack_sockaddr_in AF_INET AF_INET6\n\tgetnameinfo NI_NUMERICSERV NI_NUMERICHOST\n);\n\nuse POE::Component::Resolver::Sidecar;\n\nuse Exporter;\nuse base 'Exporter';\nour (@EXPORT_OK) = qw(AF_INET AF_INET6);\n\nmy $next_alias_index = \"aaaaaaaa\";\n\n# Determine Perl's location, per perldoc perlvar's treatment of $^X.\n\nuse Config;\nmy $perl_path = $Config{perlpath};\nif ($^O ne 'VMS') {\n\t$perl_path .= $Config{_exe} unless (\n\t\t$perl_path =~ /$Config{_exe}$/i\n\t);\n}\n\n# Plain Perl constructor.\n\nsub new {\n\tmy ($class, @args) = @_;\n\n\tcroak \"new() requires an even number of parameters\" if @args % 2;\n\tmy %args = @args;\n\n\tmy $max_resolvers   = delete($args{max_resolvers}) || 8;\n\tmy $idle_timeout    = delete($args{idle_timeout})  || 15;\n\tmy $debug           = delete($args{debug})         || 0;\n\tmy $sidecar_program = delete($args{sidecar_program});\n\n\tmy $af_order = delete($args{af_order});\n\tif (defined $af_order and @$af_order) {\n\t\tif (ref($af_order) eq \"\") {\n\t\t\t$af_order = [ $af_order ];\n\t\t}\n\t\telsif (ref($af_order) ne \"ARRAY\") {\n\t\t\tcroak \"af_order must be a scalar or an array reference\";\n\t\t}\n\n\t\tmy @illegal_afs = grep { ($_ ne AF_INET) && ($_ ne AF_INET6) } @$af_order;\n\t\tcroak \"af_order may only contain AF_INET and/or AF_INET6\" if @illegal_afs;\n\t}\n\telsif (exists $ENV{POCO_RESOLVER_IPV}) {\n\t\tmy %number_to_address_family = ( 4 => AF_INET, 6 => AF_INET6 );\n\t\t$af_order = [\n\t\t\tmap { $number_to_address_family{$_} }\n\t\t\t($ENV{POCO_RESOLVER_IPV} =~ m/([46])/g)\n\t\t];\n\t}\n\n\tunless ($af_order and @$af_order) {\n\t\t# Default to IPv4 preference for backward compatibility.\n\t\t$af_order = [ AF_INET, AF_INET6 ];\n\t}\n\n\tmy @error = sort keys %args;\n\tcroak \"unknown new() parameter(s): @error\" if @error;\n\n\tunless (defined $sidecar_program and length $sidecar_program) {\n\t\tif ($^O eq \"MSWin32\") {\n\t\t\t$sidecar_program = \\&POE::Component::Resolver::Sidecar::main;\n\t\t}\n\t\telse {\n\t\t\t$sidecar_program = [\n\t\t\t\t$perl_path,\n\t\t\t\t(map { \"-I$_\" } @INC),\n\t\t\t\t'-MPOE::Component::Resolver::Sidecar',\n\t\t\t\t'-e', 'POE::Component::Resolver::Sidecar->main()'\n\t\t\t];\n\t\t}\n\t}\n\n\tmy $self = bless {\n\t\talias => \"poe_component_resolver_\" . $next_alias_index++,\n\t\tdebug => $debug,\n\t}, $class;\n\n\tPOE::Session->create(\n\t\tinline_states => {\n\t\t\t_start           => \\&_poe_start,\n\t\t\t_stop            => \\&_poe_stop,\n\t\t\t_parent          => sub { undef },  # for ASSERT_DEFAULT\n\t\t\t_child           => sub { undef },  # for ASSERT_DEFAULT\n\t\t\trequest          => \\&_poe_request,\n\t\t\tshutdown         => \\&_poe_shutdown,\n\t\t\tcancel           => \\&_poe_cancel,\n\t\t\tsidecar_closed   => \\&_poe_sidecar_closed,\n\t\t\tsidecar_error    => \\&_poe_sidecar_error,\n\t\t\tsidecar_response => \\&_poe_sidecar_response,\n\t\t\tsidecar_signal   => \\&_poe_sidecar_signal,\n\t\t\tsidecar_eject    => \\&_poe_sidecar_eject,\n\t\t\tsidecar_attach   => \\&_poe_sidecar_attach,\n\t\t},\n\t\theap => {\n\t\t\taf_order        => $af_order,\n\t\t\talias           => $self->{alias},\n\t\t\tidle_timeout    => $idle_timeout,\n\t\t\tlast_request_id => 0,\n\t\t\tmax_resolvers   => $max_resolvers,\n\t\t\trequests        => { },\n\t\t\tsidecar_ring    => [ ],\n\t\t\tsidecar_program => $sidecar_program,\n\t\t\tdebug           => $debug,\n\t\t}\n\t);\n\n\treturn $self;\n}\n\nsub DESTROY {\n\tmy $self = shift;\n\n\t# Can't resolve the session: it must already be gone.\n\treturn unless $poe_kernel->alias_resolve($self->{alias});\n\n\tcarp \"<pcr> destroying $self->{alias}\" if $self->{debug};\n\n\t$poe_kernel->call($self->{alias}, \"shutdown\");\n}\n\nsub _poe_stop {\n\tmy $heap = $_[HEAP];\n\tcarp \"<pcr> stopping $heap->{alias}\" if $heap->{debug};\n}\n\nsub shutdown {\n\tmy $self = shift;\n\n\t# Can't resolve the session: it must already be gone.\n\treturn unless $poe_kernel->alias_resolve($self->{alias});\n\n\tcarp \"<pcr> got shutdown request for $self->{alias}\" if $self->{debug};\n\n\t$poe_kernel->call($self->{alias}, \"shutdown\");\n}\n\n# Internal POE event handler to release all resources owned by the\n# hidden POE::Session and then shut it down.  It's an event handler so\n# that this code can run \"within\" the POE::Session.\n\nsub _poe_shutdown {\n\tmy ($kernel, $heap) = @_[KERNEL, HEAP];\n\n\t$heap->{shutdown} = 1;\n\n\t$kernel->alias_remove($heap->{alias});\n\n\t_poe_wipe_sidecars($heap);\n\n\tforeach my $request (values %{$heap->{requests}}) {\n\t\t$kernel->post(\n\t\t\t$request->{sender},\n\t\t\t$request->{event},\n\t\t\t'component shut down',\n\t\t\t[ ],\n\t\t\t{ map { $_ => $request->{$_} } qw(host service misc) },\n\t\t);\n\n\t\twarn \"<pcr> $heap->{alias} --refcount for sender $request->{sender}\" if (\n\t\t\t$heap->{debug}\n\t\t);\n\n\t\t$kernel->refcount_decrement($request->{sender}, __PACKAGE__);\n\t}\n\n\t$heap->{requests} = {};\n\n\t# No more sidecars to eject.\n\t$kernel->delay(sidecar_eject => undef);\n}\n\n# POE event handler to accept a request from some other session.  The\n# public Perl resolve() method forwards into this.  This runs \"within\"\n# the session so the resources it creates are properly owned.\n\nsub _poe_request {\n\tmy ($kernel, $heap, $host, $service, $hints, $event, $misc) = @_[\n\t\tKERNEL, HEAP, ARG0..ARG4\n\t];\n\n\treturn if $heap->{shutdown};\n\n\tmy $request_id = ++$heap->{last_request_id};\n\tmy $sender_id  = $_[SENDER]->ID();\n\n\twarn \"<pcr> $heap->{alias} ++refcount for sender $sender_id\" if (\n\t\t$heap->{debug}\n\t);\n\n\t$kernel->refcount_increment($sender_id, __PACKAGE__);\n\n\t_poe_setup_sidecar_ring($kernel, $heap);\n\n\tmy $next_sidecar = pop @{$heap->{sidecar_ring}};\n\tunshift @{$heap->{sidecar_ring}}, $next_sidecar;\n\n\t$next_sidecar->put( [ $request_id, $host, $service, $hints ] );\n\n\t$heap->{requests}{$request_id} = {\n\t\tbegin       => time(),\n\t\thost        => $host,\n\t\tservice     => $service,\n\t\thints       => $hints,\n\t\tsender      => $sender_id,\n\t\tevent       => $event,\n\t\tmisc        => $misc,\n\t\tsidecar_id  => $next_sidecar->ID(),\n\t};\n\n\t# No ejecting until we're done.\n\t$kernel->delay(sidecar_eject => undef);\n\n\treturn $request_id;\n}\n\n# The user wishes to cancel a DNS request that may still be in\n# progress.  This can happen in places like PoCo::Client::HTTP when\n# the HTTP request times out before the DNS request is done.\n#\n# The public cancel() API forwards the cancelation request into the\n# POE::Session managing requests via POE::Kernel's call() method.\n\nsub cancel {\n\tmy ($self, $request_id) = @_;\n\treturn $poe_kernel->call($self->{alias}, \"cancel\", $request_id);\n}\n\n# The inside-POE cancelation code.  It must run within POE so that the\n# proper resources are removed from the correct session.\n\nsub _poe_cancel {\n\tmy ($kernel, $heap, $request_id) = @_[KERNEL, HEAP, ARG0];\n\n\treturn unless exists $heap->{requests}{$request_id};\n\n\tmy $request = $heap->{requests}{$request_id};\n\t_sidecar_cleanup($kernel, $heap, $request->{sidecar_id});\n}\n\n# POE _start handler.  Initialize the session and start sidecar\n# processes, which are owned and managed by that session.\n\nsub _poe_start {\n\tmy ($kernel, $heap) = @_[KERNEL, HEAP];\n\n\tcarp \"<pcr> starting $heap->{alias}\" if $heap->{debug};\n\n\t$kernel->alias_set($heap->{alias});\n\n\t#_poe_setup_sidecar_ring($kernel, $heap);\n\n\tundef;\n}\n\n# Internal helper sub.  Make sure the apprpriate number of sidecar\n# resolvers are running at any given time.\n\nsub _poe_setup_sidecar_ring {\n\tmy ($kernel, $heap) = @_;\n\n\treturn if $heap->{shutdown};\n\n\twhile (scalar(keys %{$heap->{sidecar}}) < $heap->{max_resolvers}) {\n\t\tmy $sidecar = POE::Wheel::Run->new(\n\t\t\tStdioFilter  => POE::Filter::Reference->new(),\n\t\t\tStdoutEvent  => 'sidecar_response',\n\t\t\tStderrEvent  => 'sidecar_error',\n\t\t\tCloseEvent   => 'sidecar_closed',\n\t\t\tProgram      => $heap->{sidecar_program},\n\t\t);\n\n\t\t$heap->{sidecar}{$sidecar->PID}   = $sidecar;\n\t\t$heap->{sidecar_id}{$sidecar->ID} = $sidecar;\n\t\tpush @{$heap->{sidecar_ring}}, $sidecar;\n\n\t\t$kernel->sig_child($sidecar->PID(), \"sidecar_signal\");\n\t}\n}\n\n# Internal helper sub to replay pending requests when their associated\n# sidecars are destroyed.\n\nsub _poe_replay_pending {\n\tmy ($kernel, $heap) = @_;\n\n\twhile (my ($request_id, $request) = each %{$heap->{requests}}) {\n\n\t\t# This request is riding in an existing sidecar.\n\t\t# No need to replay it.\n\t\tnext if exists $heap->{sidecar_id}{$request->{sidecar_id}};\n\n\t\t# Give the request ", 8192) = 8192
09:01:57.385943 stat("modules/POE/Wheel/Run.pmc", 0x7ffe12339dc0) = -1 ENOENT (No such file or directory)
09:01:57.385997 stat("modules/POE/Wheel/Run.pm", {st_mode=S_IFREG|0600, st_size=71407, ...}) = 0
09:01:57.386074 open("modules/POE/Wheel/Run.pm", O_RDONLY) = 10
09:01:57.386129 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339aa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.386175 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.386235 read(10, "package POE::Wheel::Run;\n\nuse strict;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse Carp qw(carp croak);\nuse POSIX qw(\n  sysconf setsid _SC_OPEN_MAX ECHO ICANON IEXTEN ISIG BRKINT ICRNL\n  INPCK ISTRIP IXON CSIZE PARENB OPOST TCSANOW\n);\n\nuse POE qw( Wheel Pipe::TwoWay Pipe::OneWay Driver::SysRW Filter::Line );\npush @ISA, qw(POE::Wheel);\n\n# http://rt.cpan.org/Ticket/Display.html?id=50068\n# Avoid using these constants in Windows' subprocesses (actually\n# interpreter threads).  Reported in the above ticket to avoid a\n# memory leak.\nmy ($STD_INPUT_HANDLE, $STD_OUTPUT_HANDLE, $STD_ERROR_HANDLE);\n\nBEGIN {\n  die \"$^O does not support fork()\\n\" if $^O eq 'MacOS';\n\n  local $SIG{'__DIE__'} = 'DEFAULT';\n  eval    { require IO::Pty; };\n  if ($@) {\n    eval '\n      sub PTY_AVAILABLE () { 0 }\n      sub TIOCSWINSZ_AVAILABLE () { 0 }\n    ';\n  }\n  else {\n    IO::Pty->import();\n    eval 'sub PTY_AVAILABLE () { 1 }';\n\n    eval { require IO::Tty; };\n    if ($@) {\n      eval 'sub TIOCSWINSZ_AVAILABLE () { 0 }';\n    }\n    else {\n      IO::Tty->import('TIOCSWINSZ');\n      eval 'sub TIOCSWINSZ_AVAILABLE () { 1 }';\n    }\n  }\n\n  if (POE::Kernel::RUNNING_IN_HELL) {\n    eval    { require Win32::Console; Win32::Console->import() };\n    if ($@) { die \"Win32::Console needed for POE::Wheel::Run on $^O:\\n$@\" }\n\n    eval    {\n      require Win32API::File;\n      Win32API::File->import(\"FdGetOsFHandle\");\n    };\n    if ($@) { die \"Win32API::File needed for POE::Wheel::Run on $^O:\\n$@\" }\n\n    eval    { require Win32::Process; Win32::Process->import() };\n    if ($@) { die \"Win32::Process needed for POE::Wheel::Run on $^O:\\n$@\" }\n\n    eval    { require Win32::Job; Win32::Job->import() };\n    if ($@) { die \"Win32::Job needed for POE::Wheel::Run on $^O:\\n$@\" }\n\n    eval    { require Win32; Win32->import() };\n    if ($@) { die \"Win32.pm needed for POE::Wheel::Run on $^O:\\n$@\" }\n\n    $STD_INPUT_HANDLE  = STD_INPUT_HANDLE();\n    $STD_OUTPUT_HANDLE = STD_OUTPUT_HANDLE();\n    $STD_ERROR_HANDLE  = STD_ERROR_HANDLE();\n  }\n\n  # Determine the most file descriptors we can use.\n  my $max_open_fds;\n  eval {\n    $max_open_fds = sysconf(_SC_OPEN_MAX);\n  };\n  $max_open_fds = 1024 unless $max_open_fds;\n  eval \"sub MAX_OPEN_FDS () { $max_open_fds }\";\n  die if $@;\n};\n\n# Offsets into $self.\nsub UNIQUE_ID     () {  0 }\nsub ERROR_EVENT   () {  1 }\nsub CLOSE_EVENT   () {  2 }\nsub PROGRAM       () {  3 }\nsub CHILD_PID     () {  4 }\nsub CONDUIT_TYPE  () {  5 }\nsub IS_ACTIVE     () {  6 }\nsub CLOSE_ON_CALL () {  7 }\nsub STDIO_TYPE    () {  8 }\n\nsub HANDLE_STDIN  () {  9 }\nsub FILTER_STDIN  () { 10 }\nsub DRIVER_STDIN  () { 11 }\nsub EVENT_STDIN   () { 12 }\nsub STATE_STDIN   () { 13 }\nsub OCTETS_STDIN  () { 14 }\n\nsub HANDLE_STDOUT () { 15 }\nsub FILTER_STDOUT () { 16 }\nsub DRIVER_STDOUT () { 17 }\nsub EVENT_STDOUT  () { 18 }\nsub STATE_STDOUT  () { 19 }\n\nsub HANDLE_STDERR () { 20 }\nsub FILTER_STDERR () { 21 }\nsub DRIVER_STDERR () { 22 }\nsub EVENT_STDERR  () { 23 }\nsub STATE_STDERR  () { 24 }\n\nsub MSWIN32_GROUP_PID () { 25 }\n\n# Used to work around a bug in older perl versions.\nsub CRIMSON_SCOPE_HACK ($) { 0 }\n\n#------------------------------------------------------------------------------\n\nsub new {\n  my $type = shift;\n  croak \"$type needs an even number of parameters\" if @_ & 1;\n  my %params = @_;\n\n  croak \"wheels no longer require a kernel reference as their first parameter\"\n    if @_ and ref($_[0]) eq 'POE::Kernel';\n\n  croak \"$type requires a working Kernel\" unless defined $poe_kernel;\n\n  my $program = delete $params{Program};\n  croak \"$type needs a Program parameter\" unless defined $program;\n\n  my $prog_args = delete $params{ProgramArgs};\n  $prog_args = [] unless defined $prog_args;\n  croak \"ProgramArgs must be an ARRAY reference\"\n    unless ref($prog_args) eq \"ARRAY\";\n\n  my $priority_delta = delete $params{Priority};\n  $priority_delta = 0 unless defined $priority_delta;\n\n  my $close_on_call = delete $params{CloseOnCall};\n  $close_on_call = 0 unless defined $close_on_call;\n\n  my $user_id  = delete $params{User};\n  my $group_id = delete $params{Group};\n\n  # The following $stdio_type is new.  $conduit is kept around for now\n  # to preserve the logic of the rest of the module.  This change\n  # allows a Session using POE::Wheel::Run to define the type of pipe\n  # to be created for stdin and stdout.  Read the POD on Conduit.\n  # However, the documentation lies, because if Conduit is undefined,\n  # $stdio_type is set to undefined (so the default pipe type provided\n  # by POE::Pipe::TwoWay will be used). Otherwise, $stdio_type\n  # determines what type of pipe Pipe:TwoWay creates unless it's\n  # 'pty'.\n\n  my $conduit = delete $params{Conduit};\n  my $stdio_type;\n  if (defined $conduit) {\n    croak \"$type\\'s Conduit type ($conduit) is unknown\" if (\n      $conduit ne 'pipe' and\n      $conduit ne 'pty'  and\n      $conduit ne 'pty-pipe' and\n      $conduit ne 'socketpair' and\n      $conduit ne 'inet'\n    );\n    unless ($conduit =~ /^pty(-pipe)?$/) {\n      $stdio_type = $conduit;\n      $conduit = \"pipe\";\n    }\n  }\n  else {\n    $conduit = \"pipe\";\n  }\n\n  my $winsize = delete $params{Winsize};\n\n  if ($winsize) {\n    carp \"winsize can only be specified for a Conduit of type pty\"\n      if $conduit !~ /^pty(-pipe)?$/ and $winsize;\n\n    if( 'ARRAY' eq ref $winsize and 2==@$winsize ) {\n        # Standard VGA cell in 9x16\n        # http://en.wikipedia.org/wiki/VGA-compatible_text_mode#Fonts\n        $winsize->[2] = $winsize->[1]*9;\n        $winsize->[3] = $winsize->[0]*16;\n    }\n    carp \"winsize must be a 4 element arrayref\" unless ref($winsize) eq 'ARRAY'\n      and scalar @$winsize == 4;\n\n    carp \"winsize only works when IO::Tty::TIOCSWINSZ is\"\n      unless TIOCSWINSZ_AVAILABLE;\n  }\n\n  my $stdin_event  = delete $params{StdinEvent};\n  my $stdout_event = delete $params{StdoutEvent};\n  my $stderr_event = delete $params{StderrEvent};\n\n  if ($conduit eq 'pty' and defined $stderr_event) {\n    carp \"ignoring StderrEvent with pty conduit\";\n    undef $stderr_event;\n  }\n\n  #croak \"$type needs at least one of StdinEvent, StdoutEvent or StderrEvent\"\n  #  unless (defined($stdin_event) or defined($stdout_event) or defined ($stderr_event));\n\n  my $stdio_driver  = delete $params{StdioDriver}  || POE::Driver::SysRW->new();\n  my $stdin_driver  = delete $params{StdinDriver}  || $stdio_driver;\n  my $stdout_driver = delete $params{StdoutDriver} || $stdio_driver;\n  my $stderr_driver = delete $params{StderrDriver} || POE::Driver::SysRW->new();\n\n  my $stdio_filter  = delete $params{Filter};\n  my $stdin_filter  = delete $params{StdinFilter};\n  my $stdout_filter = delete $params{StdoutFilter};\n  my $stderr_filter = delete $params{StderrFilter};\n\n  #For optional redirection...\n  my $redir_err     = delete $params{RedirectStderr};\n  my $redir_out     = delete $params{RedirectStdout};\n  my $redir_in      = delete $params{RedirectStdin};\n  my $redir_output  = delete $params{RedirectOutput};\n\n  my $no_stdin      = delete $params{NoStdin};\n\n  if(defined $redir_output) {\n    $redir_out = $redir_err = $redir_output;\n  }\n\n  #Sanity check. We can't wait for redirected filehandles\n  if( (defined $redir_in and defined $stdin_event) ||\n     (defined $redir_out and defined $stdout_event) ||\n     (defined $redir_err and defined $stderr_event) ) {\n    croak(\"Redirect* and *Event stdio options are mutually exclusive\");\n  }\n\n  if (defined $stdio_filter) {\n    croak \"Filter and StdioFilter cannot be used together\"\n      if defined $params{StdioFilter};\n    croak \"Replace deprecated Filter with StdioFilter and StderrFilter\"\n      if defined $stderr_event and not defined $stderr_filter;\n    carp \"Filter is deprecated.  Please try StdioFilter and/or StderrFilter\";\n  }\n  else {\n    $stdio_filter = delete $params{StdioFilter};\n  }\n  $stdio_filter = POE::Filter::Line->new(Literal => \"\\n\")\n    unless defined $stdio_filter;\n\n  $stdin_filter  = $stdio_filter unless defined $stdin_filter;\n  $stdout_filter = $stdio_filter unless defined $stdout_filter;\n\n  if ($conduit eq 'pty' and defined $stderr_filter) {\n    carp \"ignoring StderrFilter with pty conduit\";\n    undef $stderr_filter;\n  }\n  else {\n    $stderr_filter = POE::Filter:", 8192) = 8192
09:01:57.386889 stat("modules/POE/Pipe/TwoWay.pmc", 0x7ffe12339170) = -1 ENOENT (No such file or directory)
09:01:57.386944 stat("modules/POE/Pipe/TwoWay.pm", {st_mode=S_IFREG|0600, st_size=1046, ...}) = 0
09:01:57.387003 open("modules/POE/Pipe/TwoWay.pm", O_RDONLY) = 11
09:01:57.387055 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338e50) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.387101 lseek(11, 0, SEEK_CUR)  = 0
09:01:57.387162 read(11, "# Deprecation notice: Read POE::Pipe's documentation.\n\npackage POE::Pipe::TwoWay;\n\nuse warnings;\nuse strict;\n\nuse base qw( POE::Pipe );\n\nuse vars qw($VERSION);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n\nuse IO::Pipely qw(socketpairly);\n\nsub new {\n  my ($class, $conduit_type) = @_;\n\n  return socketpairly(\n    debug => 0,\n    type => $conduit_type,\n  );\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Pipe::TwoWay - Deprecated and replaced with delegates to IO::Pipely.\n\n=head1 SYNOPSIS\n\nSee L<POE::Pipe> and L<IO::Pipely>.\n\n=head1 DESCRIPTION\n\nThis module is deprecated.  L<IO::Pipely> was released to CPAN as its\nreplacement.  Please see L<POE::Pipe> for details, including the\ndeprecation schedule.\n\n=head1 SEE ALSO\n\nL<POE::Pipe> and L<IO::Pipely>.\n\n=head1 AUTHOR & COPYRIGHT\n\nPOE::Pipe::TwoWay is copyright 2001-2013 by Rocco Caputo.  All rights\nreserved.  POE::Pipe::TwoWay is free software; you may redistribute it\nand/or modify it under the same terms as Perl itself.\n\n=cut\n\n# rocco // vim: ts=2 sw=2 expandtab\n# TODO - Edit.\n", 8192) = 1046
09:01:57.387403 lseek(11, 395, SEEK_SET) = 395
09:01:57.387450 lseek(11, 0, SEEK_CUR)  = 395
09:01:57.387495 close(11)               = 0
09:01:57.387827 stat("modules/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.387880 stat("modules/IO/Pty.pm", 0x7ffe12339730) = -1 ENOENT (No such file or directory)
09:01:57.387930 stat("modules/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.387984 stat("modules/IO/Pty.pm", 0x7ffe12339730) = -1 ENOENT (No such file or directory)
09:01:57.388033 stat("/etc/perl/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.388083 stat("/etc/perl/IO/Pty.pm", 0x7ffe12339730) = -1 ENOENT (No such file or directory)
09:01:57.388132 stat("/usr/local/lib/perl/5.14.2/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.388183 stat("/usr/local/lib/perl/5.14.2/IO/Pty.pm", 0x7ffe12339730) = -1 ENOENT (No such file or directory)
09:01:57.388234 stat("/usr/local/share/perl/5.14.2/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.388286 stat("/usr/local/share/perl/5.14.2/IO/Pty.pm", 0x7ffe12339730) = -1 ENOENT (No such file or directory)
09:01:57.388336 stat("/usr/lib/perl5/IO/Pty.pmc", 0x7ffe123397e0) = -1 ENOENT (No such file or directory)
09:01:57.388388 stat("/usr/lib/perl5/IO/Pty.pm", {st_mode=S_IFREG|0644, st_size=8528, ...}) = 0
09:01:57.388447 open("/usr/lib/perl5/IO/Pty.pm", O_RDONLY) = 11
09:01:57.388499 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe123394c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.388546 lseek(11, 0, SEEK_CUR)  = 0
09:01:57.388604 brk(0x1b5b000)          = 0x1b5b000
09:01:57.388658 read(11, "# Documentation at the __END__\n\npackage IO::Pty;\n\nuse strict;\nuse Carp;\nuse IO::Tty qw(TIOCSCTTY TCSETCTTY TIOCNOTTY);\nuse IO::File;\nrequire POSIX;\n\nuse vars qw(@ISA $VERSION);\n\n$VERSION = 1.08; # keep same as in Tty.pm\n\n@ISA = qw(IO::Handle);\neval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };\npush @ISA, \"IO::Stty\" if (not $@);  # if IO::Stty is installed\n\nsub new {\n  my ($class) = $_[0] || \"IO::Pty\";\n  $class = ref($class) if ref($class);\n  @_ <= 1 or croak 'usage: new $class';\n\n  my ($ptyfd, $ttyfd, $ttyname) = pty_allocate();\n\n  croak \"Cannot open a pty\" if not defined $ptyfd;\n\n  my $pty = $class->SUPER::new_from_fd($ptyfd, \"r+\");\n  croak \"Cannot create a new $class from fd $ptyfd: $!\" if not $pty;\n  $pty->autoflush(1);\n  bless $pty => $class;\n\n  my $slave = IO::Tty->new_from_fd($ttyfd, \"r+\");\n  croak \"Cannot create a new IO::Tty from fd $ttyfd: $!\" if not $slave;\n  $slave->autoflush(1);\n\n  ${*$pty}{'io_pty_slave'} = $slave;\n  ${*$pty}{'io_pty_ttyname'} = $ttyname;\n  ${*$slave}{'io_tty_ttyname'} = $ttyname;\n\n  return $pty;\n}\n\nsub ttyname {\n  @_ == 1 or croak 'usage: $pty->ttyname();';\n  my $pty = shift;\n  ${*$pty}{'io_pty_ttyname'};\n}\n\n\nsub close_slave {\n  @_ == 1 or croak 'usage: $pty->close_slave();';\n\n  my $master = shift;\n\n  if (exists ${*$master}{'io_pty_slave'}) {\n    close ${*$master}{'io_pty_slave'};\n    delete ${*$master}{'io_pty_slave'};\n  }\n}\n\nsub slave {\n  @_ == 1 or croak 'usage: $pty->slave();';\n\n  my $master = shift;\n\n  if (exists ${*$master}{'io_pty_slave'}) {\n    return ${*$master}{'io_pty_slave'};\n  }\n\n  my $tty = ${*$master}{'io_pty_ttyname'};\n\n  my $slave = new IO::Tty;\n\n  $slave->open($tty, O_RDWR | O_NOCTTY) ||\n    croak \"Cannot open slave $tty: $!\";\n\n  return $slave;\n}\n\nsub make_slave_controlling_terminal {\n  @_ == 1 or croak 'usage: $pty->make_slave_controlling_terminal();';\n\n  my $self = shift;\n  local(*DEVTTY);\n\n  # loose controlling terminal explicitely\n  if (defined TIOCNOTTY) {\n    if (open (\\*DEVTTY, \"/dev/tty\")) {\n      ioctl( \\*DEVTTY, TIOCNOTTY, 0 );\n      close \\*DEVTTY;\n    }\n  }\n\n  # Create a new 'session', lose controlling terminal.\n  if (not POSIX::setsid()) {\n    warn \"setsid() failed, strange behavior may result: $!\\r\\n\" if $^W;\n  }\n\n  if (open(\\*DEVTTY, \"/dev/tty\")) {\n    warn \"Could not disconnect from controlling terminal?!\\n\" if $^W;\n    close \\*DEVTTY;\n  }\n\n  # now open slave, this should set it as controlling tty on some systems\n  my $ttyname = ${*$self}{'io_pty_ttyname'};\n  my $slv = new IO::Tty;\n  $slv->open($ttyname, O_RDWR)\n    or croak \"Cannot open slave $ttyname: $!\";\n\n  if (not exists ${*$self}{'io_pty_slave'}) {\n    ${*$self}{'io_pty_slave'} = $slv;\n  } else {\n    $slv->close;\n  }\n\n  # Acquire a controlling terminal if this doesn't happen automatically\n  if (defined TIOCSCTTY) {\n    if (not defined ioctl( ${*$self}{'io_pty_slave'}, TIOCSCTTY, 0 )) {\n      warn \"warning: TIOCSCTTY failed, slave might not be set as controlling terminal: $!\" if $^W;\n    }\n  } elsif (defined TCSETCTTY) {\n    if (not defined ioctl( ${*$self}{'io_pty_slave'}, TCSETCTTY, 0 )) {\n      warn \"warning: TCSETCTTY failed, slave might not be set as controlling terminal: $!\" if $^W;\n    }\n  }\n\n  if (not open(\\*DEVTTY, \"/dev/tty\")) {\n    warn \"Error: could not connect pty as controlling terminal!\\n\";\n    return undef;\n  } else {\n    close \\*DEVTTY;\n  }\n  \n  return 1;\n}\n\n*clone_winsize_from = \\&IO::Tty::clone_winsize_from;\n*set_raw = \\&IO::Tty::set_raw;\n\n1;\n\n__END__\n\n=head1 NAME\n\nIO::Pty - Pseudo TTY object class\n\n=head1 VERSION\n\n1.08\n\n=head1 SYNOPSIS\n\n    use IO::Pty;\n\n    $pty = new IO::Pty;\n\n    $slave  = $pty->slave;\n\n    foreach $val (1..10) {\n\tprint $pty \"$val\\n\";\n\t$_ = <$slave>;\n\tprint \"$_\";\n    }\n\n    close($slave);\n\n\n=head1 DESCRIPTION\n\nC<IO::Pty> provides an interface to allow the creation of a pseudo tty.\n\nC<IO::Pty> inherits from C<IO::Handle> and so provide all the methods\ndefined by the C<IO::Handle> package.\n\nPlease note that pty creation is very system-dependend.  If you have\nproblems, see L<IO::Tty> for help.\n\n\n=head1 CONSTRUCTOR\n\n=over 3\n\n=item new\n\nThe C<new> constructor takes no arguments and returns a new file\nobject which is the master side of the pseudo tty.\n\n=back\n\n=head1 METHODS\n\n=over 4\n\n=item ttyname()\n\nReturns the name of the slave pseudo tty. On UNIX machines this will\nbe the pathname of the device.  Use this name for informational\npurpose only, to get a slave filehandle, use slave().\n\n=item slave()\n\nThe C<slave> method will return the slave filehandle of the given\nmaster pty, opening it anew if necessary.  If IO::Stty is installed,\nyou can then call C<$slave-E<gt>stty()> to modify the terminal settings.\n\n=item close_slave()\n\nThe slave filehandle will be closed and destroyed.  This is necessary\nin the parent after forking to get rid of the open filehandle,\notherwise the parent will not notice if the child exits.  Subsequent\ncalls of C<slave()> will return a newly opened slave filehandle.\n\n=item make_slave_controlling_terminal()\n\nThis will set the slave filehandle as the controlling terminal of the\ncurrent process, which will become a session leader, so this should\nonly be called by a child process after a fork(), e.g. in the callback\nto C<sync_exec()> (see L<Proc::SyncExec>).  See the C<try> script\n(also C<test.pl>) for an example how to correctly spawn a subprocess.\n\n=item set_raw()\n\nWill set the pty to raw.  Note that this is a one-way operation, you\nneed IO::Stty to set the terminal settings to anything else.\n\nOn some systems, the master pty is not a tty.  This method checks for\nthat and returns success anyway on such systems.  Note that this\nmethod must be called on the slave, and probably should be called on\nthe master, just to be sure, i.e.\n\n  $pty->slave->set_raw();\n  $pty->set_raw();\n\n\n=item clone_winsize_from(\\*FH)\n\nGets the terminal size from filehandle FH (which must be a terminal)\nand transfers it to the pty.  Returns true on success and undef on\nfailure.  Note that this must be called upon the I<slave>, i.e.\n\n $pty->slave->clone_winsize_from(\\*STDIN);\n\nOn some systems, the master pty also isatty.  I actually have no\nidea if setting terminal sizes there is passed through to the slave,\nso if this method is called for a master that is not a tty, it\nsilently returns OK.\n\nSee the C<try> script for example code how to propagate SIGWINCH.\n\n=back\n\n\n=head1 SEE ALSO\n\nL<IO::Tty>, L<IO::Tty::Constant>, L<IO::Handle>, L<Expect>, L<Proc::SyncExec>\n\n\n=head1 MAILING LISTS\n\nAs this module is mainly used by Expect, support for it is available\nvia the two Expect mailing lists, expectperl-announce and\nexpectperl-discuss, at\n\n  http://lists.sourceforge.net/lists/listinfo/expectperl-announce\n\nand\n\n  http://lists.sourceforge.net/lists/listinfo/expectperl-discuss\n\n\n=head1 AUTHORS\n\nOriginally by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>, based on the\nPtty module by Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>.\n\nNow maintained and heavily rewritten by Roland Giersig\nE<lt>F<RGiersig@cpan.org>E<gt>.\n\nContains copyrighted stuff from openssh v3.0p1, authored by \nTatu Ylonen <ylo@cs.hut.fi>, Markus Friedl and Todd C. Miller\n<Todd.Miller@courtesan.com>.\n\n\n=head1 COPYRIGHT\n\nNow all code is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\nNevertheless the above AUTHORS retain their copyrights to the various\nparts and want to receive credit if their source code is used.\nSee the source for details.\n\n\n=head1 DISCLAIMER\n\nTHIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\nOF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nIn other words: Use at your own risk.  Provided a", 8192) = 8192
09:01:57.389110 stat("modules/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389164 stat("modules/IO/Tty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.389214 stat("modules/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389262 stat("modules/IO/Tty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.389311 stat("/etc/perl/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389360 stat("/etc/perl/IO/Tty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.389409 stat("/usr/local/lib/perl/5.14.2/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389459 stat("/usr/local/lib/perl/5.14.2/IO/Tty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.389509 stat("/usr/local/share/perl/5.14.2/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389561 stat("/usr/local/share/perl/5.14.2/IO/Tty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.389611 stat("/usr/lib/perl5/IO/Tty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.389665 stat("/usr/lib/perl5/IO/Tty.pm", {st_mode=S_IFREG|0644, st_size=7524, ...}) = 0
09:01:57.389723 open("/usr/lib/perl5/IO/Tty.pm", O_RDONLY) = 12
09:01:57.389776 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338e90) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.389822 lseek(12, 0, SEEK_CUR)  = 0
09:01:57.389880 read(12, "# Documentation at the __END__\n# -*-cperl-*-\n\npackage IO::Tty;\n\nuse IO::Handle;\nuse IO::File;\nuse IO::Tty::Constant;\nuse Carp;\n\nrequire POSIX;\nrequire DynaLoader;\n\nuse vars qw(@ISA $VERSION $XS_VERSION $CONFIG $DEBUG);\n\n$VERSION = 1.08;\n$XS_VERSION = \"1.08\";\n@ISA = qw(IO::Handle);\n\neval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };\npush @ISA, \"IO::Stty\" if (not $@);  # if IO::Stty is installed\n\nBOOT_XS: {\n    # If I inherit DynaLoader then I inherit AutoLoader and I DON'T WANT TO\n    require DynaLoader;\n\n    # DynaLoader calls dl_load_flags as a static method.\n    *dl_load_flags = DynaLoader->can('dl_load_flags');\n\n    do {\n\tdefined(&bootstrap)\n\t\t? \\&bootstrap\n\t\t: \\&DynaLoader::bootstrap\n    }->(__PACKAGE__);\n}\n\nsub import {\n    IO::Tty::Constant->export_to_level(1, @_);\n}\n\nsub open {\n    my($tty,$dev,$mode) = @_;\n\n    IO::File::open($tty,$dev,$mode) or\n\treturn undef;\n\n    $tty->autoflush;\n\n    1;\n}\n\nsub clone_winsize_from {\n  my ($self, $fh) = @_;\n  croak \"Given filehandle is not a tty in clone_winsize_from, called\"\n    if not POSIX::isatty($fh);  \n  return 1 if not POSIX::isatty($self);  # ignored for master ptys\n  my $winsize = \" \"x1024; # preallocate memory\n  ioctl($fh, &IO::Tty::Constant::TIOCGWINSZ, $winsize)\n    and ioctl($self, &IO::Tty::Constant::TIOCSWINSZ, $winsize)\n      and return 1;\n  warn \"clone_winsize_from: error: $!\" if $^W;\n  return undef;\n}\n\nsub set_raw($) {\n  require POSIX;\n  my $self = shift;\n  return 1 if not POSIX::isatty($self);\n  my $ttyno = fileno($self);\n  my $termios = new POSIX::Termios;\n  unless ($termios) {\n    warn \"set_raw: new POSIX::Termios failed: $!\";\n    return undef;\n  }\n  unless ($termios->getattr($ttyno)) {\n    warn \"set_raw: getattr($ttyno) failed: $!\";\n    return undef;\n  }\n  $termios->setiflag(0);\n  $termios->setoflag(0);\n  $termios->setlflag(0);\n  $termios->setcc(&POSIX::VMIN, 1);\n  $termios->setcc(&POSIX::VTIME, 0);\n  unless ($termios->setattr($ttyno, &POSIX::TCSANOW)) {\n    warn \"set_raw: setattr($ttyno) failed: $!\";\n    return undef;\n  }\n  return 1;\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nIO::Tty - Low-level allocate a pseudo-Tty, import constants.\n\n=head1 VERSION\n\n1.08\n\n=head1 SYNOPSIS\n\n    use IO::Tty qw(TIOCNOTTY);\n    ...\n    # use only to import constants, see IO::Pty to create ptys.\n\n=head1 DESCRIPTION\n\nC<IO::Tty> is used internally by C<IO::Pty> to create a pseudo-tty.\nYou wouldn't want to use it directly except to import constants, use\nC<IO::Pty>.  For a list of importable constants, see\nL<IO::Tty::Constant>.\n\nWindows is now supported, but ONLY under the Cygwin\nenvironment, see L<http://sources.redhat.com/cygwin/>.\n\nPlease note that pty creation is very system-dependend.  From my\nexperience, any modern POSIX system should be fine.  Find below a list\nof systems that C<IO::Tty> should work on.  A more detailed table\n(which is slowly getting out-of-date) is available from the project\npages document manager at SourceForge\nL<http://sourceforge.net/projects/expectperl/>.\n\nIf you have problems on your system and your system is listed in the\n\"verified\" list, you probably have some non-standard setup, e.g. you\ncompiled your Linux-kernel yourself and disabled ptys (bummer!).\nPlease ask your friendly sysadmin for help.\n\nIf your system is not listed, unpack the latest version of C<IO::Tty>,\ndo a C<'perl Makefile.PL; make; make test; uname -a'> and send me\n(F<RGiersig@cpan.org>) the results and I'll see what I can deduce from\nthat.  There are chances that it will work right out-of-the-box...\n\nIf it's working on your system, please send me a short note with\ndetails (version number, distribution, etc. 'uname -a' and 'perl -V'\nis a good start; also, the output from \"perl Makefile.PL\" contains a\nlot of interesting info, so please include that as well) so I can get\nan overview.  Thanks!\n\n\n=head1 VERIFIED SYSTEMS, KNOWN ISSUES\n\nThis is a list of systems that C<IO::Tty> seems to work on ('make\ntest' passes) with comments about \"features\":\n\n=over 4\n\n=item * AIX 4.3\n\nReturns EIO instead of EOF when the slave is closed.  Benign.\n\n=item * AIX 5.x\n\n=item * FreeBSD 4.4\n\nEOF on the slave tty is not reported back to the master.\n\n=item * OpenBSD 2.8\n\nThe ioctl TIOCSCTTY sometimes fails.  This is also known in\nTcl/Expect, see http://expect.nist.gov/FAQ.html\n\nEOF on the slave tty is not reported back to the master.\n\n=item * Darwin 7.9.0\n\n=item * HPUX 10.20 & 11.00\n\nEOF on the slave tty is not reported back to the master.\n\n=item * IRIX 6.5\n\n=item * Linux 2.2.x & 2.4.x\n\nReturns EIO instead of EOF when the slave is closed.  Benign.\n\n=item * OSF 4.0\n\nEOF on the slave tty is not reported back to the master.\n\n=item * Solaris 8, 2.7, 2.6\n\nHas the \"feature\" of returning EOF just once?!\n\nEOF on the slave tty is not reported back to the master.\n\n=item * Windows NT/2k/XP (under Cygwin)\n\nWhen you send (print) a too long line (>160 chars) to a non-raw pty,\nthe call just hangs forever and even alarm() cannot get you out.\nDon't complain to me...\n\nEOF on the slave tty is not reported back to the master.\n\n=item * z/OS\n\n=back\n\nThe following systems have not been verified yet for this version, but\na previous version worked on them:\n\n=over 4\n\n=item * SCO Unix\n\n=item * NetBSD\n\nprobably the same as the other *BSDs...\n\n=back\n\nIf you have additions to these lists, please mail them to\nE<lt>F<RGiersig@cpan.org>E<gt>.\n\n\n=head1 SEE ALSO\n\nL<IO::Pty>, L<IO::Tty::Constant>\n\n\n=head1 MAILING LISTS\n\nAs this module is mainly used by Expect, support for it is available\nvia the two Expect mailing lists, expectperl-announce and\nexpectperl-discuss, at\n\n  http://lists.sourceforge.net/lists/listinfo/expectperl-announce\n\nand\n\n  http://lists.sourceforge.net/lists/listinfo/expectperl-discuss\n\n\n=head1 AUTHORS\n\nOriginally by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>, based on the\nPtty module by Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>.\n\nNow maintained and heavily rewritten by Roland Giersig\nE<lt>F<RGiersig@cpan.org>E<gt>.\n\nContains copyrighted stuff from openssh v3.0p1, authored by Tatu\nYlonen <ylo@cs.hut.fi>, Markus Friedl and Todd C. Miller\n<Todd.Miller@courtesan.com>.  I also got a lot of inspiry from the pty\ncode in Xemacs.\n\n\n=head1 COPYRIGHT\n\nNow all code is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\nNevertheless the above AUTHORS retain their copyrights to the various\nparts and want to receive credit if their source code is used.\nSee the source for details.\n\n\n=head1 DISCLAIMER\n\nTHIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\nOF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nIn other words: Use at your own risk.  Provided as is.  Your mileage\nmay vary.  Read the source, Luke!\n\nAnd finally, just to be sure:\n\nAny Use of This Product, in Any Manner Whatsoever, Will Increase the\nAmount of Disorder in the Universe. Although No Liability Is Implied\nHerein, the Consumer Is Warned That This Process Will Ultimately Lead\nto the Heat Death of the Universe.\n\n=cut\n", 8192) = 7524
09:01:57.390367 stat("modules/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390421 stat("modules/IO/Tty/Constant.pm", 0x7ffe12338ad0) = -1 ENOENT (No such file or directory)
09:01:57.390471 stat("modules/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390520 stat("modules/IO/Tty/Constant.pm", 0x7ffe12338ad0) = -1 ENOENT (No such file or directory)
09:01:57.390570 stat("/etc/perl/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390619 stat("/etc/perl/IO/Tty/Constant.pm", 0x7ffe12338ad0) = -1 ENOENT (No such file or directory)
09:01:57.390669 stat("/usr/local/lib/perl/5.14.2/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390720 stat("/usr/local/lib/perl/5.14.2/IO/Tty/Constant.pm", 0x7ffe12338ad0) = -1 ENOENT (No such file or directory)
09:01:57.390771 stat("/usr/local/share/perl/5.14.2/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390822 stat("/usr/local/share/perl/5.14.2/IO/Tty/Constant.pm", 0x7ffe12338ad0) = -1 ENOENT (No such file or directory)
09:01:57.390878 stat("/usr/lib/perl5/IO/Tty/Constant.pmc", 0x7ffe12338b80) = -1 ENOENT (No such file or directory)
09:01:57.390930 stat("/usr/lib/perl5/IO/Tty/Constant.pm", {st_mode=S_IFREG|0644, st_size=7200, ...}) = 0
09:01:57.390989 open("/usr/lib/perl5/IO/Tty/Constant.pm", O_RDONLY) = 13
09:01:57.391043 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338860) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.391089 lseek(13, 0, SEEK_CUR)  = 0
09:01:57.391149 read(13, "\npackage IO::Tty::Constant;\n\nuse vars qw(@ISA @EXPORT_OK);\nrequire Exporter;\n\n@ISA = qw(Exporter);\n@EXPORT_OK = qw(B0 B110 B115200 B1200 B134 B150 B153600 B1800 B19200 B200 B230400 B2400 B300 B307200 B38400 B460800 B4800 B50 B57600 B600 B75 B76800 B9600 BRKINT BS0 BS1 BSDLY CBAUD CBAUDEXT CBRK CCTS_OFLOW CDEL CDSUSP CEOF CEOL CEOL2 CEOT CERASE CESC CFLUSH CIBAUD CIBAUDEXT CINTR CKILL CLNEXT CLOCAL CNSWTCH CNUL CQUIT CR0 CR1 CR2 CR3 CRDLY CREAD CRPRNT CRTSCTS CRTSXOFF CRTS_IFLOW CS5 CS6 CS7 CS8 CSIZE CSTART CSTOP CSTOPB CSUSP CSWTCH CWERASE DEFECHO DIOC DIOCGETP DIOCSETP DOSMODE ECHO ECHOCTL ECHOE ECHOK ECHOKE ECHONL ECHOPRT EXTA EXTB FF0 FF1 FFDLY FIORDCHK FLUSHO HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR IMAXBEL INLCR INPCK ISIG ISTRIP IUCLC IXANY IXOFF IXON KBENABLED LDCHG LDCLOSE LDDMAP LDEMAP LDGETT LDGMAP LDIOC LDNMAP LDOPEN LDSETT LDSMAP LOBLK NCCS NL0 NL1 NLDLY NOFLSH OCRNL OFDEL OFILL OLCUC ONLCR ONLRET ONOCR OPOST PAGEOUT PARENB PAREXT PARMRK PARODD PENDIN RCV1EN RTS_TOG TAB0 TAB1 TAB2 TAB3 TABDLY TCDSET TCFLSH TCGETA TCGETS TCIFLUSH TCIOFF TCIOFLUSH TCION TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW TCSBRK TCSETA TCSETAF TCSETAW TCSETCTTY TCSETS TCSETSF TCSETSW TCXONC TERM_D40 TERM_D42 TERM_H45 TERM_NONE TERM_TEC TERM_TEX TERM_V10 TERM_V61 TIOCCBRK TIOCCDTR TIOCCONS TIOCEXCL TIOCFLUSH TIOCGETD TIOCGETC TIOCGETP TIOCGLTC TIOCSETC TIOCSETN TIOCSETP TIOCSLTC TIOCGPGRP TIOCGSID TIOCGSOFTCAR TIOCGWINSZ TIOCHPCL TIOCKBOF TIOCKBON TIOCLBIC TIOCLBIS TIOCLGET TIOCLSET TIOCMBIC TIOCMBIS TIOCMGET TIOCMSET TIOCM_CAR TIOCM_CD TIOCM_CTS TIOCM_DSR TIOCM_DTR TIOCM_LE TIOCM_RI TIOCM_RNG TIOCM_RTS TIOCM_SR TIOCM_ST TIOCNOTTY TIOCNXCL TIOCOUTQ TIOCREMOTE TIOCSBRK TIOCSCTTY TIOCSDTR TIOCSETD TIOCSIGNAL TIOCSPGRP TIOCSSID TIOCSSOFTCAR TIOCSTART TIOCSTI TIOCSTOP TIOCSWINSZ TM_ANL TM_CECHO TM_CINVIS TM_LCF TM_NONE TM_SET TM_SNL TOSTOP VCEOF VCEOL VDISCARD VDSUSP VEOF VEOL VEOL2 VERASE VINTR VKILL VLNEXT VMIN VQUIT VREPRINT VSTART VSTOP VSUSP VSWTCH VT0 VT1 VTDLY VTIME VWERASE WRAP XCASE XCLUDE XMT1EN XTABS);\n\n__END__\n\n=head1 NAME\n\nIO::Tty::Constant - Terminal Constants (autogenerated)\n\n=head1 SYNOPSIS\n\n use IO::Tty::Constant qw(TIOCNOTTY);\n ...\n\n=head1 DESCRIPTION\n\nThis package defines constants usually found in <termio.h> or\n<termios.h> (and their #include hierarchy).  Find below an\nautogenerated alphabetic list of all known constants and whether they\nare defined on your system (prefixed with '+') and have compilation\nproblems ('o').  Undefined or problematic constants are set to 'undef'.\n\n=head1 DEFINED CONSTANTS\n\n=over 4\n\n=item +\n\nB0\n\n=item +\n\nB110\n\n=item +\n\nB115200\n\n=item +\n\nB1200\n\n=item +\n\nB134\n\n=item +\n\nB150\n\n=item -\n\nB153600\n\n=item +\n\nB1800\n\n=item +\n\nB19200\n\n=item +\n\nB200\n\n=item +\n\nB230400\n\n=item +\n\nB2400\n\n=item +\n\nB300\n\n=item -\n\nB307200\n\n=item +\n\nB38400\n\n=item +\n\nB460800\n\n=item +\n\nB4800\n\n=item +\n\nB50\n\n=item +\n\nB57600\n\n=item +\n\nB600\n\n=item +\n\nB75\n\n=item -\n\nB76800\n\n=item +\n\nB9600\n\n=item +\n\nBRKINT\n\n=item +\n\nBS0\n\n=item +\n\nBS1\n\n=item +\n\nBSDLY\n\n=item +\n\nCBAUD\n\n=item -\n\nCBAUDEXT\n\n=item +\n\nCBRK\n\n=item -\n\nCCTS_OFLOW\n\n=item -\n\nCDEL\n\n=item +\n\nCDSUSP\n\n=item +\n\nCEOF\n\n=item +\n\nCEOL\n\n=item -\n\nCEOL2\n\n=item +\n\nCEOT\n\n=item +\n\nCERASE\n\n=item -\n\nCESC\n\n=item +\n\nCFLUSH\n\n=item +\n\nCIBAUD\n\n=item -\n\nCIBAUDEXT\n\n=item +\n\nCINTR\n\n=item +\n\nCKILL\n\n=item +\n\nCLNEXT\n\n=item +\n\nCLOCAL\n\n=item -\n\nCNSWTCH\n\n=item -\n\nCNUL\n\n=item +\n\nCQUIT\n\n=item +\n\nCR0\n\n=item +\n\nCR1\n\n=item +\n\nCR2\n\n=item +\n\nCR3\n\n=item +\n\nCRDLY\n\n=item +\n\nCREAD\n\n=item +\n\nCRPRNT\n\n=item +\n\nCRTSCTS\n\n=item -\n\nCRTSXOFF\n\n=item -\n\nCRTS_IFLOW\n\n=item +\n\nCS5\n\n=item +\n\nCS6\n\n=item +\n\nCS7\n\n=item +\n\nCS8\n\n=item +\n\nCSIZE\n\n=item +\n\nCSTART\n\n=item +\n\nCSTOP\n\n=item +\n\nCSTOPB\n\n=item +\n\nCSUSP\n\n=item -\n\nCSWTCH\n\n=item +\n\nCWERASE\n\n=item -\n\nDEFECHO\n\n=item -\n\nDIOC\n\n=item -\n\nDIOCGETP\n\n=item -\n\nDIOCSETP\n\n=item -\n\nDOSMODE\n\n=item +\n\nECHO\n\n=item +\n\nECHOCTL\n\n=item +\n\nECHOE\n\n=item +\n\nECHOK\n\n=item +\n\nECHOKE\n\n=item +\n\nECHONL\n\n=item +\n\nECHOPRT\n\n=item +\n\nEXTA\n\n=item +\n\nEXTB\n\n=item +\n\nFF0\n\n=item +\n\nFF1\n\n=item +\n\nFFDLY\n\n=item -\n\nFIORDCHK\n\n=item +\n\nFLUSHO\n\n=item +\n\nHUPCL\n\n=item +\n\nICANON\n\n=item +\n\nICRNL\n\n=item +\n\nIEXTEN\n\n=item +\n\nIGNBRK\n\n=item +\n\nIGNCR\n\n=item +\n\nIGNPAR\n\n=item +\n\nIMAXBEL\n\n=item +\n\nINLCR\n\n=item +\n\nINPCK\n\n=item +\n\nISIG\n\n=item +\n\nISTRIP\n\n=item +\n\nIUCLC\n\n=item +\n\nIXANY\n\n=item +\n\nIXOFF\n\n=item +\n\nIXON\n\n=item -\n\nKBENABLED\n\n=item -\n\nLDCHG\n\n=item -\n\nLDCLOSE\n\n=item -\n\nLDDMAP\n\n=item -\n\nLDEMAP\n\n=item -\n\nLDGETT\n\n=item -\n\nLDGMAP\n\n=item -\n\nLDIOC\n\n=item -\n\nLDNMAP\n\n=item -\n\nLDOPEN\n\n=item -\n\nLDSETT\n\n=item -\n\nLDSMAP\n\n=item -\n\nLOBLK\n\n=item +\n\nNCCS\n\n=item +\n\nNL0\n\n=item +\n\nNL1\n\n=item +\n\nNLDLY\n\n=item +\n\nNOFLSH\n\n=item +\n\nOCRNL\n\n=item +\n\nOFDEL\n\n=item +\n\nOFILL\n\n=item +\n\nOLCUC\n\n=item +\n\nONLCR\n\n=item +\n\nONLRET\n\n=item +\n\nONOCR\n\n=item +\n\nOPOST\n\n=item -\n\nPAGEOUT\n\n=item +\n\nPARENB\n\n=item -\n\nPAREXT\n\n=item +\n\nPARMRK\n\n=item +\n\nPARODD\n\n=item +\n\nPENDIN\n\n=item -\n\nRCV1EN\n\n=item -\n\nRTS_TOG\n\n=item +\n\nTAB0\n\n=item +\n\nTAB1\n\n=item +\n\nTAB2\n\n=item +\n\nTAB3\n\n=item +\n\nTABDLY\n\n=item -\n\nTCDSET\n\n=item +\n\nTCFLSH\n\n=item +\n\nTCGETA\n\n=item +\n\nTCGETS\n\n=item +\n\nTCIFLUSH\n\n=item +\n\nTCIOFF\n\n=item +\n\nTCIOFLUSH\n\n=item +\n\nTCION\n\n=item +\n\nTCOFLUSH\n\n=item +\n\nTCOOFF\n\n=item +\n\nTCOON\n\n=item +\n\nTCSADRAIN\n\n=item +\n\nTCSAFLUSH\n\n=item +\n\nTCSANOW\n\n=item +\n\nTCSBRK\n\n=item +\n\nTCSETA\n\n=item +\n\nTCSETAF\n\n=item +\n\nTCSETAW\n\n=item -\n\nTCSETCTTY\n\n=item +\n\nTCSETS\n\n=item +\n\nTCSETSF\n\n=item +\n\nTCSETSW\n\n=item +\n\nTCXONC\n\n=item -\n\nTERM_D40\n\n=item -\n\nTERM_D42\n\n=item -\n\nTERM_H45\n\n=item -\n\nTERM_NONE\n\n=item -\n\nTERM_TEC\n\n=item -\n\nTERM_TEX\n\n=item -\n\nTERM_V10\n\n=item -\n\nTERM_V61\n\n=item +\n\nTIOCCBRK\n\n=item -\n\nTIOCCDTR\n\n=item +\n\nTIOCCONS\n\n=item +\n\nTIOCEXCL\n\n=item -\n\nTIOCFLUSH\n\n=item +\n\nTIOCGETD\n\n=item -\n\nTIOCGETC\n\n=item -\n\nTIOCGETP\n\n=item -\n\nTIOCGLTC\n\n=item -\n\nTIOCSETC\n\n=item -\n\nTIOCSETN\n\n=item -\n\nTIOCSETP\n\n=item -\n\nTIOCSLTC\n\n=item +\n\nTIOCGPGRP\n\n=item +\n\nTIOCGSID\n\n=item +\n\nTIOCGSOFTCAR\n\n=item +\n\nTIOCGWINSZ\n\n=item -\n\nTIOCHPCL\n\n=item -\n\nTIOCKBOF\n\n=item -\n\nTIOCKBON\n\n=item -\n\nTIOCLBIC\n\n=item -\n\nTIOCLBIS\n\n=item -\n\nTIOCLGET\n\n=item -\n\nTIOCLSET\n\n=item +\n\nTIOCMBIC\n\n=item +\n\nTIOCMBIS\n\n=item +\n\nTIOCMGET\n\n=item +\n\nTIOCMSET\n\n=item +\n\nTIOCM_CAR\n\n=item +\n\nTIOCM_CD\n\n=item +\n\nTIOCM_CTS\n\n=item +\n\nTIOCM_DSR\n\n=item +\n\nTIOCM_DTR\n\n=item +\n\nTIOCM_LE\n\n=item +\n\nTIOCM_RI\n\n=item +\n\nTIOCM_RNG\n\n=item +\n\nTIOCM_RTS\n\n=item +\n\nTIOCM_SR\n\n=item +\n\nTIOCM_ST\n\n=item +\n\nTIOCNOTTY\n\n=item +\n\nTIOCNXCL\n\n=item +\n\nTIOCOUTQ\n\n=item -\n\nTIOCREMOTE\n\n=item +\n\nTIOCSBRK\n\n=item +\n\nTIOCSCTTY\n\n=item -\n\nTIOCSDTR\n\n=item +\n\nTIOCSETD\n\n=item -\n\nTIOCSIGNAL\n\n=item +\n\nTIOCSPGRP\n\n=item -\n\nTIOCSSID\n\n=item +\n\nTIOCSSOFTCAR\n\n=item -\n\nTIOCSTART\n\n=item +\n\nTIOCSTI\n\n=item -\n\nTIOCSTOP\n\n=item +\n\nTIOCSWINSZ\n\n=item -\n\nTM_ANL\n\n=item -\n\nTM_CECHO\n\n=item -\n\nTM_CINVIS\n\n=item -\n\nTM_LCF\n\n=item -\n\nTM_NONE\n\n=item -\n\nTM_SET\n\n=item -\n\nTM_SNL\n\n=item +\n\nTOSTOP\n\n=item -\n\nVCEOF\n\n=item -\n\nVCEOL\n\n=item +\n\nVDISCARD\n\n=item -\n\nVDSUSP\n\n=item +\n\nVEOF\n\n=item +\n\nVEOL\n\n=item +\n\nVEOL2\n\n=item +\n\nVERASE\n\n=item +\n\nVINTR\n\n=item +\n\nVKILL\n\n=item +\n\nVLNEXT\n\n=item +\n\nVMIN\n\n=item +\n\nVQUIT\n\n=item +\n\nVREPRINT\n\n=item +\n\nVSTART\n\n=item +\n\nVSTOP\n\n=item +\n\nVSUSP\n\n=item -\n\nVSWTCH\n\n=item +\n\nVT0\n\n=item +\n\nVT1\n\n=item +\n\nVTDLY\n\n=item +\n\nVTIME\n\n=item +\n\nVWERASE\n\n=item -\n\nWRAP\n\n=item +\n\nXCASE\n\n=item -\n\nXCLUDE\n\n=item -\n\nXMT1EN\n\n=item +\n\nXTABS\n\n\n=back\n\n=head1 FOR MORE INFO SEE\n\nL<IO::Tty>\n\n=cut\n\n", 8192) = 7200
09:01:57.391607 lseek(13, 2048, SEEK_SET) = 2048
09:01:57.391655 lseek(13, 0, SEEK_CUR)  = 2048
09:01:57.391699 close(13)               = 0
09:01:57.392108 lseek(12, 2067, SEEK_SET) = 2067
09:01:57.392156 lseek(12, 0, SEEK_CUR)  = 2067
09:01:57.392201 close(12)               = 0
09:01:57.392270 stat("modules/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392322 stat("modules/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392371 stat("modules/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392420 stat("modules/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392469 stat("/etc/perl/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392518 stat("/etc/perl/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392568 stat("/usr/local/lib/perl/5.14.2/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392618 stat("/usr/local/lib/perl/5.14.2/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392669 stat("/usr/local/share/perl/5.14.2/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392722 stat("/usr/local/share/perl/5.14.2/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392774 stat("/usr/lib/perl5/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392824 stat("/usr/lib/perl5/IO/Stty.pm", 0x7ffe12339100) = -1 ENOENT (No such file or directory)
09:01:57.392875 stat("/usr/share/perl5/IO/Stty.pmc", 0x7ffe123391b0) = -1 ENOENT (No such file or directory)
09:01:57.392926 stat("/usr/share/perl5/IO/Stty.pm", {st_mode=S_IFREG|0644, st_size=21096, ...}) = 0
09:01:57.392987 open("/usr/share/perl5/IO/Stty.pm", O_RDONLY) = 12
09:01:57.393040 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12338e90) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.393086 lseek(12, 0, SEEK_CUR)  = 0
09:01:57.393149 read(12, "package IO::Stty;\n\nuse strict;\nuse warnings;\n\nuse POSIX;\n\nour $VERSION='0.03';\n\n=head1 NAME\n\nIO::Stty - Change and print terminal line settings\n\n=head1 SYNOPSIS\n\n    # calling the script directly\n    stty.pl [setting...]\n    stty.pl {-a,-g,-v,--version}\n    \n    # Calling Stty module\n    use IO::Stty;\n    IO::Stty::stty(\\*TTYHANDLE, @modes);\n\n     use IO::Stty;\n     $old_mode=IO::Stty::stty(\\*STDIN,'-g');\n\n     # Turn off echoing.\n     IO::Stty::stty(\\*STDIN,'-echo');\n\n     # Do whatever.. grab input maybe?\n     $read_password = <>;\n\n     # Now restore the old mode.\n     IO::Stty::stty(\\*STDIN,$old_mode);\n\n     # What settings do we have anyway?\n     print IO::Stty::stty(\\*STDIN,'-a');\n\n=head1 DESCRIPTION\n\nThis is the PERL POSIX compliant stty. \n\n=head1 INTRO\n\nThis has not been tailored to the IO::File stuff but will work with it as\nindicated. Before you go futzing with term parameters it's a good idea to grab\nthe current settings and restore them when you finish.\n\nstty accepts the following non-option arguments that change aspects of the\nterminal line operation. A `[-]' before a capability means that it can be\nturned off by preceding it with a `-'. \n\n=head1 stty parameters\n\n=head2 Control settings\n\n=over 4\n\n=item [-]parenb\n\nGenerate parity bit in output and expect parity bit in input.\n\n=item [-]parodd\n\nSet odd parity (even with `-').\n\n=item cs5 cs6 cs7 cs8\n\nSet character size to 5, 6, 7, or 8 bits.\n\n=item [-]hupcl [-]hup\n\nSend a hangup signal when the last process closes the tty.\n\n=item [-]cstopb\n\nUse two stop bits per character (one with `-').\n\n=item [-]cread\n\nAllow input to be received.\n\n=item [-]clocal\n\nDisable modem control signals.\n\n=back\n\n=head2 Input settings\n\n=over 4\n\n=item [-]ignbrk\n\nIgnore break characters.\n\n=item [-]brkint\n\nBreaks cause an interrupt signal.\n\n=item [-]ignpar\n\nIgnore characters with parity errors.\n\n=item [-]parmrk\n\nMark parity errors (with a 255-0-character sequence).\n\n=item [-]inpck\n\nEnable input parity checking.\n\n=item [-]istrip\n\nClear high (8th) bit of input characters.\n\n=item [-]inlcr\n\nTranslate newline to carriage return.\n\n=item [-]igncr\n\nIgnore carriage return.\n\n=item [-]icrnl\n\nTranslate carriage return to newline.\n\n=item [-]ixon\n\nEnable XON/XOFF flow control.\n\n=item [-]ixoff\n\nEnable sending of stop character when the system\ninput buffer is almost full, and start character\nwhen it becomes almost empty again.\n\n=back \n\n=head2 Output settings\n\n=over 4\n\n=item [-]opost\n\nPostprocess output.\n\n=back\n\n=head2 Local settings\n\n=over 4\n\n=item [-]isig\n\nEnable interrupt, quit, and suspend special characters.\n\n=item [-]icanon\n\nEnable erase, kill, werase, and rprnt special characters.\n\n=item [-]echo\n\nEcho input characters.\n\n=item [-]echoe, [-]crterase\n\nEcho erase characters as backspace-space-backspace.\n\n=item [-]echok\n\nEcho a newline after a kill character.\n\n=item [-]echonl\n\nEcho newline even if not echoing other characters.\n\n=item [-]noflsh\n\nDisable flushing after interrupt and quit special characters.\n\n* Though this claims non-posixhood it is supported by the perl POSIX.pm.\n\n=item [-]tostop (np)\n\nStop background jobs that try to write to the terminal.\n\n=back\n\n=head2 Combination settings\n\n=over 4\n\n=item ek\n\nReset the erase and kill special characters to their default values.\n\n=item sane\n\nSame as:\n\n    cread -ignbrk brkint -inlcr -igncr icrnl -ixoff opost \n    isig icanon echo echoe echok -echonl -noflsh -tostop \n\nalso sets all special characters to their default\nvalues.\n\n=item [-]cooked\n\nSame as:\n\n    brkint ignpar istrip icrnl ixon opost isig icanon\n\nplus sets the eof and eol characters to their default values \nif they are the same as the min and time characters.\nWith `-', same as raw.\n\n=item [-]raw\n\nSame as:\n\n    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr\n    -icrnl -ixon -ixoff -opost -isig -icanon min 1 time 0\n\nWith `-', same as cooked.\n\n=item [-]pass8\n\nSame as:\n\n    -parenb -istrip cs8\n\nWith  `-',  same  as parenb istrip cs7.\n\n=item dec\n\nSame as:\n\n    echoe echoctl echoke -ixany\n\nAlso sets the interrupt special character to Ctrl-C, erase to\nDel, and kill to Ctrl-U.\n\n=back\n\n=head2 Special characters\n\nThe special characters' default values vary from system to\nsystem. They are set with the syntax `name value', where\nthe names are listed below and the value can be given\neither literally, in hat notation (`^c'), or as an integer\nwhich may start with `0x' to indicate hexadecimal, `0' to\nindicate octal, or any other digit to indicate decimal.\nGiving a value of `^-' or `undef' disables that special\ncharacter.\n\n=over 4\n\n=item intr\n\nSend an interrupt signal.\n\n=item quit\n\nSend a quit signal.\n\n=item erase\n\nErase the last character typed.\n\n=item kill\n\nErase the current line.\n\n=item eof\n\nSend an end of file (terminate the input).\n\n=item eol\n\nEnd the line.\n\n=item start\n\nRestart the output after stopping it.\n\n=item stop\n\nStop the output.\n\n=item susp\n\nSend a terminal stop signal.\n\n=back\n\n=head2 Special settings\n\n=over 4\n\n=item min N\n\nSet the minimum number of characters that will satisfy a read \nuntil the time value has expired,  when <E>-icanon<E> is set.\n\n=item time N\n\nSet the number of tenths of a second before reads\ntime out if the min number of characters  have  not\nbeen read, when -icanon is set.\n\n=item N\n\nSet the input and output speeds to N.  N can be one\nof: 0 50 75 110 134 134.5 150 200 300 600 1200 1800\n2400 4800 9600 19200 38400 exta extb.  exta is  the\nsame  as 19200; extb is the same as 38400.  0 hangs\nup the line if -clocal is set.\n\n=back\n\n=head2 OPTIONS\n\n=over 4\n\n=item -a\n\nPrint all current settings in human-readable  form.\n\n=item -g\n\nPrint all current settings in a form  that  can  be\nused  as  an  argument  to  another stty command to\nrestore the current settings.\n\n=item -v,--version\n\nPrint version info.\n\n=back\n\n=head1 Direct Subroutines\n\n=over 4\n\n=item B<stty()>\n\n    IO::Stty::stty(\\*STDIN, @params);\n\nFrom comments:\n\n    I'm not feeling very inspired about this. Terminal parameters are obscure\n    and boring. Basically what this will do is get the current setting,\n    take the parameters, modify the setting and write it back. Zzzz.\n    This is not especially efficent and probably not too fast. Assuming the POSIX\n    spec has been implemented properly it should mostly work.\n\n=cut\n\nsub stty {\n  my $tty_handle = shift; # This should be a \\*HANDLE\n\n  @_ or die(\"No parameters passed to stty\");\n\n  # Version info\n  if ($_[0] eq '-v' || $_[0] =~ /version/ ) {\n    return $IO::Stty::VERSION.\"\\n\";\n  }\n  \n  \n\n  my @parameters;\n  my $parameter;\n  # Build the 'this really means this' cases.\n  foreach $parameter (@_) {\n    if($parameter eq 'ek') {\n      push (@parameters,'erase',8,'kill',21);\n      next;\n    }\n    if($parameter eq 'sane') {\n      push (@parameters,'cread','-ignbrk','brkint','-inlcr','-igncr','icrnl',\n        '-ixoff','opost','isig','icanon','iexten','echo','echoe','echok',\n        '-echonl','-noflsh','-tostop','echok','intr',3,'quit',28,'erase',\n        8,'kill',21,'eof',4,'eol',0,'stop',19,'start',17,'susp',26,\n        'time',0,'min',0 );\n      next;\n    # Ugh.\n    }\n    if($parameter eq 'cooked' || $parameter eq '-raw') {\n    # Is this right?\n      push (@parameters,'brkint','ignpar','istrip','icrnl','ixon','opost',\n        'isig','icanon');\n      push (@parameters,'intr',3,'quit',28,'erase',8,'kill',21,'eof',\n        4,'eol',0,'stop',19,'start',17,'susp',26,'time',0,'min',0);\n      next; \n    }\n    if($parameter eq 'raw' || $parameter eq '-cooked') {\n      push (@parameters,'-ignbrk','-brkint','-ignpar','-parmrk','-inpck',\n        '-istrip','-inlcr','-igncr','-icrnl','-ixon','-ixoff',\n        '-opost','-isig','-icanon','min',1,'time',0 );\n      next;\n    }\n    if($parameter eq 'pass8') {\n      push (@parameters,'-parenb','-istrip','cs8');\n      next;\n    }\n    if($parameter eq '-pass8') {\n      push (@parameters,'parenb','istrip','cs7');\n      next;\n    }\n    if($parameter eq 'crt') {\n      push (@parameters,'echoe','echok');\n      next;\n    }\n    if($parameter eq 'dec') {\n      # 127 == delete, no?\n      push (@parameters,'echoe','echok','intr',3,'erase', 127,'kill',21);\n      next; \n    }\n    if($parameter =~ /^\\d+$/) {\n      push (@parameters,'ispeed',$parameter,'ospeed',$parameter);\n  ", 8192) = 8192
09:01:57.393589 brk(0x1b7d000)          = 0x1b7d000
09:01:57.394713 read(12, "    next;\n    }  \n    push (@parameters,$parameter);\n  }\n    \n    \n  # Notice fileno() instead of handle->fileno(). I want it to work with \n  # normal fhs.\n  my ($file_num) = fileno($tty_handle);\n  # Is it a terminal?\n  return undef unless isatty($file_num);\n  my($tty_name) = ttyname($file_num);\n  # make a terminal object.\n  my($termios)= POSIX::Termios->new();\n  $termios->getattr($file_num) || warn \"Couldn't get terminal parameters for '$tty_name', fine num ($file_num)\";\n  my($c_cflag) = $termios->getcflag;\n  my($c_iflag) = $termios->getiflag;\n  my($ispeed)  = $termios->getispeed;\n  my($c_lflag) = $termios->getlflag;\n  my($c_oflag) = $termios->getoflag;\n  my($ospeed) = $termios->getospeed;\n  my(%control_chars);\n  $control_chars{'INTR'}=$termios->getcc(VINTR);\n  $control_chars{'QUIT'}=$termios->getcc(VQUIT);\n  $control_chars{'ERASE'}=$termios->getcc(VERASE);\n  $control_chars{'KILL'}=$termios->getcc(VKILL);\n  $control_chars{'EOF'}=$termios->getcc(VEOF);\n  $control_chars{'TIME'}=$termios->getcc(VTIME);\n  $control_chars{'MIN'}=$termios->getcc(VMIN);\n  $control_chars{'START'}=$termios->getcc(VSTART);\n  $control_chars{'STOP'}=$termios->getcc(VSTOP);\n  $control_chars{'SUSP'}=$termios->getcc(VSUSP);\n  $control_chars{'EOL'}=$termios->getcc(VEOL);\n  # OK.. we have our crap.\n  # Do we want to know what the crap is?\n  if($parameters[0] eq '-a') {\n    return show_me_the_crap ($c_cflag,$c_iflag,$ispeed,$c_lflag,$c_oflag,\n      $ospeed,\\%control_chars);\n    }\n  # did we get the '-g' flag?\n  if($parameters[0] eq '-g') {\n    return \"$c_cflag:$c_iflag:$ispeed:$c_lflag:$c_oflag:$ospeed:\".\n      $control_chars{'INTR'}.\":\".\n      $control_chars{'QUIT'}.\":\".\n      $control_chars{'ERASE'}.\":\".\n      $control_chars{'KILL'}.\":\".\n      $control_chars{'EOF'}.\":\".\n      $control_chars{'TIME'}.\":\".\n      $control_chars{'MIN'}.\":\".\n      $control_chars{'START'}.\":\".\n      $control_chars{'STOP'}.\":\".\n      $control_chars{'SUSP'}.\":\".\n      $control_chars{'EOL'};\n  }\n  # Or the converse.. -g used before and we're getting the return.\n  # Note that this uses the functionality of stty -g, not any specific\n  # method. Don't take the output here and feed it to the OS stty.\n\n  # This will make  perl -w happy.\n  my(@useless_var) = split(':',$parameters[0]);\n  if (@useless_var == 17) {\n#   print \"Feeding back...\\n\";\n   @parameters = split(':',$parameters[0]);\n   ($c_cflag,$c_iflag,$ispeed,$c_lflag,$c_oflag,$ospeed)=(@parameters);\n      $control_chars{'INTR'}=$parameters[6];\n      $control_chars{'QUIT'}=$parameters[7];\n      $control_chars{'ERASE'}=$parameters[8];\n      $control_chars{'KILL'}=$parameters[9];\n      $control_chars{'EOF'}=$parameters[10];\n      $control_chars{'TIME'}=$parameters[11];\n      $control_chars{'MIN'}=$parameters[12];\n      $control_chars{'START'}=$parameters[13];\n      $control_chars{'STOP'}=$parameters[14];\n      $control_chars{'SUSP'}=$parameters[15];\n      $control_chars{'EOL'}=$parameters[16];\n      @parameters=(); # Unset so while loop is passed.\n  }\n  # So.. what shall we set?\n  my($set_value);\n  while ($parameter = shift(@parameters)) {\n#    print \"Param:$parameter:\\n\";\n    $set_value = 1; # On by default...\n    # unset if starts w/ -, as in  -crtscts\n    $set_value = 0 if $parameter=~ s/^\\-//;\n    # Now the fun part.\n    \n    # c_cc field crap.\n    if ($parameter eq 'intr') { $control_chars{'INTR'} = shift @parameters; next;}\n    if ($parameter eq 'quit') { $control_chars{'QUIT'} = shift @parameters; next;}\n    if ($parameter eq 'erase') { $control_chars{'ERASE'} = shift @parameters; next;}\n    if ($parameter eq 'kill') { $control_chars{'KILL'} = shift @parameters; next;}\n    if ($parameter eq 'eof') { $control_chars{'EOF'} = shift @parameters; next;}\n    if ($parameter eq 'eol') { $control_chars{'EOL'} = shift @parameters; next;}\n    if ($parameter eq 'start') { $control_chars{'START'} = shift @parameters; next;}\n    if ($parameter eq 'stop') { $control_chars{'STOP'} = shift @parameters; next;}\n    if ($parameter eq 'susp') { $control_chars{'SUSP'} = shift @parameters; next;}\n    if ($parameter eq 'min') { $control_chars{'MIN'} = shift @parameters; next;}\n    if ($parameter eq 'time') { $control_chars{'TIME'} = shift @parameters; next;}\n\n    # c_cflag crap\n    if ($parameter eq 'clocal') { $c_cflag = ($set_value ? ($c_cflag | CLOCAL) : ($c_cflag & (~CLOCAL))); next; } \n    if ($parameter eq 'cread') { $c_cflag = ($set_value ? ($c_cflag | CREAD) : ($c_cflag & (~CREAD))); next; } \n    # As best I can tell, doing |~CS8 will clear the bits.. under solaris\n    # anyway, where CS5 = 0, CS6 = 0x20, CS7= 0x40, CS8=0x60\n    if ($parameter eq 'cs5') { $c_cflag = (($c_cflag & ~CS8 )| CS5); next; } \n    if ($parameter eq 'cs6') { $c_cflag = (($c_cflag & ~CS8 )| CS6); next; } \n    if ($parameter eq 'cs7') { $c_cflag = (($c_cflag & ~CS8 )| CS7); next; } \n    if ($parameter eq 'cs8') { $c_cflag = ($c_cflag | CS8); next; } \n    if ($parameter eq 'cstopb') { $c_cflag = ($set_value ? ($c_cflag | CSTOPB) : ($c_cflag & (~CSTOPB))); next; } \n    if ($parameter eq 'hupcl' || $parameter eq 'hup') { $c_cflag = ($set_value ? ($c_cflag | HUPCL) : ($c_cflag & (~HUPCL))); next; } \n    if ($parameter eq 'parenb') { $c_cflag = ($set_value ? ($c_cflag | PARENB) : ($c_cflag & (~PARENB))); next; } \n    if ($parameter eq 'parodd') { $c_cflag = ($set_value ? ($c_cflag | PARODD) : ($c_cflag & (~PARODD))); next; } \n\n    # That was fun. Still awake? c_iflag time.\n    if ($parameter eq 'brkint') { $c_iflag = (($set_value ? ($c_iflag | BRKINT) : ($c_iflag & (~BRKINT)))); next; }\n    if ($parameter eq 'icrnl') { $c_iflag = (($set_value ? ($c_iflag | ICRNL) : ($c_iflag & (~ICRNL)))); next; }\n    if ($parameter eq 'ignbrk') { $c_iflag = (($set_value ? ($c_iflag | IGNBRK) : ($c_iflag & (~IGNBRK)))); next; }\n    if ($parameter eq 'igncr') { $c_iflag = (($set_value ? ($c_iflag | IGNCR) : ($c_iflag & (~IGNCR)))); next; }\n    if ($parameter eq 'ignpar') { $c_iflag = (($set_value ? ($c_iflag | IGNPAR) : ($c_iflag & (~IGNPAR)))); next; }\n    if ($parameter eq 'inlcr') { $c_iflag = (($set_value ? ($c_iflag | INLCR) : ($c_iflag & (~INLCR)))); next; }\n    if ($parameter eq 'inpck') { $c_iflag = (($set_value ? ($c_iflag | INPCK) : ($c_iflag & (~INPCK)))); next; }\n    if ($parameter eq 'istrip') { $c_iflag = (($set_value ? ($c_iflag | ISTRIP) : ($c_iflag & (~ISTRIP)))); next; }\n    if ($parameter eq 'ixoff') { $c_iflag = (($set_value ? ($c_iflag | IXOFF) : ($c_iflag & (~IXOFF)))); next; }\n    if ($parameter eq 'ixon') { $c_iflag = (($set_value ? ($c_iflag | IXON) : ($c_iflag & (~IXON)))); next; }\n    if ($parameter eq 'parmrk') { $c_iflag = (($set_value ? ($c_iflag | PARMRK) : ($c_iflag & (~PARMRK)))); next; }\n    \n    # Are we there yet? No. Are we there yet? No. Are we there yet...\n#    print \"Values: $c_lflag,\".($c_lflag | ECHO).\" \".($c_lflag & (~ECHO)).\"\\n\";\n    if ($parameter eq 'echo') { $c_lflag = (($set_value ? ($c_lflag | ECHO) : ($c_lflag & (~ECHO)))); next; }\n    if ($parameter eq 'echoe') { $c_lflag = (($set_value ? ($c_lflag | ECHOE) : ($c_lflag & (~ECHOE)))); next; }\n    if ($parameter eq 'echok') { $c_lflag = (($set_value ? ($c_lflag | ECHOK) : ($c_lflag & (~ECHOK)))); next; }\n    if ($parameter eq 'echonl') { $c_lflag = (($set_value ? ($c_lflag | ECHONL) : ($c_lflag & (~ECHONL)))); next; }\n    if ($parameter eq 'icanon') { $c_lflag = (($set_value ? ($c_lflag | ICANON) : ($c_lflag & (~ICANON)))); next; }\n    if ($parameter eq 'iexten') { $c_lflag = (($set_value ? ($c_lflag | IEXTEN) : ($c_lflag & (~IEXTEN)))); next; }\n    if ($parameter eq 'isig') { $c_lflag = (($set_value ? ($c_lflag | ISIG) : ($c_lflag & (~ISIG)))); next; }\n    if ($parameter eq 'noflsh') { $c_lflag = (($set_value ? ($c_lflag | NOFLSH) : ($c_lflag & (~NOFLSH)))); next; }\n    if ($parameter eq 'tostop') { $c_lflag = (($set_value ? ($c_lflag | TOSTOP) : ($c_lflag & (~TOSTOP)))); next; }\n\n    # Make it stop! Make it stop!\n    # c_oflag crap.\n    if ($parameter eq 'opost') { $c_oflag = (($set_value ? ($c_oflag | OPOST) : ($c_oflag & (~OPOST)))); next; }\n  \n    # Speed?\n    if ($parameter eq 'ospeed') { $ospeed = &{\"POSIX::B\".shift(@parameters)}; next; }\n    if ($parameter eq 'ispeed') { $ispeed = &{\"POSIX::B\".shift(@", 8192) = 8192
09:01:57.395168 brk(0x1b9e000)          = 0x1b9e000
09:01:57.395930 read(12, "parameters)}; next; }\n  # Default.. parameter hasn't matched anything\n#    print \"char:\".sprintf(\"%lo\",ord($parameter)).\"\\n\";\n    warn \"IO::Stty::stty passed invalid parameter '$parameter'\\n\";\n  }\n\n  # What a pain in the ass! Ok.. let's write the crap back.\n  $termios->setcflag($c_cflag);\n  $termios->setiflag($c_iflag);\n  $termios->setispeed($ispeed);\n  $termios->setlflag($c_lflag);\n  $termios->setoflag($c_oflag);\n  $termios->setospeed($ospeed);\n  $termios->setcc(VINTR,$control_chars{'INTR'});\n  $termios->setcc(VQUIT,$control_chars{'QUIT'});\n  $termios->setcc(VERASE,$control_chars{'ERASE'});\n  $termios->setcc(VKILL,$control_chars{'KILL'});\n  $termios->setcc(VEOF,$control_chars{'EOF'});\n  $termios->setcc(VTIME,$control_chars{'TIME'});\n  $termios->setcc(VMIN,$control_chars{'MIN'});\n  $termios->setcc(VSTART,$control_chars{'START'});\n  $termios->setcc(VSTOP,$control_chars{'STOP'});\n  $termios->setcc(VSUSP,$control_chars{'SUSP'});\n  $termios->setcc(VEOL,$control_chars{'EOL'});\n  $termios->setattr($file_num,TCSANOW); # TCSANOW = do immediately. don't unbuffer first.\n  # OK.. that sucked.\n}\n\n=item B<show_me_the_crap()>\n\nNeeds documentation\n\n=cut\n\nsub show_me_the_crap {\n  my ($c_cflag,$c_iflag,$ispeed,$c_lflag,$c_oflag,\n    $ospeed,$control_chars) = @_;\n  my(%cc) = %$control_chars;\n  # rs = return string\n  my($rs)='';\n  $rs .= 'speed ';\n  if ($ospeed == B0) { $rs .= 0; }\n  if ($ospeed == B50) { $rs .= 50; }\n  if ($ospeed == B75) { $rs .= 75; }\n  if ($ospeed == B110) { $rs .= 110; }\n  if ($ospeed == B134) { $rs .= 134; }\n  if ($ospeed == B150) { $rs .= 150; }\n  if ($ospeed == B200) { $rs .= 200; }\n  if ($ospeed == B300) { $rs .= 300; }\n  if ($ospeed == B600) { $rs .= 600; }\n  if ($ospeed == B1200) { $rs .= 1200; }\n  if ($ospeed == B1800) { $rs .= 1800; }\n  if ($ospeed == B2400) { $rs .= 2400; }\n  if ($ospeed == B4800) { $rs .= 4800; }\n  if ($ospeed == B9600) { $rs .= 9600; }\n  if ($ospeed == B19200) { $rs .= 19200; }\n  if ($ospeed == B38400) { $rs .= 38400; }\n  $rs .= \" baud\\n\";\n  $rs .= <<EOM;\nintr = $cc{'INTR'}; quit = $cc{'QUIT'}; erase = $cc{'ERASE'}; kill = $cc{'KILL'};\neof = $cc{'EOF'}; eol = $cc{'EOL'}; start = $cc{'START'}; stop = $cc{'STOP'}; susp = $cc{'SUSP'};\nEOM\n;\n  # c flags.\n  $rs .= (($c_cflag & CLOCAL) ? '' : '-' ).'clocal '; \n  $rs .= (($c_cflag & CREAD) ? '' : '-' ).'cread '; \n  $rs .= (($c_cflag & CSTOPB) ? '' : '-' ).'cstopb '; \n  $rs .= (($c_cflag & HUPCL) ? '' : '-' ).'hupcl '; \n  $rs .= (($c_cflag & PARENB) ? '' : '-' ).'parenb '; \n  $rs .= (($c_cflag & PARODD) ? '' : '-' ).'parodd '; \n  $c_cflag = $c_cflag & CS8; \n  if ($c_cflag == CS8) {\n    $rs .= \"cs8\\n\";\n  } elsif ($c_cflag == CS7) {\n    $rs .= \"cs7\\n\";\n  } elsif ($c_cflag == CS6) {\n    $rs .= \"cs6\\n\";\n  } else {\n    $rs .= \"cs5\\n\";\n  }\n  # l flags.\n  $rs .= (($c_lflag & ECHO) ? '' : '-' ).'echo ';\n  $rs .= (($c_lflag & ECHOE) ? '' : '-' ).'echoe ';\n  $rs .= (($c_lflag & ECHOK) ? '' : '-' ).'echok ';\n  $rs .= (($c_lflag & ECHONL) ? '' : '-' ).'echonl ';\n  $rs .= (($c_lflag & ICANON) ? '' : '-' ).'icanon ';\n  $rs .= (($c_lflag & ISIG) ? '' : '-' ).'isig ';\n  $rs .= (($c_lflag & NOFLSH) ? '' : '-' ).'noflsh ';\n  $rs .= (($c_lflag & TOSTOP) ? '' : '-' ).'tostop ';\n  $rs .= (($c_lflag & IEXTEN) ? '' : '-' ).'iexten ';\n  # o flag. jam it after the l flags so it looks more compact.\n  $rs .= (($c_oflag & OPOST) ? '' : '-' ).\"opost\\n\";\n  #  i flags.\n  $rs .= (($c_iflag & BRKINT) ? '' : '-' ).'brkint ';\n  $rs .= (($c_iflag & IGNBRK) ? '' : '-' ).'ignbrk ';\n  $rs .= (($c_iflag & IGNPAR) ? '' : '-' ).'ignpar ';\n  $rs .= (($c_iflag & PARMRK) ? '' : '-' ).'parmrk ';\n  $rs .= (($c_iflag & INPCK) ? '' : '-' ).'inpck ';\n  $rs .= (($c_iflag & ISTRIP) ? '' : '-' ).'istrip ';\n  $rs .= (($c_iflag & INLCR) ? '' : '-' ).'inlcr ';\n  $rs .= (($c_iflag & ICRNL) ? '' : '-' ).'icrnl ';\n  $rs .= (($c_iflag & IXON) ? '' : '-' ).'ixon ';\n  $rs .= (($c_iflag & IXOFF) ? '' : '-' ).\"ixoff\\n\";\n  return $rs;\n}\n  \n=back\n\n=head1 AUTHOR\n\nAustin Schutz <auschutz@cpan.org> (Initial version and maintenance)\n\nTodd Rinaldo <toddr@cpan.org> (Maintenance)\n\n=head1 BUGS\n\nThis is use at your own risk software. Do anything you want with it except\nblame me for it blowing up your machine because it's full of bugs.\n\nSee above for what functions are supported. It's mostly standard POSIX\nstuff. If any of the settings are wrong and you actually know what some of\nthese extremely arcane settings (like what 'sane' should be in POSIX land)\nreally should be, please open an RT ticket.\n\n=head1 ACKNOWLEDGEMENTS\n\nNone\n\n=head1 COPYRIGHT & LICENSE\n\nCopyright 1997 Austin Schutz, all rights reserved.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.\n\n=cut\n\n  \n1;\n", 8192) = 4712
09:01:57.396361 brk(0x1bbf000)          = 0x1bbf000
09:01:57.396817 read(12, "", 8192)      = 0
09:01:57.396867 close(12)               = 0
09:01:57.396951 stat("modules/auto/IO/Tty", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.397006 stat("modules/auto/IO/Tty", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.397057 stat("/etc/perl/auto/IO/Tty", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.397110 stat("/usr/local/lib/perl/5.14.2/auto/IO/Tty", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.397166 stat("/usr/local/share/perl/5.14.2/auto/IO/Tty", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.397222 stat("/usr/lib/perl5/auto/IO/Tty", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
09:01:57.397284 stat("/usr/lib/perl5/auto/IO/Tty/Tty.so", {st_mode=S_IFREG|0644, st_size=29768, ...}) = 0
09:01:57.397364 stat("/usr/lib/perl5/auto/IO/Tty/Tty.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.397440 open("/usr/lib/perl5/auto/IO/Tty/Tty.so", O_RDONLY) = 12
09:01:57.397492 read(12, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340\23\0\0\0\0\0\0@\0\0\0\0\0\0\0\310m\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\204i\0\0\0\0\0\0\204i\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\210i\0\0\0\0\0\0\210i \0\0\0\0\0\210i \0\0\0\0\0p\3\0\0\0\0\0\0\210\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\260i\0\0\0\0\0\0\260i \0\0\0\0\0\260i \0\0\0\0\0\240\1\0\0\0\0\0\0\240\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0pg\0\0\0\0\0\0pg\0\0\0\0\0\0pg\0\0\0\0\0\0L\0\0\0\0\0\0\0L\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0}c(\323 \302Z\205E@\0371\30\2622'\222\337N\300\0\0\0\0%\0\0\0008\0\0\0\0\0\0\0'\0\0\0$\0\0\0\0\0\0\0\20\0\0\0\27\0\0\0\3\0\0\0%\0\0\0\32\0\0\0/\0\0\0\34\0\0\0+\0\0\0\0\0\0\0003\0\0\0\0\0\0\0)\0\0\0*\0\0\0\10\0\0\0007\0\0\0005\0\0\0.\0\0\0\23\0\0\0\21\0\0\0\v\0\0\0\0\0\0\0\16\0\0\0,\0\0\0\31\0\0\0\f\0\0\0\7\0\0\0-\0\0\0!\0\0\0\5\0\0\0\26\0\0\0\0\0\0\0004\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0000\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\30\0\0\0\0\0\0\0\33\0\0\0\t\0\0\0\4\0\0\0\0\0\0\0\22\0\0\0002\0\0\0 \0\0\0\0\0\0\0\0\0\0\0\24\0\0\0\6\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\"\0\0\0\0\0\0\0#\0\0\0\r\0\0\0\35\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0\0\0\0\0(\0\0\0\0\0\0\0001\0\0\0\0\0\0\0\3\0\0\0000\0\0\0", 832) = 832
09:01:57.397627 fstat(12, {st_mode=S_IFREG|0644, st_size=29768, ...}) = 0
09:01:57.397688 mmap(NULL, 2125072, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 12, 0) = 0x7f74323a1000
09:01:57.397738 mprotect(0x7f74323a8000, 2093056, PROT_NONE) = 0
09:01:57.397786 mmap(0x7f74325a7000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 12, 0x6000) = 0x7f74325a7000
09:01:57.397840 close(12)               = 0
09:01:57.397892 open("/etc/ld.so.cache", O_RDONLY) = 12
09:01:57.397946 fstat(12, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.397998 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 12, 0) = 0x7f7436f01000
09:01:57.398063 close(12)               = 0
09:01:57.398115 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.398174 open("/lib/x86_64-linux-gnu/libutil.so.1", O_RDONLY) = 12
09:01:57.398231 read(12, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20\16\0\0\0\0\0\0@\0\0\0\0\0\0\0\20\"\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\300\26\0\0\0\0\0\0\300\26\0\0\0\0\0\0\300\26\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0P\32\0\0\0\0\0\0P\32\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\350\35\0\0\0\0\0\0\350\35 \0\0\0\0\0\350\35 \0\0\0\0\0\20\3\0\0\0\0\0\0 \3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\20\36\0\0\0\0\0\0\20\36 \0\0\0\0\0\20\36 \0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\334\26\0\0\0\0\0\0\334\26\0\0\0\0\0\0\334\26\0\0\0\0\0\0L\0\0\0\0\0\0\0L\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\350\35\0\0\0\0\0\0\350\35 \0\0\0\0\0\350\35 \0\0\0\0\0\30\2\0\0\0\0\0\0\30\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0005\311\306 \352e\315\371\373\324X\332\0214\26\352M\340\232\177\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\n\0\0\0\"\0\0\0\1\0\0\0\6\0\0\0\200\200@\300\4 \24D\0\0\0\0\0\0\0\0\"\0\0\0#\0\0\0$\0\0\0\0\0\0\0%\0\0\0'\0\0\0(\0\0\0\0\0\0\0\365\361\253\272\217\365\310\207\237<\300|\364\243\343p\277\370\337\17_+\337\v\273\25sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\v\0\10\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.398372 fstat(12, {st_mode=S_IFREG|0644, st_size=10640, ...}) = 0
09:01:57.398429 mmap(NULL, 2105608, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 12, 0) = 0x7f743219e000
09:01:57.398478 mprotect(0x7f74321a0000, 2093056, PROT_NONE) = 0
09:01:57.398529 mmap(0x7f743239f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 12, 0x1000) = 0x7f743239f000
09:01:57.398587 close(12)               = 0
09:01:57.398644 mprotect(0x7f743239f000, 4096, PROT_READ) = 0
09:01:57.398702 munmap(0x7f7436f01000, 98904) = 0
09:01:57.399008 brk(0x1be0000)          = 0x1be0000
09:01:57.399794 lseek(11, 3470, SEEK_SET) = 3470
09:01:57.399853 lseek(11, 0, SEEK_CUR)  = 3470
09:01:57.399900 close(11)               = 0
09:01:57.400070 getrlimit(RLIMIT_NOFILE, {rlim_cur=256, rlim_max=4*1024}) = 0
09:01:57.400592 read(10, ":Line->new(Literal => \"\\n\")\n      unless defined $stderr_filter;\n  }\n\n  croak \"$type needs either StdioFilter or StdinFilter when using StdinEvent\"\n    if defined($stdin_event) and not defined($stdin_filter);\n  croak \"$type needs either StdioFilter or StdoutFilter when using StdoutEvent\"\n    if defined($stdout_event) and not defined($stdout_filter);\n  croak \"$type needs a StderrFilter when using StderrEvent\"\n    if defined($stderr_event) and not defined($stderr_filter);\n\n  my $error_event = delete $params{ErrorEvent};\n  my $close_event = delete $params{CloseEvent};\n\n  my $no_setsid = delete $params{NoSetSid};\n  my $no_setpgrp = delete $params{NoSetPgrp};\n\n  # Make sure the user didn't pass in parameters we're not aware of.\n  if (scalar keys %params) {\n    carp(\n      \"unknown parameters in $type constructor call: \",\n      join(', ', sort keys %params)\n    );\n  }\n\n  # Did the user mangle stdio?\n  unless (ref($program) eq 'CODE') {\n    croak \"Someone has closed or moved STDIN... exec() won't find it\"\n      unless defined fileno(STDIN) && fileno(STDIN) == 0;\n    croak \"Someone has closed or moved STDOUT... exec() won't find it\"\n      unless tied(*STDOUT) || defined fileno(STDOUT) && fileno(STDOUT) == 1;\n    croak \"Someone has closed or moved STDERR... exec() won't find it\"\n      unless tied(*STDERR) || defined fileno(STDERR) && fileno(STDERR) == 2;\n  }\n\n  my (\n    $stdin_read, $stdout_write, $stdout_read, $stdin_write,\n    $stderr_read, $stderr_write,\n  );\n\n  _filespec_to_fh(\\$stdin_read, \"<\", $redir_in);\n  if($redir_output) {\n    _filespec_to_fh(\\$stdout_write, \">\", $redir_output);\n    _filespec_to_fh(\\$stderr_write, \">\", $stdout_write);\n  } else {\n    _filespec_to_fh(\\$stdout_write, \">\", $redir_out);\n    _filespec_to_fh(\\$stderr_write, \">\", $redir_err);\n  }\n\n  # Create a semaphore pipe.  This is used so that the parent doesn't\n  # begin listening until the child's stdio has been set up.\n\n  my ($sem_pipe_read, $sem_pipe_write) = POE::Pipe::OneWay->new();\n  croak \"could not create semaphore pipe: $!\" unless defined $sem_pipe_read;\n\n  # Use IO::Pty if requested.  IO::Pty turns on autoflush for us.\n\n  if(defined $stdout_event\n     or defined $stdin_event\n     or defined $stderr_event\n     or (!$no_stdin))\n  #Bypass all the conduit handling if the user does not care for child I/O\n  {\n    if ($conduit =~ /^pty(-pipe)?$/) {\n      croak \"IO::Pty is not available\" unless PTY_AVAILABLE;\n\n      if(defined $redir_err or defined $redir_in or defined $redir_out) {\n        croak \"Redirection with pty conduit is unsupported\";\n      }\n\n      $stdin_write = $stdout_read = IO::Pty->new();\n      croak \"could not create master pty: $!\" unless defined $stdout_read;\n      if ($conduit eq \"pty-pipe\") {\n        ($stderr_read, $stderr_write) = POE::Pipe::OneWay->new();\n        croak \"could not make stderr pipes: $!\"\n          unless defined $stderr_read and defined $stderr_write;\n      }\n    }\n\n    # Use pipes otherwise.\n    elsif ($conduit eq 'pipe') {\n      # We make more pipes than strictly necessary in case someone wants\n      # to turn some on later.  Uses a TwoWay pipe for STDIN/STDOUT and\n      # a OneWay pipe for STDERR.  This may save 2 filehandles if\n      # socketpair() is available and no other $stdio_type is selected.\n\n      foreach (\n        [\\$redir_out, \\$stdout_read, \\$stdout_write, $stdout_event, \"stdout\"],\n        [\\$redir_err, \\$stderr_read, \\$stderr_write, $stderr_event, \"stderr\"],\n        [\\$redir_in, \\$stdin_read, \\$stdin_write, $stdin_event, \"stdin\"]\n        ) {\n        my ($redir_ref,$rfd_ref,$wfd_ref,$evname, $prettyprint) = @$_;\n        if(defined $evname && (!defined $$redir_ref)) {\n          ($$rfd_ref,$$wfd_ref) = POE::Pipe::OneWay->new();\n          croak \"could not make $prettyprint pipe: $!\"\n            unless defined $$rfd_ref and defined $$wfd_ref;\n        }\n      }\n      unless (defined($redir_in) or $no_stdin) {\n        ($stdin_read, $stdin_write) = POE::Pipe::OneWay->new();\n        croak \"could not make stdin pipe $!\"\n          unless defined $stdin_write and defined $stdin_read;\n      }\n    }\n\n    # Sanity check.\n    else {\n      croak \"unknown conduit type $conduit\";\n    }\n  }\n\n  # Block signals until safe\n  my $must_unmask;\n  if( $poe_kernel->can( '_data_sig_mask_all' ) ) {\n    $poe_kernel->_data_sig_mask_all;\n    $must_unmask = 1;\n  }\n\n  # Fork!  Woo-hoo!\n  my $pid = fork;\n\n  # Child.  Parent side continues after this block.\n  unless ($pid) {\n    # removed the croak because it wasn't \"safe\" RT#56417\n    #croak \"couldn't fork: $!\" unless defined $pid;\n    # ANY OTHER DIE/CROAK/EXIT/WHATEVER in the child MUST use the helper!\n    __PACKAGE__->_warn_and_exit_child( \"couldn't fork: $!\", int( $! ) )\n      unless defined $pid;\n\n    # Stdio should not be tied.  Resolves rt.cpan.org ticket 1648.\n    if (tied *STDIN) {\n      carp \"Cannot redirect out of tied STDIN.  Untying it\";\n      untie *STDIN;\n    }\n\n    if (tied *STDOUT) {\n      carp \"Cannot redirect into tied STDOUT.  Untying it\";\n      untie *STDOUT;\n    }\n\n    if (tied *STDERR) {\n      carp \"Cannot redirect into tied STDERR.  Untying it\";\n      untie *STDERR;\n    }\n\n    # If running pty, we delay the slave side creation 'til after\n    # doing the necessary bits to become our own [unix] session.\n    if ($conduit =~ /^pty(-pipe)?$/) {\n\n      # Become a new unix session.\n      # Program 19.3, APITUE.  W. Richard Stevens built my hot rod.\n      eval 'setsid()' unless $no_setsid;\n\n      # Acquire a controlling terminal.  Program 19.3, APITUE.\n      $stdin_write->make_slave_controlling_terminal();\n\n      # Open the slave side of the pty.\n      $stdin_read = $stdout_write = $stdin_write->slave();\n      __PACKAGE__->_warn_and_exit_child( \"could not create slave pty: $!\", int( $! ) )\n        unless defined $stdin_read;\n\n      # For a simple pty conduit, stderr is wedged into stdout.\n      $stderr_write = $stdout_write if $conduit eq 'pty';\n\n      # Put the pty conduit (slave side) into \"raw\" or \"cbreak\" mode,\n      # per APITUE 19.4 and 11.10.\n      $stdin_read->set_raw();\n\n      if (TIOCSWINSZ_AVAILABLE) {\n        if ($winsize) {\n          ioctl($stdin_read, TIOCSWINSZ, pack('vvvv', @$winsize));\n        }\n      }\n      else {\n        # Set the pty conduit (slave side) window size to our window\n        # size.  APITUE 19.4 and 19.5.\n\n        eval { $stdin_read->clone_winsize_from(\\*STDIN) } if -T STDIN;\n      }\n    }\n    else {\n      # TODO - Can this be block eval?  Or a do{} block?\n      eval 'setpgrp(0,0)' unless $no_setpgrp;\n    }\n\n    # Reset all signals in the child process.  POE's own handlers are\n    # silly to keep around in the child process since POE won't be\n    # using them.\n    my @safe_signals = $poe_kernel->_data_sig_get_safe_signals();\n    @SIG{@safe_signals} = (\"DEFAULT\") x @safe_signals;\n    $poe_kernel->_data_sig_unmask_all if $must_unmask;\n\n    # TODO How to pass events to the parent process?  Maybe over a\n    # expedited (OOB) filehandle.\n\n    # Fix the child process' priority.  Don't bother doing this if it\n    # wasn't requested.  Can't emit events on failure because we're in\n    # a separate process, so just fail quietly.\n\n    if ($priority_delta) {\n      eval {\n        if (defined(my $priority = getpriority(0, $$))) {\n          unless (setpriority(0, $$, $priority + $priority_delta)) {\n            # TODO can't set child priority\n          }\n        }\n        else {\n          # TODO can't get child priority\n        }\n      };\n      if ($@) {\n        # TODO can't get child priority\n      }\n    }\n\n    # Fix the group ID.  TODO Add getgrnam so group IDs can be\n    # specified by name.  TODO Warn if not superuser to begin with.\n    if (defined $group_id) {\n      $( = $) = $group_id;\n    }\n\n    # Fix the user ID.  TODO Add getpwnam so user IDs can be specified\n    # by name.  TODO Warn if not superuser to begin with.\n    if (defined $user_id) {\n      $< = $> = $user_id;\n    }\n\n    # Close what the child won't need.\n    close $stdin_write if defined $stdin_write;\n    close $stdout_read if defined $stdout_read;\n    close $stderr_read if defined $stderr_read;\n\n    if (POE::Kernel::RUNNING_IN_HELL) {\n      __PACKAGE__->_redirect_child_stdio_in_hell(\n        $stdin_re", 8192) = 8192
09:01:57.401074 brk(0x1c01000)          = 0x1c01000
09:01:57.401578 read(10, "ad, $stdout_write, $stderr_write\n      );\n    }\n\n    else {\n      __PACKAGE__->_redirect_child_stdio_sanely(\n        $stdin_read, $stdout_write, $stderr_write\n      );\n    }\n\n    # Make STDOUT and/or STDERR auto-flush.\n    select STDERR;  $| = 1;\n    select STDOUT;  $| = 1;\n\n    # The child doesn't need to read from the semaphore pipe.\n    $sem_pipe_read = undef;\n\n    # Run Perl code.  This is fairly consistent across most systems.\n\n    if (ref($program) eq 'CODE') {\n\n      # Tell the parent that the stdio has been set up.\n      print $sem_pipe_write \"go\\n\";\n      close $sem_pipe_write;\n\n      # Close any close-on-exec file descriptors.  Except STDIN,\n      # STDOUT, and STDERR, of course.\n      if ($close_on_call) {\n        for (0..MAX_OPEN_FDS-1) {\n          next if fileno(STDIN)  == $_;\n          next if fileno(STDOUT) == $_;\n          next if fileno(STDERR) == $_;\n          POSIX::close($_);\n        }\n      }\n\n      # TODO what if the program tries to exit? It needs to use\n      # our _exit_child_any_way_we_can handler...\n      # Should we replace CORE::exit? CORE::die too? blahhhhhh\n      # We've documented that users should not do it, but who knows!\n      eval { $program->(@$prog_args) };\n\n      my $exitval;\n      if ($@) {\n        chomp $@;\n        warn \"$@\\n\";\n        $exitval = -1;\n      }\n\n      __PACKAGE__->_exit_child_any_way_we_can( $exitval || 0 );\n    }\n\n    # Execute an external program.  This gets weird.\n\n    # Windows! What I do for you!\n    __PACKAGE__->_exec_in_hell(\n      $close_on_call, $sem_pipe_write, $program, $prog_args\n    ) if POE::Kernel::RUNNING_IN_HELL;\n\n    # Everybody else seems sane.\n    # Tell the parent that the stdio has been set up.\n    print $sem_pipe_write \"go\\n\";\n    close $sem_pipe_write;\n\n    # exec(ARRAY)\n    if (ref($program) eq 'ARRAY') {\n      exec(@$program, @$prog_args)\n         or __PACKAGE__->_warn_and_exit_child(\n           \"can't exec (@$program) in child pid $$: $!\", int( $! ) );\n    }\n\n    # exec(SCALAR)\n    exec(join(\" \", $program, @$prog_args))\n      or __PACKAGE__->_warn_and_exit_child(\n        \"can't exec ($program) in child pid $$: $!\", int( $! ) );\n  }\n\n  # Parent here.  Close what the parent won't need.\n\n  defined($stdin_read)   and close $stdin_read;\n  defined($stdout_write) and close $stdout_write;\n  defined($stderr_write) and close $stderr_write;\n\n\n\n  # Also close any slave ptys\n  $stdout_read->close_slave() if (\n    defined $stdout_read and ref($stdout_read) eq 'IO::Pty'\n  );\n\n  $stderr_read->close_slave() if (\n    defined $stderr_read and ref($stderr_read) eq 'IO::Pty'\n  );\n\n  my $active_count = 0;\n  $active_count++ if $stdout_event and $stdout_read;\n  $active_count++ if $stderr_event and $stderr_read;\n\n  my $self = bless [\n    &POE::Wheel::allocate_wheel_id(),  # UNIQUE_ID\n    $error_event,   # ERROR_EVENT\n    $close_event,   # CLOSE_EVENT\n    $program,       # PROGRAM\n    $pid,           # CHILD_PID\n    $conduit,       # CONDUIT_TYPE\n    $active_count,  # IS_ACTIVE\n    $close_on_call, # CLOSE_ON_CALL\n    $stdio_type,    # STDIO_TYPE\n    # STDIN\n    $stdin_write,   # HANDLE_STDIN\n    $stdin_filter,  # FILTER_STDIN\n    $stdin_driver,  # DRIVER_STDIN\n    $stdin_event,   # EVENT_STDIN\n    undef,          # STATE_STDIN\n    0,              # OCTETS_STDIN\n    # STDOUT\n    $stdout_read,   # HANDLE_STDOUT\n    $stdout_filter, # FILTER_STDOUT\n    $stdout_driver, # DRIVER_STDOUT\n    $stdout_event,  # EVENT_STDOUT\n    undef,          # STATE_STDOUT\n    # STDERR\n    $stderr_read,   # HANDLE_STDERR\n    $stderr_filter, # FILTER_STDERR\n    $stderr_driver, # DRIVER_STDERR\n    $stderr_event,  # EVENT_STDERR\n    undef,          # STATE_STDERR\n    undef,          # MSWIN32_GROUP_PID\n  ], $type;\n\n  # PG- I suspect <> might need PIPE\n  $poe_kernel->_data_sig_unmask_all if $must_unmask;\n\n  # Wait here while the child sets itself up.\n  $sem_pipe_write = undef;\n  {\n    local $/ = \"\\n\";  # TODO - Needed?\n    my $chldout = <$sem_pipe_read>;\n    chomp $chldout;\n    $self->[MSWIN32_GROUP_PID] = $chldout if $chldout ne 'go';\n  }\n  close $sem_pipe_read;\n\n  $self->_define_stdin_flusher() if defined $stdin_write;\n  $self->_define_stdout_reader() if defined $stdout_read;\n  $self->_define_stderr_reader() if defined $stderr_read;\n\n  return $self;\n}\n\n#------------------------------------------------------------------------------\n# Define the internal state that will flush output to the child\n# process' STDIN pipe.\n\nsub _define_stdin_flusher {\n  my $self = shift;\n\n  # Read-only members.  If any of these change, then the write state\n  # is invalidated and needs to be redefined.\n  my $unique_id    = $self->[UNIQUE_ID];\n  my $driver       = $self->[DRIVER_STDIN];\n  my $error_event  = \\$self->[ERROR_EVENT];\n  my $close_event  = \\$self->[CLOSE_EVENT];\n  my $stdin_filter = $self->[FILTER_STDIN];\n  my $stdin_event  = \\$self->[EVENT_STDIN];\n  my $is_active    = \\$self->[IS_ACTIVE];\n\n  # Read/write members.  These are done by reference, to avoid pushing\n  # $self into the anonymous sub.  Extra copies of $self are bad and\n  # can prevent wheels from destructing properly.\n  my $stdin_octets = \\$self->[OCTETS_STDIN];\n\n  # Register the select-write handler.\n  $poe_kernel->state(\n    $self->[STATE_STDIN] = ref($self) . \"($unique_id) -> select stdin\",\n    sub {                             # prevents SEGV\n      0 && CRIMSON_SCOPE_HACK('<');\n                                      # subroutine starts here\n      my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n\n      $$stdin_octets = $driver->flush($handle);\n\n      # When you can't write, nothing else matters.\n      if ($!) {\n        $$error_event && $k->call(\n          $me, $$error_event,\n          'write', ($!+0), $!, $unique_id, \"STDIN\"\n        );\n        $k->select_write($handle);\n      }\n\n      # Could write, or perhaps couldn't but only because the\n      # filehandle's buffer is choked.\n      else {\n\n        # All chunks written; fire off a \"flushed\" event.\n        unless ($$stdin_octets) {\n          $k->select_pause_write($handle);\n          $$stdin_event && $k->call($me, $$stdin_event, $unique_id);\n        }\n      }\n    }\n  );\n\n  $poe_kernel->select_write($self->[HANDLE_STDIN], $self->[STATE_STDIN]);\n\n  # Pause the write select immediately, unless output is pending.\n  $poe_kernel->select_pause_write($self->[HANDLE_STDIN])\n    unless ($self->[OCTETS_STDIN]);\n}\n\n#------------------------------------------------------------------------------\n# Define the internal state that will read input from the child\n# process' STDOUT pipe.  This is virtually identical to\n# _define_stderr_reader, but they aren't implemented as a common\n# function for speed reasons.\n\nsub _define_stdout_reader {\n  my $self = shift;\n\n  # Can't do anything if we don't have a handle.\n  return unless defined $self->[HANDLE_STDOUT];\n\n  # No event?  Unregister the handler and leave.\n  my $stdout_event  = \\$self->[EVENT_STDOUT];\n  unless ($$stdout_event) {\n    $poe_kernel->select_read($self->[HANDLE_STDOUT]);\n    return;\n  }\n\n  # If any of these change, then the read state is invalidated and\n  # needs to be redefined.\n  my $unique_id     = $self->[UNIQUE_ID];\n  my $driver        = $self->[DRIVER_STDOUT];\n  my $stdout_filter = $self->[FILTER_STDOUT];\n\n  # These can change without redefining the callback since they're\n  # enclosed by reference.\n  my $is_active     = \\$self->[IS_ACTIVE];\n  my $close_event   = \\$self->[CLOSE_EVENT];\n  my $error_event   = \\$self->[ERROR_EVENT];\n\n  # Register the select-read handler for STDOUT.\n  if (\n    $stdout_filter->can(\"get_one\") and\n    $stdout_filter->can(\"get_one_start\")\n  ) {\n    $poe_kernel->state(\n      $self->[STATE_STDOUT] = ref($self) . \"($unique_id) -> select stdout\",\n      sub {\n        # prevents SEGV\n        0 && CRIMSON_SCOPE_HACK('<');\n\n        # subroutine starts here\n        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n        if (defined(my $raw_input = $driver->get($handle))) {\n          $stdout_filter->get_one_start($raw_input);\n          while (1) {\n            my $next_rec = $stdout_filter->get_one();\n            last unless @$next_rec;\n            foreach my $cooked_input (@$next_rec) {\n              $k->call($me, $$stdout_event, $cooked_input, $", 8192) = 8192
09:01:57.402496 brk(0x1c22000)          = 0x1c22000
09:01:57.402681 read(10, "unique_id);\n            }\n          }\n        }\n        else {\n          $$error_event and $k->call(\n            $me, $$error_event,\n            'read', ($!+0), $!, $unique_id, 'STDOUT'\n          );\n          unless (--$$is_active) {\n            $k->call( $me, $$close_event, $unique_id )\n              if defined $$close_event;\n          }\n          $k->select_read($handle);\n        }\n      }\n    );\n  }\n\n  # Otherwise we can't get one.\n  else {\n    $poe_kernel->state(\n      $self->[STATE_STDOUT] = ref($self) . \"($unique_id) -> select stdout\",\n      sub {\n        # prevents SEGV\n        0 && CRIMSON_SCOPE_HACK('<');\n\n        # subroutine starts here\n        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n        if (defined(my $raw_input = $driver->get($handle))) {\n          foreach my $cooked_input (@{$stdout_filter->get($raw_input)}) {\n            $k->call($me, $$stdout_event, $cooked_input, $unique_id);\n          }\n        }\n        else {\n          $$error_event and\n            $k->call(\n              $me, $$error_event,\n              'read', ($!+0), $!, $unique_id, 'STDOUT'\n            );\n          unless (--$$is_active) {\n            $k->call( $me, $$close_event, $unique_id )\n              if defined $$close_event;\n          }\n          $k->select_read($handle);\n        }\n      }\n    );\n  }\n\n  # register the state's select\n  $poe_kernel->select_read($self->[HANDLE_STDOUT], $self->[STATE_STDOUT]);\n}\n\n#------------------------------------------------------------------------------\n# Define the internal state that will read input from the child\n# process' STDERR pipe.\n\nsub _define_stderr_reader {\n  my $self = shift;\n\n  # Can't do anything if we don't have a handle.\n  return unless defined $self->[HANDLE_STDERR];\n\n  # No event?  Unregister the handler and leave.\n  my $stderr_event  = \\$self->[EVENT_STDERR];\n  unless ($$stderr_event) {\n    $poe_kernel->select_read($self->[HANDLE_STDERR]);\n    return;\n  }\n\n  my $unique_id     = $self->[UNIQUE_ID];\n  my $driver        = $self->[DRIVER_STDERR];\n  my $stderr_filter = $self->[FILTER_STDERR];\n\n  # These can change without redefining the callback since they're\n  # enclosed by reference.\n  my $error_event   = \\$self->[ERROR_EVENT];\n  my $close_event   = \\$self->[CLOSE_EVENT];\n  my $is_active     = \\$self->[IS_ACTIVE];\n\n  # Register the select-read handler for STDERR.\n  if (\n    $stderr_filter->can(\"get_one\") and\n    $stderr_filter->can(\"get_one_start\")\n  ) {\n    $poe_kernel->state(\n      $self->[STATE_STDERR] = ref($self) . \"($unique_id) -> select stderr\",\n      sub {\n        # prevents SEGV\n        0 && CRIMSON_SCOPE_HACK('<');\n\n        # subroutine starts here\n        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n        if (defined(my $raw_input = $driver->get($handle))) {\n          $stderr_filter->get_one_start($raw_input);\n          while (1) {\n            my $next_rec = $stderr_filter->get_one();\n            last unless @$next_rec;\n            foreach my $cooked_input (@$next_rec) {\n              $k->call($me, $$stderr_event, $cooked_input, $unique_id);\n            }\n          }\n        }\n        else {\n          $$error_event and $k->call(\n            $me, $$error_event,\n            'read', ($!+0), $!, $unique_id, 'STDERR'\n          );\n          unless (--$$is_active) {\n            $k->call( $me, $$close_event, $unique_id )\n              if defined $$close_event;\n          }\n          $k->select_read($handle);\n        }\n      }\n    );\n  }\n\n  # Otherwise we can't get_one().\n  else {\n    $poe_kernel->state(\n      $self->[STATE_STDERR] = ref($self) . \"($unique_id) -> select stderr\",\n      sub {\n        # prevents SEGV\n        0 && CRIMSON_SCOPE_HACK('<');\n\n        # subroutine starts here\n        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];\n        if (defined(my $raw_input = $driver->get($handle))) {\n          foreach my $cooked_input (@{$stderr_filter->get($raw_input)}) {\n            $k->call($me, $$stderr_event, $cooked_input, $unique_id);\n          }\n        }\n        else {\n          $$error_event and $k->call(\n            $me, $$error_event,\n            'read', ($!+0), $!, $unique_id, 'STDERR'\n          );\n          unless (--$$is_active) {\n            $k->call( $me, $$close_event, $unique_id )\n              if defined $$close_event;\n          }\n          $k->select_read($handle);\n        }\n      }\n    );\n  }\n\n  # Register the state's select.\n  $poe_kernel->select_read($self->[HANDLE_STDERR], $self->[STATE_STDERR]);\n}\n\n#------------------------------------------------------------------------------\n# Redefine events.\n\nsub event {\n  my $self = shift;\n  push(@_, undef) if (scalar(@_) & 1);\n\n  my ($redefine_stdin, $redefine_stdout, $redefine_stderr) = (0, 0, 0);\n\n  while (@_) {\n    my ($name, $event) = splice(@_, 0, 2);\n\n    if ($name eq 'StdinEvent') {\n      $self->[EVENT_STDIN] = $event;\n      $redefine_stdin = 1;\n    }\n    elsif ($name eq 'StdoutEvent') {\n      $self->[EVENT_STDOUT] = $event;\n      $redefine_stdout = 1;\n    }\n    elsif ($name eq 'StderrEvent') {\n      if ($self->[CONDUIT_TYPE] ne 'pty') {\n        $self->[EVENT_STDERR] = $event;\n        $redefine_stderr = 1;\n      }\n      else {\n        carp \"ignoring StderrEvent on a pty conduit\";\n      }\n    }\n    elsif ($name eq 'ErrorEvent') {\n      $self->[ERROR_EVENT] = $event;\n    }\n    elsif ($name eq 'CloseEvent') {\n      $self->[CLOSE_EVENT] = $event;\n    }\n    else {\n      carp \"ignoring unknown Run parameter '$name'\";\n    }\n  }\n\n  # Recalculate the active handles count.\n  my $active_count = 0;\n  $active_count++ if $self->[EVENT_STDOUT] and $self->[HANDLE_STDOUT];\n  $active_count++ if $self->[EVENT_STDERR] and $self->[HANDLE_STDERR];\n  $self->[IS_ACTIVE] = $active_count;\n}\n\n#------------------------------------------------------------------------------\n# Destroy the wheel.\n\nsub DESTROY {\n  my $self = shift;\n\n  return if(ref POE::Kernel->get_active_session eq 'POE::Kernel');\n\n  # Turn off the STDIN thing.\n  if ($self->[HANDLE_STDIN]) {\n    $poe_kernel->select_write($self->[HANDLE_STDIN]);\n    $self->[HANDLE_STDIN] = undef;\n  }\n\n  if ($self->[STATE_STDIN]) {\n    $poe_kernel->state($self->[STATE_STDIN]);\n    $self->[STATE_STDIN] = undef;\n  }\n\n  if ($self->[HANDLE_STDOUT]) {\n    $poe_kernel->select_read($self->[HANDLE_STDOUT]);\n    $self->[HANDLE_STDOUT] = undef;\n  }\n  if ($self->[STATE_STDOUT]) {\n    $poe_kernel->state($self->[STATE_STDOUT]);\n    $self->[STATE_STDOUT] = undef;\n  }\n\n  if ($self->[HANDLE_STDERR]) {\n    $poe_kernel->select_read($self->[HANDLE_STDERR]);\n    $self->[HANDLE_STDERR] = undef;\n  }\n  if ($self->[STATE_STDERR]) {\n    $poe_kernel->state($self->[STATE_STDERR]);\n    $self->[STATE_STDERR] = undef;\n  }\n\n  &POE::Wheel::free_wheel_id($self->[UNIQUE_ID]);\n}\n\n#------------------------------------------------------------------------------\n# Queue input for the child process.\n\nsub put {\n  my ($self, @chunks) = @_;\n\n  # Avoid big bada boom if someone put()s on a dead wheel.\n  croak \"Called put() on a wheel without an open STDIN handle\" unless (\n    $self->[HANDLE_STDIN]\n  );\n\n  if (\n    $self->[OCTETS_STDIN] =  # assignment on purpose\n    $self->[DRIVER_STDIN]->put($self->[FILTER_STDIN]->put(\\@chunks))\n  ) {\n    $poe_kernel->select_resume_write($self->[HANDLE_STDIN]);\n  }\n\n  # No watermark.\n  return 0;\n}\n\n#------------------------------------------------------------------------------\n# Pause and resume various input events.\n\nsub pause_stdout {\n  my $self = shift;\n  return unless defined $self->[HANDLE_STDOUT];\n  $poe_kernel->select_pause_read($self->[HANDLE_STDOUT]);\n}\n\nsub pause_stderr {\n  my $self = shift;\n  return unless defined $self->[HANDLE_STDERR];\n  $poe_kernel->select_pause_read($self->[HANDLE_STDERR]);\n}\n\nsub resume_stdout {\n  my $self = shift;\n  return unless defined $self->[HANDLE_STDOUT];\n  $poe_kernel->select_resume_read($self->[HANDLE_STDOUT]);\n}\n\nsub resume_stderr {\n  my $self = shift;\n  return unless defined $self->[HANDLE_STDERR];\n  $poe_kernel->select_resume_read($self->[HANDLE_STDERR]);\n}\n\n# Shutdown the pipe that leads to the child's STDIN.\nsub shutdown_stdin {\n  my $self = shift;\n  return unless defined $self->[HANDLE_STDIN];\n\n  $poe_kernel->select_write($self->[HANDLE_STDIN], undef);", 8192) = 8192
09:01:57.403718 brk(0x1c43000)          = 0x1c43000
09:01:57.403880 read(10, "\n\n  eval { local $^W = 0; shutdown($self->[HANDLE_STDIN], 1) };\n  if ($@ or $self->[HANDLE_STDIN] != $self->[HANDLE_STDOUT]) {\n    close $self->[HANDLE_STDIN];\n  }\n\n  $self->[HANDLE_STDIN] = undef;\n}\n\n#------------------------------------------------------------------------------\n# Redefine filters, one at a time or at once.  This is based on PG's\n# code in Wheel::ReadWrite.\n\nsub _transfer_stdout_buffer {\n  my ($self, $buf) = @_;\n\n  my $old_output_filter = $self->[FILTER_STDOUT];\n\n  # Assign old buffer contents to the new filter, and send out any\n  # pending packets.\n\n  # Use \"get_one\" if the new filter implements it.\n  if (defined $buf) {\n    if (\n      $old_output_filter->can(\"get_one\") and\n      $old_output_filter->can(\"get_one_start\")\n    ) {\n      $old_output_filter->get_one_start($buf);\n\n      # Don't bother to continue if the filter has switched out from\n      # under our feet again.  The new switcher will finish the job.\n\n      while ($self->[FILTER_STDOUT] == $old_output_filter) {\n        my $next_rec = $old_output_filter->get_one();\n        last unless @$next_rec;\n        foreach my $cooked_input (@$next_rec) {\n          $poe_kernel->call(\n            $poe_kernel->get_active_session(), $self->[EVENT_STDOUT],\n            $cooked_input, $self->[UNIQUE_ID]\n          );\n        }\n      }\n    }\n\n    # Otherwise use the old get() behavior.\n    else {\n      foreach my $cooked_input (@{$self->[FILTER_STDOUT]->get($buf)}) {\n        $poe_kernel->call(\n          $poe_kernel->get_active_session(), $self->[EVENT_STDOUT],\n          $cooked_input, $self->[UNIQUE_ID]\n        );\n      }\n    }\n  }\n}\n\nsub _transfer_stderr_buffer {\n  my ($self, $buf) = @_;\n\n  my $old_output_filter = $self->[FILTER_STDERR];\n\n  # Assign old buffer contents to the new filter, and send out any\n  # pending packets.\n\n  # Use \"get_one\" if the new filter implements it.\n  if (defined $buf) {\n    if (\n      $old_output_filter->can(\"get_one\") and\n      $old_output_filter->can(\"get_one_start\")\n    ) {\n      $old_output_filter->get_one_start($buf);\n\n      # Don't bother to continue if the filter has switched out from\n      # under our feet again.  The new switcher will finish the job.\n\n      while ($self->[FILTER_STDERR] == $old_output_filter) {\n        my $next_rec = $old_output_filter->get_one();\n        last unless @$next_rec;\n        foreach my $cooked_input (@$next_rec) {\n          $poe_kernel->call(\n            $poe_kernel->get_active_session(), $self->[EVENT_STDERR],\n            $cooked_input, $self->[UNIQUE_ID]\n          );\n        }\n      }\n    }\n\n    # Otherwise use the old get() behavior.\n    else {\n      foreach my $cooked_input (@{$self->[FILTER_STDERR]->get($buf)}) {\n        $poe_kernel->call(\n          $poe_kernel->get_active_session(), $self->[EVENT_STDERR],\n          $cooked_input, $self->[UNIQUE_ID]\n        );\n      }\n    }\n  }\n}\n\nsub set_stdio_filter {\n  my ($self, $new_filter) = @_;\n  $self->set_stdout_filter($new_filter);\n  $self->set_stdin_filter($new_filter);\n}\n\nsub set_stdin_filter {\n  my ($self, $new_filter) = @_;\n  $self->[FILTER_STDIN] = $new_filter;\n}\n\nsub set_stdout_filter {\n  my ($self, $new_filter) = @_;\n\n  my $buf = $self->[FILTER_STDOUT]->get_pending();\n  $self->[FILTER_STDOUT] = $new_filter;\n\n  $self->_transfer_stdout_buffer($buf);\n}\n\nsub set_stderr_filter {\n  my ($self, $new_filter) = @_;\n\n  my $buf = $self->[FILTER_STDERR]->get_pending();\n  $self->[FILTER_STDERR] = $new_filter;\n\n  $self->_transfer_stderr_buffer($buf);\n}\n\nsub get_stdin_filter {\n  my $self = shift;\n  return $self->[FILTER_STDIN];\n}\n\nsub get_stdout_filter {\n  my $self = shift;\n  return $self->[FILTER_STDOUT];\n}\n\nsub get_stderr_filter {\n  my $self = shift;\n  return $self->[FILTER_STDERR];\n}\n\n#------------------------------------------------------------------------------\n# Data accessors.\n\nsub get_driver_out_octets {\n  $_[0]->[OCTETS_STDIN];\n}\n\nsub get_driver_out_messages {\n  $_[0]->[DRIVER_STDIN]->get_out_messages_buffered();\n}\n\nsub ID {\n  $_[0]->[UNIQUE_ID];\n}\n\nsub PID {\n  $_[0]->[CHILD_PID];\n}\n\nsub kill {\n  my ($self, $signal) = @_;\n  $signal = 'TERM' unless defined $signal;\n  if ( $self->[MSWIN32_GROUP_PID] ) {\n    # TODO use https://rt.cpan.org/Ticket/Display.html?id=67774 when available :)\n    Win32::Process::KillProcess( $self->[MSWIN32_GROUP_PID], 293 ) ? 1 : 0;\n  }\n  else {\n    eval { kill $signal, $self->[CHILD_PID] };\n  }\n}\n\n### Internal helpers.\n\nsub _redirect_child_stdio_in_hell {\n  my ($class, $stdin_read, $stdout_write, $stderr_write) = @_;\n\n  # Win32 needs the stdio handles closed before they're reopened\n  # because the standard handles aren't dup()'d.\n\n  close STDIN;\n  close STDOUT;\n  close STDERR;\n\n  $class->_redirect_child_stdio_sanely(\n    $stdin_read, $stdout_write, $stderr_write\n  );\n\n  # The Win32 pseudo fork sets up the std handles in the child\n  # based on the true win32 handles.  The reopening of stdio\n  # handles isn't enough.  We must also set the underlying\n  # Win32 notion of these handles for completeness.\n  #\n  # Only necessary for the exec, as Perl CODE subroutine goes\n  # through 0/1/2 which are correct.  But of course that coderef\n  # might invoke exec, so better do it regardless.\n  #\n  # HACK: Using Win32::Console as nothing else exposes\n  # SetStdHandle\n  #\n  # TODO - https://rt.cpan.org/Ticket/Display.html?id=50068 claims\n  # that these _SetStdHandle() calls may leak memory.  Do we have\n  # alternatives?\n\n  Win32::Console::_SetStdHandle(\n    $STD_INPUT_HANDLE,\n    FdGetOsFHandle(fileno($stdin_read))\n  ) if defined $stdin_read;\n\n  Win32::Console::_SetStdHandle(\n    $STD_OUTPUT_HANDLE,\n    FdGetOsFHandle(fileno($stdout_write))\n  ) if defined $stdout_write;\n\n  Win32::Console::_SetStdHandle(\n    $STD_ERROR_HANDLE,\n    FdGetOsFHandle(fileno($stderr_write))\n  ) if defined $stderr_write;\n}\n\nsub _filespec_to_fh {\n  my ($dest,$mode,$fspec) = @_;\n  return unless defined $fspec;\n  if(ref $fspec) {\n    if (ref $fspec eq 'GLOB') {\n      open $$dest, \"$mode&\", $fspec;\n    } else {\n      die(\"Bad file specifier '$fspec'\");\n    }\n  } else {\n    open $$dest, $mode, $fspec;\n  }\n}\n\nsub _redirect_child_stdio_sanely {\n  my ($class, $stdin_read, $stdout_write, $stderr_write) = @_;\n\n  # Note: we use 2-arg open() below because Perl 5.6 doesn't recognize\n  # the '>&' and '<&' modes with a 3-arg open()\n\n  # Redirect STDIN from the read end of the stdin pipe.\n  if(defined $stdin_read) {\n    open( STDIN, \"<&\" . fileno($stdin_read) )\n      or $class->_warn_and_exit_child(\n        \"can't redirect STDIN in child pid $$: $!\", int( $! ) );\n  }\n\n  # Redirect STDOUT to the write end of the stdout pipe.\n  if(defined $stdout_write) {\n    open( STDOUT, \">&\" . fileno($stdout_write) )\n      or $class->_warn_and_exit_child(\n        \"can't redirect stdout in child pid $$: $!\", int( $! ) );\n  }\n    # Redirect STDERR to the write end of the stderr pipe.\n  if(defined $stderr_write) {\n    open( STDERR, \">&\" . fileno($stderr_write) )\n      or $class->_warn_and_exit_child(\n        \"can't redirect stderr in child pid $$: $!\", int( $! ) );\n  }\n}\n\nsub _exit_child_any_way_we_can {\n  my $class = shift;\n  my $exitval = shift || 0;\n\n  # First make sure stdio are flushed.\n  close STDIN  if defined fileno(STDIN); # Voodoo?\n  close STDOUT if defined fileno(STDOUT);\n  close STDERR if defined fileno(STDERR);\n\n  # On Windows, subprocesses run in separate threads.  All the \"fancy\"\n  # methods act on entire processes, so they also exit the parent.\n\n  unless (POE::Kernel::RUNNING_IN_HELL) {\n    # Try to avoid triggering END blocks and object destructors.\n    eval { POSIX::_exit( $exitval ); };\n\n    # TODO those methods will not exit with $exitval... what to do?\n    eval { CORE::kill KILL => $$; };\n    eval { exec(\"$^X -e 0\"); };\n  } else {\n    eval { CORE::kill( KILL => $$ ); };\n\n    # TODO Interestingly enough, the KILL is not enough to terminate this process...\n    # However, it *is* enough to stop execution of END blocks/etc\n    # So we will end up falling through to the exit( $exitval ) below\n  }\n\n  # Do what we must.\n  exit( $exitval );\n}\n\n# RUNNING_IN_HELL use Win32::Process to create a pucker new shiny\n# process. It'll inherit our processes handles which is neat.\n\nsub _exec_in_hell {\n  my (\n    $c", 8192) = 8192
09:01:57.404880 read(10, "lass, $close_on_call, $sem_pipe_write,\n    $program, $prog_args\n  ) = @_;\n\n  # Close any close-on-exec file descriptors.\n  # Except STDIN, STDOUT, and STDERR, of course.\n\n  if ($close_on_call) {\n    for (0..MAX_OPEN_FDS-1) {\n      next if fileno(STDIN) == $_;\n      next if fileno(STDOUT) == $_;\n      next if fileno(STDERR) == $_;\n      POSIX::close($_);\n    }\n  }\n\n  my ($appname, $cmdline);\n\n  if (ref $program eq 'ARRAY') {\n    $appname = $program->[0];\n    $cmdline = join(\n      ' ',\n      map { /\\s/ && ! /\"/ ? qq{\"$_\"} : $_ }\n      (@$program, @$prog_args)\n    );\n  }\n  else {\n    $appname = undef;\n    $cmdline = join(\n      ' ', $program,\n      map { /\\s/ && ! /\"/ ? qq{\"$_\"} : $_ }\n      @$prog_args\n    );\n  }\n\n  my $w32job;\n\n  unless ( $w32job = Win32::Job->new() ) {\n    print $sem_pipe_write \"go\\n\\n\"; # TODO why the double newline?\n    close $sem_pipe_write;\n    $class->_warn_and_exit_child(\n      Win32::FormatMessage( Win32::GetLastError() ), Win32::GetLastError() );\n  }\n\n  my $w32pid;\n\n  unless ( $w32pid = $w32job->spawn( $appname, $cmdline ) ) {\n    print $sem_pipe_write \"go\\n\";\n    close $sem_pipe_write;\n    $class->_warn_and_exit_child(\n      Win32::FormatMessage( Win32::GetLastError() ), Win32::GetLastError() );\n  }\n\n  print $sem_pipe_write \"$w32pid\\n\";\n  close $sem_pipe_write;\n\n  # TODO why 60? Why not MAX_INT so we don't do unnecessary work?\n  my $ok = $w32job->watch( sub { 0 }, 60 );\n  my $hashref = $w32job->status();\n\n  # In case flushing them wasn't good enough.\n  close STDOUT if defined fileno(STDOUT);\n  close STDERR if defined fileno(STDERR);\n\n  $class->_exit_child_any_way_we_can( $hashref->{$w32pid}->{exitcode} );\n}\n\n# Simple helper to ease the pain of warn+exit\nsub _warn_and_exit_child {\n  my( $class, $warning, $exitval ) = @_;\n\n  warn \"$warning\\n\";\n\n  $class->_exit_child_any_way_we_can( $exitval );\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Wheel::Run - portably run blocking code and programs in subprocesses\n\n=head1 SYNOPSIS\n\n  #!/usr/bin/perl\n\n  use warnings;\n  use strict;\n\n  use POE qw( Wheel::Run );\n\n  POE::Session->create(\n    inline_states => {\n      _start           => \\&on_start,\n      got_child_stdout => \\&on_child_stdout,\n      got_child_stderr => \\&on_child_stderr,\n      got_child_close  => \\&on_child_close,\n      got_child_signal => \\&on_child_signal,\n    }\n  );\n\n  POE::Kernel->run();\n  exit 0;\n\n  sub on_start {\n    my $child = POE::Wheel::Run->new(\n      Program => [ \"/bin/ls\", \"-1\", \"/\" ],\n      StdoutEvent  => \"got_child_stdout\",\n      StderrEvent  => \"got_child_stderr\",\n      CloseEvent   => \"got_child_close\",\n    );\n\n    $_[KERNEL]->sig_child($child->PID, \"got_child_signal\");\n\n    # Wheel events include the wheel's ID.\n    $_[HEAP]{children_by_wid}{$child->ID} = $child;\n\n    # Signal events include the process ID.\n    $_[HEAP]{children_by_pid}{$child->PID} = $child;\n\n    print(\n      \"Child pid \", $child->PID,\n      \" started as wheel \", $child->ID, \".\\n\"\n    );\n  }\n\n  # Wheel event, including the wheel's ID.\n  sub on_child_stdout {\n    my ($stdout_line, $wheel_id) = @_[ARG0, ARG1];\n    my $child = $_[HEAP]{children_by_wid}{$wheel_id};\n    print \"pid \", $child->PID, \" STDOUT: $stdout_line\\n\";\n  }\n\n  # Wheel event, including the wheel's ID.\n  sub on_child_stderr {\n    my ($stderr_line, $wheel_id) = @_[ARG0, ARG1];\n    my $child = $_[HEAP]{children_by_wid}{$wheel_id};\n    print \"pid \", $child->PID, \" STDERR: $stderr_line\\n\";\n  }\n\n  # Wheel event, including the wheel's ID.\n  sub on_child_close {\n    my $wheel_id = $_[ARG0];\n    my $child = delete $_[HEAP]{children_by_wid}{$wheel_id};\n\n    # May have been reaped by on_child_signal().\n    unless (defined $child) {\n      print \"wid $wheel_id closed all pipes.\\n\";\n      return;\n    }\n\n    print \"pid \", $child->PID, \" closed all pipes.\\n\";\n    delete $_[HEAP]{children_by_pid}{$child->PID};\n  }\n\n  sub on_child_signal {\n    print \"pid $_[ARG1] exited with status $_[ARG2].\\n\";\n    my $child = delete $_[HEAP]{children_by_pid}{$_[ARG1]};\n\n    # May have been reaped by on_child_close().\n    return unless defined $child;\n\n    delete $_[HEAP]{children_by_wid}{$child->ID};\n  }\n\n=head1 DESCRIPTION\n\nPOE::Wheel::Run executes a program or block of code in a subprocess,\ncreated the usual way: using fork().  The parent process may exchange\ninformation with the child over the child's STDIN, STDOUT and STDERR\nfilehandles.\n\nIn the parent process, the POE::Wheel::Run object represents the child\nprocess.  It has methods such as PID() and kill() to query and manage\nthe child process.\n\nPOE::Wheel::Run's put() method sends data to the child's STDIN.  Child\noutput on STDOUT and STDERR may be dispatched as events within the\nparent, if requested.\n\nPOE::Wheel::Run can also notify the parent when the child has closed\nits output filehandles.  Some programs remain active, but they close\ntheir output filehandles to indicate they are done writing.\n\nA more reliable way to detect child exit is to use POE::Kernel's\nsig_child() method to wait for the wheel's process to be reaped.  It\nis in fact vital to use sig_child() in all circumstances since without\nit, POE will not try to reap child processes.\n\nFailing to use sig_child() has in the past led to wedged machines.\nLong-running programs have leaked processes, eventually consuming all\navailable slots in the process table and requiring reboots.\n\nBecause process leaks are so severe, POE::Kernel will check for this\ncondition on exit and display a notice if it finds that processes are\nleaking.  Developers should heed these warnings.\n\nPOE::Wheel::Run communicates with the child process in a line-based\nfashion by default.  Programs may override this by specifying some\nother POE::Filter object in L</StdinFilter>, L</StdoutFilter>,\nL</StdioFilter> and/or L</StderrFilter>.\n\n=head1 PUBLIC METHODS\n\n=head2 Constructor\n\nPOE::Wheel subclasses tend to perform a lot of setup so that they run\nlighter and faster.  POE::Wheel::Run's constructor is no exception.\n\n=head3 new\n\nnew() creates and returns a new POE::Wheel::Run object.  If it's\nsuccessful, the object will represent a child process with certain\nspecified qualities.  It also provides an OO- and event-based\ninterface for asynchronously interacting with the process.\n\n=head4 Conduit\n\nConduit specifies the inter-process communications mechanism that will\nbe used to pass data between the parent and child process.  Conduit\nmay be one of \"pipe\", \"socketpair\", \"inet\", \"pty\", or \"pty-pipe\".\nPOE::Wheel::Run will use the most appropriate Conduit for the run-time\n(not the compile-time) operating system, but this varies from one OS\nto the next.\n\nInternally, POE::Wheel::Run passes the Conduit type to\nL<POE::Pipe::OneWay> and L<POE::Pipe::TwoWay>.  These helper classes\nwere created to make IPC portable and reusable.  They do not require\nthe rest of POE.\n\nThree Conduit types use pipes or pipelike inter-process communication:\n\"pipe\", \"socketpair\" and \"inet\".  They determine whether the internal\nIPC uses pipe(), socketpair() or Internet sockets.  These Conduit\nvalues are passed through to L<POE::Pipe::OneWay> or\nL<POE::Pipe::TwoWay> internally.\n\nThe \"pty\" conduit type runs the child process under a pseudo-tty,\nwhich is created by L<IO::Pty>.  Pseudo-ttys (ptys) convince child\nprocesses that they are interacting with terminals rather than pipes.\nThis may be used to trick programs like ssh into believing it's secure\nto prompt for a password, although passphraseless identities might be\nbetter for that.\n\nThe \"pty\" conduit cannot separate STDERR from STDOUT, but the\n\"pty-pipe\" mode can.\n\nThe \"pty-pipe\" conduit uses a pty for STDIN and STDOUT and a one-way\npipe for STDERR.  The additional pipe keeps STDERR output separate\nfrom STDOUT.\n\nThe L<IO::Pty> module is only loaded if \"pty\" or \"pty-pipe\" is used.\nIt's not a dependency until it's actually needed.\n\n=for comment\nTODO - Example.\n\n=head4 Winsize\n\nWinsize sets the child process' terminal size.  Its value should be an\narrayref with four elements.  The first two elements must be the\nnumber of lines and columns for the child's terminal window,\nrespectively.  The second pair of elements describe the terminal's X\nand Y dimensions in pixels.  If the last pair is missing, they will be calculate", 8192) = 8192
09:01:57.405400 brk(0x1c64000)          = 0x1c64000
09:01:57.405566 lseek(10, 42825, SEEK_SET) = 42825
09:01:57.405613 lseek(10, 0, SEEK_CUR)  = 42825
09:01:57.405664 close(10)               = 0
09:01:57.405757 stat("modules/POE/Filter/Reference.pmc", 0x7ffe12339dc0) = -1 ENOENT (No such file or directory)
09:01:57.405810 stat("modules/POE/Filter/Reference.pm", {st_mode=S_IFREG|0600, st_size=13979, ...}) = 0
09:01:57.405868 open("modules/POE/Filter/Reference.pm", O_RDONLY) = 10
09:01:57.405920 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe12339aa0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.405966 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.406020 read(10, "# Filter::Reference partial copyright 1998 Artur Bergman\n# <artur@vogon-solutions.com>.  Partial copyright 1999 Philip Gwyn.\n\npackage POE::Filter::Reference;\n\nuse strict;\nuse POE::Filter;\n\nuse vars qw($VERSION @ISA);\n$VERSION = '1.367'; # NOTE - Should be #.### (three decimal places)\n@ISA = qw(POE::Filter);\n\nuse Carp qw(carp croak confess);\n\nsub BUFFER    () { 0 }\nsub FREEZE    () { 1 }\nsub THAW      () { 2 }\nsub COMPRESS  () { 3 }\nsub NO_FATALS () { 4 }\nsub MAX_BUFFER () { 5 }\nsub BAD_BUFFER () { 6 }\nsub FIRST_UNUSED   () { 7 }\n\nuse base 'Exporter';\nour @EXPORT_OK = qw( FIRST_UNUSED );\n\nmy %KNOWN_PARAMS = (\n    Compression => 1,\n    Serializer  => 1,\n    NoFatals    => 1,\n    MaxBuffer   => 1 \n);\n\n#------------------------------------------------------------------------------\n# Try to require one of the default freeze/thaw packages.\nuse vars qw( $DEF_FREEZER $DEF_FREEZE $DEF_THAW );\nBEGIN {\n  local $SIG{'__DIE__'} = 'DEFAULT';\n\n  my @packages = qw(Storable FreezeThaw YAML);\n  foreach my $package (@packages) {\n    eval { require \"$package.pm\"; import $package (); };\n    if ($@) {\n      warn $@;\n      next;\n    }\n\n    # Found a good freezer!\n    $DEF_FREEZER = $package;\n    last;\n  }\n  die \"Filter::Reference requires one of @packages\" unless defined $DEF_FREEZER;\n}\n\n# Some processing here\n($DEF_FREEZE, $DEF_THAW) = _get_methods($DEF_FREEZER);\n\n#------------------------------------------------------------------------------\n# Try to acquire Compress::Zlib at run time.\n\nmy $zlib_status = undef;\nsub _include_zlib {\n  local $SIG{'__DIE__'} = 'DEFAULT';\n\n  unless (defined $zlib_status) {\n    eval \"use Compress::Zlib qw(compress uncompress)\";\n    if ($@) {\n      $zlib_status = $@;\n      eval(\n        \"sub compress   { @_ }\\n\" .\n        \"sub uncompress { @_ }\"\n      );\n    }\n    else {\n      $zlib_status = '';\n    }\n  }\n\n  $zlib_status;\n}\n\n#------------------------------------------------------------------------------\n\nsub _get_methods {\n  my($freezer)=@_;\n  my $freeze=$freezer->can('nfreeze') || $freezer->can('freeze');\n  my $thaw=$freezer->can('thaw');\n  return unless $freeze and $thaw;\n  return ($freeze, $thaw);\n}\n\n#------------------------------------------------------------------------------\n\nsub new\n{\n  my $type = shift;\n\n  # Convert from old style to new style\n  # $l == 1\n  #     ->new( undef ) => (Serializer => undef)\n  #     ->new( $class ) => (Serializer => class)\n  # not defined $_[0]\n  #     ->new( undef, 1 ) => (Serializer => undef, Compression => 1)\n  #     ->new( undef, undef, 1 ) => (Serializer => undef, Compression => undef, NoFatals =>1)\n  # $l == 3\n  #     ->new( $class, 1, 1 ) => (Serializer => undef, Compression => 1, NoFatals =>1)\n  # ($l <= 3 and not $KNOWN_PARAMS{$_[0]})\n  #     ->new( $class, 1 ) \n  my %params;\n  my $l = scalar @_;\n  if( $l == 1 or $l == 3 or not defined $_[0] or \n        ( $l<=3 and not $KNOWN_PARAMS{$_[0]}) ) { \n    if( 'HASH' eq ref $_[0] ) {     # do we \n        %params = %{ $_[0] };\n    }\n    else {\n        %params = ( Serializer  => $_[0],\n                    Compression => $_[1],\n                    NoFatals    => $_[2]\n                  );\n    }\n  } \n  else {\n    croak \"$type requires an even number of parameters\" if @_ and @_ & 1;\n    %params = @_;\n  }\n\n  my($freeze, $thaw);\n  my $freezer = $params{Serializer};\n  unless (defined $freezer) {\n    # Okay, load the default one!\n    $freezer = $DEF_FREEZER;\n    $freeze  = $DEF_FREEZE;\n    $thaw    = $DEF_THAW;\n  }\n  else {\n    # What did we get?\n    if (ref $freezer) {\n      # It's an object, create an closure\n      my($freezetmp, $thawtmp) = _get_methods($freezer);\n      $freeze = sub { $freezetmp->($freezer, @_) };\n      $thaw   = sub { $thawtmp->  ($freezer, @_) };\n    }\n    else {\n      # A package name?\n      # First, find out if the package has the necessary methods.\n      ($freeze, $thaw) = _get_methods($freezer);\n\n      # If not, try to reload the module.\n      unless ($freeze and $thaw) {\n        my $path = $freezer;\n        $path =~ s{::}{/}g;\n        $path .= '.pm';\n\n        # Force a reload if necessary.  This is naive and can leak\n        # memory, so we only do it until we get the desired methods.\n        delete $INC{$path};\n\n        eval {\n          local $^W = 0;\n          require $path;\n          $freezer->import();\n        };\n\n        carp $@ if $@;\n        ($freeze, $thaw) = _get_methods($freezer);\n      }\n    }\n  }\n\n  # Now get the methods we want\n  carp \"$freezer doesn't have a freeze or nfreeze method\" unless $freeze;\n  carp \"$freezer doesn't have a thaw method\" unless $thaw;\n\n  # Should ->new() return undef() it if fails to find the methods it\n  # wants?\n  return unless $freeze and $thaw;\n\n  # Maximum buffer\n  my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \\%params );\n\n  # Compression\n  my $compression = $params{Compression}||0;\n  if ($compression) {\n    my $zlib_status = _include_zlib();\n    if ($zlib_status ne '') {\n      warn \"Compress::Zlib load failed with error: $zlib_status\\n\";\n      carp \"Filter::Reference compression option ignored\";\n      $compression = 0;\n    }\n  }\n\n  # No fatals\n  my $no_fatals = $params{NoFatals}||0;\n\n  delete @params{ keys %KNOWN_PARAMS };\n  carp(\"$type ignores unknown parameters: \", join(', ', sort keys %params))\n    if scalar keys %params;\n\n  my $self = bless [\n    '',              # BUFFER\n    $freeze,         # FREEZE\n    $thaw,           # THAW\n    $compression,    # COMPRESS\n    $no_fatals,      # NO_FATALS\n    $max_buffer,     # MAX_BUFFER\n    ''               # BAD_BUFFER\n  ], $type;\n  $self;\n}\n\n#------------------------------------------------------------------------------\n\nsub get {\n  my ($self, $stream) = @_;\n  my @return;\n\n  $self->get_one_start($stream);\n  while (1) {\n    my $next = $self->get_one();\n    last unless @$next;\n    push @return, @$next;\n  }\n\n  return \\@return;\n}\n\n#------------------------------------------------------------------------------\n# 2001-07-27 RCC: The get_one() variant of get() allows Wheel::Xyz to\n# retrieve one filtered block at a time.  This is necessary for filter\n# changing and proper input flow control.\n\nsub get_one_start {\n  my ($self, $stream) = @_;\n  $self->[BUFFER] .= join('', @$stream);\n  if( $self->[MAX_BUFFER] < length( $self->[BUFFER] ) ) {\n    $self->[BAD_BUFFER] = \"Framing buffer exceeds the limit\";\n    die $self->[BAD_BUFFER] unless $self->[NO_FATALS];\n  }\n}\n\nsub get_one {\n  my $self = shift;\n\n  # Need to check lengths in octets, not characters.\n  BEGIN { eval { require bytes } and bytes->import; }\n\n  if( $self->[BAD_BUFFER] ) {\n    my $err = $self->[BAD_BUFFER];\n    $self->[BAD_BUFFER] = '';\n    return [ $err ];\n  }\n\n  if (\n    $self->[BUFFER] =~ /^(\\d+)\\0/ and\n    length($self->[BUFFER]) >= $1 + length($1) + 1\n  ) {\n    substr($self->[BUFFER], 0, length($1) + 1) = \"\";\n    my $next_message = substr($self->[BUFFER], 0, $1);\n    substr($self->[BUFFER], 0, $1) = \"\";\n    $next_message = uncompress($next_message) if $self->[COMPRESS];\n\n    unless ($self->[NO_FATALS]) {\n      return [ $self->[THAW]->($next_message) ];\n    }\n\n    my $thawed = eval { $self->[THAW]->($next_message) };\n    return [ \"$@\" ] if $@;\n    return [ $thawed ];\n  }\n\n  return [ ];\n}\n\n#------------------------------------------------------------------------------\n# freeze one or more references, and return a string representing them\n\nsub put {\n  my ($self, $references) = @_;\n\n  # Need to check lengths in octets, not characters.\n  BEGIN { eval { require bytes } and bytes->import; }\n\n  my @raw = map {\n    confess \"Choking on a non-reference ($_)\" unless ref();\n    my $frozen = $self->[FREEZE]->($_);\n    $frozen = compress($frozen) if $self->[COMPRESS];\n    length($frozen) . \"\\0\" . $frozen;\n  } @$references;\n  \\@raw;\n}\n\n#------------------------------------------------------------------------------\n# Return everything we have outstanding.  Do not destroy our framing\n# buffer, though.\n\nsub get_pending {\n  my $self = shift;\n  return undef unless length $self->[BUFFER];\n  return [ $self->[BUFFER] ];\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Filter::Reference - freeze and thaw arbitrary Perl data\n\n=head1 SYNOPSIS\n\n  #!perl\n\n  use YAML;\n  use POE qw(Wheel::ReadWrite Filter::Ref", 8192) = 8192
09:01:57.407366 brk(0x1c85000)          = 0x1c85000
09:01:57.407428 lseek(10, 8036, SEEK_SET) = 8036
09:01:57.407475 lseek(10, 0, SEEK_CUR)  = 8036
09:01:57.407519 close(10)               = 0
09:01:57.407721 stat("modules/POE/Component/Resolver/Sidecar.pmc", 0x7ffe1233a3e0) = -1 ENOENT (No such file or directory)
09:01:57.407790 stat("modules/POE/Component/Resolver/Sidecar.pm", {st_mode=S_IFREG|0600, st_size=2388, ...}) = 0
09:01:57.407854 open("modules/POE/Component/Resolver/Sidecar.pm", O_RDONLY) = 10
09:01:57.407908 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a0c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.407955 lseek(10, 0, SEEK_CUR)  = 0
09:01:57.408016 read(10, "package POE::Component::Resolver::Sidecar;\n{\n  $POE::Component::Resolver::Sidecar::VERSION = '0.921';\n}\n\nuse warnings;\nuse strict;\n\nuse Storable qw(nfreeze thaw);\n\nuse Socket qw(getaddrinfo);\n\nsub main {\n\tmy $buffer = \"\";\n\tmy $read_length;\n\n\tbinmode(STDIN);\n\tbinmode(STDOUT);\n\tselect STDOUT; $| = 1;\n\n\tuse bytes;\n\n\twhile (1) {\n\t\tif (defined $read_length) {\n\t\t\tif (length($buffer) >= $read_length) {\n\t\t\t\tmy $request = thaw(substr($buffer, 0, $read_length, \"\"));\n\t\t\t\t$read_length = undef;\n\n\t\t\t\tmy ($request_id, $host, $service, $hints) = @$request;\n\t\t\t\tmy ($err, @addrs) = getaddrinfo($host, $service, $hints);\n\n\t\t\t\tmy $streamable = nfreeze( [ $request_id, $err, \\@addrs ] );\n\t\t\t\tmy $stream = length($streamable) . chr(0) . $streamable;\n\n\t\t\t\tmy $octets_wrote = syswrite(STDOUT, $stream);\n\t\t\t\tdie $! unless $octets_wrote == length($stream);\n\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\telsif ($buffer =~ s/^(\\d+)\\0//) {\n\t\t\t$read_length = $1;\n\t\t\tnext;\n\t\t}\n\n\t\tmy $octets_read = sysread(STDIN, $buffer, 4096, length($buffer));\n\t\tlast unless $octets_read;\n\t}\n\n\texit 0;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Resolver::Sidecar - delegate subprocess to call getaddrinfo()\n\n=head1 VERSION\n\nversion 0.921\n\n=head1 SYNOPSIS\n\nUsed internally by POE::Component::Resolver.\n\n=head1 DESCRIPTION\n\nPOE::Component::Resolver creates subprocesses to call getaddrinfo() so\nthat the main program doesn't block during that time.\n\nThe actual getaddrinfo() calling code is abstracted into this module\nso it can be run in a separate executable program.  This reduces the\nmemory footprint of forking the entire main process for just\ngetaddrinfo().\n\nIt's a strong, useful pattern that other POE::Components have\nimplemented before.  POE::Quickie does it generically.\nPOE::Component::SimpleDBI and POE::Component::EasyDBI do it so their\nDBI subprocesses are relatively lightweight.\n\n=head2 main\n\nThe main code to read POE::Component::Resolver requests from STDIN and\nwrite getaddrinfo() responses to STDOUT.\n\n=head1 SEE ALSO\n\nL<POE::Component::Generic> is one generic implementation of this\npattern.\n\nL<POE::Quickie> is another generic implementation of this pattern.\n\n=head1 BUGS\n\nNone known.\n\n=head1 LICENSE\n\nExcept where otherwise noted, this distribution is Copyright 2011 by\nRocco Caputo.  All rights reserved.  This distribution is free\nsoftware; you may redistribute it and/or modify it under the same\nterms as Perl itself.\n\n=cut\n", 8192) = 2388
09:01:57.408390 lseek(10, 1054, SEEK_SET) = 1054
09:01:57.408440 lseek(10, 0, SEEK_CUR)  = 1054
09:01:57.408487 close(10)               = 0
09:01:57.409340 read(9, "to a new sidecar.\n\t\tmy $next_sidecar = pop @{$heap->{sidecar_ring}};\n\t\tunshift @{$heap->{sidecar_ring}}, $next_sidecar;\n\n\t\t$request->{sidecar_id} = $next_sidecar->ID();\n\n\t\t$next_sidecar->put(\n\t\t\t[\n\t\t\t\t$request_id, $request->{host}, $request->{service}, $request->{hints}\n\t\t\t]\n\t\t);\n\t}\n}\n\n# Internal event handler to briefly defer replaying requests until any\n# responses in the queue have had time to be delivered.  This prevents\n# us from replaying requests that may already have answers.\n\nsub _poe_sidecar_attach {\n\tmy ($kernel, $heap) = @_[KERNEL, HEAP];\n\n\t# Nothing to do if we don't have requests.\n\treturn unless scalar keys %{$heap->{requests}};\n\n\t# Requests exist.\n\t_poe_setup_sidecar_ring($kernel, $heap);\n\t_poe_replay_pending($kernel, $heap);\n}\n\n# Plain public Perl method.  Begin resolving something.\n\nsub resolve {\n\tmy ($self, @args) = @_;\n\n\tcroak \"resolve() requires an even number of parameters\" if @args % 2;\n\tmy %args = @args;\n\n\tmy $host = delete $args{host};\n\tcroak \"resolve() requires a host\" unless defined $host and length $host;\n\n\tmy $service = delete $args{service};\n\tcroak \"resolve() requires a service\" unless (\n\t\tdefined $service and length $service\n\t);\n\n\tmy $misc = delete $args{misc};\n\t$misc = \"\" unless defined $misc;\n\n\tmy $hints = delete $args{hints};\n\t$hints ||= { };\n\n\tmy $event = delete $args{event};\n\t$event = \"resolver_response\" unless defined $event and length $event;\n\n\tmy @error = sort keys %args;\n\tcroak \"unknown resolve() parameter(s): @error\" if @error;\n\n\tmy $result;\n\tcroak \"resolve() on shutdown resolver\" unless (\n\t\t$result = $poe_kernel->call(\n\t\t\t$self->{alias}, \"request\", $host, $service, $hints, $event, $misc\n\t\t)\n\t);\n\n\tcarp \"<pcr> $self->{alias} request for host($host) service($service)\" if (\n\t\t$self->{debug}\n\t);\n\n\treturn $result;\n}\n\n# A sidecar process has produced an error or warning.  Pass it\n# through to the parent process' console.\n\nsub _poe_sidecar_error {\n\twarn __PACKAGE__, \" error in getaddrinfo subprocess: $_[ARG0]\\n\";\n}\n\n# A sidecar process has closed its standard output.  We will receive\n# no more responses from it.  Clean up the sidecar's resources, and\n# start new ones if necessary.\n\nsub _poe_sidecar_closed {\n\tmy ($kernel, $heap, $wheel_id) = @_[KERNEL, HEAP, ARG0];\n\n\t# Don't bother checking for pending requests if we've shut down.\n\treturn if $heap->{shutdown};\n\n\t_sidecar_cleanup($kernel, $heap, $wheel_id);\n}\n\nsub _sidecar_cleanup {\n\tmy ($kernel, $heap, $wheel_id) = @_;\n\n\tmy $sidecar = delete $heap->{sidecar_id}{$wheel_id};\n\tif (defined $sidecar) {\n\t\t$sidecar->kill(9);\n\t\tdelete $heap->{sidecar}{$sidecar->PID()};\n\t}\n\n\t# Remove the sidecar from the rotation.\n\tmy $i = @{$heap->{sidecar_ring}};\n\twhile ($i--) {\n\t\tnext unless $heap->{sidecar_ring}[$i]->ID() == $wheel_id;\n\t\tsplice(@{$heap->{sidecar_ring}}, $i, 1);\n\t\tlast;\n\t}\n\n\t_poe_setup_sidecar_ring($kernel, $heap);\n\t_poe_replay_pending($kernel, $heap) if scalar keys %{$heap->{requests}};\n}\n\n# A sidecar has produced a response.  Pass it back to the original\n# caller of resolve().  If we've run out of requests, briefly defer a\n# partial shutdown.  We don't need all those sidecar processes if we\n# might be done.\n\nsub _poe_sidecar_response {\n\tmy ($kernel, $heap, $response_rec) = @_[KERNEL, HEAP, ARG0];\n\tmy ($request_id, $error, $addresses) = @$response_rec;\n\n\tmy $request_rec = delete $heap->{requests}{$request_id};\n\treturn unless defined $request_rec;\n\n\tif (defined $heap->{af_order}) {\n\t\tmy @filtered_addresses;\n\t\tforeach my $af_filter (@{$heap->{af_order}}) {\n\t\t\tpush @filtered_addresses, grep { $_->{family} == $af_filter } @$addresses;\n\t\t}\n\t\t$addresses = \\@filtered_addresses;\n\t}\n\n\t$kernel->post(\n\t\t$request_rec->{sender}, $request_rec->{event},\n\t\t$error, $addresses,\n\t\t{ map { $_ => $request_rec->{$_} } qw(host service misc) },\n\t);\n\n\twarn \"<pcr> $heap->{alias} --refcount for sender $request_rec->{sender}\" if (\n\t\t$heap->{debug}\n\t);\n\n\t$kernel->refcount_decrement($request_rec->{sender}, __PACKAGE__);\n\n\t# No more requests?  Consder detaching sidecar.\n\t$kernel->delay(sidecar_eject => $heap->{idle_timeout}) unless (\n\t\tscalar keys %{$heap->{requests}}\n\t);\n}\n\n# A sidecar process has exited.  Clean up its resources, and attach a\n# replacement sidecar if there are requests.\n\nsub _poe_sidecar_signal {\n\tmy ($heap, $pid) = @_[HEAP, ARG1];\n\n\treturn unless exists $heap->{sidecar}{$pid};\n\tmy $sidecar = delete $heap->{sidecar}{$pid};\n\tmy $sidecar_id = $sidecar->ID();\n\tdelete $heap->{sidecar_id}{$sidecar_id};\n\n\t# Remove the sidecar from the rotation.\n\tmy $i = @{$heap->{sidecar_ring}};\n\twhile ($i--) {\n\t\tnext unless $heap->{sidecar_ring}[$i]->ID() == $sidecar_id;\n\t\tsplice(@{$heap->{sidecar_ring}}, 1, 1);\n\t\tlast;\n\t}\n\n\t$_[KERNEL]->yield(\"sidecar_attach\") if scalar keys %{$heap->{requests}};\n\n\tundef;\n}\n\n# Event handler to defer wiping out all sidecars.  This allows for\n# lazy cleanup, which may eliminate thrashing in some situations.\n\nsub _poe_sidecar_eject {\n\tmy ($kernel, $heap) = @_[KERNEL, HEAP];\n\t_poe_wipe_sidecars($heap) unless scalar keys %{$heap->{requests}};\n}\n\n# Internal helper sub to synchronously wipe out all sidecars.\n\nsub _poe_wipe_sidecars {\n\tmy $heap = shift;\n\n\treturn unless @{$heap->{sidecar_ring}};\n\n\tforeach my $sidecar (@{$heap->{sidecar_ring}}) {\n\t\t$sidecar->kill(-9);\n\t}\n\n\t$heap->{sidecar}      = {};\n\t$heap->{sidecar_id}   = {};\n\t$heap->{sidecar_ring} = [];\n}\n\nsub unpack_addr {\n\tmy ($self, $address_rec) = @_;\n\n\t# [rt.cpan.org 76314] Untaint the address.\n\tmy ($input_addr) = ($address_rec->{addr} =~ /\\A(.*)\\z/s);\n\n\tmy ($error, $address, $port) = (\n\t\t(getnameinfo $input_addr, NI_NUMERICHOST | NI_NUMERICSERV)[0,1]\n\t);\n\n\treturn if $error;\n\treturn($address, $port) if wantarray();\n\treturn $address;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Resolver - A non-blocking getaddrinfo() resolver\n\n=head1 VERSION\n\nversion 0.921\n\n=head1 SYNOPSIS\n\n\t#!/usr/bin/perl\n\n\tuse warnings;\n\tuse strict;\n\n\tuse POE;\n\tuse POE::Component::Resolver qw(AF_INET AF_INET6);\n\n\tmy $r = POE::Component::Resolver->new(\n\t\tmax_resolvers => 8,\n\t\tidle_timeout  => 5,\n\t\taf_order      => [ AF_INET6, AF_INET ],\n\t\t# sidecar_program => $path_to_program,\n\t);\n\n\tmy @hosts = qw( ipv6-test.com );\n\tmy $tcp   = getprotobyname(\"tcp\");\n\n\tPOE::Session->create(\n\t\tinline_states => {\n\t\t\t_start => sub {\n\t\t\t\tforeach my $host (@hosts) {\n\t\t\t\t\t$r->resolve(\n\t\t\t\t\t\thost    => $host,\n\t\t\t\t\t\tservice => \"http\",\n\t\t\t\t\t\tevent   => \"got_response\",\n\t\t\t\t\t\thints   => { protocol => $tcp },\n\t\t\t\t\t) or die $!;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_stop => sub { print \"client session stopped\\n\" },\n\n\t\t\tgot_response => sub {\n\t\t\t\tmy ($error, $addresses, $request) = @_[ARG0..ARG2];\n\t\t\t\tuse YAML; print YAML::Dump(\n\t\t\t\t\t{\n\t\t\t\t\t\terror => $error,\n\t\t\t\t\t\taddr => $addresses,\n\t\t\t\t\t\treq => $request,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t},\n\t\t}\n\t);\n\n\tPOE::Kernel->run();\n\n=head1 DESCRIPTION\n\nPOE::Component::Resolver performs Socket::getaddrinfo() calls in\nsubprocesses where they're permitted to block as long as necessary.\n\nBy default it will run eight subprocesses and prefer address families\nin whatever order getaddrinfo() returns them.  These defaults can be\noverridden with constructor parameters.  getaddrinfo() delegates to\nthe operating system's resolver, which may be reconfigured according\nto the usual conventions.\n\n=head2 PUBLIC METHODS\n\n=head3 new\n\nCreate a new resolver.  Returns an object that must be held and used\nto make requests.  See the synopsis.\n\nAccepts up to four optional named parameters.\n\n\"af_order\" may contain an arrayref with the address families to\npermit, in the order in which they're preferred.  Without \"af_order\",\nthe component will prefer IPv4 addresses over IPv6 for legacy\ncompatibility.  This may change in the future as IPv6 gains more\nwidespread acceptance.  See L</ENVIRONMENT VARIABLES> for a way to\noverride the default without hacking modules.\n\n\t# Prefer IPv6 addresses, but also return IPv4 ones.\n\tmy $r1 = POE::Component::Resolver->new(\n\t\taf_order => [ AF_INET6, AF_INET ]\n\t);\n\n\t# Only return IPv6 addresses,\n\t# or nothing in cases where only IPv4 addresses exist.\n\tmy $r2 = POE::Component::Resolver->new(\n\t\taf_order => [ AF_INET6 ]\n\t);\n\n\"idle_timeout\" determines how long to keep idle resolver subprocesses\nbefore cleaning them up, in seconds.  It defaults to 15.0 seconds.\n\n\"max_resolvers\"", 8192) = 8192
09:01:57.409872 brk(0x1ca6000)          = 0x1ca6000
09:01:57.410401 lseek(9, 13871, SEEK_SET) = 13871
09:01:57.410453 lseek(9, 0, SEEK_CUR)   = 13871
09:01:57.410498 close(9)                = 0
09:01:57.410656 stat("modules/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.410709 stat("modules/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.410759 stat("modules/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.410807 stat("modules/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.410856 stat("/etc/perl/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.410907 stat("/etc/perl/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.410956 stat("/usr/local/lib/perl/5.14.2/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.411007 stat("/usr/local/lib/perl/5.14.2/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.411074 stat("/usr/local/share/perl/5.14.2/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.411124 stat("/usr/local/share/perl/5.14.2/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.411175 stat("/usr/lib/perl5/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.411225 stat("/usr/lib/perl5/Net/IP/Minimal.pm", 0x7ffe1233a960) = -1 ENOENT (No such file or directory)
09:01:57.411275 stat("/usr/share/perl5/Net/IP/Minimal.pmc", 0x7ffe1233aa10) = -1 ENOENT (No such file or directory)
09:01:57.411331 stat("/usr/share/perl5/Net/IP/Minimal.pm", {st_mode=S_IFREG|0644, st_size=3019, ...}) = 0
09:01:57.411391 open("/usr/share/perl5/Net/IP/Minimal.pm", O_RDONLY) = 9
09:01:57.411445 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233a6f0) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.411495 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.411553 read(9, "package Net::IP::Minimal;\n{\n  $Net::IP::Minimal::VERSION = '0.02';\n}\n\n#ABSTRACT: Minimal functions from Net::IP\n\nuse strict;\nuse warnings;\n\nrequire Exporter;\n\nour @ISA = qw(Exporter);\nour @EXPORT_OK = qw(ip_get_version ip_is_ipv4 ip_is_ipv6);\nour %EXPORT_TAGS = ( 'PROC' => [ @EXPORT_OK ] );\n\nsub ip_get_version {\n    my $ip = shift;\n\n    # If the address does not contain any ':', maybe it's IPv4\n    $ip !~ /:/ and ip_is_ipv4($ip) and return '4';\n\n    # Is it IPv6 ?\n    ip_is_ipv6($ip) and return '6';\n\n    return;\n}\n\nsub ip_is_ipv4 {\n  my @field = split /\\./, shift;\n\n  return 0 if @field > 4;       # too many fields\n  return 0 if @field == 0;      # no fields at all\n\n  foreach ( @field ) {\n    return 0 unless /./;      # reject if empty\n    return 0 if /[^0-9]/;     # reject non-digit\n    return 0 if $_ > 255;     # reject bad value\n  }\n\n  return 1;\n}\n\n\nsub ip_is_ipv6 {\n  for ( shift ) {\n    my @field = split /:/;      # split into fields\n    return 0 if (@field < 3) or (@field > 8);\n\n    return 0 if /::.*::/;     # reject multiple ::\n\n    if ( /\\./ ) {       # IPv6:IPv4\n      return 0 unless _ip_is_ipv4(pop @field);\n    }\n\n    foreach ( @field ) {\n      next unless /./;    # skip ::\n      return 0 if /[^0-9a-f]/i; # reject non-hexdigit\n      return 0 if length $_ > 4;  # reject bad value\n    }\n  }\n  return 1;\n}\n\n\nqq[IP freely];\n\n\n__END__\n=pod\n\n=head1 NAME\n\nNet::IP::Minimal - Minimal functions from Net::IP\n\n=head1 VERSION\n\nversion 0.02\n\n=head1 SYNOPSIS\n\n  use Net::IP::Minimal qw[:PROC];\n\n  my $ip = '172.16.0.216';\n\n  ip_is_ipv4( $ip ) and print \"$ip is IPv4\";\n\n  $ip = 'dead:beef:89ab:cdef:0123:4567:89ab:cdef';\n\n  ip_is_ipv6( $ip ) and print \"$ip is IPv6\";\n\n  print ip_get_version( $ip );\n\n=head1 DESCRIPTION\n\nL<Net::IP> is very feature complete, but I found I was only using three of its functions\nand it uses quite a bit of memory L<https://rt.cpan.org/Public/Bug/Display.html?id=24525>.\n\nThis module only provides the minimal number of functions that I use in my modules.\n\n=head1 FUNCTIONS\n\nThe same as L<Net::IP> these functions are not exported by default. You may import them explicitly\nor use C<:PROC> to import them all.\n\n=over\n\n=item C<ip_get_version>\n\nTry to guess the IP version of an IP address.\n\n    Params  : IP address\n    Returns : 4, 6, undef(unable to determine)\n\nC<$version = ip_get_version ($ip)>\n\n=item C<ip_is_ipv4>\n\nCheck if an IP address is of type 4.\n\n    Params  : IP address\n    Returns : 1 (yes) or 0 (no)\n\nC<ip_is_ipv4($ip) and print \"$ip is IPv4\";>\n\n=item C<ip_is_ipv6>\n\nCheck if an IP address is of type 6.\n\n    Params            : IP address\n    Returns           : 1 (yes) or 0 (no)\n\nC<ip_is_ipv6($ip) and print \"$ip is IPv6\";>\n\n=back\n\n=head1 SEE ALSO\n\nL<Net::IP>\n\n=head1 AUTHOR\n\nChris Williams <chris@bingosnet.co.uk>\n\n=head1 COPYRIGHT AND LICENSE\n\nThis software is copyright (c) 2011 by Chris Williams and RIPE-NCC.\n\nThis is free software; you can redistribute it and/or modify it under\nthe same terms as the Perl 5 programming language system itself.\n\n=cut\n\n", 8192) = 3019
09:01:57.411971 lseek(9, 1359, SEEK_SET) = 1359
09:01:57.412019 lseek(9, 0, SEEK_CUR)   = 1359
09:01:57.412064 close(9)                = 0
09:01:57.412269 open("/etc/nsswitch.conf", O_RDONLY) = 9
09:01:57.412328 fstat(9, {st_mode=S_IFREG|0644, st_size=513, ...}) = 0
09:01:57.412381 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f2f000
09:01:57.412430 read(9, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference' and `info' packages installed, try:\n# `info libc \"Name Service Switch\"' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files mdns4_minimal [NOTFOUND=return] dns mdns4\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 513
09:01:57.412513 read(9, "", 4096)       = 0
09:01:57.412560 close(9)                = 0
09:01:57.412605 munmap(0x7f7436f2f000, 4096) = 0
09:01:57.412665 open("/etc/ld.so.cache", O_RDONLY) = 9
09:01:57.412715 fstat(9, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.412768 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 9, 0) = 0x7f7436f01000
09:01:57.412814 close(9)                = 0
09:01:57.412860 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.412916 open("/usr/lib/libnss_db.so.2", O_RDONLY) = 9
09:01:57.412969 read(9, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\27\0\0\0\0\0\0@\0\0\0\0\0\0\0\360S\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\324O\0\0\0\0\0\0\324O\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\0P\0\0\0\0\0\0\0P \0\0\0\0\0\0P \0\0\0\0\0\20\3\0\0\0\0\0\0\240\5\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0(P\0\0\0\0\0\0(P \0\0\0\0\0(P \0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0008E\0\0\0\0\0\0008E\0\0\0\0\0\0008E\0\0\0\0\0\0\264\1\0\0\0\0\0\0\264\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0?\f8P\31\276\335M\4\270\321\323\360\257\24D~\351\264S\0\0\0\0C\0\0\0H\0\0\0\24\0\0\0\27\0\0\0\0\0\0\0002\0\0\0(\0\0\0*\0\0\0\0\0\0\0\0\0\0\0001\0\0\0003\0\0\0\0\0\0\0\"\0\0\0\0\0\0\0/\0\0\0008\0\0\0\33\0\0\0\0\0\0\0E\0\0\0\0\0\0\0\34\0\0\0\22\0\0\0:\0\0\0\0\0\0\0#\0\0\0\0\0\0\0005\0\0\0\f\0\0\0\0\0\0\0G\0\0\0+\0\0\0\30\0\0\0\0\0\0\0009\0\0\0\26\0\0\0\0\0\0\0\20\0\0\0\32\0\0\0\25\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\31\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\21\0\0\0>\0\0\0F\0\0\0\0\0\0\0!\0\0\0\0\0\0\0<\0\0\0\16\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\35\0\0\0\2\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0)\0\0\0=\0\0\0\7\0\0\0\t\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0A\0\0\0\23\0\0\0", 832) = 832
09:01:57.413109 fstat(9, {st_mode=S_IFREG|0644, st_size=23216, ...}) = 0
09:01:57.413167 mmap(NULL, 2119072, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0x7f7431f98000
09:01:57.413218 mprotect(0x7f7431f9d000, 2097152, PROT_NONE) = 0
09:01:57.413268 mmap(0x7f743219d000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x5000) = 0x7f743219d000
09:01:57.413321 close(9)                = 0
09:01:57.413374 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.413424 open("/lib/x86_64-linux-gnu/libnss_files.so.2", O_RDONLY) = 9
09:01:57.413479 read(9, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\200!\0\0\0\0\0\0@\0\0\0\0\0\0\0\200\262\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\360\223\0\0\0\0\0\0\360\223\0\0\0\0\0\0\360\223\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\214\251\0\0\0\0\0\0\214\251\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\320\255\0\0\0\0\0\0\320\255 \0\0\0\0\0\320\255 \0\0\0\0\0\220\3\0\0\0\0\0\0\270\7\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\370\255\0\0\0\0\0\0\370\255 \0\0\0\0\0\370\255 \0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\f\224\0\0\0\0\0\0\f\224\0\0\0\0\0\0\f\224\0\0\0\0\0\0\344\2\0\0\0\0\0\0\344\2\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\320\255\0\0\0\0\0\0\320\255 \0\0\0\0\0\320\255 \0\0\0\0\0000\2\0\0\0\0\0\0000\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\267\20\5\31\361\24N\247\367\244\32\271\16T\20\317\377\242\27t\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0k\0\0\0000\0\0\0\10\0\0\0\t\0\0\0\22F\344\25\240\245\201\0\t\10\2\30\223\6\210\0\0\0z\0]\201\240Jx\2100*\220\200\0$\7!\5\24)\"\226<\0\4\0\33\0\20\2\0\0@\10\201\3100\200\200@@\206\0B\0\200\3000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0005\0\0\0006\0\0\0\0\0\0\0007\0\0\0\0\0\0\0008\0\0\0:\0\0\0;\0\0\0\0\0\0\0=\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0B\0\0\0\0\0\0\0C\0\0\0", 832) = 832
09:01:57.413614 fstat(9, {st_mode=S_IFREG|0644, st_size=47616, ...}) = 0
09:01:57.413673 mmap(NULL, 2143624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0x7f7431d8c000
09:01:57.413728 mprotect(0x7f7431d97000, 2093056, PROT_NONE) = 0
09:01:57.413779 mmap(0x7f7431f96000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0xa000) = 0x7f7431f96000
09:01:57.413839 close(9)                = 0
09:01:57.413891 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.413946 open("/usr/lib/x86_64-linux-gnu/libdb-5.1.so", O_RDONLY) = 9
09:01:57.413998 read(9, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340\312\2\0\0\0\0\0@\0\0\0\0\0\0\0\30*\30\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\35\0\34\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0L\237\27\0\0\0\0\0L\237\27\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0 \242\27\0\0\0\0\0 \2427\0\0\0\0\0 \2427\0\0\0\0\0\300\206\0\0\0\0\0\0\360\206\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0P\356\27\0\0\0\0\0P\3567\0\0\0\0\0P\3567\0\0\0\0\0\20\2\0\0\0\0\0\0\20\2\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\30\10\26\0\0\0\0\0\30\10\26\0\0\0\0\0\30\10\26\0\0\0\0\0D=\0\0\0\0\0\0D=\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0 \242\27\0\0\0\0\0 \2427\0\0\0\0\0 \2427\0\0\0\0\0\340]\0\0\0\0\0\0\340]\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0k\10\221\21]-\236\354\357\220\24\362:\7K6C\2147$\0\0\0\0\7\4\0\0\332\6\0\0e\6\0\0\1\4\0\0 \2\0\0\0\0\0\0-\6\0\0\342\5\0\0\321\5\0\0\254\3\0\0\217\2\0\0\3\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0w\0\0\0\303\1\0\0\226\6\0\0_\4\0\0\234\0\0\0\346\0\0\0F\6\0\0\16\6\0\0\20\1\0\0:\4\0\0\0\0\0\0\265\6\0\0\217\1\0\0\327\3\0\0\305\2\0\0P\1\0\0&\2\0\0,\5\0\0f\6\0\0\0\0\0\0\314\1\0\0\251\0\0\0\0\0\0\0\302\0\0\0\302\3\0\0F\4\0\0\325\6\0\0\344\4\0\0\30\3\0\0;\3\0\0\t\2\0\0h\1\0\0\335\1\0\0\6\6\0\0\322\1\0\0\354\1\0\0003\2\0\0H\5\0\0\337\5\0\0\1\5\0\0\341\4\0\0\0\0\0\0\0\0\0\0\376\1\0\0\202\0\0\0Y\1\0\0\0\0\0\0\230\1\0\0\372\4\0\0?\5\0\0\363\2\0\0\231\4\0\0\244\1\0\0\244\3\0\0o\1\0\0\0\0\0\0\234\5\0\0\272\5\0\0\367\4\0\0|\0\0\0K\0\0\0\331\5\0\0\377\1\0\0\344\2\0\0\0\0\0\0004\4\0\0k\5\0\0\354\3\0\0\0\0\0\0", 832) = 832
09:01:57.414152 fstat(9, {st_mode=S_IFREG|0644, st_size=1585496, ...}) = 0
09:01:57.414210 mmap(NULL, 3680528, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0x7f7431a09000
09:01:57.414259 mprotect(0x7f7431b83000, 2097152, PROT_NONE) = 0
09:01:57.414309 mmap(0x7f7431d83000, 36864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x17a000) = 0x7f7431d83000
09:01:57.414366 close(9)                = 0
09:01:57.414604 mprotect(0x7f7431d83000, 24576, PROT_READ) = 0
09:01:57.414658 mprotect(0x7f7431f96000, 4096, PROT_READ) = 0
09:01:57.414715 munmap(0x7f7436f01000, 98904) = 0
09:01:57.414798 open("/proc/stat", O_RDONLY|O_CLOEXEC) = 9
09:01:57.414862 read(9, "cpu  4231677 176717 354334 189452819 35456 0 80058 109907 0 0\ncpu0 561166 28565 44778 23642466 4319 0 10043 13796 0 0\ncpu1 517254 23856 44191 23691935 4329 0 10015 13538 0 0\ncpu2 510803 18450 43880 23703930 4542 0 9962 13562 0 0\ncpu3 546983 19361 43029 23667860 4224 0 9954 13710 0 0\ncpu4 525859 21710 44014 23685440 4447 0 9985 13666 0 0\ncpu5 519886 21090 44029 23691590 4576 0 10047 13900 0 0\ncpu6 511809 23588 44262 23697286 4448 0 10004 13708 0 0\ncpu7 537914 20094 46151 23672311 4568 0 10046 14024 0 0\nintr 587475544 39 9 0 0 324 0 2 0 1 0 0 0 113 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 663 0 312096 0 408871 0 78856 0 7174 0 77818 0 353186 0 57384 0 100 0 20396041 340 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nctxt 268543132\nbtime 1453555865\nprocesses 486334\nprocs_running 1\nprocs_blocked 0\nsoftirq 1144564533 0 486101741 57539 22969174 0 0 15420 355257060 8 280163591\n", 8192) = 2217
09:01:57.415037 close(9)                = 0
09:01:57.415117 open("/var/lib/misc/DB_CONFIG", O_RDONLY) = -1 ENOENT (No such file or directory)
09:01:57.415179 stat("/var/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, ...}) = 0
09:01:57.415261 open("/proc/stat", O_RDONLY|O_CLOEXEC) = 9
09:01:57.415316 read(9, "cpu  4231677 176717 354334 189452819 35456 0 80058 109907 0 0\ncpu0 561166 28565 44778 23642466 4319 0 10043 13796 0 0\ncpu1 517254 23856 44191 23691935 4329 0 10015 13538 0 0\ncpu2 510803 18450 43880 23703930 4542 0 9962 13562 0 0\ncpu3 546983 19361 43029 23667860 4224 0 9954 13710 0 0\ncpu4 525859 21710 44014 23685440 4447 0 9985 13666 0 0\ncpu5 519886 21090 44029 23691590 4576 0 10047 13900 0 0\ncpu6 511809 23588 44262 23697286 4448 0 10004 13708 0 0\ncpu7 537914 20094 46151 23672311 4568 0 10046 14024 0 0\nintr 587475564 39 9 0 0 324 0 2 0 1 0 0 0 113 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 663 0 312096 0 408871 0 78856 0 7174 0 77818 0 353186 0 57384 0 100 0 20396041 340 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nctxt 268543172\nbtime 1453555865\nprocesses 486334\nprocs_running 1\nprocs_blocked 0\nsoftirq 1144564533 0 486101741 57539 22969174 0 0 15420 355257060 8 280163591\n", 8192) = 2217
09:01:57.415476 close(9)                = 0
09:01:57.415542 mmap(NULL, 212992, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436ee6000
09:01:57.415678 stat("/var/lib/misc/protocols.db", 0x7ffe1233a3f0) = -1 ENOENT (No such file or directory)
09:01:57.415753 munmap(0x7f7436ee6000, 212992) = 0
09:01:57.415841 open("/etc/protocols", O_RDONLY|O_CLOEXEC) = 9
09:01:57.415897 fstat(9, {st_mode=S_IFREG|0644, st_size=2933, ...}) = 0
09:01:57.415950 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7436f2f000
09:01:57.416004 read(9, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP'')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\ndccp\t33\tDCCP\t\t# Datagram Congestion Control Prot. [RFC4340]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol [RFC5798]\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nmobility-header 135 Mobility-Header # Mobility Support for IPv6 [RFC3775]\nudplite\t136\tUDPLite\t\t# UDP-Lite [RFC3828]\nmpls-in-ip 137\tMPLS-in-IP\t# MPLS-in-IP [RFC4023]\nmanet\t138\t\t\t# MANET Protocols [RFC5498]\nhip\t139\tHIP\t\t# Host Identity Protocol\nshim6\t140\tShim6\t\t# Shim6 Protocol [RFC5533]\nwesp\t141\tWESP\t\t# Wrapped Encapsulating Security Payload\nrohc\t142\tROHC\t\t# Robust Header Compression\n", 4096) = 2933
09:01:57.416186 close(9)                = 0
09:01:57.416232 munmap(0x7f7436f2f000, 4096) = 0
09:01:57.416805 brk(0x1cc7000)          = 0x1cc7000
09:01:57.417003 read(8, "self->[SF_REQ_INDEX]{$request->[RQ_ID]};\n      _free_req_id($request->[RQ_ID]);\n\n      next;\n    }\n\n    # we can't easily take this out of the outer loop since _check_free_pool\n    # can change it from under us\n    my @free_sockets   = keys(%{$self->[SF_SOCKETS]});\n\n    # Try to free over-committed (but unused) sockets until we're back\n    # under SF_MAX_OPEN sockets.  Bail out if we can't free enough.\n    # TODO - Consider removing @free_sockets in least- to\n    # most-recently used order.\n    while ($currently_open >= $self->[SF_MAX_OPEN]) {\n      last QUEUED unless @free_sockets;\n      my $next_to_go = $free_sockets[rand(@free_sockets)];\n      $self->_remove_socket_from_pool($next_to_go);\n      $currently_open--;\n    }\n\n    # Start the request.  Create a wheel to begin the connection.\n    # Move the wheel and its request into SF_WHEELS.\n    DEBUG and warn \"WAKEUP: creating wheel for $req_key\";\n\n    my $addr = ($request->[RQ_IP] or $request->[RQ_ADDRESS]);\n    my $wheel = POE::Wheel::SocketFactory->new(\n      (\n        defined($self->[SF_BIND_ADDR])\n        ? (BindAddress => $self->[SF_BIND_ADDR])\n        : ()\n      ),\n      RemoteAddress => $addr,\n      RemotePort    => $request->[RQ_PORT],\n      SuccessEvent  => \"ka_conn_success\",\n      FailureEvent  => \"ka_conn_failure\",\n      SocketDomain  => $request->[RQ_ADDR_FAM],\n    );\n\n    $self->[SF_WHEELS]{$wheel->ID} = [\n      $wheel,     # WHEEL_WHEEL\n      $request,   # WHEEL_REQUEST\n    ];\n\n    # store the wheel's ID in the request object\n    $request->[RQ_WHEEL_ID] = $wheel->ID;\n\n    # Count it as used, so we don't over commit file handles.\n    $currently_open++;\n    $self->[SF_USED_EACH]{$req_key}++;\n\n    # Temporarily store the SF_USED record under the wheel ID.  It\n    # will be moved to the socket when the wheel responds.\n    $self->[SF_USED]{$wheel->ID} = [\n      undef,     # USED_SOCKET\n      time(),    # USED_TIME\n      $req_key,  # USED_KEY\n    ];\n\n    # Mark the request index as one to splice out.\n\n    push @splice_list, $request_index;\n  }\n  continue {\n    $request_index++;\n  }\n\n  # The @splice_list is a list of element indices that need to be\n  # spliced out of the request queue.  We scan in backwards, from\n  # highest index to lowest, so that each splice does not affect the\n  # indices of the other.\n  #\n  # This removes the request from the queue.  It's vastly important\n  # that the request be entered into SF_WHEELS before now.\n\n  my $splice_index = @splice_list;\n  while ($splice_index--) {\n    splice @{$self->[SF_QUEUE]}, $splice_list[$splice_index], 1;\n  }\n}\n\nsub allocate {\n  my $self = shift;\n  croak \"allocate() needs an even number of parameters\" if @_ % 2;\n  my %args = @_;\n\n  # TODO - Validate arguments.\n\n  my $scheme  = delete $args{scheme};\n  croak \"allocate() needs a 'scheme'\"  unless $scheme;\n  my $address = delete $args{addr};\n  croak \"allocate() needs an 'addr'\"   unless $address;\n  my $port    = delete $args{port};\n  croak \"allocate() needs a 'port'\"    unless $port;\n  my $event   = delete $args{event};\n  croak \"allocate() needs an 'event'\"  unless $event;\n  my $context = delete $args{context};\n  croak \"allocate() needs a 'context'\" unless $context;\n  my $timeout = delete $args{timeout};\n  $timeout    = $self->[SF_TIMEOUT]    unless $timeout;\n\n  my $for_scheme  = delete($args{for_scheme}) || $scheme;\n  my $for_address = delete($args{for_addr}) || $address;\n  my $for_port    = delete($args{for_port}) || $port;\n\n  croak \"allocate() on shut-down connection manager\" if $self->[SF_SHUTDOWN];\n\n  my @unknown = sort keys %args;\n  if (@unknown) {\n    croak \"allocate() doesn't accept: @unknown\";\n  }\n\n  my $conn_key = (\n    \"$scheme $address $port for $for_scheme $for_address $for_port\"\n  );\n\n  # If we have a connection pool for the scheme/address/port triple,\n  # then we can maybe post an available connection right away.\n\n  my $existing_connection = $self->_check_free_pool($conn_key);\n  if (defined $existing_connection) {\n    $poe_kernel->post(\n      $poe_kernel->get_active_session,\n      $event => {\n        addr       => $address,\n        context    => $context,\n        port       => $port,\n        scheme     => $scheme,\n        connection => $existing_connection,\n        from_cache => \"immediate\",\n      }\n    );\n    return;\n  }\n\n  # We can't honor the request immediately, so it's put into a queue.\n  DEBUG and warn \"ALLOCATE: enqueuing request for $conn_key\";\n\n  my $request = [\n    $poe_kernel->get_active_session(),  # RQ_SESSION\n    $event,       # RQ_EVENT\n    $scheme,      # RQ_SCHEME\n    $address,     # RQ_ADDRESS\n    undef,        # RQ_IP\n    $port,        # RQ_PORT\n    $conn_key,    # RQ_CONN_KEY\n    $context,     # RQ_CONTEXT\n    $timeout,     # RQ_TIMEOUT\n    time(),       # RQ_START\n    undef,        # RQ_TIMER_ID\n    undef,        # RQ_WHEEL_ID\n    1,            # RQ_ACTIVE\n    _allocate_req_id(), # RQ_ID\n    undef,        # RQ_ADDR_FAM\n    $for_scheme,  # RQ_FOR_SCHEME\n    $for_address, # RQ_FOR_ADDRESS\n    $for_port,    # RQ_FOR_PORT\n    undef,        # RQ_RESOLVER_ID\n  ];\n\n  $self->[SF_REQ_INDEX]{$request->[RQ_ID]} = $request;\n\n  $poe_kernel->refcount_increment(\n    $request->[RQ_SESSION]->ID(),\n    \"poco-client-keepalive\"\n  );\n\n  $poe_kernel->call($self->[SF_ALIAS], ka_set_timeout     => $request);\n  $poe_kernel->call($self->[SF_ALIAS], ka_resolve_request => $request);\n\n  return $request->[RQ_ID];\n}\n\nsub deallocate {\n  my ($self, $req_id) = @_;\n\n  croak \"deallocate() requires a request ID\" unless(\n    defined($req_id) and exists($active_req_ids{$req_id})\n  );\n\n  my $request = delete $self->[SF_REQ_INDEX]{$req_id};\n  unless (defined $request) {\n    DEBUG_DEALLOCATE and warn \"deallocate could not find request $req_id\";\n    return;\n  }\n  _free_req_id($request->[RQ_ID]);\n\n  # Now pass the vetted request & its ID into our manager session.\n  $poe_kernel->call($self->[SF_ALIAS], \"ka_deallocate\", $request, $req_id);\n}\n\nsub _ka_deallocate {\n  my ($self, $heap, $request, $req_id) = @_[OBJECT, HEAP, ARG0, ARG1];\n\n  my $conn_key = $request->[RQ_CONN_KEY];\n  my $existing_connection = $self->_check_free_pool($conn_key);\n\n  # Existing connection.  Remove it from the pool, and delete the socket.\n  if (defined $existing_connection) {\n    $self->_remove_socket_from_pool($existing_connection->{socket});\n    DEBUG_DEALLOCATE and warn(\n      \"deallocate called, deleted already-connected socket\"\n    );\n    return;\n  }\n\n  # No connection yet.  Cancel the request.\n  DEBUG_DEALLOCATE and warn(\n    \"deallocate called without an existing connection.  \",\n    \"cancelling connection request\"\n  );\n\n  unless (exists $heap->{dns_requests}{$request->[RQ_ADDRESS]}) {\n    DEBUG_DEALLOCATE and warn(\n      \"deallocate cannot cancel dns -- no pending request\"\n    );\n    return;\n  }\n\n  $poe_kernel->call( $self->[SF_ALIAS], ka_cancel_dns_response => $request );\n  return;\n}\n\nsub _ka_cancel_dns_response {\n  my ($self, $kernel, $heap, $request) = @_[OBJECT, KERNEL, HEAP, ARG0];\n\n  my $address = $request->[RQ_ADDRESS];\n  DEBUG_DNS and warn \"DNS: canceling request for $address\\n\";\n\n  my $requests = $heap->{dns_requests}{$address};\n\n  # Remove the resolver request for the address of this connection\n  # request\n\n  my $req_index = @$requests;\n  while ($req_index--) {\n    next unless $requests->[$req_index] == $request;\n    splice(@$requests, $req_index, 1);\n    last;\n  }\n\n  # Clean up the structure for the address if there are no more\n  # requests to resolve that address.\n\n  unless (@$requests) {\n    DEBUG_DNS and warn \"DNS: canceled all requests for $address\";\n    $self->[SF_RESOLVER]->cancel( $request->[RQ_RESOLVER_ID] );\n    delete $heap->{dns_requests}{$address};\n  }\n\n  # cancel our attempt to connect\n  $poe_kernel->alarm_remove( $request->[RQ_TIMER_ID] );\n  $poe_kernel->refcount_decrement(\n    $request->[RQ_SESSION]->ID(), \"poco-client-keepalive\"\n  );\n}\n\n# Set the request's timeout, in the component's context.\n\nsub _ka_set_timeout {\n  my ($kernel, $request) = @_[KERNEL, ARG0];\n  $request->[RQ_TIMER_ID] = $kernel->delay_set(\n    ka_request_timeout => $request->[RQ_TIMEOUT], $request\n  );\n}\n\n# The request has timed out.  Mark it as defunct, and respond with an\n# ETIMEDOUT error.\n\nsub _ka_request_timeo", 8192) = 8192
09:01:57.418141 read(8, "ut {\n  my ($self, $kernel, $request) = @_[OBJECT, KERNEL, ARG0];\n\n  DEBUG and warn(\n    \"CON: request from session \", $request->[RQ_SESSION]->ID,\n    \" for address \", $request->[RQ_ADDRESS], \" timed out\"\n  );\n  $! = ETIMEDOUT;\n\n  # The easiest way to do this?  Simulate an error from the wheel\n  # itself.\n\n  if (defined $request->[RQ_WHEEL_ID]) {\n    @_[ARG0..ARG3] = (\"connect\", $!+0, \"$!\", $request->[RQ_WHEEL_ID]);\n    goto &_ka_conn_failure;\n  }\n\n  my ($errnum, $errstr) = ($!+0, \"$!\");\n\n  # No wheel yet.  It must have timed out in connect.\n  if ($request->[RQ_RESOLVER_ID]) {\n    $self->[SF_RESOLVER]->cancel( $request->[RQ_RESOLVER_ID] );\n    $request->[RQ_RESOLVER_ID] = undef;\n  }\n\n  # But what if there is no wheel?\n  _respond_with_error($request, \"connect\", $errnum, $errstr),\n}\n\n# Connection failed.  Remove the SF_WHEELS record corresponding to the\n# request.  Remove the SF_USED placeholder record so it won't count\n# anymore.  Send a failure notice to the requester.\n\nsub _ka_conn_failure {\n  my ($self, $func, $errnum, $errstr, $wheel_id) = @_[OBJECT, ARG0..ARG3];\n\n  DEBUG and warn \"CON: sending $errstr for function $func\";\n  # Remove the SF_WHEELS record.\n  my $wheel_rec = delete $self->[SF_WHEELS]{$wheel_id};\n  my $request   = $wheel_rec->[WHEEL_REQUEST];\n\n  # Remove the SF_USED placeholder.\n  delete $self->[SF_USED]{$wheel_id};\n\n  # remove the wheel-to-request index\n  delete $self->[SF_REQ_INDEX]{$request->[RQ_ID]};\n  _free_req_id($request->[RQ_ID]);\n\n  # Discount the use by request key, removing the SF_USED record\n  # entirely if it's now moot.\n  my $request_key = $request->[RQ_CONN_KEY];\n  $self->_decrement_used_each($request_key);\n\n  # Tell the requester about the failure.\n  _respond_with_error($request, $func, $errnum, $errstr),\n\n  $self->_ka_wake_up($_[KERNEL]);\n}\n\n# Connection succeeded.  Remove the SF_WHEELS record corresponding to\n# the request.  Flesh out the placeholder SF_USED record so it counts.\n\nsub _ka_conn_success {\n  my ($self, $socket, $wheel_id) = @_[OBJECT, ARG0, ARG3];\n\n  # Remove the SF_WHEELS record.\n  my $wheel_rec = delete $self->[SF_WHEELS]{$wheel_id};\n  my $request   = $wheel_rec->[WHEEL_REQUEST];\n\n  # remove the wheel-to-request index\n  delete $self->[SF_REQ_INDEX]{$request->[RQ_ID]};\n  _free_req_id($request->[RQ_ID]);\n\n  # Remove the SF_USED placeholder, add in the socket, and store it\n  # properly.\n  my $used = delete $self->[SF_USED]{$wheel_id};\n\n  unless ($request->[RQ_SCHEME] eq 'https') {\n    $self->_store_socket($used, $socket);\n    $self->_send_back_socket($request, $socket);\n    return;\n  }\n\n  # HTTPS here.\n  # Really applies to all SSL schemes.\n\n  unless ($ssl_available) {\n    die \"There is no SSL support, please install POE::Component::SSLify\";\n  }\n\n  eval {\n    $socket = POE::Component::SSLify::Client_SSLify(\n      $socket,\n\n      # TODO - To make non-blocking sslify work, I need to somehow\n      # defer the response until the following callback says it's\n      # fine.  Or if the callback says there's an error, it needs to\n      # be propagated out.\n      #\n      # Problem is, just setting the callback doesn't seem to get the\n      # connection to complete (successfully or otherwise).  There\n      # needs to be something more going on... but what?\n\n#      sub {\n#        my ($socket, $status, $errval) = @_;\n#        $errval = 'undef' unless defined $errval;\n#\n#        warn \"socket($socket) status($status) errval($errval)\";\n#\n#        # Connected okay.\n#        if ($status == 1) {\n#          $self->_send_back_socket($request, $socket);\n#          $self = $request = undef;\n#          return;\n#        }\n#\n#        # Didn't connect okay, or hasn't so far.\n#        # Report the error.\n#        if ($errval == 1) {\n#\n#          # Get all known errors, but only retain the most recent one.\n#          # I'm not sure this is needed, but the API mentions an error\n#          # queue, which implies that it could contain stale errors.\n#\n#          my $errnum;\n#          while (my $new_errnum = Net::SSLeay::ERR_get_error()) {\n#            $errnum = $new_errnum;\n#          }\n#\n#          my $errstr = Net::SSLeay::ERR_error_string($errnum);\n#          warn \"   ssl_error($errnum) string($errstr)\";\n#          _respond_with_error($request, \"sslify\", undef, $errstr);\n#\n#          # TODO - May the circle be broken.\n#          $self = $request = undef;\n#          return;\n#        }\n#      }\n    );\n  };\n\n  if ($@) {\n    _respond_with_error($request, \"sslify\", undef, \"$@\");\n    return;\n  }\n\n  # TODO - I think for SSL we just need to _store_socket().  The call\n  # to _send_back_socket() should be inside the SSL callback.\n  #\n  # Also, I think the callback might leak.  $request and $self may\n  # need to be weakened.\n\n  $self->_store_socket($used, $socket);\n  $self->_send_back_socket($request, $socket);\n}\n\nsub _store_socket {\n  my ($self, $used, $socket) = @_;\n  $used->[USED_SOCKET]      = $socket;\n  $self->[SF_USED]{$socket} = $used;\n}\n\nsub _send_back_socket {\n  my ($self, $request, $socket) = @_;\n\n  DEBUG and warn(\n    \"CON: posting... to $request->[RQ_SESSION] . $request->[RQ_EVENT]\"\n  );\n\n  # Build a connection object around the socket.\n  my $connection = POE::Component::Connection::Keepalive->new(\n    socket  => $socket,\n    manager => $self,\n  );\n\n  # Give the socket to the requester.\n  _respond(\n    $request, {\n      connection => $connection,\n    }\n  );\n}\n\n# The user is done with a socket.  Make it available for reuse.\n\nsub free {\n  my ($self, $socket) = @_;\n\n  return if $self->[SF_SHUTDOWN];\n  DEBUG and warn \"FREE: freeing socket\";\n\n  # Remove the accompanying SF_USED record.\n  croak \"can't free() undefined socket\" unless defined $socket;\n  my $used = delete $self->[SF_USED]{$socket};\n  croak \"can't free() unallocated socket\" unless defined $used;\n\n  # Reclaim the socket.\n  $poe_kernel->call($self->[SF_ALIAS], \"ka_reclaim_socket\", $used);\n\n  # Avoid returning things by mistake.\n  return;\n}\n\n# A sink for deliberately unhandled events.\n\nsub _ka_ignore_this_event {\n  # Do nothing.\n}\n\n# An internal method to fetch a socket from the free pool, if one\n# exists.\n\nsub _check_free_pool {\n  my ($self, $conn_key) = @_;\n\n  return unless exists $self->[SF_POOL]{$conn_key};\n\n  my $free = $self->[SF_POOL]{$conn_key};\n\n  DEBUG and warn \"CHECK: reusing $conn_key\";\n\n  my $next_socket = (values %$free)[0];\n  delete $free->{$next_socket};\n  unless (keys %$free) {\n    delete $self->[SF_POOL]{$conn_key};\n  }\n\n  # _check_free_pool() may be operating in another session, so we call\n  # the correct one here.\n  $poe_kernel->call($self->[SF_ALIAS], \"ka_relinquish_socket\", $next_socket);\n\n  $self->[SF_USED]{$next_socket} = [\n    $next_socket,  # USED_SOCKET\n    time(),        # USED_TIME\n    $conn_key,     # USED_KEY\n  ];\n\n  delete $self->[SF_SOCKETS]{$next_socket};\n\n  $self->[SF_USED_EACH]{$conn_key}++;\n\n    # Build a connection object around the socket.\n    my $connection = POE::Component::Connection::Keepalive->new(\n      socket  => $next_socket,\n      manager => $self,\n    );\n\n  return $connection;\n}\n\nsub _decrement_used_each {\n  my ($self, $request_key) = @_;\n  unless (--$self->[SF_USED_EACH]{$request_key}) {\n    delete $self->[SF_USED_EACH]{$request_key};\n  }\n}\n\n# Reclaim a socket.  Put it in the free socket pool, and wrap it with\n# select_read() to discard any data and detect when it's closed.\n\nsub _ka_reclaim_socket {\n  my ($self, $kernel, $used) = @_[OBJECT, KERNEL, ARG0];\n\n  my $socket = $used->[USED_SOCKET];\n\n  # Decrement the usage counter for the given connection key.\n  my $request_key = $used->[USED_KEY];\n  $self->_decrement_used_each($request_key);\n\n  # Socket is closed.  We can't reuse it.\n  unless (defined fileno $socket) {\n    DEBUG and warn \"RECLAIM: freed socket has previously been closed\";\n    goto &_ka_wake_up;\n  }\n\n  # Socket is still open.  Check for lingering data.\n  DEBUG and warn \"RECLAIM: checking if socket still works\";\n\n  # Check for data on the socket, which implies that the server\n  # doesn't know we're done.  That leads to desynchroniziation on the\n  # protocol level, which strongly implies that we can't reuse the\n  # socket.  In this case, we'll make a quick attempt at fetching all\n  # the data, then close th", 8192) = 8192
09:01:57.418612 brk(0x1ce8000)          = 0x1ce8000
09:01:57.419234 read(8, "e socket.\n\n  my $rin = '';\n  vec($rin, fileno($socket), 1) = 1;\n  my ($rout, $eout);\n  my $socket_is_active = select ($rout=$rin, undef, $eout=$rin, 0);\n\n  if ($socket_is_active) {\n    DEBUG and warn \"RECLAIM: socket is still active; trying to drain\";\n    use bytes;\n\n    my $socket_had_data = sysread($socket, my $buf = \"\", 65536) || 0;\n    DEBUG and warn \"RECLAIM: socket had $socket_had_data bytes. 0 means EOF\";\n    DEBUG and warn \"RECLAIM: Giving up on socket.\";\n\n    # Avoid common FIN_WAIT_2 issues, but only for valid sockets.\n    #if ($socket_had_data and fileno($socket)) {\n    if ($socket_had_data) {\n      my $opt_result = setsockopt(\n        $socket, SOL_SOCKET, SO_LINGER, pack(\"sll\",1,0,0)\n      );\n      die \"setsockopt: \" . ($!+0) . \" $!\" if (not $opt_result and $!  != EBADF);\n    }\n\n    goto &_ka_wake_up;\n  }\n\n  # Socket is alive and has no data, so it's in a quiet, theoretically\n  # reclaimable state.\n\n  DEBUG and warn \"RECLAIM: reclaiming socket\";\n\n  # Watch the socket, and set a keep-alive timeout.\n  $kernel->select_read($socket, \"ka_socket_activity\");\n  my $timer_id = $kernel->delay_set(\n    ka_keepalive_timeout => $self->[SF_KEEPALIVE], $socket\n  );\n\n  # Record the socket as free to be used.\n  $self->[SF_POOL]{$request_key}{$socket} = $socket;\n  $self->[SF_SOCKETS]{$socket} = [\n    $request_key,       # SK_KEY\n    $timer_id,          # SK_TIMER\n  ];\n\n  goto &_ka_wake_up;\n}\n\n# Socket timed out.  Discard it.\n\nsub _ka_keepalive_timeout {\n  my ($self, $socket) = @_[OBJECT, ARG0];\n  $self->_remove_socket_from_pool($socket);\n}\n\n# Relinquish a socket.  Stop selecting on it.\n\nsub _ka_relinquish_socket {\n  my ($kernel, $socket) = @_[KERNEL, ARG0];\n  $kernel->alarm_remove($_[OBJECT][SF_SOCKETS]{$socket}[SK_TIMER]);\n  $kernel->select_read($socket, undef);\n}\n\n# Shut down the component.  Release any sockets we're currently\n# holding onto.  Clean up any timers.  Remove the alias it's known by.\n\nsub shutdown {\n  my $self = shift;\n  return if $self->[SF_SHUTDOWN];\n  $poe_kernel->call($self->[SF_ALIAS], \"ka_shutdown\");\n}\n\nsub _ka_shutdown {\n  my ($self, $kernel, $heap) = @_[OBJECT, KERNEL, HEAP];\n\n  return if $self->[SF_SHUTDOWN];\n\n  $instances--;\n\n  # Clean out the request queue.\n  foreach my $request (@{$self->[SF_QUEUE]}) {\n    $self->_shutdown_request($kernel, $request);\n  }\n  $self->[SF_QUEUE] = [ ];\n\n  # Clean out the socket pool.\n  foreach my $sockets (values %{$self->[SF_POOL]}) {\n    foreach my $socket (values %$sockets) {\n      $kernel->alarm_remove($self->[SF_SOCKETS]{$socket}[SK_TIMER]);\n      $kernel->select_read($socket, undef);\n    }\n  }\n\n  # Stop any pending resolver requests.\n  foreach my $host (keys %{$heap->{dns_requests}}) {\n    DEBUG and warn \"SHT: Shutting down resolver requests for $host\";\n\n    foreach my $request (@{$heap->{dns_requests}{$host}}) {\n      $self->_shutdown_request($kernel, $request);\n    }\n\n    # Technically not needed since the resolver shutdown should do it.\n    # They all share the same host, so canceling the first should get\n    # them all.\n    $self->[SF_RESOLVER]->cancel(\n      $heap->{dns_requests}{$host}[0][RQ_RESOLVER_ID]\n    );\n  }\n\n  $heap->{dns_requests} = { };\n\n  # Shut down the resolver.\n  DEBUG and warn \"SHT: Shutting down resolver\";\n  if ( $self->[SF_RESOLVER] != $default_resolver ) {\n    $self->[SF_RESOLVER]->shutdown();\n  }\n  $self->[SF_RESOLVER] = undef;\n\n  if ( $default_resolver and !$instances ) {\n    $default_resolver->shutdown();\n    $default_resolver = undef;\n  }\n\n  # Finish keepalive's shutdown.\n  $kernel->alias_remove($self->[SF_ALIAS]);\n  $self->[SF_SHUTDOWN] = 1;\n\n  return;\n}\n\nsub _shutdown_request {\n  my ($self, $kernel, $request) = @_;\n\n  if (defined $request->[RQ_TIMER_ID]) {\n    DEBUG and warn \"SHT: Shutting down resolver timer $request->[RQ_TIMER_ID]\";\n    $kernel->alarm_remove($request->[RQ_TIMER_ID]);\n  }\n\n  if (defined $request->[RQ_WHEEL_ID]) {\n    DEBUG and warn \"SHT: Shutting down resolver wheel $request->[RQ_TIMER_ID]\";\n    delete $self->[SF_WHEELS]{$request->[RQ_WHEEL_ID]};\n\n    # remove the wheel-to-request index\n    delete $self->[SF_REQ_INDEX]{$request->[RQ_ID]};\n    _free_req_id($request->[RQ_ID]);\n  }\n\n  if (defined $request->[RQ_SESSION]) {\n    my $session_id = $request->[RQ_SESSION]->ID;\n    DEBUG and warn \"SHT: Releasing session $session_id\";\n    $kernel->refcount_decrement($session_id, \"poco-client-keepalive\");\n  }\n}\n\n# A socket in the free pool has activity.  Read from it and discard\n# the output.  Discard the socket on error or remote closure.\n\nsub _ka_socket_activity {\n  my ($self, $kernel, $socket) = @_[OBJECT, KERNEL, ARG0];\n\n  if (DEBUG) {\n    my $socket_rec = $self->[SF_SOCKETS]{$socket};\n    my $key = $socket_rec->[SK_KEY];\n    warn \"CON: Got activity on socket for $key\";\n  }\n\n  # Any socket activity on a kept-alive socket implies that the socket\n  # is no longer reusable.\n\n  use bytes;\n  my $socket_had_data = sysread($socket, my $buf = \"\", 65536) || 0;\n  DEBUG and warn \"CON: socket had $socket_had_data bytes. 0 means EOF\";\n  DEBUG and warn \"CON: Removing socket from the pool\";\n\n  $self->_remove_socket_from_pool($socket);\n}\n\nsub _ka_resolve_request {\n  my ($self, $kernel, $heap, $request) = @_[OBJECT, KERNEL, HEAP, ARG0];\n\n  my $host = $request->[RQ_ADDRESS];\n\n  # Skip DNS resolution if it's already a dotted quad.\n  # ip_is_ipv4() doesn't require quads, so we count the dots.\n  #\n  # TODO - Do the same for IPv6 addresses containing colons?\n  # TODO - Would require AF_INET6 support around the SocketFactory.\n  if ((($host =~ tr[.][.]) == 3) and ip_is_ipv4($host)) {\n    DEBUG_DNS and warn \"DNS: $host is a dotted quad; skipping lookup\";\n    $kernel->call($self->[SF_ALIAS], ka_add_to_queue => $request);\n    return;\n  }\n\n  # It's already pending DNS resolution.  Combine this with previous.\n  if (exists $heap->{dns_requests}{$host}) {\n    DEBUG_DNS and warn \"DNS: $host is piggybacking on a pending lookup.\\n\";\n\n    # All requests for the same host share the same resolver ID.\n    # TODO - Although it should probably be keyed on host:port.\n    $request->[RQ_RESOLVER_ID] = $heap->{dns_requests}{$host}[0][RQ_RESOLVER_ID];\n\n    push @{$heap->{dns_requests}{$host}}, $request;\n    return;\n  }\n\n  # New request.  Start lookup.\n  $heap->{dns_requests}{$host} = [ $request ];\n\n  $request->[RQ_RESOLVER_ID] = $self->[SF_RESOLVER]->resolve(\n    event   => 'ka_dns_response',\n    host    => $host,\n    service => $request->[RQ_PORT],\n    hints   => { protocol => TCP_PROTO },\n  );\n\n  DEBUG_DNS and warn \"DNS: looking up $host in the background.\\n\";\n}\n\nsub _ka_dns_response {\n  my ($self, $kernel, $heap, $response_error, $addresses, $request) = @_[\n    OBJECT, KERNEL, HEAP, ARG0..ARG2\n  ];\n\n  # We've shut down.  Nothing to do here.\n  return if $self->[SF_SHUTDOWN];\n\n  my $request_address = $request->{host};\n  my $requests = delete $heap->{dns_requests}{$request_address};\n\n  DEBUG_DNS and warn \"DNS: got response for request address $request_address\";\n\n  # Requests on record.\n  if (defined $requests) {\n    # We can receive responses for canceled requests.  Ignore them: we\n    # cannot cancel PoCo::Client::DNS requests, so this is how we reap\n    # them when they're canceled.\n    if ($requests eq 'cancelled') {\n      DEBUG_DNS and warn \"DNS: reaping cancelled request for $request_address\";\n      return;\n    }\n    unless (ref $requests eq 'ARRAY') {\n      die \"DNS: got an unknown requests for $request_address: $requests\";\n    }\n  }\n  else {\n    die \"DNS: Unexpectedly undefined requests for $request_address\";\n  }\n\n  # This is an error.  Cancel all requests for the address.\n  # Tell everybody that their requests failed.\n  if ($response_error) {\n    DEBUG_DNS and warn \"DNS: resolver error = $response_error\";\n    foreach my $request (@$requests) {\n      _respond_with_error($request, \"resolve\", undef, $response_error),\n    }\n    return;\n  }\n\n  DEBUG_DNS and warn \"DNS: got a response\";\n\n  # A response!\n  foreach my $address_rec (@$addresses) {\n    my $numeric = $self->[SF_RESOLVER]->unpack_addr($address_rec);\n\n    DEBUG_DNS and warn \"DNS: $request_address resolves to $numeric\";\n\n    foreach my $request (@$requests) {\n      # Don't bother continuing inactive requests.\n      next unless ", 8192) = 8192
09:01:57.420094 brk(0x1d09000)          = 0x1d09000
09:01:57.420578 read(8, "$request->[RQ_ACTIVE];\n      $request->[RQ_IP] = $numeric;\n      $request->[RQ_ADDR_FAM] = $address_rec->{family};\n      $kernel->yield(ka_add_to_queue => $request);\n    }\n\n    # Return after the first good answer.\n    return;\n  }\n\n  # Didn't return here.  No address record for the host?\n  foreach my $request (@$requests) {\n    DEBUG_DNS and warn \"DNS: $request_address does not resolve\";\n    _respond_with_error($request, \"resolve\", undef, \"Host has no address.\"),\n  }\n}\n\n\nsub _ka_add_to_queue {\n  my ($self, $kernel, $request) = @_[OBJECT, KERNEL, ARG0];\n\n  push @{ $self->[SF_QUEUE] }, $request;\n\n  # If the queue has more than one request in it, then it already has\n  # a wakeup event pending.  We don't need to send another one.\n\n  return if @{$self->[SF_QUEUE]} > 1;\n\n  # If the component's allocated socket count is maxed out, then it\n  # will check the queue when an existing socket is released.  We\n  # don't need to wake it up here.\n\n  return if keys(%{$self->[SF_USED]}) >= $self->[SF_MAX_OPEN];\n\n  # Likewise, we shouldn't awaken the session if there are no\n  # available slots for the given scheme/address/port triple.  \"|| 0\"\n  # to avoid an undef error.\n\n  my $conn_key = $request->[RQ_CONN_KEY];\n  return if (\n    ($self->[SF_USED_EACH]{$conn_key} || 0) >= $self->[SF_MAX_HOST]\n  );\n\n  # Wake the session up, and return nothing, signifying sound and fury\n  # yet to come.\n  DEBUG and warn \"posting wakeup for $conn_key\";\n  $poe_kernel->post($self->[SF_ALIAS], \"ka_wake_up\");\n  return;\n}\n\n# Remove a socket from the free pool, by the socket handle itself.\n\nsub _remove_socket_from_pool {\n  my ($self, $socket) = @_;\n\n  my $socket_rec = delete $self->[SF_SOCKETS]{$socket};\n  my $key = $socket_rec->[SK_KEY];\n\n  # Get the blessed version.\n  DEBUG and warn \"removing socket for $key\";\n  $socket = delete $self->[SF_POOL]{$key}{$socket};\n\n  unless (keys %{$self->[SF_POOL]{$key}}) {\n    delete $self->[SF_POOL]{$key};\n  }\n\n  $poe_kernel->alarm_remove($socket_rec->[SK_TIMER]);\n  $poe_kernel->select_read($socket, undef);\n\n  # Avoid common FIN_WAIT_2 issues.\n  # Commented out because fileno() will return true for closed\n  # sockets, which makes setsockopt() highly unhappy.  Also, SO_LINGER\n  # will cause te socket closure to block, which is less than ideal.\n  # We need to revisit this another way, or just let sockets enter\n  # FIN_WAIT_2.\n\n#  if (fileno $socket) {\n#    setsockopt($socket, SOL_SOCKET, SO_LINGER, pack(\"sll\",1,0,0)) or die(\n#      \"setsockopt: $!\"\n#    );\n#  }\n}\n\n# Internal function.  NOT AN EVENT HANDLER.\n\nsub _respond_with_error {\n  my ($request, $func, $num, $string) = @_;\n  _respond(\n    $request,\n    {\n      connection => undef,\n      function   => $func,\n      error_num  => $num,\n      error_str  => $string,\n    }\n  );\n}\n\nsub _respond {\n  my ($request, $fields) = @_;\n\n  # Bail out early if the request isn't active.\n  return unless $request->[RQ_ACTIVE] and $request->[RQ_SESSION];\n\n  $poe_kernel->post(\n    $request->[RQ_SESSION],\n    $request->[RQ_EVENT],\n    {\n      addr        => $request->[RQ_ADDRESS],\n      context     => $request->[RQ_CONTEXT],\n      port        => $request->[RQ_PORT],\n      scheme      => $request->[RQ_SCHEME],\n      for_addr    => $request->[RQ_FOR_ADDRESS],\n      for_scheme  => $request->[RQ_FOR_SCHEME],\n      for_port    => $request->[RQ_FOR_PORT],\n      %$fields,\n    }\n  );\n\n  # Drop the extra refcount.\n  $poe_kernel->refcount_decrement(\n    $request->[RQ_SESSION]->ID(),\n    \"poco-client-keepalive\"\n  );\n\n  # Remove associated timer.\n  if ($request->[RQ_TIMER_ID]) {\n    $poe_kernel->alarm_remove($request->[RQ_TIMER_ID]);\n    $request->[RQ_TIMER_ID] = undef;\n  }\n\n  # Deactivate the request.\n  $request->[RQ_ACTIVE] = undef;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Client::Keepalive - manage connections, with keep-alive\n\n=head1 VERSION\n\nversion 0.272\n\n=head1 SYNOPSIS\n\n  use warnings;\n  use strict;\n\n  use POE;\n  use POE::Component::Client::Keepalive;\n\n  POE::Session->create(\n    inline_states => {\n      _start    => \\&start,\n      got_conn  => \\&got_conn,\n      got_error => \\&handle_error,\n      got_input => \\&handle_input,\n    }\n  );\n\n  POE::Kernel->run();\n  exit;\n\n  sub start {\n    $_[HEAP]{ka} = POE::Component::Client::Keepalive->new();\n\n    $_[HEAP]{ka}->allocate(\n      scheme  => \"http\",\n      addr    => \"127.0.0.1\",\n      port    => 9999,\n      event   => \"got_conn\",\n      context => \"arbitrary data (even a reference) here\",\n      timeout => 60,\n    );\n\n    print \"Connection is in progress.\\n\";\n  }\n\n  sub got_conn {\n    my ($kernel, $heap, $response) = @_[KERNEL, HEAP, ARG0];\n\n    my $conn    = $response->{connection};\n    my $context = $response->{context};\n\n    if (defined $conn) {\n      if ($response->{from_cache}) {\n        print \"Connection was established immediately.\\n\";\n      }\n      else {\n        print \"Connection was established asynchronously.\\n\";\n      }\n\n      $conn->start(\n        InputEvent => \"got_input\",\n        ErrorEvent => \"got_error\",\n      );\n      return;\n    }\n\n    print(\n      \"Connection could not be established: \",\n      \"$response->{function} error $response->{error_num}: \",\n      \"$response->{error_str}\\n\"\n    );\n  }\n\n  sub handle_input {\n    my $input = $_[ARG0];\n    print \"$input\\n\";\n  }\n\n  sub handle_error {\n    my $heap = $_[HEAP];\n    delete $heap->{connection};\n    $heap->{ka}->shutdown();\n  }\n\n=head1 DESCRIPTION\n\nPOE::Component::Client::Keepalive creates and manages connections for\nother components.  It maintains a cache of kept-alive connections for\nquick reuse.  It is written specifically for clients that can benefit\nfrom kept-alive connections, such as HTTP clients.  Using it for\none-shot connections would probably be silly.\n\n=over 2\n\n=item new\n\nCreates a new keepalive connection manager.  A program may contain\nseveral connection managers.  Each will operate independently of the\nothers.  None will know about the limits set in the others, so it's\npossible to overrun your file descriptors for a process if you're not\ncareful.\n\nnew() takes up to five parameters.  All of them are optional.\n\nTo limit the number of simultaneous connections to a particular host\n(defined by a combination of scheme, address and port):\n\n  max_per_host => $max_simultaneous_host_connections, # defaults to 4\n\nTo limit the overall number of connections that may be open at once,\nuse\n\n  max_open     => $maximum_open_connections, # defaults to 128\n\nPrograms are required to give connections back to the manager when\nthey are done.  See the free() method for how that works.  The\nconnection manager will keep connections alive for a period of time\nbefore recycling them.  The maximum keep-alive time may be set with\n\n  keep_alive   => $seconds_to_keep_free_conns_alive, # defaults to 15\n\nPrograms may not want to wait a long time for a connection to be\nestablished.  They can set the request timeout to alter how long the\ncomponent holds a request before generating an error.\n\n  timeout      => $seconds_to_process_a_request, # defaults to 120\n\nSpecify a bind_address to bind all client sockets to a particular\nlocal address.  The value of bind_address will be passed directly to\nPOE::Wheel::SocketFactory.  See that module's documentation for\nimplementation details.\n\n=item allocate\n\nAllocate a new connection.  Allocate() will return a request ID\nimmediately.  The allocated connection, however, will be posted back\nto the requesting session.  This happens even if the connection was\nfound in the component's keep-alive cache.  It's a bit slower, but the\nuse cases are cleaner that way.\n\nAllocate() requires five parameters and has an optional sixth.\n\nSpecify the scheme that will be used to communicate on the connection\n(typically http or https).  The scheme is required, but you're free to\nmake something up here.  It's used internally to differentiate\ndifferent types of socket (e.g., ssl vs. cleartext) on the same\naddress and port.\n\n  scheme  => $connection_scheme,\n\nRequest a connection to a particular address and port.  The address\nand port must be numeric.  Both the address and port are required.\n\n  address => $remote_address,\n  port    => $remote_port,\n\nSpecify an name of the event to post when an asynchronous response is\nr", 8192) = 8192
09:01:57.421339 lseek(8, 36495, SEEK_SET) = 36495
09:01:57.421386 lseek(8, 0, SEEK_CUR)   = 36495
09:01:57.421431 close(8)                = 0
09:01:57.421977 brk(0x1d2a000)          = 0x1d2a000
09:01:57.422085 read(7, "e\n    #\n    # TODO CONNECT - We must ask PCC::Keepalive to establish an http\n    # socket, not https.  The initial proxy interactin is plaintext?\n\n    $request->[REQ_CONN_ID] = $heap->{cm}->allocate(\n      scheme  => $request->scheme,\n      addr    => $request->host,\n      port    => $request->port,\n      context => $request->ID,\n      event   => 'got_connect_done',\n      @timeout,\n    );\n  };\n  if ($@) {\n    delete $heap->{request}->{$request->ID};\n    delete $heap->{ext_request_to_int_id}->{$http_request};\n\n    # we can reach here for things like host being invalid.\n    $request->error(400, $@);\n  }\n}\n\n\nsub _poco_weeble_connect_done {\n  my ($heap, $response) = @_[HEAP, ARG0];\n\n  my $connection = $response->{'connection'};\n  my $request_id = $response->{'context'};\n\n  # Can't handle connections if we're shut down.\n  # TODO - How do we still get these?  Were they previously queued or\n  # something?\n  if ($heap->{is_shut_down}) {\n    _internal_cancel(\n      $heap, $request_id, 408, \"Request timed out (request canceled)\"\n    );\n    return;\n  }\n\n  if (defined $connection) {\n    DEBUG and warn \"CON: request $request_id connected ok...\";\n\n    my $request = $heap->{request}->{$request_id};\n    unless (defined $request) {\n      DEBUG and warn \"CON: ignoring connection for canceled request\";\n      return;\n    }\n\n    my $block_size = $heap->{factory}->block_size;\n\n    # get wheel from the connection\n    my $new_wheel = $connection->start(\n      Driver       => POE::Driver::SysRW->new(BlockSize => $block_size),\n      InputFilter  => POE::Filter::HTTPHead->new(),\n      OutputFilter => POE::Filter::Stream->new(),\n      InputEvent   => 'got_socket_input',\n      FlushedEvent => 'got_socket_flush',\n      ErrorEvent   => 'got_socket_error',\n    );\n\n    DEBUG and warn \"CON: request $request_id uses wheel \", $new_wheel->ID;\n\n    # Add the new wheel ID to the lookup table.\n    $heap->{wheel_to_request}->{ $new_wheel->ID() } = $request_id;\n\n    $request->[REQ_CONNECTION] = $connection;\n\n    # SSLify needs us to call it's function to get the \"real\" socket\n    my $peer_addr;\n    if ( $request->scheme eq 'http' ) {\n      $peer_addr = getpeername($new_wheel->get_input_handle());\n    } else {\n      my $socket = $new_wheel->get_input_handle();\n      $peer_addr = getpeername(POE::Component::SSLify::SSLify_GetSocket($socket));\n    }\n\n    if (defined $peer_addr) {\n      my ($error, $address, $port) = getnameinfo(\n        $peer_addr, NI_NUMERICHOST | NI_NUMERICSERV\n      );\n\n      if ($error) {\n        $request->[REQ_PEERNAME] = \"error: $error\";\n      }\n      else {\n        $request->[REQ_PEERNAME] = \"$address.$port\";\n      }\n    }\n    else {\n      $request->[REQ_PEERNAME] = \"error: $!\";\n    }\n\n    $request->create_timer($heap->{factory}->timeout);\n    $request->send_to_wheel;\n  }\n  else {\n    DEBUG and warn(\n      \"CON: Error connecting for request $request_id --- \", $_[SENDER]->ID\n    );\n\n    my ($operation, $errnum, $errstr) = (\n      $response->{function},\n      $response->{error_num} || '??',\n      $response->{error_str}\n    );\n\n    DEBUG and warn(\n      \"CON: request $request_id encountered $operation error \" .\n      \"$errnum: $errstr\"\n    );\n\n    DEBUG and warn \"I/O: removing request $request_id\";\n    my $request = delete $heap->{request}->{$request_id};\n    $request->remove_timeout();\n    delete $heap->{ext_request_to_int_id}->{$request->[REQ_HTTP_REQUEST]};\n\n    # Post an error response back to the requesting session.\n    $request->connect_error($operation, $errnum, $errstr);\n  }\n}\n\n\nsub _poco_weeble_timeout {\n  my ($kernel, $heap, $request_id) = @_[KERNEL, HEAP, ARG0];\n\n  DEBUG and warn \"T/O: request $request_id timed out\";\n\n  # Discard the request.  Keep a copy for a few bits of cleanup.\n  DEBUG and warn \"I/O: removing request $request_id\";\n  my $request = delete $heap->{request}->{$request_id};\n\n  unless (defined $request) {\n    die(\n      \"T/O: unexpectedly undefined request for id $request_id\\n\",\n      \"T/O: known request IDs: \", join(\", \", keys %{$heap->{request}}), \"\\n\",\n      \"...\",\n    );\n  }\n\n  DEBUG and warn \"T/O: request $request_id has timer \", $request->timer;\n  $request->remove_timeout();\n  delete $heap->{ext_request_to_int_id}->{$request->[REQ_HTTP_REQUEST]};\n\n  # There's a wheel attached to the request.  Shut it down.\n  if ($request->wheel) {\n    my $wheel_id = $request->wheel->ID();\n    DEBUG and warn \"T/O: request $request_id is wheel $wheel_id\";\n\n    # Shut down the connection so it's not reused.\n    $request->wheel->shutdown_input();\n    delete $heap->{wheel_to_request}->{$wheel_id};\n  }\n\n\n  DEBUG and do {\n    die( \"T/O: request $request_id is unexpectedly zero\" )\n      unless $request->[REQ_STATE];\n    warn \"T/O: request_state = \" . sprintf(\"%#04x\\n\", $request->[REQ_STATE]);\n  };\n\n  # Hey, we haven't sent back a response yet!\n  unless ($request->[REQ_STATE] & (RS_REDIRECTED | RS_POSTED)) {\n\n    # Well, we have a response.  Isn't that nice?  Let's send it.\n    if ($request->[REQ_STATE] & (RS_IN_CONTENT | RS_DONE)) {\n      _finish_request($heap, $request);\n      return;\n    }\n\n    # Post an error response back to the requesting session.\n    DEBUG and warn \"I/O: Disconnect, keepalive timeout or HTTP/1.0.\";\n    $request->error(408, \"Request timed out\") if $request->[REQ_STATE];\n    return;\n  }\n}\n\n\nsub _poco_weeble_io_flushed {\n  my ($heap, $wheel_id) = @_[HEAP, ARG0];\n\n  # We sent the request.  Now we're looking for a response.  It may be\n  # bad to assume we won't get a response until a request has flushed.\n  my $request_id = $heap->{wheel_to_request}->{$wheel_id};\n  if (not defined $request_id) {\n    DEBUG and warn \"!!!: unexpectedly undefined request ID\";\n    return;\n  }\n\n  DEBUG and warn(\n    \"I/O: wheel $wheel_id (request $request_id) flushed its request...\"\n  );\n\n  my $request = $heap->{request}->{$request_id};\n\n  # Read content to send from a callback\n  if ( ref $request->[REQ_HTTP_REQUEST]->content() eq 'CODE' ) {\n    my $callback = $request->[REQ_HTTP_REQUEST]->content();\n\n    my $buf = eval { $callback->() };\n\n    if ( $buf ) {\n      $request->wheel->put($buf);\n\n      # reset the timeout\n      # Have to also reset REQ_START_TIME or timer ends early\n      $request->remove_timeout;\n      $request->[REQ_START_TIME] = time();\n      $request->create_timer($heap->{factory}->timeout);\n\n      return;\n    }\n  }\n\n  $request->[REQ_STATE] ^= RS_SENDING;\n  $request->[REQ_STATE] = RS_IN_HEAD;\n\n  # XXX - Removed a second time.  The first time was in version 0.53,\n  # because the EOF generated by shutdown_output() causes some servers\n  # to disconnect rather than send their responses.\n  # $request->wheel->shutdown_output();\n}\n\n\nsub _poco_weeble_io_error {\n  my ($kernel, $heap, $operation, $errnum, $errstr, $wheel_id) =\n    @_[KERNEL, HEAP, ARG0..ARG3];\n\n  DEBUG and warn(\n    \"I/O: wheel $wheel_id encountered $operation error $errnum: $errstr\"\n  );\n\n  # Drop the wheel.\n  my $request_id = delete $heap->{wheel_to_request}->{$wheel_id};\n\n  # There was no corresponding request?  Nothing left to do here.\n  # We might have got here because the server sent EOF after we were done processing\n  # the request, and deleted it from our cache. ( notes for RT#50231 )\n  return unless $request_id;\n\n  DEBUG and warn \"I/O: removing request $request_id\";\n  my $request = delete $heap->{request}->{$request_id};\n  $request->remove_timeout;\n  delete $heap->{ext_request_to_int_id}{$request->[REQ_HTTP_REQUEST]};\n\n  # Otherwise the remote end simply closed.  If we've got a pending\n  # response, then post it back to the client.\n  DEBUG and warn \"STATE is \", $request->[REQ_STATE];\n\n  # Except when we're redirected.  In this case, the connection was but\n  # one step towards our destination.\n  return if ($request->[REQ_STATE] & RS_REDIRECTED);\n\n  # If there was a non-zero error, then something bad happened.  Post\n  # an error response back, if we haven't posted anything before.\n  if ($errnum) {\n    if ($operation eq \"connect\") {\n      $request->connect_error($operation, $errnum, $errstr);\n      return;\n    }\n\n    unless ($request->[REQ_STATE] & RS_POSTED) {\n      $request->error(400, \"$operation error $errnum: $errstr\");\n    }\n    return;\n  }\n\n  # We seem to have finished with", 8192) = 8192
09:01:57.423221 read(7, " the request.  Send back a response.\n  if (\n    $request->[REQ_STATE] & (RS_IN_CONTENT | RS_DONE) and\n    not $request->[REQ_STATE] & RS_POSTED\n  ) {\n    _finish_request($heap, $request);\n    return;\n  }\n\n  # We have already posted a response, so this is a remote keepalive\n  # timeout or other delayed socket shutdown.  Nothing left to do.\n  if ($request->[REQ_STATE] & RS_POSTED) {\n    DEBUG and warn \"I/O: Disconnect, remote keepalive timeout or HTTP/1.0.\";\n    return;\n  }\n\n  # We never received a response.\n  if (not defined $request->[REQ_RESPONSE]) {\n    # Check for pending data indicating a LF-free HTTP 0.9 response.\n    my $lines = $request->wheel->get_input_filter()->get_pending();\n    my $text = join '' => @$lines;\n    DEBUG and warn \"Got \", length($text), \" bytes of data without LF.\";\n\n    # If we have data, build and return a response from it.\n    if ($text =~ /\\S/) {\n      DEBUG and warn(\n        \"Generating HTTP response for HTTP/0.9 response without LF.\"\n      );\n      $request->[REQ_RESPONSE] = HTTP::Response->new(\n        200, 'OK', [\n          'Content-Type'  => 'text/html',\n          'X-PCCH-Peer'   => $request->[REQ_PEERNAME],\n        ], $text\n      );\n      $request->[REQ_RESPONSE]->protocol('HTTP/0.9');\n      $request->[REQ_RESPONSE]->request($request->[REQ_HTTP_REQUEST]);\n      $request->[REQ_STATE] = RS_DONE;\n      $request->return_response;\n      return;\n    }\n\n    # No data received.  This is an incomplete response.\n    $request->error(400, \"Incomplete response - $request_id\");\n    return;\n  }\n\n  # We haven't built a proper response, and nothing returned by the\n  # server can be turned into a proper response.  Send back an error.\n  # Changed to 406 after considering rt.cpan.org 20975.\n  #\n  # 10.4.7 406 Not Acceptable\n  #\n  # The resource identified by the request is only capable of\n  # generating response entities which have content characteristics\n  # not acceptable according to the accept headers sent in the\n  # request.\n\n  $request->error(406, \"Server response is Not Acceptable - $request_id\");\n}\n\n\n#------------------------------------------------------------------------------\n# Read a chunk of response.  This code is directly adapted from Artur\n# Bergman's nifty POE::Filter::HTTPD, which does pretty much the same\n# in the other direction.\n\nsub _poco_weeble_io_read {\n  my ($kernel, $heap, $input, $wheel_id) = @_[KERNEL, HEAP, ARG0, ARG1];\n  my $request_id = $heap->{wheel_to_request}->{$wheel_id};\n\n  DEBUG and warn \"I/O: wheel $wheel_id got input...\";\n  DEBUG_DATA and warn (ref($input) ? $input->as_string : _hexdump($input));\n\n  # There was no corresponding request?  Nothing left to do here.\n  #\n  # We might have got here because the server sent EOF after we were\n  # done processing the request, and deleted it from our cache. (\n  # notes for RT#50231 )\n  return unless defined $request_id;\n\n  my $request = $heap->{request}->{$request_id};\n  return unless defined $request;\n  DEBUG and warn(\n    \"REQUEST $request_id is $request <\",\n    $request->[REQ_HTTP_REQUEST]->uri(), \">\"\n  );\n\n  # Reset the timeout if we get data.\n  $kernel->delay_adjust($request->timer, $heap->{factory}->timeout);\n\n  if ($request->[REQ_STATE] & RS_REDIRECTED) {\n    DEBUG and warn \"input for request that was redirected\";\n    return;\n  }\n\n\n  # The very first line ought to be status.  If it's not, then it's\n  # part of the content.\n  if ($request->[REQ_STATE] & RS_IN_HEAD) {\n    if (defined $input) {\n      $input->request ($request->[REQ_HTTP_REQUEST]);\n      #warn(\n      #  \"INPUT for \", $request->[REQ_HTTP_REQUEST]->uri,\n      #  \" is \\n\",$input->as_string\n      #)\n    }\n    else {\n      #warn \"NO INPUT\";\n    }\n\n    # FIXME: LordVorp gets here without $input being a HTTP::Response.\n    # FIXME: This happens when the response is HTTP/0.9 and doesn't\n    # include a status line.  See t/53_response_parser.t.\n    $request->[REQ_RESPONSE] = $input;\n    $input->header(\"X-PCCH-Peer\", $request->[REQ_PEERNAME]);\n\n    # TODO CONNECT - If we've got the headers to a CONNECT request,\n    # then we can switch to the actual request.  This is like a faux\n    # redirect where the socket gets reused.\n    #\n    # 1. Switch the socket to SSL.\n    # 2. Switch the request from CONNECT mode to regular mode, using\n    #    the method proposed in PCCH::Request.\n    # 3. Send the original request via PCCH::Request->send_to_wheel().\n    #    This puts the client back into the RS_SENDING state.\n    # 4. Reset any data/state so it appears we never went through\n    #    CONNECT.\n    # 5. Make sure that PCC::Keepalive will discard the socket when\n    #    we're done with it.\n    # 6. Return.  The connection should proceed as normal.\n    #\n    # I think the normal handling for HTTP errors will cover the case\n    # of CONNECT failure.  If not, we can refine the implementation as\n    # needed.\n\n    # Some responses are without content by definition\n    # FIXME: #12363\n    # Make sure we finish even when it isn't one of these, but there\n    # is no content.\n    if (\n      $request->[REQ_HTTP_REQUEST]->method eq 'HEAD'\n      or $input->code =~ /^(?:1|[23]04)/\n      or (\n        defined($input->content_length())\n        and $input->content_length() == 0\n      )\n    ) {\n      if (_try_redirect($request_id, $input, $request)) {\n        my $old_request = delete $heap->{request}->{$request_id};\n        delete $heap->{wheel_to_request}->{$wheel_id};\n        if (defined $old_request) {\n          DEBUG and warn \"I/O: removed request $request_id\";\n          $old_request->remove_timeout();\n          delete $heap->{ext_request_to_int_id}{$old_request->[REQ_HTTP_REQUEST]};\n          $old_request->[REQ_CONNECTION] = undef;\n        }\n        return;\n      }\n      $request->[REQ_STATE] |= RS_DONE;\n      $request->remove_timeout();\n      _finish_request($heap, $request);\n      return;\n    }\n    else {\n      # If we have content length, and it's more than the maximum we\n      # requested, then fail without bothering with the content.\n      if (\n        defined($heap->{factory}->max_response_size())\n        and defined($input->content_length())\n        and $input->content_length() > $heap->{factory}->max_response_size()\n      ) {\n        _internal_cancel(\n          $heap, $request_id, 406,\n          \"Response content length \" . $input->content_length() .\n          \" is greater than specified MaxSize of \" .\n          $heap->{factory}->max_response_size() .\n          \".  Use range requests to retrieve specific amounts of content.\"\n        );\n        return;\n      }\n\n      $request->[REQ_STATE] |= RS_IN_CONTENT;\n      $request->[REQ_STATE] &= ~RS_IN_HEAD;\n      #FIXME: probably want to find out when the content from this\n      #       request is in, and only then do the new request, so we\n      #       can reuse the connection.\n      if (_try_redirect($request_id, $input, $request)) {\n        my $old_request = delete $heap->{request}->{$request_id};\n        delete $heap->{wheel_to_request}->{$wheel_id};\n        if (defined $old_request) {\n          DEBUG and warn \"I/O: removed request $request_id\";\n          delete $heap->{ext_request_to_int_id}{$old_request->[REQ_HTTP_REQUEST]};\n          $old_request->remove_timeout();\n          $old_request->close_connection();\n        }\n        return;\n      }\n\n      # RFC 2616 14.41:  If multiple encodings have been applied to an\n      # entity, the transfer-codings MUST be listed in the order in\n      # which they were applied.\n\n      my ($filter, @filters);\n\n      # Transfer encoding.\n\n      my $te = $input->header('Transfer-Encoding');\n      if (defined $te) {\n        my @te = split(/\\s*,\\s*/, lc($te));\n\n        while (@te and exists $te_filters{$te[-1]}) {\n          my $encoding = pop @te;\n          my $fclass = $te_filters{$encoding};\n          push @filters, $fclass->new();\n        }\n\n        if (@te) {\n          $input->header('Transfer-Encoding', join(', ', @te));\n        }\n        else {\n          $input->header('Transfer-Encoding', undef);\n        }\n      }\n\n      # Content encoding.\n\n      my $ce = $input->header('Content-Encoding');\n      if (defined $ce) {\n        my @ce = split(/\\s*,\\s*/, lc($ce));\n\n        while (@ce and exists $te_filters{$ce[-1]", 8192) = 8192
09:01:57.424019 brk(0x1d4b000)          = 0x1d4b000
09:01:57.424269 read(7, "}) {\n          my $encoding = pop @ce;\n          my $fclass = $te_filters{$encoding};\n          push @filters, $fclass->new();\n        }\n\n        if (@ce) {\n          $input->header('Content-Encoding', join(', ', @ce));\n        }\n        else {\n          $input->header('Content-Encoding', undef);\n        }\n      }\n\n      if (@filters > 1) {\n        $filter = POE::Filter::Stackable->new( Filters => \\@filters );\n      }\n      elsif (@filters) {\n        $filter = $filters[0];\n      }\n      else {\n        # Punt if we have no specified filters.\n        $filter = POE::Filter::Stream->new;\n      }\n\n      # do this last, because it triggers a read\n      $request->wheel->set_input_filter($filter);\n    }\n    return;\n  }\n\n  # We're in a content state.\n  if ($request->[REQ_STATE] & RS_IN_CONTENT) {\n    if (ref($input) and UNIVERSAL::isa($input, 'HTTP::Response')) {\n      # there was a problem in the input filter\n      # $request->close_connection;\n    }\n    else {\n      $request->add_content($input);\n    }\n  }\n\n  # POST response without disconnecting\n  if (\n    $request->[REQ_STATE] & RS_DONE and\n    not $request->[REQ_STATE] & RS_POSTED\n  ) {\n    $request->remove_timeout;\n    _finish_request($heap, $request);\n  }\n\n}\n\n\n#------------------------------------------------------------------------------\n# Generate a hex dump of some input. This is not a POE function.\n\nsub _hexdump {\n  my $data = shift;\n\n  my $dump;\n  my $offset = 0;\n  while (length $data) {\n    my $line = substr($data, 0, 16);\n    substr($data, 0, 16) = '';\n\n    my $hexdump  = unpack 'H*', $line;\n    $hexdump =~ s/(..)/$1 /g;\n\n    $line =~ tr[ -~][.]c;\n    $dump .= sprintf( \"%04x %-47.47s - %s\\n\", $offset, $hexdump, $line );\n    $offset += 16;\n  }\n\n  return $dump;\n}\n\n\n# Check for and handle redirect.  Returns true if redirect should\n# occur, or false if there's no redirect.\n\nsub _try_redirect {\n  my ($request_id, $input, $request) = @_;\n\n  if (my $newrequest = $request->check_redirect) {\n    DEBUG and warn(\n      \"Redirected $request_id \", $input->code, \" to <\",\n      $newrequest->uri, \">\"\n    );\n    my @proxy;\n    if ($request->[REQ_USING_PROXY]) {\n      push @proxy, (\n        'http://' .  $request->host .  ':' .  $request->port .  '/'\n      );\n    }\n\n    $poe_kernel->yield(\n      request =>\n      $request,\n      $newrequest,\n      \"_redir_\".$request->ID,\n      $request->[REQ_PROG_POSTBACK],\n      @proxy\n    );\n\n    return 1;\n  }\n\n  return;\n}\n\n\n# Complete a request. This was moved out of _poco_weeble_io_error(). This is\n# not a POE function.\n\nsub _finish_request {\n  my ($heap, $request) = @_;\n\n  my $request_id = $request->ID;\n  if (DEBUG) {\n    carp \"XXX: calling _finish_request(request id = $request_id)\";\n  }\n\n  # XXX What does this do?\n  $request->add_eof;\n\n  # KeepAlive: added the RS_POSTED flag\n  $request->[REQ_STATE] |= RS_POSTED;\n\n  my $wheel_id = defined $request->wheel ? $request->wheel->ID : \"(undef)\";\n  DEBUG and warn \"Wheel from request is \", $wheel_id;\n  # clean up the request\n  my $address = \"$request->[REQ_HOST]:$request->[REQ_PORT]\";\n\n  DEBUG and warn \"address is $address\";\n\n  return _clear_req_cache( $heap, $request_id );\n}\n\n\nsub _poco_weeble_remove_request {\n  my ($kernel, $heap, $request_id) = @_[KERNEL, HEAP, ARG0];\n\n  return _clear_req_cache( $heap, $request_id );\n}\n\n\n# helper subroutine to remove a request from our caches\n\nsub _clear_req_cache {\n  my ($heap, $request_id) = @_;\n\n  my $request = delete $heap->{request}->{$request_id};\n  return unless defined $request;\n\n  DEBUG and warn \"I/O: removed request $request_id\";\n\n  $request->remove_timeout();\n  delete $heap->{ext_request_to_int_id}{$request->[REQ_HTTP_REQUEST]};\n  if (my $wheel = $request->wheel) {\n    delete $heap->{wheel_to_request}->{$wheel->ID};\n  }\n\n  # If the response wants us to close the connection, regrettably do\n  # so.  Only matters if the request is defined.\n  if ($request->[REQ_CONNECTION]) {\n    if (defined(my $response = $request->[REQ_RESPONSE])) {\n      my $connection_header = $response->header('Connection');\n      if (defined $connection_header and $connection_header =~ /\\bclose\\b/) {\n        DEBUG and warn \"I/O: closing connection on server's request\";\n        $request->close_connection();\n      }\n    }\n  }\n\n  return;\n}\n\n\n# Cancel a single request by HTTP::Request object.\n\nsub _poco_weeble_cancel {\n  my ($kernel, $heap, $request) = @_[KERNEL, HEAP, ARG0];\n  my $request_id = $heap->{ext_request_to_int_id}{$request};\n  return unless defined $request_id;\n  _internal_cancel(\n    $heap, $request_id, 408, \"Request timed out (request canceled)\"\n  );\n}\n\n\nsub _internal_cancel {\n  my ($heap, $request_id, $code, $message) = @_;\n\n  my $request = delete $heap->{request}{$request_id};\n  return unless defined $request;\n\n  DEBUG and warn \"CXL: canceling request $request_id\";\n  $request->remove_timeout();\n  delete $heap->{ext_request_to_int_id}{$request->[REQ_HTTP_REQUEST]};\n\n  if ($request->wheel) {\n    my $wheel_id = $request->wheel->ID;\n    DEBUG and warn \"CXL: Request $request_id canceling wheel $wheel_id\";\n    delete $heap->{wheel_to_request}{$wheel_id};\n  }\n\n  if ($request->[REQ_CONNECTION]) {\n    DEBUG and warn \"I/O: Closing connection during internal cancel\";\n    $request->close_connection();\n  }\n  else {\n    # Didn't connect yet; inform connection manager to cancel\n    # connection request.\n\n    $heap->{cm}->deallocate($request->[REQ_CONN_ID]);\n  }\n\n  unless ($request->[REQ_STATE] & RS_POSTED) {\n    $request->error($code, $message);\n  }\n}\n\n\n# Shut down the entire component.\nsub _poco_weeble_shutdown {\n  my ($kernel, $heap) = @_[KERNEL, HEAP];\n\n  $heap->{is_shut_down} = 1;\n\n  my @request_ids = keys %{$heap->{request}};\n  foreach my $request_id (@request_ids) {\n    _internal_cancel(\n      $heap, $request_id, 408, \"Request timed out (component shut down)\"\n    );\n  }\n\n  # Shut down the connection manager subcomponent.\n  if (defined $heap->{cm}) {\n    DEBUG and warn \"CXL: Client::HTTP shutting down Client::Keepalive\";\n    $heap->{cm}->shutdown();\n    delete $heap->{cm};\n  }\n\n  # Final cleanup of this component.\n  $kernel->alias_remove($heap->{alias});\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nPOE::Component::Client::HTTP - a HTTP user-agent component\n\n=head1 VERSION\n\nversion 0.949\n\n=head1 SYNOPSIS\n\n  use POE qw(Component::Client::HTTP);\n\n  POE::Component::Client::HTTP->spawn(\n    Agent     => 'SpiffCrawler/0.90',   # defaults to something long\n    Alias     => 'ua',                  # defaults to 'weeble'\n    From      => 'spiffster@perl.org',  # defaults to undef (no header)\n    Protocol  => 'HTTP/0.9',            # defaults to 'HTTP/1.1'\n    Timeout   => 60,                    # defaults to 180 seconds\n    MaxSize   => 16384,                 # defaults to entire response\n    Streaming => 4096,                  # defaults to 0 (off)\n    FollowRedirects => 2,               # defaults to 0 (off)\n    Proxy     => \"http://localhost:80\", # defaults to HTTP_PROXY env. variable\n    NoProxy   => [ \"localhost\", \"127.0.0.1\" ], # defs to NO_PROXY env. variable\n    BindAddr  => \"12.34.56.78\",         # defaults to INADDR_ANY\n  );\n\n  $kernel->post(\n    'ua',        # posts to the 'ua' alias\n    'request',   # posts to ua's 'request' state\n    'response',  # which of our states will receive the response\n    $request,    # an HTTP::Request object\n  );\n\n  # This is the sub which is called when the session receives a\n  # 'response' event.\n  sub response_handler {\n    my ($request_packet, $response_packet) = @_[ARG0, ARG1];\n\n    # HTTP::Request\n    my $request_object  = $request_packet->[0];\n\n    # HTTP::Response\n    my $response_object = $response_packet->[0];\n\n    my $stream_chunk;\n    if (! defined($response_object->content)) {\n      $stream_chunk = $response_packet->[1];\n    }\n\n    print(\n      \"*\" x 78, \"\\n\",\n      \"*** my request:\\n\",\n      \"-\" x 78, \"\\n\",\n      $request_object->as_string(),\n      \"*\" x 78, \"\\n\",\n      \"*** their response:\\n\",\n      \"-\" x 78, \"\\n\",\n      $response_object->as_string(),\n    );\n\n    if (defined $stream_chunk) {\n      print \"-\" x 40, \"\\n\", $stream_chunk, \"\\n\";\n    }\n\n    print \"*\" x 78, \"\\n\";\n  }\n\n=head1 DESCRIPTION\n\nPOE::Component::Client::HTTP is an HTTP user-agent for POE.  It lets\nother sessi", 8192) = 8192
09:01:57.425334 lseek(7, 30692, SEEK_SET) = 30692
09:01:57.425382 lseek(7, 0, SEEK_CUR)   = 30692
09:01:57.425428 close(7)                = 0
09:01:57.425628 stat("modules/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.425685 stat("modules/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.425736 stat("modules/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.425784 stat("modules/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.425833 stat("/etc/perl/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.425883 stat("/etc/perl/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.425932 stat("/usr/local/lib/perl/5.14.2/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.425984 stat("/usr/local/lib/perl/5.14.2/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.426043 stat("/usr/local/share/perl/5.14.2/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.426101 stat("/usr/local/share/perl/5.14.2/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.426153 stat("/usr/lib/perl5/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.426204 stat("/usr/lib/perl5/HTML/TreeBuilder.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.426255 stat("/usr/share/perl5/HTML/TreeBuilder.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.426307 stat("/usr/share/perl5/HTML/TreeBuilder.pm", {st_mode=S_IFREG|0644, st_size=83655, ...}) = 0
09:01:57.426372 open("/usr/share/perl5/HTML/TreeBuilder.pm", O_RDONLY) = 7
09:01:57.426427 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.426473 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.426532 read(7, "package HTML::TreeBuilder;\n\n# ABSTRACT: Parser that builds a HTML syntax tree\n\nuse warnings;\nuse strict;\nuse integer;    # vroom vroom!\nuse Carp ();\n\nour $VERSION = '5.02'; # VERSION from OurPkgVersion\n\n#---------------------------------------------------------------------------\n# Make a 'DEBUG' constant...\n\nour $DEBUG; # Must be set BEFORE loading this file\nBEGIN {\n\n    # We used to have things like\n    #  print $indent, \"lalala\" if $Debug;\n    # But there were an awful lot of having to evaluate $Debug's value.\n    # If we make that depend on a constant, like so:\n    #   sub DEBUG () { 1 } # or whatever value.\n    #   ...\n    #   print $indent, \"lalala\" if DEBUG;\n    # Which at compile-time (thru the miracle of constant folding) turns into:\n    #   print $indent, \"lalala\";\n    # or, if DEBUG is a constant with a true value, then that print statement\n    # is simply optimized away, and doesn't appear in the target code at all.\n    # If you don't believe me, run:\n    #    perl -MO=Deparse,-uHTML::TreeBuilder -e 'BEGIN { \\\n    #      $HTML::TreeBuilder::DEBUG = 4}  use HTML::TreeBuilder'\n    # and see for yourself (substituting whatever value you want for $DEBUG\n    # there).\n## no critic\n    if ( defined &DEBUG ) {\n\n        # Already been defined!  Do nothing.\n    }\n    elsif ( $] < 5.00404 ) {\n\n        # Grudgingly accomodate ancient (pre-constant) versions.\n        eval 'sub DEBUG { $Debug } ';\n    }\n    elsif ( !$DEBUG ) {\n        eval 'sub DEBUG () {0}';    # Make it a constant.\n    }\n    elsif ( $DEBUG =~ m<^\\d+$>s ) {\n        eval 'sub DEBUG () { ' . $DEBUG . ' }';    # Make THAT a constant.\n    }\n    else {                                         # WTF?\n        warn \"Non-numeric value \\\"$DEBUG\\\" in \\$HTML::Element::DEBUG\";\n        eval 'sub DEBUG () { $DEBUG }';            # I guess.\n    }\n## use critic\n}\n\n#---------------------------------------------------------------------------\n\nuse HTML::Entities ();\nuse HTML::Tagset 3.02 ();\n\nuse HTML::Element ();\nuse HTML::Parser 3.46 ();\nour @ISA = qw(HTML::Element HTML::Parser);\n\n# This looks schizoid, I know.\n# It's not that we ARE an element AND a parser.\n# We ARE an element, but one that knows how to handle signals\n#  (method calls) from Parser in order to elaborate its subtree.\n\n# Legacy aliases:\n*HTML::TreeBuilder::isKnown             = \\%HTML::Tagset::isKnown;\n*HTML::TreeBuilder::canTighten          = \\%HTML::Tagset::canTighten;\n*HTML::TreeBuilder::isHeadElement       = \\%HTML::Tagset::isHeadElement;\n*HTML::TreeBuilder::isBodyElement       = \\%HTML::Tagset::isBodyElement;\n*HTML::TreeBuilder::isPhraseMarkup      = \\%HTML::Tagset::isPhraseMarkup;\n*HTML::TreeBuilder::isHeadOrBodyElement = \\%HTML::Tagset::isHeadOrBodyElement;\n*HTML::TreeBuilder::isList              = \\%HTML::Tagset::isList;\n*HTML::TreeBuilder::isTableElement      = \\%HTML::Tagset::isTableElement;\n*HTML::TreeBuilder::isFormElement       = \\%HTML::Tagset::isFormElement;\n*HTML::TreeBuilder::p_closure_barriers  = \\@HTML::Tagset::p_closure_barriers;\n\n#==========================================================================\n# Two little shortcut constructors:\n\nsub new_from_file {    # or from a FH\n    my $class = shift;\n    Carp::croak(\"new_from_file takes only one argument\")\n        unless @_ == 1;\n    Carp::croak(\"new_from_file is a class method only\")\n        if ref $class;\n    my $new = $class->new();\n    defined $new->parse_file( $_[0] )\n        or Carp::croak(\"unable to parse file: $!\");\n    return $new;\n}\n\nsub new_from_content {    # from any number of scalars\n    my $class = shift;\n    Carp::croak(\"new_from_content is a class method only\")\n        if ref $class;\n    my $new = $class->new();\n    foreach my $whunk (@_) {\n        if ( ref($whunk) eq 'SCALAR' ) {\n            $new->parse($$whunk);\n        }\n        else {\n            $new->parse($whunk);\n        }\n        last if $new->{'_stunted'};    # might as well check that.\n    }\n    $new->eof();\n    return $new;\n}\n\nsub new_from_url {                     # should accept anything that LWP does.\n    undef our $lwp_response;\n    my $class = shift;\n    Carp::croak(\"new_from_url takes only one argument\")\n        unless @_ == 1;\n    Carp::croak(\"new_from_url is a class method only\")\n        if ref $class;\n    my $url = shift;\n    my $new = $class->new();\n\n    require LWP::UserAgent;\n    # RECOMMEND PREREQ: LWP::UserAgent 5.815\n    LWP::UserAgent->VERSION( 5.815 ); # HTTP::Headers content_is_html method\n    $lwp_response = LWP::UserAgent->new->get( $url );\n\n    Carp::croak(\"GET failed on $url: \" . $lwp_response->status_line)\n          unless $lwp_response->is_success;\n    Carp::croak(\"$url returned \" . $lwp_response->content_type . \" not HTML\")\n          unless $lwp_response->content_is_html;\n\n    $new->parse( $lwp_response->decoded_content );\n    $new->eof;\n    undef $lwp_response;        # Processed successfully\n    return $new;\n}\n\n# TODO: document more fully?\nsub parse_content {    # from any number of scalars\n    my $tree = shift;\n    my $retval;\n    foreach my $whunk (@_) {\n        if ( ref($whunk) eq 'SCALAR' ) {\n            $retval = $tree->parse($$whunk);\n        }\n        else {\n            $retval = $tree->parse($whunk);\n        }\n        last if $tree->{'_stunted'};    # might as well check that.\n    }\n    $tree->eof();\n    return $retval;\n}\n\n#---------------------------------------------------------------------------\n\nsub new {                               # constructor!\n    my $class = shift;\n    $class = ref($class) || $class;\n\n    # Initialize HTML::Element part\n    my $self = $class->element_class->new('html');\n\n    {\n\n        # A hack for certain strange versions of Parser:\n        my $other_self = HTML::Parser->new();\n        %$self = ( %$self, %$other_self );    # copy fields\n           # Yes, multiple inheritance is messy.  Kids, don't try this at home.\n        bless $other_self, \"HTML::TreeBuilder::_hideyhole\";\n\n        # whack it out of the HTML::Parser class, to avoid the destructor\n    }\n\n    # The root of the tree is special, as it has these funny attributes,\n    # and gets reblessed into this class.\n\n    # Initialize parser settings\n    $self->{'_implicit_tags'}       = 1;\n    $self->{'_implicit_body_p_tag'} = 0;\n\n    # If true, trying to insert text, or any of %isPhraseMarkup right\n    #  under 'body' will implicate a 'p'.  If false, will just go there.\n\n    $self->{'_tighten'} = 1;\n\n    # whether ignorable WS in this tree should be deleted\n\n    $self->{'_implicit'} = 1; # to delete, once we find a real open-\"html\" tag\n\n    $self->{'_ignore_unknown'}      = 1;\n    $self->{'_ignore_text'}         = 0;\n    $self->{'_warn'}                = 0;\n    $self->{'_no_space_compacting'} = 0;\n    $self->{'_store_comments'}      = 0;\n    $self->{'_store_declarations'}  = 1;\n    $self->{'_store_pis'}           = 0;\n    $self->{'_p_strict'}            = 0;\n    $self->{'_no_expand_entities'}  = 0;\n\n    # Parse attributes passed in as arguments\n    if (@_) {\n        my %attr = @_;\n        for ( keys %attr ) {\n            $self->{\"_$_\"} = $attr{$_};\n        }\n    }\n\n    $HTML::Element::encoded_content = $self->{'_no_expand_entities'};\n\n    # rebless to our class\n    bless $self, $class;\n\n    $self->{'_element_count'} = 1;\n\n    # undocumented, informal, and maybe not exactly correct\n\n    $self->{'_head'} = $self->insert_element( 'head', 1 );\n    $self->{'_pos'}  = undef;                                # pull it back up\n    $self->{'_body'} = $self->insert_element( 'body', 1 );\n    $self->{'_pos'} = undef;    # pull it back up again\n\n    return $self;\n}\n\n#==========================================================================\n\nsub _elem                       # universal accessor...\n{\n    my ( $self, $elem, $val ) = @_;\n    my $old = $self->{$elem};\n    $self->{$elem} = $val if defined $val;\n    return $old;\n}\n\n# accessors....\nsub implicit_tags       { shift->_elem( '_implicit_tags',       @_ ); }\nsub implicit_body_p_tag { shift->_elem( '_implicit_body_p_tag', @_ ); }\nsub p_strict            { shift->_elem( '_p_strict',            @_ ); }\nsub no_space_compacting { shift->_elem( '_no_space_compacting', @_ ); }\nsub ignore_unknown      { shift->_elem( '_ignore_unkn", 8192) = 8192
09:01:57.426945 brk(0x1d6c000)          = 0x1d6c000
09:01:57.427157 stat("modules/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427209 stat("modules/HTML/Entities.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.427260 stat("modules/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427308 stat("modules/HTML/Entities.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.427357 stat("/etc/perl/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427408 stat("/etc/perl/HTML/Entities.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.427457 stat("/usr/local/lib/perl/5.14.2/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427508 stat("/usr/local/lib/perl/5.14.2/HTML/Entities.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.427558 stat("/usr/local/share/perl/5.14.2/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427608 stat("/usr/local/share/perl/5.14.2/HTML/Entities.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.427660 stat("/usr/lib/perl5/HTML/Entities.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.427712 stat("/usr/lib/perl5/HTML/Entities.pm", {st_mode=S_IFREG|0644, st_size=14995, ...}) = 0
09:01:57.427771 open("/usr/lib/perl5/HTML/Entities.pm", O_RDONLY) = 8
09:01:57.427824 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.427873 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.427935 read(8, "package HTML::Entities;\n\n=encoding utf8\n\n=head1 NAME\n\nHTML::Entities - Encode or decode strings with HTML entities\n\n=head1 SYNOPSIS\n\n use HTML::Entities;\n\n $a = \"V&aring;re norske tegn b&oslash;r &#230res\";\n decode_entities($a);\n encode_entities($a, \"\\200-\\377\");\n\nFor example, this:\n\n $input = \"vis-\303\240-vis Beyonc\303\251's na\303\257ve\\npapier-m\303\242ch\303\251 r\303\251sum\303\251\";\n print encode_entities($input), \"\\n\"\n\nPrints this out:\n\n vis-&agrave;-vis Beyonc&eacute;'s na&iuml;ve\n papier-m&acirc;ch&eacute; r&eacute;sum&eacute;\n\n=head1 DESCRIPTION\n\nThis module deals with encoding and decoding of strings with HTML\ncharacter entities.  The module provides the following functions:\n\n=over 4\n\n=item decode_entities( $string, ... )\n\nThis routine replaces HTML entities found in the $string with the\ncorresponding Unicode character.  Unrecognized entities are left alone.\n\nIf multiple strings are provided as argument they are each decoded\nseparately and the same number of strings are returned.\n\nIf called in void context the arguments are decoded in-place.\n\nThis routine is exported by default.\n\n=item _decode_entities( $string, \\%entity2char )\n\n=item _decode_entities( $string, \\%entity2char, $expand_prefix )\n\nThis will in-place replace HTML entities in $string.  The %entity2char\nhash must be provided.  Named entities not found in the %entity2char\nhash are left alone.  Numeric entities are expanded unless their value\noverflow.\n\nThe keys in %entity2char are the entity names to be expanded and their\nvalues are what they should expand into.  The values do not have to be\nsingle character strings.  If a key has \";\" as suffix,\nthen occurrences in $string are only expanded if properly terminated\nwith \";\".  Entities without \";\" will be expanded regardless of how\nthey are terminated for compatibility with how common browsers treat\nentities in the Latin-1 range.\n\nIf $expand_prefix is TRUE then entities without trailing \";\" in\n%entity2char will even be expanded as a prefix of a longer\nunrecognized name.  The longest matching name in %entity2char will be\nused. This is mainly present for compatibility with an MSIE\nmisfeature.\n\n   $string = \"foo&nbspbar\";\n   _decode_entities($string, { nb => \"@\", nbsp => \"\\xA0\" }, 1);\n   print $string;  # will print \"foo\302\240bar\"\n\nThis routine is exported by default.\n\n=item encode_entities( $string )\n\n=item encode_entities( $string, $unsafe_chars )\n\nThis routine replaces unsafe characters in $string with their entity\nrepresentation. A second argument can be given to specify which characters to\nconsider unsafe.  The unsafe characters is specified using the regular\nexpression character class syntax (what you find within brackets in regular\nexpressions).\n\nThe default set of characters to encode are control chars, high-bit chars, and\nthe C<< < >>, C<< & >>, C<< > >>, C<< ' >> and C<< \" >> characters.  But this,\nfor example, would encode I<just> the C<< < >>, C<< & >>, C<< > >>, and C<< \"\n>> characters:\n\n  $encoded = encode_entities($input, '<>&\"');\n\nand this would only encode non-plain ascii:\n\n  $encoded = encode_entities($input, '^\\n\\x20-\\x25\\x27-\\x7e');\n\nThis routine is exported by default.\n\n=item encode_entities_numeric( $string )\n\n=item encode_entities_numeric( $string, $unsafe_chars )\n\nThis routine works just like encode_entities, except that the replacement\nentities are always C<&#xI<hexnum>;> and never C<&I<entname>;>.  For\nexample, C<encode_entities(\"r\\xF4le\")> returns \"r&ocirc;le\", but\nC<encode_entities_numeric(\"r\\xF4le\")> returns \"r&#xF4;le\".\n\nThis routine is I<not> exported by default.  But you can always\nexport it with C<use HTML::Entities qw(encode_entities_numeric);>\nor even C<use HTML::Entities qw(:DEFAULT encode_entities_numeric);>\n\n=back\n\nAll these routines modify the string passed as the first argument, if\ncalled in a void context.  In scalar and array contexts, the encoded or\ndecoded string is returned (without changing the input string).\n\nIf you prefer not to import these routines into your namespace, you can\ncall them as:\n\n  use HTML::Entities ();\n  $decoded = HTML::Entities::decode($a);\n  $encoded = HTML::Entities::encode($a);\n  $encoded = HTML::Entities::encode_numeric($a);\n\nThe module can also export the %char2entity and the %entity2char\nhashes, which contain the mapping from all characters to the\ncorresponding entities (and vice versa, respectively).\n\n=head1 COPYRIGHT\n\nCopyright 1995-2006 Gisle Aas. All rights reserved.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n=cut\n\nuse strict;\nuse vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);\nuse vars qw(%entity2char %char2entity);\n\nrequire 5.004;\nrequire Exporter;\n@ISA = qw(Exporter);\n\n@EXPORT = qw(encode_entities decode_entities _decode_entities);\n@EXPORT_OK = qw(%entity2char %char2entity encode_entities_numeric);\n\n$VERSION = \"3.69\";\nsub Version { $VERSION; }\n\nrequire HTML::Parser;  # for fast XS implemented decode_entities\n\n\n%entity2char = (\n # Some normal chars that have special meaning in SGML context\n amp    => '&',  # ampersand \n'gt'    => '>',  # greater than\n'lt'    => '<',  # less than\n quot   => '\"',  # double quote\n apos   => \"'\",  # single quote\n\n # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML\n AElig\t=> chr(198),  # capital AE diphthong (ligature)\n Aacute\t=> chr(193),  # capital A, acute accent\n Acirc\t=> chr(194),  # capital A, circumflex accent\n Agrave\t=> chr(192),  # capital A, grave accent\n Aring\t=> chr(197),  # capital A, ring\n Atilde\t=> chr(195),  # capital A, tilde\n Auml\t=> chr(196),  # capital A, dieresis or umlaut mark\n Ccedil\t=> chr(199),  # capital C, cedilla\n ETH\t=> chr(208),  # capital Eth, Icelandic\n Eacute\t=> chr(201),  # capital E, acute accent\n Ecirc\t=> chr(202),  # capital E, circumflex accent\n Egrave\t=> chr(200),  # capital E, grave accent\n Euml\t=> chr(203),  # capital E, dieresis or umlaut mark\n Iacute\t=> chr(205),  # capital I, acute accent\n Icirc\t=> chr(206),  # capital I, circumflex accent\n Igrave\t=> chr(204),  # capital I, grave accent\n Iuml\t=> chr(207),  # capital I, dieresis or umlaut mark\n Ntilde\t=> chr(209),  # capital N, tilde\n Oacute\t=> chr(211),  # capital O, acute accent\n Ocirc\t=> chr(212),  # capital O, circumflex accent\n Ograve\t=> chr(210),  # capital O, grave accent\n Oslash\t=> chr(216),  # capital O, slash\n Otilde\t=> chr(213),  # capital O, tilde\n Ouml\t=> chr(214),  # capital O, dieresis or umlaut mark\n THORN\t=> chr(222),  # capital THORN, Icelandic\n Uacute\t=> chr(218),  # capital U, acute accent\n Ucirc\t=> chr(219),  # capital U, circumflex accent\n Ugrave\t=> chr(217),  # capital U, grave accent\n Uuml\t=> chr(220),  # capital U, dieresis or umlaut mark\n Yacute\t=> chr(221),  # capital Y, acute accent\n aacute\t=> chr(225),  # small a, acute accent\n acirc\t=> chr(226),  # small a, circumflex accent\n aelig\t=> chr(230),  # small ae diphthong (ligature)\n agrave\t=> chr(224),  # small a, grave accent\n aring\t=> chr(229),  # small a, ring\n atilde\t=> chr(227),  # small a, tilde\n auml\t=> chr(228),  # small a, dieresis or umlaut mark\n ccedil\t=> chr(231),  # small c, cedilla\n eacute\t=> chr(233),  # small e, acute accent\n ecirc\t=> chr(234),  # small e, circumflex accent\n egrave\t=> chr(232),  # small e, grave accent\n eth\t=> chr(240),  # small eth, Icelandic\n euml\t=> chr(235),  # small e, dieresis or umlaut mark\n iacute\t=> chr(237),  # small i, acute accent\n icirc\t=> chr(238),  # small i, circumflex accent\n igrave\t=> chr(236),  # small i, grave accent\n iuml\t=> chr(239),  # small i, dieresis or umlaut mark\n ntilde\t=> chr(241),  # small n, tilde\n oacute\t=> chr(243),  # small o, acute accent\n ocirc\t=> chr(244),  # small o, circumflex accent\n ograve\t=> chr(242),  # small o, grave accent\n oslash\t=> chr(248),  # small o, slash\n otilde\t=> chr(245),  # small o, tilde\n ouml\t=> chr(246),  # small o, dieresis or umlaut mark\n szlig\t=> chr(223),  # small sharp s, German (sz ligature)\n thorn\t=> chr(254),  # small thorn, Icelandic\n uacute\t=> chr(250),  # small u, acute accent\n ucirc\t=> chr(251),  # small u, circumflex accent\n ugrave\t=> chr(249),  # small u, grave accent\n uuml\t=> chr(252),  # small u, dieresis or umlaut mark\n yacute\t=> chr(253),  # small y, acute accent\n yuml\t=> chr(255),  # small y, dieresis or umlaut mark\n", 8192) = 8192
09:01:57.428575 read(8, "\n # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)\n copy   => chr(169),  # copyright sign\n reg    => chr(174),  # registered sign\n nbsp   => chr(160),  # non breaking space\n\n # Additional ISO-8859/1 entities listed in rfc1866 (section 14)\n iexcl  => chr(161),\n cent   => chr(162),\n pound  => chr(163),\n curren => chr(164),\n yen    => chr(165),\n brvbar => chr(166),\n sect   => chr(167),\n uml    => chr(168),\n ordf   => chr(170),\n laquo  => chr(171),\n'not'   => chr(172),    # not is a keyword in perl\n shy    => chr(173),\n macr   => chr(175),\n deg    => chr(176),\n plusmn => chr(177),\n sup1   => chr(185),\n sup2   => chr(178),\n sup3   => chr(179),\n acute  => chr(180),\n micro  => chr(181),\n para   => chr(182),\n middot => chr(183),\n cedil  => chr(184),\n ordm   => chr(186),\n raquo  => chr(187),\n frac14 => chr(188),\n frac12 => chr(189),\n frac34 => chr(190),\n iquest => chr(191),\n'times' => chr(215),    # times is a keyword in perl\n divide => chr(247),\n\n ( $] > 5.007 ? (\n  'OElig;'    => chr(338),\n  'oelig;'    => chr(339),\n  'Scaron;'   => chr(352),\n  'scaron;'   => chr(353),\n  'Yuml;'     => chr(376),\n  'fnof;'     => chr(402),\n  'circ;'     => chr(710),\n  'tilde;'    => chr(732),\n  'Alpha;'    => chr(913),\n  'Beta;'     => chr(914),\n  'Gamma;'    => chr(915),\n  'Delta;'    => chr(916),\n  'Epsilon;'  => chr(917),\n  'Zeta;'     => chr(918),\n  'Eta;'      => chr(919),\n  'Theta;'    => chr(920),\n  'Iota;'     => chr(921),\n  'Kappa;'    => chr(922),\n  'Lambda;'   => chr(923),\n  'Mu;'       => chr(924),\n  'Nu;'       => chr(925),\n  'Xi;'       => chr(926),\n  'Omicron;'  => chr(927),\n  'Pi;'       => chr(928),\n  'Rho;'      => chr(929),\n  'Sigma;'    => chr(931),\n  'Tau;'      => chr(932),\n  'Upsilon;'  => chr(933),\n  'Phi;'      => chr(934),\n  'Chi;'      => chr(935),\n  'Psi;'      => chr(936),\n  'Omega;'    => chr(937),\n  'alpha;'    => chr(945),\n  'beta;'     => chr(946),\n  'gamma;'    => chr(947),\n  'delta;'    => chr(948),\n  'epsilon;'  => chr(949),\n  'zeta;'     => chr(950),\n  'eta;'      => chr(951),\n  'theta;'    => chr(952),\n  'iota;'     => chr(953),\n  'kappa;'    => chr(954),\n  'lambda;'   => chr(955),\n  'mu;'       => chr(956),\n  'nu;'       => chr(957),\n  'xi;'       => chr(958),\n  'omicron;'  => chr(959),\n  'pi;'       => chr(960),\n  'rho;'      => chr(961),\n  'sigmaf;'   => chr(962),\n  'sigma;'    => chr(963),\n  'tau;'      => chr(964),\n  'upsilon;'  => chr(965),\n  'phi;'      => chr(966),\n  'chi;'      => chr(967),\n  'psi;'      => chr(968),\n  'omega;'    => chr(969),\n  'thetasym;' => chr(977),\n  'upsih;'    => chr(978),\n  'piv;'      => chr(982),\n  'ensp;'     => chr(8194),\n  'emsp;'     => chr(8195),\n  'thinsp;'   => chr(8201),\n  'zwnj;'     => chr(8204),\n  'zwj;'      => chr(8205),\n  'lrm;'      => chr(8206),\n  'rlm;'      => chr(8207),\n  'ndash;'    => chr(8211),\n  'mdash;'    => chr(8212),\n  'lsquo;'    => chr(8216),\n  'rsquo;'    => chr(8217),\n  'sbquo;'    => chr(8218),\n  'ldquo;'    => chr(8220),\n  'rdquo;'    => chr(8221),\n  'bdquo;'    => chr(8222),\n  'dagger;'   => chr(8224),\n  'Dagger;'   => chr(8225),\n  'bull;'     => chr(8226),\n  'hellip;'   => chr(8230),\n  'permil;'   => chr(8240),\n  'prime;'    => chr(8242),\n  'Prime;'    => chr(8243),\n  'lsaquo;'   => chr(8249),\n  'rsaquo;'   => chr(8250),\n  'oline;'    => chr(8254),\n  'frasl;'    => chr(8260),\n  'euro;'     => chr(8364),\n  'image;'    => chr(8465),\n  'weierp;'   => chr(8472),\n  'real;'     => chr(8476),\n  'trade;'    => chr(8482),\n  'alefsym;'  => chr(8501),\n  'larr;'     => chr(8592),\n  'uarr;'     => chr(8593),\n  'rarr;'     => chr(8594),\n  'darr;'     => chr(8595),\n  'harr;'     => chr(8596),\n  'crarr;'    => chr(8629),\n  'lArr;'     => chr(8656),\n  'uArr;'     => chr(8657),\n  'rArr;'     => chr(8658),\n  'dArr;'     => chr(8659),\n  'hArr;'     => chr(8660),\n  'forall;'   => chr(8704),\n  'part;'     => chr(8706),\n  'exist;'    => chr(8707),\n  'empty;'    => chr(8709),\n  'nabla;'    => chr(8711),\n  'isin;'     => chr(8712),\n  'notin;'    => chr(8713),\n  'ni;'       => chr(8715),\n  'prod;'     => chr(8719),\n  'sum;'      => chr(8721),\n  'minus;'    => chr(8722),\n  'lowast;'   => chr(8727),\n  'radic;'    => chr(8730),\n  'prop;'     => chr(8733),\n  'infin;'    => chr(8734),\n  'ang;'      => chr(8736),\n  'and;'      => chr(8743),\n  'or;'       => chr(8744),\n  'cap;'      => chr(8745),\n  'cup;'      => chr(8746),\n  'int;'      => chr(8747),\n  'there4;'   => chr(8756),\n  'sim;'      => chr(8764),\n  'cong;'     => chr(8773),\n  'asymp;'    => chr(8776),\n  'ne;'       => chr(8800),\n  'equiv;'    => chr(8801),\n  'le;'       => chr(8804),\n  'ge;'       => chr(8805),\n  'sub;'      => chr(8834),\n  'sup;'      => chr(8835),\n  'nsub;'     => chr(8836),\n  'sube;'     => chr(8838),\n  'supe;'     => chr(8839),\n  'oplus;'    => chr(8853),\n  'otimes;'   => chr(8855),\n  'perp;'     => chr(8869),\n  'sdot;'     => chr(8901),\n  'lceil;'    => chr(8968),\n  'rceil;'    => chr(8969),\n  'lfloor;'   => chr(8970),\n  'rfloor;'   => chr(8971),\n  'lang;'     => chr(9001),\n  'rang;'     => chr(9002),\n  'loz;'      => chr(9674),\n  'spades;'   => chr(9824),\n  'clubs;'    => chr(9827),\n  'hearts;'   => chr(9829),\n  'diams;'    => chr(9830),\n ) : ())\n);\n\n\n# Make the opposite mapping\nwhile (my($entity, $char) = each(%entity2char)) {\n    $entity =~ s/;\\z//;\n    $char2entity{$char} = \"&$entity;\";\n}\ndelete $char2entity{\"'\"};  # only one-way decoding\n\n# Fill in missing entities\nfor (0 .. 255) {\n    next if exists $char2entity{chr($_)};\n    $char2entity{chr($_)} = \"&#$_;\";\n}\n\nmy %subst;  # compiled encoding regexps\n\nsub encode_entities\n{\n    return undef unless defined $_[0];\n    my $ref;\n    if (defined wantarray) {\n\tmy $x = $_[0];\n\t$ref = \\$x;     # copy\n    } else {\n\t$ref = \\$_[0];  # modify in-place\n    }\n    if (defined $_[1] and length $_[1]) {\n\tunless (exists $subst{$_[1]}) {\n\t    # Because we can't compile regex we fake it with a cached sub\n\t    my $chars = $_[1];\n\t    $chars =~ s,(?<!\\\\)([]/]),\\\\$1,g;\n\t    $chars =~ s,(?<!\\\\)\\\\\\z,\\\\\\\\,;\n\t    my $code = \"sub {\\$_[0] =~ s/([$chars])/\\$char2entity{\\$1} || num_entity(\\$1)/ge; }\";\n\t    $subst{$_[1]} = eval $code;\n\t    die( $@ . \" while trying to turn range: \\\"$_[1]\\\"\\n \"\n\t      . \"into code: $code\\n \"\n\t    ) if $@;\n\t}\n\t&{$subst{$_[1]}}($$ref);\n    } else {\n\t# Encode control chars, high bit chars and '<', '&', '>', ''' and '\"'\n\t$$ref =~ s/([^\\n\\r\\t !\\#\\$%\\(-;=?-~])/$char2entity{$1} || num_entity($1)/ge;\n    }\n    $$ref;\n}\n\nsub encode_entities_numeric {\n    local %char2entity;\n    return &encode_entities;   # a goto &encode_entities wouldn't work\n}\n\n\nsub num_entity {\n    sprintf \"&#x%X;\", ord($_[0]);\n}\n\n# Set up aliases\n*encode = \\&encode_entities;\n*encode_numeric = \\&encode_entities_numeric;\n*encode_numerically = \\&encode_entities_numeric;\n*decode = \\&decode_entities;\n\n1;\n", 8192) = 6803
09:01:57.429431 brk(0x1d8d000)          = 0x1d8d000
09:01:57.429585 read(8, "", 8192)       = 0
09:01:57.429634 close(8)                = 0
09:01:57.429736 stat("modules/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.429788 stat("modules/HTML/Parser.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.429837 stat("modules/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.429885 stat("modules/HTML/Parser.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.429934 stat("/etc/perl/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.429982 stat("/etc/perl/HTML/Parser.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.430040 stat("/usr/local/lib/perl/5.14.2/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.430097 stat("/usr/local/lib/perl/5.14.2/HTML/Parser.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.430148 stat("/usr/local/share/perl/5.14.2/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.430199 stat("/usr/local/share/perl/5.14.2/HTML/Parser.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.430249 stat("/usr/lib/perl5/HTML/Parser.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.430299 stat("/usr/lib/perl5/HTML/Parser.pm", {st_mode=S_IFREG|0644, st_size=39796, ...}) = 0
09:01:57.430357 open("/usr/lib/perl5/HTML/Parser.pm", O_RDONLY) = 8
09:01:57.430410 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.430456 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.430516 read(8, "package HTML::Parser;\n\n# Copyright 1996-2009, Gisle Aas.\n# Copyright 1999-2000, Michael A. Chase.\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\nuse strict;\nuse vars qw($VERSION @ISA);\n\n$VERSION = \"3.69\";\n\nrequire HTML::Entities;\n\nrequire XSLoader;\nXSLoader::load('HTML::Parser', $VERSION);\n\nsub new\n{\n    my $class = shift;\n    my $self = bless {}, $class;\n    return $self->init(@_);\n}\n\n\nsub init\n{\n    my $self = shift;\n    $self->_alloc_pstate;\n\n    my %arg = @_;\n    my $api_version = delete $arg{api_version} || (@_ ? 3 : 2);\n    if ($api_version >= 4) {\n\trequire Carp;\n\tCarp::croak(\"API version $api_version not supported \" .\n\t\t    \"by HTML::Parser $VERSION\");\n    }\n\n    if ($api_version < 3) {\n\t# Set up method callbacks compatible with HTML-Parser-2.xx\n\t$self->handler(text    => \"text\",    \"self,text,is_cdata\");\n\t$self->handler(end     => \"end\",     \"self,tagname,text\");\n\t$self->handler(process => \"process\", \"self,token0,text\");\n\t$self->handler(start   => \"start\",\n\t\t                  \"self,tagname,attr,attrseq,text\");\n\n\t$self->handler(comment =>\n\t\t       sub {\n\t\t\t   my($self, $tokens) = @_;\n\t\t\t   for (@$tokens) {\n\t\t\t       $self->comment($_);\n\t\t\t   }\n\t\t       }, \"self,tokens\");\n\n\t$self->handler(declaration =>\n\t\t       sub {\n\t\t\t   my $self = shift;\n\t\t\t   $self->declaration(substr($_[0], 2, -1));\n\t\t       }, \"self,text\");\n    }\n\n    if (my $h = delete $arg{handlers}) {\n\t$h = {@$h} if ref($h) eq \"ARRAY\";\n\twhile (my($event, $cb) = each %$h) {\n\t    $self->handler($event => @$cb);\n\t}\n    }\n\n    # In the end we try to assume plain attribute or handler\n    while (my($option, $val) = each %arg) {\n\tif ($option =~ /^(\\w+)_h$/) {\n\t    $self->handler($1 => @$val);\n\t}\n        elsif ($option =~ /^(text|start|end|process|declaration|comment)$/) {\n\t    require Carp;\n\t    Carp::croak(\"Bad constructor option '$option'\");\n        }\n\telse {\n\t    $self->$option($val);\n\t}\n    }\n\n    return $self;\n}\n\n\nsub parse_file\n{\n    my($self, $file) = @_;\n    my $opened;\n    if (!ref($file) && ref(\\$file) ne \"GLOB\") {\n        # Assume $file is a filename\n        local(*F);\n        open(F, \"<\", $file) || return undef;\n\tbinmode(F);  # should we? good for byte counts\n        $opened++;\n        $file = *F;\n    }\n    my $chunk = '';\n    while (read($file, $chunk, 512)) {\n\t$self->parse($chunk) || last;\n    }\n    close($file) if $opened;\n    $self->eof;\n}\n\n\nsub netscape_buggy_comment  # legacy\n{\n    my $self = shift;\n    require Carp;\n    Carp::carp(\"netscape_buggy_comment() is deprecated.  \" .\n\t       \"Please use the strict_comment() method instead\");\n    my $old = !$self->strict_comment;\n    $self->strict_comment(!shift) if @_;\n    return $old;\n}\n\n# set up method stubs\nsub text { }\n*start       = \\&text;\n*end         = \\&text;\n*comment     = \\&text;\n*declaration = \\&text;\n*process     = \\&text;\n\n1;\n\n__END__\n\n\n=head1 NAME\n\nHTML::Parser - HTML parser class\n\n=head1 SYNOPSIS\n\n use HTML::Parser ();\n\n # Create parser object\n $p = HTML::Parser->new( api_version => 3,\n                         start_h => [\\&start, \"tagname, attr\"],\n                         end_h   => [\\&end,   \"tagname\"],\n                         marked_sections => 1,\n                       );\n\n # Parse document text chunk by chunk\n $p->parse($chunk1);\n $p->parse($chunk2);\n #...\n $p->eof;                 # signal end of document\n\n # Parse directly from file\n $p->parse_file(\"foo.html\");\n # or\n open(my $fh, \"<:utf8\", \"foo.html\") || die;\n $p->parse_file($fh);\n\n=head1 DESCRIPTION\n\nObjects of the C<HTML::Parser> class will recognize markup and\nseparate it from plain text (alias data content) in HTML\ndocuments.  As different kinds of markup and text are recognized, the\ncorresponding event handlers are invoked.\n\nC<HTML::Parser> is not a generic SGML parser.  We have tried to\nmake it able to deal with the HTML that is actually \"out there\", and\nit normally parses as closely as possible to the way the popular web\nbrowsers do it instead of strictly following one of the many HTML\nspecifications from W3C.  Where there is disagreement, there is often\nan option that you can enable to get the official behaviour.\n\nThe document to be parsed may be supplied in arbitrary chunks.  This\nmakes on-the-fly parsing as documents are received from the network\npossible.\n\nIf event driven parsing does not feel right for your application, you\nmight want to use C<HTML::PullParser>.  This is an C<HTML::Parser>\nsubclass that allows a more conventional program structure.\n\n\n=head1 METHODS\n\nThe following method is used to construct a new C<HTML::Parser> object:\n\n=over\n\n=item $p = HTML::Parser->new( %options_and_handlers )\n\nThis class method creates a new C<HTML::Parser> object and\nreturns it.  Key/value argument pairs may be provided to assign event\nhandlers or initialize parser options.  The handlers and parser\noptions can also be set or modified later by the method calls described below.\n\nIf a top level key is in the form \"<event>_h\" (e.g., \"text_h\") then it\nassigns a handler to that event, otherwise it initializes a parser\noption. The event handler specification value must be an array\nreference.  Multiple handlers may also be assigned with the 'handlers\n=> [%handlers]' option.  See examples below.\n\nIf new() is called without any arguments, it will create a parser that\nuses callback methods compatible with version 2 of C<HTML::Parser>.\nSee the section on \"version 2 compatibility\" below for details.\n\nThe special constructor option 'api_version => 2' can be used to\ninitialize version 2 callbacks while still setting other options and\nhandlers.  The 'api_version => 3' option can be used if you don't want\nto set any options and don't want to fall back to v2 compatible\nmode.\n\nExamples:\n\n $p = HTML::Parser->new(api_version => 3,\n                        text_h => [ sub {...}, \"dtext\" ]);\n\nThis creates a new parser object with a text event handler subroutine\nthat receives the original text with general entities decoded.\n\n $p = HTML::Parser->new(api_version => 3,\n\t\t\tstart_h => [ 'my_start', \"self,tokens\" ]);\n\nThis creates a new parser object with a start event handler method\nthat receives the $p and the tokens array.\n\n $p = HTML::Parser->new(api_version => 3,\n\t\t        handlers => { text => [\\@array, \"event,text\"],\n                                      comment => [\\@array, \"event,text\"],\n                                    });\n\nThis creates a new parser object that stores the event type and the\noriginal text in @array for text and comment events.\n\n=back\n\nThe following methods feed the HTML document\nto the C<HTML::Parser> object:\n\n=over\n\n=item $p->parse( $string )\n\nParse $string as the next chunk of the HTML document.  Handlers invoked should\nnot attempt to modify the $string in-place until $p->parse returns.\n\nIf an invoked event handler aborts parsing by calling $p->eof, then $p->parse()\nwill return a FALSE value.  Otherwise the return value is a reference to the\nparser object ($p).\n\n=item $p->parse( $code_ref )\n\nIf a code reference is passed as the argument to be parsed, then the\nchunks to be parsed are obtained by invoking this function repeatedly.\nParsing continues until the function returns an empty (or undefined)\nresult.  When this happens $p->eof is automatically signaled.\n\nParsing will also abort if one of the event handlers calls $p->eof.\n\nThe effect of this is the same as:\n\n while (1) {\n    my $chunk = &$code_ref();\n    if (!defined($chunk) || !length($chunk)) {\n        $p->eof;\n        return $p;\n    }\n    $p->parse($chunk) || return undef;\n }\n\nBut it is more efficient as this loop runs internally in XS code.\n\n=item $p->parse_file( $file )\n\nParse text directly from a file.  The $file argument can be a\nfilename, an open file handle, or a reference to an open file\nhandle.\n\nIf $file contains a filename and the file can't be opened, then the\nmethod returns an undefined value and $! tells why it failed.\nOtherwise the return value is a reference to the parser object.\n\nIf a file handle is passed as the $file argument, then the file will\nnormally be read until EOF, but not closed.\n\nIf an invoked event handler aborts parsing by calling $p->eof,\nthen $p->parse_file() may not have read the entire", 8192) = 8192
09:01:57.431317 lseek(8, 2888, SEEK_SET) = 2888
09:01:57.431365 lseek(8, 0, SEEK_CUR)   = 2888
09:01:57.431410 close(8)                = 0
09:01:57.431495 stat("/usr/lib/perl5/auto/HTML/Parser/Parser.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.431557 stat("/usr/lib/perl5/auto/HTML/Parser/Parser.so", {st_mode=S_IFREG|0644, st_size=47904, ...}) = 0
09:01:57.431621 stat("/usr/lib/perl5/auto/HTML/Parser/Parser.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.431694 open("/usr/lib/perl5/auto/HTML/Parser/Parser.so", O_RDONLY) = 8
09:01:57.431748 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220)\0\0\0\0\0\0@\0\0\0\0\0\0\0`\264\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\364\250\0\0\0\0\0\0\364\250\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0H\254\0\0\0\0\0\0H\254 \0\0\0\0\0H\254 \0\0\0\0\0008\7\0\0\0\0\0\0H\7\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\240\255\0\0\0\0\0\0\240\255 \0\0\0\0\0\240\255 \0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0000\242\0\0\0\0\0\0000\242\0\0\0\0\0\0000\242\0\0\0\0\0\0\344\0\0\0\0\0\0\0\344\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0H\254\0\0\0\0\0\0H\254 \0\0\0\0\0H\254 \0\0\0\0\0\270\3\0\0\0\0\0\0\270\3\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\264\313\322\340\241\337ok\230\220\246\2757\35\322\24\373\267\241&\0\0\0\0a\0\0\0i\0\0\0\0\0\0\0\0\0\0\0\26\0\0\0\10\0\0\0M\0\0\0\0\0\0\0009\0\0\0E\0\0\0\0\0\0\0\23\0\0\0\33\0\0\0d\0\0\0\0\0\0\0Y\0\0\0\0\0\0\0[\0\0\0&\0\0\0003\0\0\0\0\0\0\0\17\0\0\0>\0\0\0X\0\0\0\6\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0\35\0\0\0I\0\0\0b\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$\0\0\0\0\0\0\0e\0\0\0Q\0\0\0(\0\0\0P\0\0\0;\0\0\0.\0\0\0-\0\0\0B\0\0\0\0\0\0\0W\0\0\0K\0\0\0]\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0@\0\0\0002\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0J\0\0\0\16\0\0\0\7\0\0\0)\0\0\0\0\0\0\0A\0\0\0R\0\0\0!\0\0\0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0008\0\0\0", 832) = 832
09:01:57.431884 fstat(8, {st_mode=S_IFREG|0644, st_size=47904, ...}) = 0
09:01:57.431941 mmap(NULL, 2143120, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f74317fd000
09:01:57.431990 mprotect(0x7f7431808000, 2093056, PROT_NONE) = 0
09:01:57.432038 mmap(0x7f7431a07000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0xa000) = 0x7f7431a07000
09:01:57.432096 close(8)                = 0
09:01:57.432159 mprotect(0x7f7431a07000, 4096, PROT_READ) = 0
09:01:57.432511 brk(0x1dae000)          = 0x1dae000
09:01:57.432827 stat("modules/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.432879 stat("modules/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.432928 stat("modules/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.432977 stat("modules/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.433026 stat("/etc/perl/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.433075 stat("/etc/perl/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.433124 stat("/usr/local/lib/perl/5.14.2/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.433175 stat("/usr/local/lib/perl/5.14.2/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.433225 stat("/usr/local/share/perl/5.14.2/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.433275 stat("/usr/local/share/perl/5.14.2/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.433325 stat("/usr/lib/perl5/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.433374 stat("/usr/lib/perl5/HTML/Tagset.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.433424 stat("/usr/share/perl5/HTML/Tagset.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.433474 stat("/usr/share/perl5/HTML/Tagset.pm", {st_mode=S_IFREG|0644, st_size=12948, ...}) = 0
09:01:57.433539 open("/usr/share/perl5/HTML/Tagset.pm", O_RDONLY) = 8
09:01:57.433598 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.433645 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.433723 read(8, "package HTML::Tagset;\n\nuse strict;\n\n=head1 NAME\n\nHTML::Tagset - data tables useful in parsing HTML\n\n=head1 VERSION\n\nVersion 3.20\n\n=cut\n\nuse vars qw( $VERSION );\n\n$VERSION = '3.20';\n\n=head1 SYNOPSIS\n\n  use HTML::Tagset;\n  # Then use any of the items in the HTML::Tagset package\n  #  as need arises\n\n=head1 DESCRIPTION\n\nThis module contains several data tables useful in various kinds of\nHTML parsing operations.\n\nNote that all tag names used are lowercase.\n\nIn the following documentation, a \"hashset\" is a hash being used as a\nset -- the hash conveys that its keys are there, and the actual values\nassociated with the keys are not significant.  (But what values are\nthere, are always true.)\n\n=cut\n\nuse vars qw(\n    $VERSION\n    %emptyElement %optionalEndTag %linkElements %boolean_attr\n    %isHeadElement %isBodyElement %isPhraseMarkup\n    %is_Possible_Strict_P_Content\n    %isHeadOrBodyElement\n    %isList %isTableElement %isFormElement\n    %isKnown %canTighten\n    @p_closure_barriers\n    %isCDATA_Parent\n);\n\n=head1 VARIABLES\n\nNote that none of these variables are exported.\n\n=head2 hashset %HTML::Tagset::emptyElement\n\nThis hashset has as values the tag-names (GIs) of elements that cannot\nhave content.  (For example, \"base\", \"br\", \"hr\".)  So\nC<$HTML::Tagset::emptyElement{'hr'}> exists and is true.\nC<$HTML::Tagset::emptyElement{'dl'}> does not exist, and so is not true.\n\n=cut\n\n%emptyElement   = map {; $_ => 1 } qw(base link meta isindex\n                                     img br hr wbr\n                                     input area param\n                                     embed bgsound spacer\n                                     basefont col frame\n                                     ~comment ~literal\n                                     ~declaration ~pi\n                                    );\n# The \"~\"-initial names are for pseudo-elements used by HTML::Entities\n#  and TreeBuilder\n\n=head2 hashset %HTML::Tagset::optionalEndTag\n\nThis hashset lists tag-names for elements that can have content, but whose\nend-tags are generally, \"safely\", omissible.  Example:\nC<$HTML::Tagset::emptyElement{'li'}> exists and is true.\n\n=cut\n\n%optionalEndTag = map {; $_ => 1 } qw(p li dt dd); # option th tr td);\n\n=head2 hash %HTML::Tagset::linkElements\n\nValues in this hash are tagnames for elements that might contain\nlinks, and the value for each is a reference to an array of the names\nof attributes whose values can be links.\n\n=cut\n\n%linkElements =\n(\n 'a'       => ['href'],\n 'applet'  => ['archive', 'codebase', 'code'],\n 'area'    => ['href'],\n 'base'    => ['href'],\n 'bgsound' => ['src'],\n 'blockquote' => ['cite'],\n 'body'    => ['background'],\n 'del'     => ['cite'],\n 'embed'   => ['pluginspage', 'src'],\n 'form'    => ['action'],\n 'frame'   => ['src', 'longdesc'],\n 'iframe'  => ['src', 'longdesc'],\n 'ilayer'  => ['background'],\n 'img'     => ['src', 'lowsrc', 'longdesc', 'usemap'],\n 'input'   => ['src', 'usemap'],\n 'ins'     => ['cite'],\n 'isindex' => ['action'],\n 'head'    => ['profile'],\n 'layer'   => ['background', 'src'],\n 'link'    => ['href'],\n 'object'  => ['classid', 'codebase', 'data', 'archive', 'usemap'],\n 'q'       => ['cite'],\n 'script'  => ['src', 'for'],\n 'table'   => ['background'],\n 'td'      => ['background'],\n 'th'      => ['background'],\n 'tr'      => ['background'],\n 'xmp'     => ['href'],\n);\n\n=head2 hash %HTML::Tagset::boolean_attr\n\nThis hash (not hashset) lists what attributes of what elements can be\nprinted without showing the value (for example, the \"noshade\" attribute\nof \"hr\" elements).  For elements with only one such attribute, its value\nis simply that attribute name.  For elements with many such attributes,\nthe value is a reference to a hashset containing all such attributes.\n\n=cut\n\n%boolean_attr = (\n# TODO: make these all hashes\n  'area'   => 'nohref',\n  'dir'    => 'compact',\n  'dl'     => 'compact',\n  'hr'     => 'noshade',\n  'img'    => 'ismap',\n  'input'  => { 'checked' => 1, 'readonly' => 1, 'disabled' => 1 },\n  'menu'   => 'compact',\n  'ol'     => 'compact',\n  'option' => 'selected',\n  'select' => 'multiple',\n  'td'     => 'nowrap',\n  'th'     => 'nowrap',\n  'ul'     => 'compact',\n);\n\n#==========================================================================\n# List of all elements from Extensible HTML version 1.0 Transitional DTD:\n#\n#   a abbr acronym address applet area b base basefont bdo big\n#   blockquote body br button caption center cite code col colgroup\n#   dd del dfn dir div dl dt em fieldset font form h1 h2 h3 h4 h5 h6\n#   head hr html i iframe img input ins isindex kbd label legend li\n#   link map menu meta noframes noscript object ol optgroup option p\n#   param pre q s samp script select small span strike strong style\n#   sub sup table tbody td textarea tfoot th thead title tr tt u ul\n#   var\n#\n# Varia from Mozilla source internal table of tags:\n#   Implemented:\n#     xmp listing wbr nobr frame frameset noframes ilayer\n#     layer nolayer spacer embed multicol\n#   But these are unimplemented:\n#     sound??  keygen??  server??\n# Also seen here and there:\n#     marquee??  app??  (both unimplemented)\n#==========================================================================\n\n=head2 hashset %HTML::Tagset::isPhraseMarkup\n\nThis hashset contains all phrasal-level elements.\n\n=cut\n\n%isPhraseMarkup = map {; $_ => 1 } qw(\n  span abbr acronym q sub sup\n  cite code em kbd samp strong var dfn strike\n  b i u s tt small big \n  a img br\n  wbr nobr blink\n  font basefont bdo\n  spacer embed noembed\n);  # had: center, hr, table\n\n\n=head2 hashset %HTML::Tagset::is_Possible_Strict_P_Content\n\nThis hashset contains all phrasal-level elements that be content of a\nP element, for a strict model of HTML.\n\n=cut\n\n%is_Possible_Strict_P_Content = (\n %isPhraseMarkup,\n %isFormElement,\n map {; $_ => 1} qw( object script map )\n  # I've no idea why there's these latter exceptions.\n  # I'm just following the HTML4.01 DTD.\n);\n\n#from html4 strict:\n#<!ENTITY % fontstyle \"TT | I | B | BIG | SMALL\">\n#\n#<!ENTITY % phrase \"EM | STRONG | DFN | CODE |\n#                   SAMP | KBD | VAR | CITE | ABBR | ACRONYM\" >\n#\n#<!ENTITY % special\n#   \"A | IMG | OBJECT | BR | SCRIPT | MAP | Q | SUB | SUP | SPAN | BDO\">\n#\n#<!ENTITY % formctrl \"INPUT | SELECT | TEXTAREA | LABEL | BUTTON\">\n#\n#<!-- %inline; covers inline or \"text-level\" elements -->\n#<!ENTITY % inline \"#PCDATA | %fontstyle; | %phrase; | %special; | %formctrl;\">\n\n=head2 hashset %HTML::Tagset::isHeadElement\n\nThis hashset contains all elements that elements that should be\npresent only in the 'head' element of an HTML document.\n\n=cut\n\n%isHeadElement = map {; $_ => 1 }\n qw(title base link meta isindex script style object bgsound);\n\n=head2 hashset %HTML::Tagset::isList\n\nThis hashset contains all elements that can contain \"li\" elements.\n\n=cut\n\n%isList         = map {; $_ => 1 } qw(ul ol dir menu);\n\n=head2 hashset %HTML::Tagset::isTableElement\n\nThis hashset contains all elements that are to be found only in/under\na \"table\" element.\n\n=cut\n\n%isTableElement = map {; $_ => 1 }\n qw(tr td th thead tbody tfoot caption col colgroup);\n\n=head2 hashset %HTML::Tagset::isFormElement\n\nThis hashset contains all elements that are to be found only in/under\na \"form\" element.\n\n=cut\n\n%isFormElement  = map {; $_ => 1 }\n qw(input select option optgroup textarea button label);\n\n=head2 hashset %HTML::Tagset::isBodyElement\n\nThis hashset contains all elements that are to be found only in/under\nthe \"body\" element of an HTML document.\n\n=cut\n\n%isBodyElement = map {; $_ => 1 } qw(\n  h1 h2 h3 h4 h5 h6\n  p div pre plaintext address blockquote\n  xmp listing\n  center\n\n  multicol\n  iframe ilayer nolayer\n  bgsound\n\n  hr\n  ol ul dir menu li\n  dl dt dd\n  ins del\n  \n  fieldset legend\n  \n  map area\n  applet param object\n  isindex script noscript\n  table\n  center\n  form\n ),\n keys %isFormElement,\n keys %isPhraseMarkup,   # And everything phrasal\n keys %isTableElement,\n;\n\n\n=head2 hashset %HTML::Tagset::isHeadOrBodyElement\n\nThis hashset includes all elements that I notice can fall either in\nthe head or in the body.\n\n=cut\n\n%isHeadOrBodyElement = map {; $_ => 1 }\n  qw(script isindex style object map area param noscript bgsound);\n  # i.e., if we find 'script' in the 'body' ", 8192) = 8192
09:01:57.434148 brk(0x1dd4000)          = 0x1dd4000
09:01:57.434868 read(8, "or the 'head', don't freak out.\n\n\n=head2 hashset %HTML::Tagset::isKnown\n\nThis hashset lists all known HTML elements.\n\n=cut\n\n%isKnown = (%isHeadElement, %isBodyElement,\n  map{; $_=>1 }\n   qw( head body html\n       frame frameset noframes\n       ~comment ~pi ~directive ~literal\n));\n # that should be all known tags ever ever\n\n\n=head2 hashset %HTML::Tagset::canTighten\n\nThis hashset lists elements that might have ignorable whitespace as\nchildren or siblings.\n\n=cut\n\n%canTighten = %isKnown;\ndelete @canTighten{\n  keys(%isPhraseMarkup), 'input', 'select',\n  'xmp', 'listing', 'plaintext', 'pre',\n};\n  # xmp, listing, plaintext, and pre  are untightenable, and\n  #   in a really special way.\n@canTighten{'hr','br'} = (1,1);\n # exceptional 'phrasal' things that ARE subject to tightening.\n\n# The one case where I can think of my tightening rules failing is:\n#  <p>foo bar<center> <em>baz quux</em> ...\n#                    ^-- that would get deleted.\n# But that's pretty gruesome code anyhow.  You gets what you pays for.\n\n#==========================================================================\n\n=head2 array @HTML::Tagset::p_closure_barriers\n\nThis array has a meaning that I have only seen a need for in\nC<HTML::TreeBuilder>, but I include it here on the off chance that someone\nmight find it of use:\n\nWhen we see a \"E<lt>pE<gt>\" token, we go lookup up the lineage for a p\nelement we might have to minimize.  At first sight, we might say that\nif there's a p anywhere in the lineage of this new p, it should be\nclosed.  But that's wrong.  Consider this document:\n\n  <html>\n    <head>\n      <title>foo</title>\n    </head>\n    <body>\n      <p>foo\n        <table>\n          <tr>\n            <td>\n               foo\n               <p>bar\n            </td>\n          </tr>\n        </table>\n      </p>\n    </body>\n  </html>\n\nThe second p is quite legally inside a much higher p.\n\nMy formalization of the reason why this is legal, but this:\n\n  <p>foo<p>bar</p></p>\n\nisn't, is that something about the table constitutes a \"barrier\" to\nthe application of the rule about what p must minimize.\n\nSo C<@HTML::Tagset::p_closure_barriers> is the list of all such\nbarrier-tags.\n\n=cut\n\n@p_closure_barriers = qw(\n  li blockquote\n  ul ol menu dir\n  dl dt dd\n  td th tr table caption\n  div\n );\n\n# In an ideal world (i.e., XHTML) we wouldn't have to bother with any of this\n# monkey business of barriers to minimization!\n\n=head2 hashset %isCDATA_Parent\n\nThis hashset includes all elements whose content is CDATA.\n\n=cut\n\n%isCDATA_Parent = map {; $_ => 1 }\n  qw(script style  xmp listing plaintext);\n\n# TODO: there's nothing else that takes CDATA children, right?\n\n# As the HTML3 DTD (Raggett 1995-04-24) noted:\n#   The XMP, LISTING and PLAINTEXT tags are incompatible with SGML\n#   and derive from very early versions of HTML. They require non-\n#   standard parsers and will cause problems for processing\n#   documents with standard SGML tools.\n\n\n=head1 CAVEATS\n\nYou may find it useful to alter the behavior of modules (like\nC<HTML::Element> or C<HTML::TreeBuilder>) that use C<HTML::Tagset>'s\ndata tables by altering the data tables themselves.  You are welcome\nto try, but be careful; and be aware that different modules may or may\nreact differently to the data tables being changed.\n\nNote that it may be inappropriate to use these tables for I<producing>\nHTML -- for example, C<%isHeadOrBodyElement> lists the tagnames\nfor all elements that can appear either in the head or in the body,\nsuch as \"script\".  That doesn't mean that I am saying your code that\nproduces HTML should feel free to put script elements in either place!\nIf you are producing programs that spit out HTML, you should be\nI<intimately> familiar with the DTDs for HTML or XHTML (available at\nC<http://www.w3.org/>), and you should slavishly obey them, not\nthe data tables in this document.\n\n=head1 SEE ALSO\n\nL<HTML::Element>, L<HTML::TreeBuilder>, L<HTML::LinkExtor>\n\n=head1 COPYRIGHT & LICENSE\n\nCopyright 1995-2000 Gisle Aas.\n\nCopyright 2000-2005 Sean M. Burke.\n\nCopyright 2005-2008 Andy Lester.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.\n\n=head1 ACKNOWLEDGEMENTS\n\nMost of the code/data in this module was adapted from code written\nby Gisle Aas for C<HTML::Element>, C<HTML::TreeBuilder>, and\nC<HTML::LinkExtor>.  Then it was maintained by Sean M. Burke.\n\n=head1 AUTHOR\n\nCurrent maintainer: Andy Lester, C<< <andy at petdance.com> >>\n\n=head1 BUGS\n\nPlease report any bugs or feature requests to\nC<bug-html-tagset at rt.cpan.org>, or through the web interface at\nL<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=HTML-Tagset>.  I will\nbe notified, and then you'll automatically be notified of progress on\nyour bug as I make changes.\n\n=cut\n\n1;\n", 8192) = 4756
09:01:57.435182 read(8, "", 8192)       = 0
09:01:57.435231 close(8)                = 0
09:01:57.435484 stat("modules/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.435536 stat("modules/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.435587 stat("modules/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.435635 stat("modules/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.435685 stat("/etc/perl/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.435735 stat("/etc/perl/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.435785 stat("/usr/local/lib/perl/5.14.2/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.435838 stat("/usr/local/lib/perl/5.14.2/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.435891 stat("/usr/local/share/perl/5.14.2/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.435942 stat("/usr/local/share/perl/5.14.2/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.435992 stat("/usr/lib/perl5/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.436043 stat("/usr/lib/perl5/HTML/Element.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.436093 stat("/usr/share/perl5/HTML/Element.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.436143 stat("/usr/share/perl5/HTML/Element.pm", {st_mode=S_IFREG|0644, st_size=141060, ...}) = 0
09:01:57.436202 open("/usr/share/perl5/HTML/Element.pm", O_RDONLY) = 8
09:01:57.436255 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.436302 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.436370 read(8, "package HTML::Element;\n\n# ABSTRACT: Class for objects that represent HTML elements\n\nuse strict;\nuse warnings;\n\nour $VERSION = '5.02'; # VERSION from OurPkgVersion\n\nuse Carp           ();\nuse HTML::Entities ();\nuse HTML::Tagset   ();\nuse integer;    # vroom vroom!\n\n# This controls encoding entities on output.\n# When set entities won't be re-encoded.\n# Defaulting off because parser defaults to unencoding entities\nour $encoded_content = 0;\n\nuse vars qw($html_uc $Debug $ID_COUNTER $VERSION %list_type_to_sub);\n\n# Set up support for weak references, if possible:\nmy $using_weaken;\n\n#=head1 CLASS METHODS\n\n\nsub Use_Weak_Refs {\n    my $self_or_class = shift;\n\n    if (@_) {    # set\n        $using_weaken = !! shift; # Normalize boolean value\n        Carp::croak(\"The installed Scalar::Util lacks support for weak references\")\n              if $using_weaken and not defined &Scalar::Util::weaken;\n\n        no warnings 'redefine';\n        *_weaken = $using_weaken ? \\&Scalar::Util::weaken : sub ($) {};\n    } # end if setting value\n\n    return $using_weaken;\n} # end Use_Weak_Refs\n\nBEGIN {\n    # Attempt to import weaken from Scalar::Util, but don't complain\n    # if we can't.  Also, rename it to _weaken.\n    require Scalar::Util;\n\n    __PACKAGE__->Use_Weak_Refs(defined &Scalar::Util::weaken);\n}\n\nsub import {\n    my $class = shift;\n\n    for (@_) {\n        if (/^-(no_?)?weak$/) {\n            $class->Use_Weak_Refs(not $1);\n        } else {\n            Carp::croak(\"$_ is not exported by the $class module\");\n        }\n    }\n} # end import\n\n\n$Debug = 0 unless defined $Debug;\n\n#=head1 SUBROUTINES\n\n\nsub Version {\n    Carp::carp(\"Deprecated subroutine HTML::Element::Version called\");\n    $VERSION;\n}\n\nmy $nillio = [];\n\n*HTML::Element::emptyElement   = \\%HTML::Tagset::emptyElement;      # legacy\n*HTML::Element::optionalEndTag = \\%HTML::Tagset::optionalEndTag;    # legacy\n*HTML::Element::linkElements   = \\%HTML::Tagset::linkElements;      # legacy\n*HTML::Element::boolean_attr   = \\%HTML::Tagset::boolean_attr;      # legacy\n*HTML::Element::canTighten     = \\%HTML::Tagset::canTighten;        # legacy\n\n# Constants for signalling back to the traverser:\nmy $travsignal_package = __PACKAGE__ . '::_travsignal';\nmy ( $ABORT, $PRUNE, $PRUNE_SOFTLY, $OK, $PRUNE_UP )\n    = map { my $x = $_; bless \\$x, $travsignal_package; }\n    qw(\n    ABORT  PRUNE   PRUNE_SOFTLY   OK   PRUNE_UP\n);\n\n\n## Comments from Father Chrysostomos RT #58880\n## The sole purpose for empty parentheses after a sub name is to make it\n## parse as a 0-ary (nihilary?) function. I.e., ABORT+1 should parse as\n## ABORT()+1, not ABORT(+1). The parentheses also tell perl that it can\n### be inlined.\n##Deparse is really useful for demonstrating this:\n##$ perl -MO=Deparse,-p -e 'sub ABORT {7} print ABORT+8'\n# Vs\n# perl -MO=Deparse,-p -e 'sub ABORT() {7} print ABORT+8'\n#\n# With the parentheses, it not only makes it parse as a term.\n# It even resolves the constant at compile-time, making the code run faster.\n\n## no critic\nsub ABORT ()        {$ABORT}\nsub PRUNE ()        {$PRUNE}\nsub PRUNE_SOFTLY () {$PRUNE_SOFTLY}\nsub OK ()           {$OK}\nsub PRUNE_UP ()     {$PRUNE_UP}\n## use critic\n\n$html_uc = 0;\n\n# set to 1 if you want tag and attribute names from starttag and endtag\n#  to be uc'd\n\n# regexs for XML names\n# http://www.w3.org/TR/2006/REC-xml11-20060816/NT-NameStartChar\nmy $START_CHAR\n    = qr/(?:\\:|[A-Z]|_|[a-z]|[\\x{C0}-\\x{D6}]|[\\x{D8}-\\x{F6}]|[\\x{F8}-\\x{2FF}]|[\\x{370}-\\x{37D}]|[\\x{37F}-\\x{1FFF}]|[\\x{200C}-\\x{200D}]|[\\x{2070}-\\x{218F}]|[\\x{2C00}-\\x{2FEF}]|[\\x{3001}-\\x{D7FF}]|[\\x{F900}-\\x{FDCF}]|[\\x{FDF0}-\\x{FFFD}]|[\\x{10000}-\\x{EFFFF}])/;\n\n# http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-NameChar\nmy $NAME_CHAR\n    = qr/(?:$START_CHAR|-|\\.|[0-9]|\\x{B7}|[\\x{0300}-\\x{036F}]|[\\x{203F}-\\x{2040}])/;\n\n# Elements that does not have corresponding end tags (i.e. are empty)\n\n#==========================================================================\n\n#=head1 BASIC METHODS\n\n\n#\n# An HTML::Element is represented by blessed hash reference, much like\n# Tree::DAG_Node objects.  Key-names not starting with '_' are reserved\n# for the SGML attributes of the element.\n# The following special keys are used:\n#\n#    '_tag':    The tag name (i.e., the generic identifier)\n#    '_parent': A reference to the HTML::Element above (when forming a tree)\n#    '_pos':    The current position (a reference to a HTML::Element) is\n#               where inserts will be placed (look at the insert_element\n#               method)  If not set, the implicit value is the object itself.\n#    '_content': A ref to an array of nodes under this.\n#                It might not be set.\n#\n# Example: <img src=\"gisle.jpg\" alt=\"Gisle's photo\"> is represented like this:\n#\n#  bless {\n#     _tag => 'img',\n#     src  => 'gisle.jpg',\n#     alt  => \"Gisle's photo\",\n#  }, 'HTML::Element';\n#\n\nsub new {\n    my $class = shift;\n    $class = ref($class) || $class;\n\n    my $tag = shift;\n    Carp::croak(\"No tagname\") unless defined $tag and length $tag;\n    Carp::croak \"\\\"$tag\\\" isn't a good tag name!\"\n        if $tag =~ m/[<>\\/\\x00-\\x20]/;    # minimal sanity, certainly!\n    my $self = bless { _tag => scalar( $class->_fold_case($tag) ) }, $class;\n    my ( $attr, $val );\n    while ( ( $attr, $val ) = splice( @_, 0, 2 ) ) {\n## RT #42209 why does this default to the attribute name and not remain unset or the empty string?\n        $val = $attr unless defined $val;\n        $self->{ $class->_fold_case($attr) } = $val;\n    }\n    if ( $tag eq 'html' ) {\n        $self->{'_pos'} = undef;\n    }\n    _weaken($self->{'_parent'}) if $self->{'_parent'};\n    return $self;\n}\n\n\nsub attr {\n    my $self = shift;\n    my $attr = scalar( $self->_fold_case(shift) );\n    if (@_) {    # set\n        if ( defined $_[0] ) {\n            my $old = $self->{$attr};\n            $self->{$attr} = $_[0];\n            return $old;\n        }\n        else {    # delete, actually\n            return delete $self->{$attr};\n        }\n    }\n    else {        # get\n        return $self->{$attr};\n    }\n}\n\n\nsub tag {\n    my $self = shift;\n    if (@_) {    # set\n        $self->{'_tag'} = $self->_fold_case( $_[0] );\n    }\n    else {       # get\n        $self->{'_tag'};\n    }\n}\n\n\nsub parent {\n    my $self = shift;\n    if (@_) {    # set\n        Carp::croak \"an element can't be made its own parent\"\n            if defined $_[0] and ref $_[0] and $self eq $_[0];    # sanity\n        _weaken($self->{'_parent'} = $_[0]);\n    }\n    else {\n        $self->{'_parent'};                                       # get\n    }\n}\n\n\nsub content_list {\n    return wantarray\n        ? @{ shift->{'_content'} || return () }\n        : scalar @{ shift->{'_content'} || return 0 };\n}\n\n\n# a read-only method!  can't say $h->content( [] )!\nsub content {\n    return shift->{'_content'};\n}\n\n\nsub content_array_ref {\n    return shift->{'_content'} ||= [];\n}\n\n\nsub content_refs_list {\n    return \\( @{ shift->{'_content'} || return () } );\n}\n\n\nsub implicit {\n    return shift->attr( '_implicit', @_ );\n}\n\n\nsub pos {\n    my $self = shift;\n    my $pos  = $self->{'_pos'};\n    if (@_) {    # set\n        my $parm = shift;\n        if ( defined $parm and $parm ne $self ) {\n            $self->{'_pos'} = $parm;    # means that element\n        }\n        else {\n            $self->{'_pos'} = undef;    # means $self\n        }\n    }\n    return $pos if defined($pos);\n    return $self;\n}\n\n\nsub all_attr {\n    return %{ $_[0] };\n\n    # Yes, trivial.  But no other way for the user to do the same\n    #  without breaking encapsulation.\n    # And if our object representation changes, this method's behavior\n    #  should stay the same.\n}\n\nsub all_attr_names {\n    return keys %{ $_[0] };\n}\n\n\nsub all_external_attr {\n    my $self = $_[0];\n    return map( ( length($_) && substr( $_, 0, 1 ) eq '_' )\n        ? ()\n        : ( $_, $self->{$_} ),\n        keys %$self );\n}\n\nsub all_external_attr_names {\n    return grep !( length($_) && substr( $_, 0, 1 ) eq '_' ), keys %{ $_[0] };\n}\n\n\nsub id {\n    if ( @_ == 1 ) {\n        return $_[0]{'id'};\n    }\n    elsif ( @_ == 2 ) {\n        if ( defined $_[1] ) {\n            return $_[0]{'id'} = $_[1];\n        }\n        else {\n            return delete $_[0]{'id'};\n        }\n    ", 8192) = 8192
09:01:57.437488 read(8, "}\n    else {\n        Carp::croak '$node->id can\\'t take ' . scalar(@_) . ' parameters!';\n    }\n}\n\n\nsub _gensym {\n    unless ( defined $ID_COUNTER ) {\n\n        # start it out...\n        $ID_COUNTER = sprintf( '%04x', rand(0x1000) );\n        $ID_COUNTER =~ tr<0-9a-f><J-NP-Z>;    # yes, skip letter \"oh\"\n        $ID_COUNTER .= '00000';\n    }\n    ++$ID_COUNTER;\n}\n\nsub idf {\n    my $nparms = scalar @_;\n\n    if ( $nparms == 1 ) {\n        my $x;\n        if ( defined( $x = $_[0]{'id'} ) and length $x ) {\n            return $x;\n        }\n        else {\n            return $_[0]{'id'} = _gensym();\n        }\n    }\n    if ( $nparms == 2 ) {\n        if ( defined $_[1] ) {\n            return $_[0]{'id'} = $_[1];\n        }\n        else {\n            return delete $_[0]{'id'};\n        }\n    }\n    Carp::croak '$node->idf can\\'t take ' . scalar(@_) . ' parameters!';\n}\n\n\nsub push_content {\n    my $self = shift;\n    return $self unless @_;\n\n    my $content = ( $self->{'_content'} ||= [] );\n    for (@_) {\n        if ( ref($_) eq 'ARRAY' ) {\n\n            # magically call new_from_lol\n            push @$content, $self->new_from_lol($_);\n            _weaken($content->[-1]->{'_parent'} = $self);\n        }\n        elsif ( ref($_) ) {    # insert an element\n            $_->detach if $_->{'_parent'};\n            _weaken($_->{'_parent'} = $self);\n            push( @$content, $_ );\n        }\n        else {                 # insert text segment\n            if ( @$content && !ref $content->[-1] ) {\n\n                # last content element is also text segment -- append\n                $content->[-1] .= $_;\n            }\n            else {\n                push( @$content, $_ );\n            }\n        }\n    }\n    return $self;\n}\n\n\nsub unshift_content {\n    my $self = shift;\n    return $self unless @_;\n\n    my $content = ( $self->{'_content'} ||= [] );\n    for ( reverse @_ ) {    # so they get added in the order specified\n        if ( ref($_) eq 'ARRAY' ) {\n\n            # magically call new_from_lol\n            unshift @$content, $self->new_from_lol($_);\n            _weaken($content->[0]->{'_parent'} = $self);\n        }\n        elsif ( ref $_ ) {    # insert an element\n            $_->detach if $_->{'_parent'};\n            _weaken($_->{'_parent'} = $self);\n            unshift( @$content, $_ );\n        }\n        else {                # insert text segment\n            if ( @$content && !ref $content->[0] ) {\n\n                # last content element is also text segment -- prepend\n                $content->[0] = $_ . $content->[0];\n            }\n            else {\n                unshift( @$content, $_ );\n            }\n        }\n    }\n    return $self;\n}\n\n# Cf.  splice ARRAY,OFFSET,LENGTH,LIST\n\n\nsub splice_content {\n    my ( $self, $offset, $length, @to_add ) = @_;\n    Carp::croak \"splice_content requires at least one argument\"\n        if @_ < 2;    # at least $h->splice_content($offset);\n\n    my $content = ( $self->{'_content'} ||= [] );\n\n    # prep the list\n\n    my @out;\n    if ( @_ > 2 ) {    # self, offset, length, ...\n        foreach my $n (@to_add) {\n            if ( ref($n) eq 'ARRAY' ) {\n                $n = $self->new_from_lol($n);\n                _weaken($n->{'_parent'} = $self);\n            }\n            elsif ( ref($n) ) {\n                $n->detach;\n                _weaken($n->{'_parent'} = $self);\n            }\n        }\n        @out = splice @$content, $offset, $length, @to_add;\n    }\n    else {    #  self, offset\n        @out = splice @$content, $offset;\n    }\n    foreach my $n (@out) {\n        $n->{'_parent'} = undef if ref $n;\n    }\n    return @out;\n}\n\n\nsub detach {\n    my $self = $_[0];\n    return undef unless ( my $parent = $self->{'_parent'} );\n    $self->{'_parent'} = undef;\n    my $cohort = $parent->{'_content'} || return $parent;\n    @$cohort = grep { not( ref($_) and $_ eq $self ) } @$cohort;\n\n    # filter $self out, if parent has any evident content\n\n    return $parent;\n}\n\n\nsub detach_content {\n    my $c = $_[0]->{'_content'} || return ();    # in case of no content\n    for (@$c) {\n        $_->{'_parent'} = undef if ref $_;\n    }\n    return splice @$c;\n}\n\n\nsub replace_with {\n    my ( $self, @replacers ) = @_;\n    Carp::croak \"the target node has no parent\"\n        unless my ($parent) = $self->{'_parent'};\n\n    my $parent_content = $parent->{'_content'};\n    Carp::croak \"the target node's parent has no content!?\"\n        unless $parent_content and @$parent_content;\n\n    my $replacers_contains_self;\n    for (@replacers) {\n        if ( !ref $_ ) {\n\n            # noop\n        }\n        elsif ( $_ eq $self ) {\n\n            # noop, but check that it's there just once.\n            Carp::croak \"Replacement list contains several copies of target!\"\n                if $replacers_contains_self++;\n        }\n        elsif ( $_ eq $parent ) {\n            Carp::croak \"Can't replace an item with its parent!\";\n        }\n        elsif ( ref($_) eq 'ARRAY' ) {\n            $_ = $self->new_from_lol($_);\n            _weaken($_->{'_parent'} = $parent);\n        }\n        else {\n            $_->detach;\n            _weaken($_->{'_parent'} = $parent);\n\n            # each of these are necessary\n        }\n    }    # for @replacers\n    @$parent_content = map { ( ref($_) and $_ eq $self ) ? @replacers : $_ }\n        @$parent_content;\n\n    $self->{'_parent'} = undef unless $replacers_contains_self;\n\n    # if replacers does contain self, then the parent attribute is fine as-is\n\n    return $self;\n}\n\n\nsub preinsert {\n    my $self = shift;\n    return $self unless @_;\n    return $self->replace_with( @_, $self );\n}\n\n\nsub postinsert {\n    my $self = shift;\n    return $self unless @_;\n    return $self->replace_with( $self, @_ );\n}\n\n\nsub replace_with_content {\n    my $self = $_[0];\n    Carp::croak \"the target node has no parent\"\n        unless my ($parent) = $self->{'_parent'};\n\n    my $parent_content = $parent->{'_content'};\n    Carp::croak \"the target node's parent has no content!?\"\n        unless $parent_content and @$parent_content;\n\n    my $content_r = $self->{'_content'} || [];\n    @$parent_content = map { ( ref($_) and $_ eq $self ) ? @$content_r : $_ }\n        @$parent_content;\n\n    $self->{'_parent'} = undef;    # detach $self from its parent\n\n    # Update parentage link, removing from $self's content list\n    for ( splice @$content_r ) { _weaken($_->{'_parent'} = $parent) if ref $_ }\n\n    return $self;                  # note: doesn't destroy it.\n}\n\n\nsub delete_content {\n    for (\n        splice @{\n            delete( $_[0]->{'_content'} )\n\n                # Deleting it here (while holding its value, for the moment)\n                #  will keep calls to detach() from trying to uselessly filter\n                #  the list (as they won't be able to see it once it's been\n                #  deleted)\n                || return ( $_[0] )    # in case of no content\n        },\n        0\n\n        # the splice is so we can null the array too, just in case\n        # something somewhere holds a ref to it\n        )\n    {\n        $_->delete if ref $_;\n    }\n    $_[0];\n}\n\n\n# two handy aliases\nsub destroy         { shift->delete(@_) }\nsub destroy_content { shift->delete_content(@_) }\n\nsub delete {\n    my $self = $_[0];\n    $self->delete_content    # recurse down\n        if $self->{'_content'} && @{ $self->{'_content'} };\n\n    $self->detach if $self->{'_parent'} and $self->{'_parent'}{'_content'};\n\n    # not the typical case\n\n    %$self = ();             # null out the whole object on the way out\n    return;\n}\n\n\nsub clone {\n\n    #print \"Cloning $_[0]\\n\";\n    my $it = shift;\n    Carp::croak \"clone() can be called only as an object method\"\n        unless ref $it;\n    Carp::croak \"clone() takes no arguments\" if @_;\n\n    my $new = bless {%$it}, ref($it);    # COPY!!! HOOBOY!\n    delete @$new{ '_content', '_parent', '_pos', '_head', '_body' };\n\n    # clone any contents\n    if ( $it->{'_content'} and @{ $it->{'_content'} } ) {\n        $new->{'_content'}\n            = [ ref($it)->clone_list( @{ $it->{'_content'} } ) ];\n        for ( @{ $new->{'_content'} } ) {\n            _weaken($_->{'_parent'} = $new) if ref $_;\n        }\n    }\n\n    return $new;\n}\n\n\nsub clone_list {\n    Carp::croak \"clone_list can be called", 8192) = 8192
09:01:57.438485 brk(0x1df5000)          = 0x1df5000
09:01:57.438764 read(8, " only as a class method\"\n        if ref shift @_;\n\n    # all that does is get me here\n    return map {\n        ref($_)\n            ? $_->clone    # copy by method\n            : $_           # copy by evaluation\n    } @_;\n}\n\n\nsub normalize_content {\n    my $start = $_[0];\n    my $c;\n    return\n        unless $c = $start->{'_content'} and ref $c and @$c;   # nothing to do\n        # TODO: if we start having text elements, deal with catenating those too?\n    my @stretches = (undef);    # start with a barrier\n\n    # I suppose this could be rewritten to treat stretches as it goes, instead\n    #  of at the end.  But feh.\n\n    # Scan:\n    for ( my $i = 0; $i < @$c; ++$i ) {\n        if ( defined $c->[$i] and ref $c->[$i] ) {    # not a text segment\n            if ( $stretches[0] ) {\n\n                # put in a barrier\n                if ( $stretches[0][1] == 1 ) {\n\n                    #print \"Nixing stretch at \", $i-1, \"\\n\";\n                    undef $stretches[0]; # nix the previous one-node \"stretch\"\n                }\n                else {\n\n                    #print \"End of stretch at \", $i-1, \"\\n\";\n                    unshift @stretches, undef;\n                }\n            }\n\n            # else no need for a barrier\n        }\n        else {                           # text segment\n            $c->[$i] = '' unless defined $c->[$i];\n            if ( $stretches[0] ) {\n                ++$stretches[0][1];      # increase length\n            }\n            else {\n\n                #print \"New stretch at $i\\n\";\n                unshift @stretches, [ $i, 1 ];    # start and length\n            }\n        }\n    }\n\n    # Now combine.  Note that @stretches is in reverse order, so the indexes\n    # still make sense as we work our way thru (i.e., backwards thru $c).\n    foreach my $s (@stretches) {\n        if ( $s and $s->[1] > 1 ) {\n\n            #print \"Stretch at \", $s->[0], \" for \", $s->[1], \"\\n\";\n            $c->[ $s->[0] ]\n                .= join( '', splice( @$c, $s->[0] + 1, $s->[1] - 1 ) )\n\n                # append the subsequent ones onto the first one.\n        }\n    }\n    return;\n}\n\n\nsub delete_ignorable_whitespace {\n\n    # This doesn't delete all sorts of whitespace that won't actually\n    #  be used in rendering, tho -- that's up to the rendering application.\n    # For example:\n    #   <input type='text' name='foo'>\n    #     [some whitespace]\n    #   <input type='text' name='bar'>\n    # The WS between the two elements /will/ get used by the renderer.\n    # But here:\n    #   <input type='hidden' name='foo' value='1'>\n    #     [some whitespace]\n    #   <input type='text' name='bar' value='2'>\n    # the WS between them won't be rendered in any way, presumably.\n\n    #my $Debug = 4;\n    die \"delete_ignorable_whitespace can be called only as an object method\"\n        unless ref $_[0];\n\n    print \"About to tighten up...\\n\" if $Debug > 2;\n    my (@to_do) = ( $_[0] );    # Start off.\n    my ( $i, $sibs, $ptag, $this );    # scratch for the loop...\n    while (@to_do) {\n        if (   ( $ptag = ( $this = shift @to_do )->{'_tag'} ) eq 'pre'\n            or $ptag eq 'textarea'\n            or $HTML::Tagset::isCDATA_Parent{$ptag} )\n        {\n\n            # block the traversal under those\n            print \"Blocking traversal under $ptag\\n\" if $Debug;\n            next;\n        }\n        next unless ( $sibs = $this->{'_content'} and @$sibs );\n        for ( $i = $#$sibs; $i >= 0; --$i ) {   # work backwards thru the list\n            if ( ref $sibs->[$i] ) {\n                unshift @to_do, $sibs->[$i];\n\n                # yes, this happens in pre order -- we're going backwards\n                # thru this sibling list.  I doubt it actually matters, tho.\n                next;\n            }\n            next if $sibs->[$i] =~ m<[^\\n\\r\\f\\t ]>s;   # it's /all/ whitespace\n\n            print \"Under $ptag whose canTighten \",\n                \"value is \", 0 + $HTML::Element::canTighten{$ptag}, \".\\n\"\n                if $Debug > 3;\n\n            # It's all whitespace...\n\n            if ( $i == 0 ) {\n                if ( @$sibs == 1 ) {                   # I'm an only child\n                    next unless $HTML::Element::canTighten{$ptag};    # parent\n                }\n                else {    # I'm leftmost of many\n                          # if either my parent or sib are eligible, I'm good.\n                    next\n                        unless $HTML::Element::canTighten{$ptag}    # parent\n                            or (ref $sibs->[1]\n                                and $HTML::Element::canTighten{ $sibs->[1]\n                                        {'_tag'} }    # right sib\n                            );\n                }\n            }\n            elsif ( $i == $#$sibs ) {                 # I'm rightmost of many\n                    # if either my parent or sib are eligible, I'm good.\n                next\n                    unless $HTML::Element::canTighten{$ptag}    # parent\n                        or (ref $sibs->[ $i - 1 ]\n                            and $HTML::Element::canTighten{ $sibs->[ $i - 1 ]\n                                    {'_tag'} }                  # left sib\n                        );\n            }\n            else {    # I'm the piggy in the middle\n                      # My parent doesn't matter -- it all depends on my sibs\n                next\n                    unless ref $sibs->[ $i - 1 ]\n                        or ref $sibs->[ $i + 1 ];\n\n                # if NEITHER sib is a node, quit\n\n                next if\n\n                    # bailout condition: if BOTH are INeligible nodes\n                    #  (as opposed to being text, or being eligible nodes)\n                    ref $sibs->[ $i - 1 ]\n                        and ref $sibs->[ $i + 1 ]\n                        and !$HTML::Element::canTighten{ $sibs->[ $i - 1 ]\n                                {'_tag'} }    # left sib\n                        and !$HTML::Element::canTighten{ $sibs->[ $i + 1 ]\n                                {'_tag'} }    # right sib\n                ;\n            }\n\n       # Unknown tags aren't in canTighten and so AREN'T subject to tightening\n\n            print \"  delendum: child $i of $ptag\\n\" if $Debug > 3;\n            splice @$sibs, $i, 1;\n        }\n\n        # end of the loop-over-children\n    }\n\n    # end of the while loop.\n\n    return;\n}\n\n\nsub insert_element {\n    my ( $self, $tag, $implicit ) = @_;\n    return $self->pos() unless $tag;    # noop if nothing to insert\n\n    my $e;\n    if ( ref $tag ) {\n        $e   = $tag;\n        $tag = $e->tag;\n    }\n    else {    # just a tag name -- so make the element\n        $e = $self->element_class->new($tag);\n        ++( $self->{'_element_count'} ) if exists $self->{'_element_count'};\n\n        # undocumented.  see TreeBuilder.\n    }\n\n    $e->{'_implicit'} = 1 if $implicit;\n\n    my $pos = $self->{'_pos'};\n    $pos = $self unless defined $pos;\n\n    $pos->push_content($e);\n\n    $self->{'_pos'} = $pos = $e\n        unless $self->_empty_element_map->{$tag} || $e->{'_empty_element'};\n\n    $pos;\n}\n\n#==========================================================================\n# Some things to override in XML::Element\n\nsub _empty_element_map {\n    \\%HTML::Element::emptyElement;\n}\n\nsub _fold_case_LC {\n    if (wantarray) {\n        shift;\n        map lc($_), @_;\n    }\n    else {\n        return lc( $_[1] );\n    }\n}\n\nsub _fold_case_NOT {\n    if (wantarray) {\n        shift;\n        @_;\n    }\n    else {\n        return $_[1];\n    }\n}\n\n*_fold_case = \\&_fold_case_LC;\n\n#==========================================================================\n\n#=head1 DUMPING METHODS\n\n\nsub dump {\n    my ( $self, $fh, $depth ) = @_;\n    $fh    = *STDOUT{IO} unless defined $fh;\n    $depth = 0           unless defined $depth;\n    print $fh \"  \" x $depth, $self->starttag, \" \\@\", $self->address,\n        $self->{'_implicit'} ? \" (IMPLICIT)\\n\" : \"\\n\";\n    for ( @{ $self->{'_content'} } ) {\n        if ( ref $_ ) {    # element\n            $_->dump( $fh, $depth + 1 );    # recurse\n        }\n        else {                              # text node\n            print $fh \"  \" x ( $depth + 1 );\n            if ( length($_) > 65 or m<[\\x00-\\x1F]> ) {\n\n                # it needs prettyin' up", 8192) = 8192
09:01:57.439643 read(8, " somehow or other\n                my $x\n                    = ( length($_) <= 65 )\n                    ? $_\n                    : ( substr( $_, 0, 65 ) . '...' );\n                $x =~ s<([\\x00-\\x1F])>\n                     <'\\\\x'.(unpack(\"H2\",$1))>eg;\n                print $fh qq{\"$x\"\\n};\n            }\n            else {\n                print $fh qq{\"$_\"\\n};\n            }\n        }\n    }\n}\n\n\nsub as_HTML {\n    my ( $self, $entities, $indent, $omissible_map ) = @_;\n\n    #my $indent_on = defined($indent) && length($indent);\n    my @html = ();\n\n    $omissible_map ||= \\%HTML::Element::optionalEndTag;\n    my $empty_element_map = $self->_empty_element_map;\n\n    my $last_tag_tightenable    = 0;\n    my $this_tag_tightenable    = 0;\n    my $nonindentable_ancestors = 0;    # count of nonindentible tags over us.\n\n    my ( $tag, $node, $start, $depth ); # per-iteration scratch\n\n    if ( defined($indent) && length($indent) ) {\n        $self->traverse(\n            sub {\n                ( $node, $start, $depth ) = @_;\n                if ( ref $node ) {      # it's an element\n\n                    # detect bogus classes. RT #35948, #61673\n                    $node->can('starttag')\n                        or Carp::confess( \"Object of class \"\n                            . ref($node)\n                            . \" cannot be processed by HTML::Element\" );\n\n                    $tag = $node->{'_tag'};\n\n                    if ($start) {       # on the way in\n                        if ((   $this_tag_tightenable\n                                = $HTML::Element::canTighten{$tag}\n                            )\n                            and !$nonindentable_ancestors\n                            and $last_tag_tightenable\n                            )\n                        {\n                            push\n                                @html,\n                                \"\\n\",\n                                $indent x $depth,\n                                $node->starttag($entities),\n                                ;\n                        }\n                        else {\n                            push( @html, $node->starttag($entities) );\n                        }\n                        $last_tag_tightenable = $this_tag_tightenable;\n\n                        ++$nonindentable_ancestors\n                            if $tag eq 'pre'\n                                or $HTML::Tagset::isCDATA_Parent{$tag};\n\n                    }\n                    elsif (\n                        not(   $empty_element_map->{$tag}\n                            or $omissible_map->{$tag} )\n                        )\n                    {\n\n                        # on the way out\n                        if (   $tag eq 'pre'\n                            or $HTML::Tagset::isCDATA_Parent{$tag} )\n                        {\n                            --$nonindentable_ancestors;\n                            $last_tag_tightenable\n                                = $HTML::Element::canTighten{$tag};\n                            push @html, $node->endtag;\n\n                        }\n                        else {    # general case\n                            if ((   $this_tag_tightenable\n                                    = $HTML::Element::canTighten{$tag}\n                                )\n                                and !$nonindentable_ancestors\n                                and $last_tag_tightenable\n                                )\n                            {\n                                push\n                                    @html,\n                                    \"\\n\",\n                                    $indent x $depth,\n                                    $node->endtag,\n                                    ;\n                            }\n                            else {\n                                push @html, $node->endtag;\n                            }\n                            $last_tag_tightenable = $this_tag_tightenable;\n\n                           #print \"$tag tightenable: $this_tag_tightenable\\n\";\n                        }\n                    }\n                }\n                else {    # it's a text segment\n\n                    $last_tag_tightenable = 0;    # I guess this is right\n                    HTML::Entities::encode_entities( $node, $entities )\n\n                        # That does magic things if $entities is undef.\n                        unless (\n                        ( defined($entities) && !length($entities) )\n\n                        # If there's no entity to encode, don't call it\n                        || $HTML::Tagset::isCDATA_Parent{ $_[3]{'_tag'} }\n\n                        # To keep from amp-escaping children of script et al.\n                        # That doesn't deal with descendants; but then, CDATA\n                        #  parents shouldn't /have/ descendants other than a\n                        #  text children (or comments?)\n                        || $encoded_content\n                        );\n                    if ($nonindentable_ancestors) {\n                        push @html, $node;    # say no go\n                    }\n                    else {\n                        if ($last_tag_tightenable) {\n                            $node =~ s<[\\n\\r\\f\\t ]+>< >s;\n\n                            #$node =~ s< $><>s;\n                            $node =~ s<^ ><>s;\n                            push\n                                @html,\n                                \"\\n\",\n                                $indent x $depth,\n                                $node,\n\n           #Text::Wrap::wrap($indent x $depth, $indent x $depth, \"\\n\" . $node)\n                                ;\n                        }\n                        else {\n                            push\n                                @html,\n                                $node,\n\n                                #Text::Wrap::wrap('', $indent x $depth, $node)\n                                ;\n                        }\n                    }\n                }\n                1;    # keep traversing\n            }\n        );            # End of parms to traverse()\n    }\n    else {            # no indenting -- much simpler code\n        $self->traverse(\n            sub {\n                ( $node, $start ) = @_;\n                if ( ref $node ) {\n\n                    # detect bogus classes. RT #35948\n                    $node->isa( $self->element_class )\n                        or Carp::confess( \"Object of class \"\n                            . ref($node)\n                            . \" cannot be processed by HTML::Element\" );\n\n                    $tag = $node->{'_tag'};\n                    if ($start) {    # on the way in\n                        push( @html, $node->starttag($entities) );\n                    }\n                    elsif (\n                        not(   $empty_element_map->{$tag}\n                            or $omissible_map->{$tag} )\n                        )\n                    {\n\n                        # on the way out\n                        push( @html, $node->endtag );\n                    }\n                }\n                else {\n\n                    # simple text content\n                    HTML::Entities::encode_entities( $node, $entities )\n\n                        # That does magic things if $entities is undef.\n                        unless (\n                        ( defined($entities) && !length($entities) )\n\n                        # If there's no entity to encode, don't call it\n                        || $HTML::Tagset::isCDATA_Parent{ $_[3]{'_tag'} }\n\n                        # To keep from amp-escaping children of script et al.\n                        # That doesn't deal with descendants; but then, CDATA\n                        #  parents shouldn't /have/ descendants other than a\n                        #  text children (or comments?)\n                        || $encoded_content\n                        );\n                    push( @html, $node );\n                }\n                1;    # keep traversing\n            }\n        );            # End of parms to traverse()\n    }\n\n    if ( $self->{_store_declarations} && defined $self->{_decl} ) {\n        unshift @html, sprin", 8192) = 8192
09:01:57.440166 brk(0x1e16000)          = 0x1e16000
09:01:57.440489 read(8, "tf \"<!%s>\\n\", $self->{_decl}->{text};\n    }\n\n    return join( '', @html );\n}\n\n\nsub as_text {\n\n    # Yet another iteratively implemented traverser\n    my ( $this, %options ) = @_;\n    my $skip_dels = $options{'skip_dels'} || 0;\n    my (@pile) = ($this);\n    my $tag;\n    my $text = '';\n    while (@pile) {\n        if ( !defined( $pile[0] ) ) {    # undef!\n                                         # no-op\n        }\n        elsif ( !ref( $pile[0] ) ) {     # text bit!  save it!\n            $text .= shift @pile;\n        }\n        else {                           # it's a ref -- traverse under it\n            unshift @pile, @{ $this->{'_content'} || $nillio }\n                unless ( $tag = ( $this = shift @pile )->{'_tag'} ) eq 'style'\n                or $tag eq 'script'\n                or ( $skip_dels and $tag eq 'del' );\n        }\n    }\n    return $text;\n}\n\n# extra_chars added for RT #26436\nsub as_trimmed_text {\n    my ( $this, %options ) = @_;\n    my $text = $this->as_text(%options);\n    my $extra_chars = $options{'extra_chars'} || '';\n\n    $text =~ s/[\\n\\r\\f\\t$extra_chars ]+$//s;\n    $text =~ s/^[\\n\\r\\f\\t$extra_chars ]+//s;\n    $text =~ s/[\\n\\r\\f\\t$extra_chars ]+/ /g;\n    return $text;\n}\n\nsub as_text_trimmed { shift->as_trimmed_text(@_) }   # alias, because I forget\n\n\n# TODO: make it wrap, if not indent?\n\nsub as_XML {\n\n    # based an as_HTML\n    my ($self) = @_;\n\n    #my $indent_on = defined($indent) && length($indent);\n    my @xml               = ();\n    my $empty_element_map = $self->_empty_element_map;\n\n    my ( $tag, $node, $start );    # per-iteration scratch\n    $self->traverse(\n        sub {\n            ( $node, $start ) = @_;\n            if ( ref $node ) {     # it's an element\n                $tag = $node->{'_tag'};\n                if ($start) {      # on the way in\n\n                    foreach my $attr ( $node->all_attr_names() ) {\n                        Carp::croak(\n                            \"$tag has an invalid attribute name '$attr'\")\n                            unless ( $attr eq '/' || $self->_valid_name($attr) );\n                    }\n\n                    if ( $empty_element_map->{$tag}\n                        and !@{ $node->{'_content'} || $nillio } )\n                    {\n                        push( @xml, $node->starttag_XML( undef, 1 ) );\n                    }\n                    else {\n                        push( @xml, $node->starttag_XML(undef) );\n                    }\n                }\n                else {    # on the way out\n                    unless ( $empty_element_map->{$tag}\n                        and !@{ $node->{'_content'} || $nillio } )\n                    {\n                        push( @xml, $node->endtag_XML() );\n                    }     # otherwise it will have been an <... /> tag.\n                }\n            }\n            else {        # it's just text\n                _xml_escape($node);\n                push( @xml, $node );\n            }\n            1;            # keep traversing\n        }\n    );\n\n    join( '', @xml, \"\\n\" );\n}\n\nsub _xml_escape {\n\n# DESTRUCTIVE (a.k.a. \"in-place\")\n# Five required escapes: http://www.w3.org/TR/2006/REC-xml11-20060816/#syntax\n# We allow & if it's part of a valid escape already: http://www.w3.org/TR/2006/REC-xml11-20060816/#sec-references\n    foreach my $x (@_) {\n\n        # In strings with no encoded entities all & should be encoded.\n        if ($encoded_content) {\n            $x\n                =~ s/&(?!                 # An ampersand that isn't followed by...\n                (\\#\\d+; |                 # A hash mark, digits and semicolon, or\n                \\#x[\\da-f]+; |            # A hash mark, \"x\", hex digits and semicolon, or\n                $START_CHAR$NAME_CHAR+; ) # A valid unicode entity name and semicolon\n           )/&amp;/gx;    # Needs to be escaped to amp\n        }\n        else {\n            $x =~ s/&/&amp;/g;\n        }\n\n        # simple character escapes\n        $x =~ s/</&lt;/g;\n        $x =~ s/>/&gt;/g;\n        $x =~ s/\"/&quot;/g;\n        $x =~ s/'/&apos;/g;\n    }\n    return;\n}\n\n\n# NOTES:\n#\n# It's been suggested that attribute names be made :-keywords:\n#   (:_tag \"img\" :border 0 :src \"pie.png\" :usemap \"#main.map\")\n# However, it seems that Scheme has no such data type as :-keywords.\n# So, for the moment at least, I tend toward simplicity, uniformity,\n#  and universality, where everything a string or a list.\n\nsub as_Lisp_form {\n    my @out;\n\n    my $sub;\n    my $depth = 0;\n    my ( @list, $val );\n    $sub = sub {    # Recursor\n        my $self = $_[0];\n        @list = ( '_tag', $self->{'_tag'} );\n        @list = () unless defined $list[-1];    # unlikely\n\n        for ( sort keys %$self ) {              # predictable ordering\n            next\n                if $_ eq '_content'\n                    or $_ eq '_tag'\n                    or $_ eq '_parent'\n                    or $_ eq '/';\n\n            # Leave the other private attributes, I guess.\n            push @list, $_, $val\n                if defined( $val = $self->{$_} );    # and !ref $val;\n        }\n\n        for (@list) {\n\n            # octal-escape it\n            s<([^\\x20\\x21\\x23\\x27-\\x5B\\x5D-\\x7E])>\n         <sprintf('\\\\%03o',ord($1))>eg;\n            $_ = qq{\"$_\"};\n        }\n        push @out, ( '  ' x $depth ) . '(' . join ' ', splice @list;\n        if ( @{ $self->{'_content'} || $nillio } ) {\n            $out[-1] .= \" \\\"_content\\\" (\\n\";\n            ++$depth;\n            foreach my $c ( @{ $self->{'_content'} } ) {\n                if ( ref($c) ) {\n\n                    # an element -- recurse\n                    $sub->($c);\n                }\n                else {\n\n                    # a text segment -- stick it in and octal-escape it\n                    push @out, $c;\n                    $out[-1] =~ s<([^\\x20\\x21\\x23\\x27-\\x5B\\x5D-\\x7E])>\n             <sprintf('\\\\%03o',ord($1))>eg;\n\n                    # And quote and indent it.\n                    $out[-1] .= \"\\\"\\n\";\n                    $out[-1] = ( '  ' x $depth ) . '\"' . $out[-1];\n                }\n            }\n            --$depth;\n            substr( $out[-1], -1 )\n                = \"))\\n\";    # end of _content and of the element\n        }\n        else {\n            $out[-1] .= \")\\n\";\n        }\n        return;\n    };\n\n    $sub->( $_[0] );\n    undef $sub;\n    return join '', @out;\n}\n\n\nsub format {\n    my ( $self, $formatter ) = @_;\n    unless ( defined $formatter ) {\n        # RECOMMEND PREREQ: HTML::FormatText\n        require HTML::FormatText;\n        $formatter = HTML::FormatText->new();\n    }\n    $formatter->format($self);\n}\n\n\nsub starttag {\n    my ( $self, $entities ) = @_;\n\n    my $name = $self->{'_tag'};\n\n    return $self->{'text'}              if $name eq '~literal';\n    return \"<!\" . $self->{'text'} . \">\" if $name eq '~declaration';\n    return \"<?\" . $self->{'text'} . \">\" if $name eq '~pi';\n\n    if ( $name eq '~comment' ) {\n        if ( ref( $self->{'text'} || '' ) eq 'ARRAY' ) {\n\n            # Does this ever get used?  And is this right?\n            return\n                \"<!\"\n                . join( ' ', map( \"--$_--\", @{ $self->{'text'} } ) ) . \">\";\n        }\n        else {\n            return \"<!--\" . $self->{'text'} . \"-->\";\n        }\n    }\n\n    my $tag = $html_uc ? \"<\\U$name\" : \"<\\L$name\";\n    my $val;\n    for ( sort keys %$self ) {    # predictable ordering\n        next if !length $_ or m/^_/s or $_ eq '/';\n        $val = $self->{$_};\n        next if !defined $val;    # or ref $val;\n        if ($_ eq $val &&         # if attribute is boolean, for this element\n            exists( $HTML::Element::boolean_attr{$name} )\n            && (ref( $HTML::Element::boolean_attr{$name} )\n                ? $HTML::Element::boolean_attr{$name}{$_}\n                : $HTML::Element::boolean_attr{$name} eq $_\n            )\n            )\n        {\n            $tag .= $html_uc ? \" \\U$_\" : \" \\L$_\";\n        }\n        else {                    # non-boolean attribute\n\n            if ( ref $val eq 'HTML::Element'\n                and $val->{_tag} eq '~literal' )\n            {\n                $val = $val->{text};\n            }\n            else {\n                HTML::Entities::encode_entities( $val, $entities )\n                    unless (\n         ", 8192) = 8192
09:01:57.441492 brk(0x1e37000)          = 0x1e37000
09:01:57.441652 read(8, "           defined($entities) && !length($entities)\n                    || $encoded_content\n\n                    );\n            }\n\n            $val = qq{\"$val\"};\n            $tag .= $html_uc ? qq{ \\U$_\\E=$val} : qq{ \\L$_\\E=$val};\n        }\n    }    # for keys\n    if ( scalar $self->content_list == 0\n        && $self->_empty_element_map->{ $self->tag } )\n    {\n        return $tag . \" />\";\n    }\n    else {\n        return $tag . \">\";\n    }\n}\n\n\nsub starttag_XML {\n    my ($self) = @_;\n\n    # and a third parameter to signal emptiness?\n\n    my $name = $self->{'_tag'};\n\n    return $self->{'text'}               if $name eq '~literal';\n    return '<!' . $self->{'text'} . '>'  if $name eq '~declaration';\n    return \"<?\" . $self->{'text'} . \"?>\" if $name eq '~pi';\n\n    if ( $name eq '~comment' ) {\n        if ( ref( $self->{'text'} || '' ) eq 'ARRAY' ) {\n\n            # Does this ever get used?  And is this right?\n            $name = join( ' ', @{ $self->{'text'} } );\n        }\n        else {\n            $name = $self->{'text'};\n        }\n        $name =~ s/--/-&#45;/g;    # can't have double --'s in XML comments\n        return \"<!-- $name -->\";\n    }\n\n    my $tag = \"<$name\";\n    my $val;\n    for ( sort keys %$self ) {     # predictable ordering\n        next if !length $_ or m/^_/s or $_ eq '/';\n\n        # Hm -- what to do if val is undef?\n        # I suppose that shouldn't ever happen.\n        next if !defined( $val = $self->{$_} );    # or ref $val;\n        _xml_escape($val);\n        $tag .= qq{ $_=\"$val\"};\n    }\n    @_ == 3 ? \"$tag />\" : \"$tag>\";\n}\n\n\nsub endtag {\n    $html_uc ? \"</\\U$_[0]->{'_tag'}>\" : \"</\\L$_[0]->{'_tag'}>\";\n}\n\nsub endtag_XML {\n    \"</$_[0]->{'_tag'}>\";\n}\n\n#==========================================================================\n# This, ladies and germs, is an iterative implementation of a\n# recursive algorithm.  DON'T TRY THIS AT HOME.\n# Basically, the algorithm says:\n#\n# To traverse:\n#   1: pre-order visit this node\n#   2: traverse any children of this node\n#   3: post-order visit this node, unless it's a text segment,\n#       or a prototypically empty node (like \"br\", etc.)\n# Add to that the consideration of the callbacks' return values,\n# so you can block visitation of the children, or siblings, or\n# abort the whole excursion, etc.\n#\n# So, why all this hassle with making the code iterative?\n# It makes for real speed, because it eliminates the whole\n# hassle of Perl having to allocate scratch space for each\n# instance of the recursive sub.  Since the algorithm\n# is basically simple (and not all recursive ones are!) and\n# has few necessary lexicals (basically just the current node's\n# content list, and the current position in it), it was relatively\n# straightforward to store that information not as the frame\n# of a sub, but as a stack, i.e., a simple Perl array (well, two\n# of them, actually: one for content-listrefs, one for indexes of\n# current position in each of those).\n\nmy $NIL = [];\n\nsub traverse {\n    my ( $start, $callback, $ignore_text ) = @_;\n\n    Carp::croak \"traverse can be called only as an object method\"\n        unless ref $start;\n\n    Carp::croak('must provide a callback for traverse()!')\n        unless defined $callback and ref $callback;\n\n    # Elementary type-checking:\n    my ( $c_pre, $c_post );\n    if ( UNIVERSAL::isa( $callback, 'CODE' ) ) {\n        $c_pre = $c_post = $callback;\n    }\n    elsif ( UNIVERSAL::isa( $callback, 'ARRAY' ) ) {\n        ( $c_pre, $c_post ) = @$callback;\n        Carp::croak(\n            \"pre-order callback \\\"$c_pre\\\" is true but not a coderef!\")\n            if $c_pre and not UNIVERSAL::isa( $c_pre, 'CODE' );\n        Carp::croak(\n            \"pre-order callback \\\"$c_post\\\" is true but not a coderef!\")\n            if $c_post and not UNIVERSAL::isa( $c_post, 'CODE' );\n        return $start unless $c_pre or $c_post;\n\n        # otherwise there'd be nothing to actually do!\n    }\n    else {\n        Carp::croak(\"$callback is not a known kind of reference\")\n            unless ref($callback);\n    }\n\n    my $empty_element_map = $start->_empty_element_map;\n\n    my (@C) = [$start];    # a stack containing lists of children\n    my (@I) = (-1);        # initial value must be -1 for each list\n         # a stack of indexes to current position in corresponding lists in @C\n         # In each of these, 0 is the active point\n\n    # scratch:\n    my ($rv,           # return value of callback\n        $this,         # current node\n        $content_r,    # child list of $this\n    );\n\n    # THE BIG LOOP\n    while (@C) {\n\n        # Move to next item in this frame\n        if ( !defined( $I[0] ) or ++$I[0] >= @{ $C[0] } ) {\n\n            # We either went off the end of this list, or aborted the list\n            # So call the post-order callback:\n            if (    $c_post\n                and defined $I[0]\n                and @C > 1\n\n                # to keep the next line from autovivifying\n                and defined( $this = $C[1][ $I[1] ] )    # sanity, and\n                     # suppress callbacks on exiting the fictional top frame\n                and ref($this)    # sanity\n                and not(\n                    $this->{'_empty_element'}\n                    || ( $empty_element_map->{ $this->{'_tag'} || '' }\n                        && !@{ $this->{'_content'} } )    # RT #49932\n                )    # things that don't get post-order callbacks\n                )\n            {\n                shift @I;\n                shift @C;\n\n                #print \"Post! at depth\", scalar(@I), \"\\n\";\n                $rv = $c_post->(\n\n                    #map $_, # copy to avoid any messiness\n                    $this,     # 0: this\n                    0,         # 1: startflag (0 for post-order call)\n                    @I - 1,    # 2: depth\n                );\n\n                if ( defined($rv) and ref($rv) eq $travsignal_package ) {\n                    $rv = $$rv;    #deref\n                    if ( $rv eq 'ABORT' ) {\n                        last;      # end of this excursion!\n                    }\n                    elsif ( $rv eq 'PRUNE' ) {\n\n                        # NOOP on post!!\n                    }\n                    elsif ( $rv eq 'PRUNE_SOFTLY' ) {\n\n                        # NOOP on post!!\n                    }\n                    elsif ( $rv eq 'OK' ) {\n\n                        # noop\n                    }\n                    elsif ( $rv eq 'PRUNE_UP' ) {\n                        $I[0] = undef;\n                    }\n                    else {\n                        die \"Unknown travsignal $rv\\n\";\n\n                        # should never happen\n                    }\n                }\n            }\n            else {\n                shift @I;\n                shift @C;\n            }\n            next;\n        }\n\n        $this = $C[0][ $I[0] ];\n\n        if ($c_pre) {\n            if ( defined $this and ref $this ) {    # element\n                $rv = $c_pre->(\n\n                    #map $_, # copy to avoid any messiness\n                    $this,     # 0: this\n                    1,         # 1: startflag (1 for pre-order call)\n                    @I - 1,    # 2: depth\n                );\n            }\n            else {             # text segment\n                next if $ignore_text;\n                $rv = $c_pre->(\n\n                    #map $_, # copy to avoid any messiness\n                    $this,           # 0: this\n                    1,               # 1: startflag (1 for pre-order call)\n                    @I - 1,          # 2: depth\n                    $C[1][ $I[1] ],  # 3: parent\n                                     # And there will always be a $C[1], since\n                             #  we can't start traversing at a text node\n                    $I[0]    # 4: index of self in parent's content list\n                );\n            }\n            if ( not $rv ) {    # returned false.  Same as PRUNE.\n                next;           # prune\n            }\n            elsif ( ref($rv) eq $travsignal_package ) {\n                $rv = $$rv;     # deref\n                if ( $rv eq 'ABORT' ) {\n                    last;       # end of this excursion!\n                }\n                elsif ( $rv eq 'PRUNE' ) {\n      ", 8192) = 8192
09:01:57.442553 read(8, "              next;\n                }\n                elsif ( $rv eq 'PRUNE_SOFTLY' ) {\n                    if (ref($this)\n                        and not( $this->{'_empty_element'}\n                            || $empty_element_map->{ $this->{'_tag'} || '' } )\n                        )\n                    {\n\n             # push a dummy empty content list just to trigger a post callback\n                        unshift @I, -1;\n                        unshift @C, $NIL;\n                    }\n                    next;\n                }\n                elsif ( $rv eq 'OK' ) {\n\n                    # noop\n                }\n                elsif ( $rv eq 'PRUNE_UP' ) {\n                    $I[0] = undef;\n                    next;\n\n                    # equivalent of last'ing out of the current child list.\n\n            # Used to have PRUNE_UP_SOFTLY and ABORT_SOFTLY here, but the code\n            # for these was seriously upsetting, served no particularly clear\n            # purpose, and could not, I think, be easily implemented with a\n            # recursive routine.  All bad things!\n                }\n                else {\n                    die \"Unknown travsignal $rv\\n\";\n\n                    # should never happen\n                }\n            }\n\n            # else fall thru to meaning same as \\'OK'.\n        }\n\n        # end of pre-order calling\n\n        # Now queue up content list for the current element...\n        if (ref $this\n            and not(    # ...except for those which...\n                not( $content_r = $this->{'_content'} and @$content_r )\n\n                # ...have empty content lists...\n                and $this->{'_empty_element'}\n                || $empty_element_map->{ $this->{'_tag'} || '' }\n\n                # ...and that don't get post-order callbacks\n            )\n            )\n        {\n            unshift @I, -1;\n            unshift @C, $content_r || $NIL;\n\n            #print $this->{'_tag'}, \" ($this) adds content_r \", $C[0], \"\\n\";\n        }\n    }\n    return $start;\n}\n\n\nsub is_inside {\n    my $self = shift;\n    return 0 unless @_; # if no items specified, I guess this is right.\n\n    my $current = $self;\n\n    # the loop starts by looking at the given element\n    while ( defined $current and ref $current ) {\n        for (@_) {\n            if (ref) {    # element\n                return 1 if $_ eq $current;\n            }\n            else {        # tag name\n                return 1 if $_ eq $current->{'_tag'};\n            }\n        }\n        $current = $current->{'_parent'};\n    }\n    0;\n}\n\n\nsub is_empty {\n    my $self = shift;\n    !$self->{'_content'} || !@{ $self->{'_content'} };\n}\n\n\nsub pindex {\n    my $self = shift;\n\n    my $parent = $self->{'_parent'}    || return undef;\n    my $pc     = $parent->{'_content'} || return undef;\n    for ( my $i = 0; $i < @$pc; ++$i ) {\n        return $i if ref $pc->[$i] and $pc->[$i] eq $self;\n    }\n    return undef;               # we shouldn't ever get here\n}\n\n#--------------------------------------------------------------------------\n\n\nsub left {\n    Carp::croak \"left() is supposed to be an object method\"\n        unless ref $_[0];\n    my $pc = ( $_[0]->{'_parent'} || return )->{'_content'}\n        || die \"parent is childless?\";\n\n    die \"parent is childless\" unless @$pc;\n    return if @$pc == 1;    # I'm an only child\n\n    if (wantarray) {\n        my @out;\n        foreach my $j (@$pc) {\n            return @out if ref $j and $j eq $_[0];\n            push @out, $j;\n        }\n    }\n    else {\n        for ( my $i = 0; $i < @$pc; ++$i ) {\n            return $i ? $pc->[ $i - 1 ] : undef\n                if ref $pc->[$i] and $pc->[$i] eq $_[0];\n        }\n    }\n\n    die \"I'm not in my parent's content list?\";\n    return;\n}\n\n\nsub right {\n    Carp::croak \"right() is supposed to be an object method\"\n        unless ref $_[0];\n    my $pc = ( $_[0]->{'_parent'} || return )->{'_content'}\n        || die \"parent is childless?\";\n\n    die \"parent is childless\" unless @$pc;\n    return if @$pc == 1;    # I'm an only child\n\n    if (wantarray) {\n        my ( @out, $seen );\n        foreach my $j (@$pc) {\n            if ($seen) {\n                push @out, $j;\n            }\n            else {\n                $seen = 1 if ref $j and $j eq $_[0];\n            }\n        }\n        die \"I'm not in my parent's content list?\" unless $seen;\n        return @out;\n    }\n    else {\n        for ( my $i = 0; $i < @$pc; ++$i ) {\n            return +( $i == $#$pc ) ? undef : $pc->[ $i + 1 ]\n                if ref $pc->[$i] and $pc->[$i] eq $_[0];\n        }\n        die \"I'm not in my parent's content list?\";\n        return;\n    }\n}\n\n#--------------------------------------------------------------------------\n\n\nsub address {\n    if ( @_ == 1 ) {    # report-address form\n        return join(\n            '.',\n            reverse(    # so it starts at the top\n                map( $_->pindex() || '0',    # so that root's undef -> '0'\n                    $_[0],                   # self and...\n                    $_[0]->lineage )\n            )\n        );\n    }\n    else {                                   # get-node-at-address\n        my @stack = split( /\\./, $_[1] );\n        my $here;\n\n        if ( @stack and !length $stack[0] ) {    # relative addressing\n            $here = $_[0];\n            shift @stack;\n        }\n        else {                                   # absolute addressing\n            return undef unless 0 == shift @stack; # pop the initial 0-for-root\n            $here = $_[0]->root;\n        }\n\n        while (@stack) {\n            return undef\n                unless $here->{'_content'}\n                    and @{ $here->{'_content'} } > $stack[0];\n\n            # make sure the index isn't too high\n            $here = $here->{'_content'}[ shift @stack ];\n            return undef if @stack and not ref $here;\n\n            # we hit a text node when we expected a non-terminal element node\n        }\n\n        return $here;\n    }\n}\n\n\nsub depth {\n    my $here  = $_[0];\n    my $depth = 0;\n    while ( defined( $here = $here->{'_parent'} ) and ref($here) ) {\n        ++$depth;\n    }\n    return $depth;\n}\n\n\nsub root {\n    my $here = my $root = shift;\n    while ( defined( $here = $here->{'_parent'} ) and ref($here) ) {\n        $root = $here;\n    }\n    return $root;\n}\n\n\nsub lineage {\n    my $here = shift;\n    my @lineage;\n    while ( defined( $here = $here->{'_parent'} ) and ref($here) ) {\n        push @lineage, $here;\n    }\n    return @lineage;\n}\n\n\nsub lineage_tag_names {\n    my $here = my $start = shift;\n    my @lineage_names;\n    while ( defined( $here = $here->{'_parent'} ) and ref($here) ) {\n        push @lineage_names, $here->{'_tag'};\n    }\n    return @lineage_names;\n}\n\n\nsub descendents { shift->descendants(@_) }\n\nsub descendants {\n    my $start = shift;\n    if (wantarray) {\n        my @descendants;\n        $start->traverse(\n            [    # pre-order sub only\n                sub {\n                    push( @descendants, $_[0] );\n                    return 1;\n                },\n                undef    # no post\n            ],\n            1,           # ignore text\n        );\n        shift @descendants;    # so $self doesn't appear in the list\n        return @descendants;\n    }\n    else {                     # just returns a scalar\n        my $descendants = -1;    # to offset $self being counted\n        $start->traverse(\n            [                    # pre-order sub only\n                sub {\n                    ++$descendants;\n                    return 1;\n                },\n                undef            # no post\n            ],\n            1,                   # ignore text\n        );\n        return $descendants;\n    }\n}\n\n\nsub find { shift->find_by_tag_name(@_) }\n\n# yup, a handy alias\n\nsub find_by_tag_name {\n    my (@pile) = shift(@_);    # start out the to-do stack for the traverser\n    Carp::croak \"find_by_tag_name can be called only as an object method\"\n        unless ref $pile[0];\n    return () unless @_;\n    my (@tags) = $pile[0]->_fold_case(@_);\n    my ( @matching, $this, $this_tag );\n    while (@pile) {\n        $this_tag = ( $this = shift @pile )->{'_tag'};\n        foreach my $t (@tags) {\n            if ( $t eq $thi", 8192) = 8192
09:01:57.443206 brk(0x1e58000)          = 0x1e58000
09:01:57.443688 read(8, "s_tag ) {\n                if (wantarray) {\n                    push @matching, $this;\n                    last;\n                }\n                else {\n                    return $this;\n                }\n            }\n        }\n        unshift @pile, grep ref($_), @{ $this->{'_content'} || next };\n    }\n    return @matching if wantarray;\n    return;\n}\n\n\nsub find_by_attribute {\n\n    # We could limit this to non-internal attributes, but hey.\n    my ( $self, $attribute, $value ) = @_;\n    Carp::croak \"Attribute must be a defined value!\"\n        unless defined $attribute;\n    $attribute = $self->_fold_case($attribute);\n\n    my @matching;\n    my $wantarray = wantarray;\n    my $quit;\n    $self->traverse(\n        [    # pre-order only\n            sub {\n                if ( exists $_[0]{$attribute}\n                    and $_[0]{$attribute} eq $value )\n                {\n                    push @matching, $_[0];\n                    return HTML::Element::ABORT\n                        unless $wantarray;    # only take the first\n                }\n                1;                            # keep traversing\n            },\n            undef                             # no post\n        ],\n        1,                                    # yes, ignore text nodes.\n    );\n\n    if ($wantarray) {\n        return @matching;\n    }\n    else {\n        return $matching[0];\n    }\n}\n\n#--------------------------------------------------------------------------\n\n\nsub look_down {\n    ref( $_[0] ) or Carp::croak \"look_down works only as an object method\";\n\n    my @criteria;\n    for ( my $i = 1; $i < @_; ) {\n        Carp::croak \"Can't use undef as an attribute name\"\n            unless defined $_[$i];\n        if ( ref $_[$i] ) {\n            Carp::croak \"A \" . ref( $_[$i] ) . \" value is not a criterion\"\n                unless ref $_[$i] eq 'CODE';\n            push @criteria, $_[ $i++ ];\n        }\n        else {\n            Carp::croak \"param list to look_down ends in a key!\" if $i == $#_;\n            push @criteria, [\n                scalar( $_[0]->_fold_case( $_[$i] ) ),\n                defined( $_[ $i + 1 ] )\n                ? ( ( ref $_[ $i + 1 ] ? $_[ $i + 1 ] : lc( $_[ $i + 1 ] ) ),\n                    ref( $_[ $i + 1 ] )\n                    )\n\n                    # yes, leave that LC!\n                : undef\n            ];\n            $i += 2;\n        }\n    }\n    Carp::croak \"No criteria?\" unless @criteria;\n\n    my (@pile) = ( $_[0] );\n    my ( @matching, $val, $this );\nNode:\n    while ( defined( $this = shift @pile ) ) {\n\n        # Yet another traverser implemented with merely iterative code.\n        foreach my $c (@criteria) {\n            if ( ref($c) eq 'CODE' ) {\n                next Node unless $c->($this);    # jump to the continue block\n            }\n            else {                               # it's an attr-value pair\n                next Node                        # jump to the continue block\n                    if                           # two values are unequal if:\n                        ( defined( $val = $this->{ $c->[0] } ) )\n                    ? (     !defined $c->[ 1\n                                ]    # actual is def, critval is undef => fail\n                                     # allow regex matching\n                                     # allow regex matching\n                                or (\n                                  $c->[2] eq 'Regexp'\n                                ? $val !~ $c->[1]\n                                : ( ref $val ne $c->[2]\n\n                                        # have unequal ref values => fail\n                                        or lc($val) ne lc( $c->[1] )\n\n                                       # have unequal lc string values => fail\n                                )\n                                )\n                        )\n                    : (     defined $c->[1]\n                        )    # actual is undef, critval is def => fail\n            }\n        }\n\n        # We make it this far only if all the criteria passed.\n        return $this unless wantarray;\n        push @matching, $this;\n    }\n    continue {\n        unshift @pile, grep ref($_), @{ $this->{'_content'} || $nillio };\n    }\n    return @matching if wantarray;\n    return;\n}\n\n\nsub look_up {\n    ref( $_[0] ) or Carp::croak \"look_up works only as an object method\";\n\n    my @criteria;\n    for ( my $i = 1; $i < @_; ) {\n        Carp::croak \"Can't use undef as an attribute name\"\n            unless defined $_[$i];\n        if ( ref $_[$i] ) {\n            Carp::croak \"A \" . ref( $_[$i] ) . \" value is not a criterion\"\n                unless ref $_[$i] eq 'CODE';\n            push @criteria, $_[ $i++ ];\n        }\n        else {\n            Carp::croak \"param list to look_up ends in a key!\" if $i == $#_;\n            push @criteria, [\n                scalar( $_[0]->_fold_case( $_[$i] ) ),\n                defined( $_[ $i + 1 ] )\n                ? ( ( ref $_[ $i + 1 ] ? $_[ $i + 1 ] : lc( $_[ $i + 1 ] ) ),\n                    ref( $_[ $i + 1 ] )\n                    )\n                : undef    # Yes, leave that LC!\n            ];\n            $i += 2;\n        }\n    }\n    Carp::croak \"No criteria?\" unless @criteria;\n\n    my ( @matching, $val );\n    my $this = $_[0];\nNode:\n    while (1) {\n\n       # You'll notice that the code here is almost the same as for look_down.\n        foreach my $c (@criteria) {\n            if ( ref($c) eq 'CODE' ) {\n                next Node unless $c->($this);    # jump to the continue block\n            }\n            else {                               # it's an attr-value pair\n                next Node                        # jump to the continue block\n                    if                           # two values are unequal if:\n                        ( defined( $val = $this->{ $c->[0] } ) )\n                    ? (     !defined $c->[ 1\n                                ]    # actual is def, critval is undef => fail\n                                or (\n                                  $c->[2] eq 'Regexp'\n                                ? $val !~ $c->[1]\n                                : ( ref $val ne $c->[2]\n\n                                        # have unequal ref values => fail\n                                        or lc($val) ne $c->[1]\n\n                                       # have unequal lc string values => fail\n                                )\n                                )\n                        )\n                    : (     defined $c->[1]\n                        )    # actual is undef, critval is def => fail\n            }\n        }\n\n        # We make it this far only if all the criteria passed.\n        return $this unless wantarray;\n        push @matching, $this;\n    }\n    continue {\n        last unless defined( $this = $this->{'_parent'} ) and ref $this;\n    }\n\n    return @matching if wantarray;\n    return;\n}\n\n#--------------------------------------------------------------------------\n\n\nsub attr_get_i {\n    if ( @_ > 2 ) {\n        my $self = shift;\n        Carp::croak \"No attribute names can be undef!\"\n            if grep !defined($_), @_;\n        my @attributes = $self->_fold_case(@_);\n        if (wantarray) {\n            my @out;\n            foreach my $x ( $self, $self->lineage ) {\n                push @out,\n                    map { exists( $x->{$_} ) ? $x->{$_} : () } @attributes;\n            }\n            return @out;\n        }\n        else {\n            foreach my $x ( $self, $self->lineage ) {\n                foreach my $attribute (@attributes) {\n                    return $x->{$attribute}\n                        if exists $x->{$attribute};    # found\n                }\n            }\n            return;                                    # never found\n        }\n    }\n    else {\n\n        # Single-attribute search.  Simpler, most common, so optimize\n        #  for the most common case\n        Carp::croak \"Attribute name must be a defined value!\"\n            unless defined $_[1];\n        my $self      = $_[0];\n        my $attribute = $self->_fold_case( $_[1] );\n        if (wantarray) {                               # list context\n            return\n                map { exists( $_->{$attribute} ) ? $", 8192) = 8192
09:01:57.444434 brk(0x1e79000)          = 0x1e79000
09:01:57.444695 read(8, "_->{$attribute} : () }\n                $self, $self->lineage;\n        }\n        else {                                         # scalar context\n            foreach my $x ( $self, $self->lineage ) {\n                return $x->{$attribute} if exists $x->{$attribute};    # found\n            }\n            return;    # never found\n        }\n    }\n}\n\n\nsub tagname_map {\n    my (@pile) = $_[0];    # start out the to-do stack for the traverser\n    Carp::croak \"find_by_tag_name can be called only as an object method\"\n        unless ref $pile[0];\n    my ( %map, $this_tag, $this );\n    while (@pile) {\n        $this_tag = ''\n            unless defined( $this_tag = ( $this = shift @pile )->{'_tag'} )\n        ;    # dance around the strange case of having an undef tagname.\n        push @{ $map{$this_tag} ||= [] }, $this;    # add to map\n        unshift @pile, grep ref($_),\n            @{ $this->{'_content'} || next };       # traverse\n    }\n    return \\%map;\n}\n\n\nsub extract_links {\n    my $start = shift;\n\n    my %wantType;\n    @wantType{ $start->_fold_case(@_) } = (1) x @_;    # if there were any\n    my $wantType = scalar(@_);\n\n    my @links;\n\n    # TODO: add xml:link?\n\n    my ( $link_attrs, $tag, $self, $val );    # scratch for each iteration\n    $start->traverse(\n        [   sub {                             # pre-order call only\n                $self = $_[0];\n\n                $tag = $self->{'_tag'};\n                return 1\n                    if $wantType && !$wantType{$tag};    # if we're selective\n\n                if (defined(\n                        $link_attrs = $HTML::Element::linkElements{$tag}\n                    )\n                    )\n                {\n\n                    # If this is a tag that has any link attributes,\n                    #  look over possibly present link attributes,\n                    #  saving the value, if found.\n                    for ( ref($link_attrs) ? @$link_attrs : $link_attrs ) {\n                        if ( defined( $val = $self->attr($_) ) ) {\n                            push( @links, [ $val, $self, $_, $tag ] );\n                        }\n                    }\n                }\n                1;    # return true, so we keep recursing\n            },\n            undef\n        ],\n        1,            # ignore text nodes\n    );\n    \\@links;\n}\n\n\nsub simplify_pres {\n    my $pre = 0;\n\n    my $sub;\n    my $line;\n    $sub = sub {\n        ++$pre if $_[0]->{'_tag'} eq 'pre';\n        foreach my $it ( @{ $_[0]->{'_content'} || return } ) {\n            if ( ref $it ) {\n                $sub->($it);    # recurse!\n            }\n            elsif ($pre) {\n\n                #$it =~ s/(?:(?:\\cm\\cj*)|(?:\\cj))/\\n/g;\n\n                $it = join \"\\n\", map {\n                    ;\n                    $line = $_;\n                    while (\n                        $line\n                        =~ s/^([^\\t]*)(\\t+)/$1.(\" \" x ((length($2)<<3)-(length($1)&7)))/e\n\n              # Sort of adapted from Text::Tabs -- yes, it's hardwired-in that\n              # tabs are at every EIGHTH column.\n                        )\n                    {\n                    }\n                    $line;\n                    }\n                    split /(?:(?:\\cm\\cj*)|(?:\\cj))/, $it, -1;\n            }\n        }\n        --$pre if $_[0]->{'_tag'} eq 'pre';\n        return;\n    };\n    $sub->( $_[0] );\n\n    undef $sub;\n    return;\n}\n\n\nsub same_as {\n    die 'same_as() takes only one argument: $h->same_as($i)' unless @_ == 2;\n    my ( $h, $i ) = @_[ 0, 1 ];\n    die \"same_as() can be called only as an object method\" unless ref $h;\n\n    return 0 unless defined $i and ref $i;\n\n    # An element can't be same_as anything but another element!\n    # They needn't be of the same class, tho.\n\n    return 1 if $h eq $i;\n\n    # special (if rare) case: anything is the same as... itself!\n\n    # assumes that no content lists in/under $h or $i contain subsequent\n    #  text segments, like: ['foo', ' bar']\n\n    # compare attributes now.\n    #print \"Comparing tags of $h and $i...\\n\";\n\n    return 0 unless $h->{'_tag'} eq $i->{'_tag'};\n\n    # only significant attribute whose name starts with \"_\"\n\n    #print \"Comparing attributes of $h and $i...\\n\";\n    # Compare attributes, but only the real ones.\n    {\n\n        # Bear in mind that the average element has very few attributes,\n        #  and that element names are rather short.\n        # (Values are a different story.)\n\n    # XXX I would think that /^[^_]/ would be faster, at least easier to read.\n        my @keys_h\n            = sort grep { length $_ and substr( $_, 0, 1 ) ne '_' } keys %$h;\n        my @keys_i\n            = sort grep { length $_ and substr( $_, 0, 1 ) ne '_' } keys %$i;\n\n        return 0 unless @keys_h == @keys_i;\n\n        # different number of real attributes?  they're different.\n        for ( my $x = 0; $x < @keys_h; ++$x ) {\n            return 0\n                unless $keys_h[$x] eq $keys_i[$x] and    # same key name\n                    $h->{ $keys_h[$x] } eq $i->{ $keys_h[$x] };   # same value\n             # Should this test for definedness on values?\n             # People shouldn't be putting undef in attribute values, I think.\n        }\n    }\n\n    #print \"Comparing children of $h and $i...\\n\";\n    my $hcl = $h->{'_content'} || [];\n    my $icl = $i->{'_content'} || [];\n\n    return 0 unless @$hcl == @$icl;\n\n    # different numbers of children?  they're different.\n\n    if (@$hcl) {\n\n        # compare each of the children:\n        for ( my $x = 0; $x < @$hcl; ++$x ) {\n            if ( ref $hcl->[$x] ) {\n                return 0 unless ref( $icl->[$x] );\n\n                # an element can't be the same as a text segment\n                # Both elements:\n                return 0 unless $hcl->[$x]->same_as( $icl->[$x] );  # RECURSE!\n            }\n            else {\n                return 0 if ref( $icl->[$x] );\n\n                # a text segment can't be the same as an element\n                # Both text segments:\n                return 0 unless $hcl->[$x] eq $icl->[$x];\n            }\n        }\n    }\n\n    return 1;    # passed all the tests!\n}\n\n\nsub new_from_lol {\n    my $class = shift;\n    $class = ref($class) || $class;\n\n  # calling as an object method is just the same as ref($h)->new_from_lol(...)\n    my $lol = $_[1];\n\n    my @ancestor_lols;\n\n    # So we can make sure there's no cyclicities in this lol.\n    # That would be perverse, but one never knows.\n    my ( $sub, $k, $v, $node );    # last three are scratch values\n    $sub = sub {\n\n        #print \"Building for $_[0]\\n\";\n        my $lol = $_[0];\n        return unless @$lol;\n        my ( @attributes, @children );\n        Carp::croak \"Cyclicity detected in source LOL tree, around $lol?!?\"\n            if grep( $_ eq $lol, @ancestor_lols );\n        push @ancestor_lols, $lol;\n\n        my $tag_name = 'null';\n\n        # Recursion in in here:\n        for ( my $i = 0; $i < @$lol; ++$i ) {    # Iterate over children\n            if ( ref( $lol->[$i] ) eq 'ARRAY' )\n            {    # subtree: most common thing in loltree\n                push @children, $sub->( $lol->[$i] );\n            }\n            elsif ( !ref( $lol->[$i] ) ) {\n                if ( $i == 0 ) {    # name\n                    $tag_name = $lol->[$i];\n                    Carp::croak \"\\\"$tag_name\\\" isn't a good tag name!\"\n                        if $tag_name =~ m/[<>\\/\\x00-\\x20]/\n                    ;               # minimal sanity, certainly!\n                }\n                else {              # text segment child\n                    push @children, $lol->[$i];\n                }\n            }\n            elsif ( ref( $lol->[$i] ) eq 'HASH' ) {    # attribute hashref\n                keys %{ $lol->[$i] };   # reset the each-counter, just in case\n                while ( ( $k, $v ) = each %{ $lol->[$i] } ) {\n                    push @attributes, $class->_fold_case($k), $v\n                        if defined $v\n                            and $k ne '_name'\n                            and $k ne '_content'\n                            and $k ne '_parent';\n\n                    # enforce /some/ sanity!\n                }\n            }\n            elsif ( UNIVERSAL::isa( $lol->[$i], __PACKAGE__ ) ) {\n                if ( $", 8192) = 8192
09:01:57.445654 brk(0x1e9a000)          = 0x1e9a000
09:01:57.445722 read(8, "lol->[$i]->{'_parent'} ) {    # if claimed\n                        #print \"About to clone \", $lol->[$i], \"\\n\";\n                    push @children, $lol->[$i]->clone();\n                }\n                else {\n                    push @children, $lol->[$i];    # if unclaimed...\n                         #print \"Claiming \", $lol->[$i], \"\\n\";\n                    $lol->[$i]->{'_parent'} = 1;    # claim it NOW\n                      # This WILL be replaced by the correct value once we actually\n                      #  construct the parent, just after the end of this loop...\n                }\n            }\n            else {\n                Carp::croak \"new_from_lol doesn't handle references of type \"\n                    . ref( $lol->[$i] );\n            }\n        }\n\n        pop @ancestor_lols;\n        $node = $class->new($tag_name);\n\n        #print \"Children: @children\\n\";\n\n        if ( $class eq __PACKAGE__ ) {    # Special-case it, for speed:\n            %$node = ( %$node, @attributes ) if @attributes;\n\n            #print join(' ', $node, ' ' , map(\"<$_>\", %$node), \"\\n\");\n            if (@children) {\n                $node->{'_content'} = \\@children;\n                foreach my $c (@children) {\n                    _weaken($c->{'_parent'} = $node)\n                        if ref $c;\n                }\n            }\n        }\n        else {                            # Do it the clean way...\n                                          #print \"Done neatly\\n\";\n            while (@attributes) { $node->attr( splice @attributes, 0, 2 ) }\n            $node->push_content(\n                  map { _weaken($_->{'_parent'} = $node) if ref $_; $_ }\n                    @children )\n                if @children;\n        }\n\n        return $node;\n    };\n\n    # End of sub definition.\n\n    if (wantarray) {\n        my (@nodes) = map { ; ( ref($_) eq 'ARRAY' ) ? $sub->($_) : $_ } @_;\n        # Let text bits pass thru, I guess.  This makes this act more like\n        #  unshift_content et al.  Undocumented.\n\n        undef $sub;\n        # so it won't be in its own frame, so its refcount can hit 0\n\n        return @nodes;\n    }\n    else {\n        Carp::croak \"new_from_lol in scalar context needs exactly one lol\"\n            unless @_ == 1;\n        return $_[0] unless ref( $_[0] ) eq 'ARRAY';\n        # used to be a fatal error.  still undocumented tho.\n\n        $node = $sub->( $_[0] );\n        undef $sub;\n        # so it won't be in its own frame, so its refcount can hit 0\n\n        return $node;\n    }\n}\n\n\nsub objectify_text {\n    my (@stack) = ( $_[0] );\n\n    my ($this);\n    while (@stack) {\n        foreach my $c ( @{ ( $this = shift @stack )->{'_content'} } ) {\n            if ( ref($c) ) {\n                unshift @stack, $c;    # visit it later.\n            }\n            else {\n                $c = $this->element_class->new(\n                    '~text',\n                    'text'    => $c,\n                    '_parent' => $this\n                );\n            }\n        }\n    }\n    return;\n}\n\nsub deobjectify_text {\n    my (@stack) = ( $_[0] );\n    my ($old_node);\n\n    if ( $_[0]{'_tag'} eq '~text' ) {    # special case\n            # Puts the $old_node variable to a different purpose\n        if ( $_[0]{'_parent'} ) {\n            $_[0]->replace_with( $old_node = delete $_[0]{'text'} )->delete;\n        }\n        else {    # well, that's that, then!\n            $old_node = delete $_[0]{'text'};\n        }\n\n        if ( ref( $_[0] ) eq __PACKAGE__ ) {    # common case\n            %{ $_[0] } = ();                    # poof!\n        }\n        else {\n\n            # play nice:\n            delete $_[0]{'_parent'};\n            $_[0]->delete;\n        }\n        return '' unless defined $old_node;     # sanity!\n        return $old_node;\n    }\n\n    while (@stack) {\n        foreach my $c ( @{ ( shift @stack )->{'_content'} } ) {\n            if ( ref($c) ) {\n                if ( $c->{'_tag'} eq '~text' ) {\n                    $c = ( $old_node = $c )->{'text'};\n                    if ( ref($old_node) eq __PACKAGE__ ) {    # common case\n                        %$old_node = ();                      # poof!\n                    }\n                    else {\n\n                        # play nice:\n                        delete $old_node->{'_parent'};\n                        $old_node->delete;\n                    }\n                }\n                else {\n                    unshift @stack, $c;    # visit it later.\n                }\n            }\n        }\n    }\n\n    return undef;\n}\n\n\n{\n\n    # The next three subs are basically copied from Number::Latin,\n    # based on a one-liner by Abigail.  Yes, I could simply require that\n    # module, and a Roman numeral module too, but really, HTML-Tree already\n    # has enough dependecies as it is; and anyhow, I don't need the functions\n    # that do latin2int or roman2int.\n    no integer;\n\n    sub _int2latin {\n        return unless defined $_[0];\n        return '0' if $_[0] < 1 and $_[0] > -1;\n        return '-' . _i2l( abs int $_[0] )\n            if $_[0] <= -1;    # tolerate negatives\n        return _i2l( int $_[0] );\n    }\n\n    sub _int2LATIN {\n\n        # just the above plus uc\n        return unless defined $_[0];\n        return '0' if $_[0] < 1 and $_[0] > -1;\n        return '-' . uc( _i2l( abs int $_[0] ) )\n            if $_[0] <= -1;    # tolerate negs\n        return uc( _i2l( int $_[0] ) );\n    }\n\n    my @alpha = ( 'a' .. 'z' );\n\n    sub _i2l {                 # the real work\n        my $int = $_[0] || return \"\";\n        _i2l( int( ( $int - 1 ) / 26 ) )\n            . $alpha[ $int % 26 - 1 ];    # yes, recursive\n            # Yes, 26 => is (26 % 26 - 1), which is -1 => Z!\n    }\n}\n\n{\n\n    # And now, some much less impressive Roman numerals code:\n\n    my (@i) = ( '', qw(I II III IV V VI VII VIII IX) );\n    my (@x) = ( '', qw(X XX XXX XL L LX LXX LXXX XC) );\n    my (@c) = ( '', qw(C CC CCC CD D DC DCC DCCC CM) );\n    my (@m) = ( '', qw(M MM MMM) );\n\n    sub _int2ROMAN {\n        my ( $i, $pref );\n        return '0'\n            if 0 == ( $i = int( $_[0] || 0 ) );    # zero is a special case\n        return $i + 0 if $i <= -4000 or $i >= 4000;\n\n       # Because over 3999 would require non-ASCII chars, like D-with-)-inside\n        if ( $i < 0 ) {    # grumble grumble tolerate negatives grumble\n            $pref = '-';\n            $i    = abs($i);\n        }\n        else {\n            $pref = '';    # normal case\n        }\n\n        my ( $x, $c, $m ) = ( 0, 0, 0 );\n        if ( $i >= 10 ) {\n            $x = $i / 10;\n            $i %= 10;\n            if ( $x >= 10 ) {\n                $c = $x / 10;\n                $x %= 10;\n                if ( $c >= 10 ) { $m = $c / 10; $c %= 10; }\n            }\n        }\n\n        #print \"m$m c$c x$x i$i\\n\";\n\n        return join( '', $pref, $m[$m], $c[$c], $x[$x], $i[$i] );\n    }\n\n    sub _int2roman { lc( _int2ROMAN( $_[0] ) ) }\n}\n\nsub _int2int { $_[0] }    # dummy\n\n%list_type_to_sub = (\n    'I' => \\&_int2ROMAN,\n    'i' => \\&_int2roman,\n    'A' => \\&_int2LATIN,\n    'a' => \\&_int2latin,\n    '1' => \\&_int2int,\n);\n\nsub number_lists {\n    my (@stack) = ( $_[0] );\n    my ( $this, $tag, $counter, $numberer );    # scratch\n    while (@stack) {    # yup, pre-order-traverser idiom\n        if ( ( $tag = ( $this = shift @stack )->{'_tag'} ) eq 'ol' ) {\n\n            # Prep some things:\n            $counter\n                = ( ( $this->{'start'} || '' ) =~ m<^\\s*(\\d{1,7})\\s*$>s )\n                ? $1\n                : 1;\n            $numberer = $list_type_to_sub{ $this->{'type'} || '' }\n                || $list_type_to_sub{'1'};\n\n            # Immeditately iterate over all children\n            foreach my $c ( @{ $this->{'_content'} || next } ) {\n                next unless ref $c;\n                unshift @stack, $c;\n                if ( $c->{'_tag'} eq 'li' ) {\n                    $counter = $1\n                        if (\n                        ( $c->{'value'} || '' ) =~ m<^\\s*(\\d{1,7})\\s*$>s );\n                    $c->{'_bullet'} = $numberer->($counter) . '.';\n                    ++$counter;\n                }\n            }\n\n        }\n        elsif ( $tag eq 'ul' or $tag eq 'dir' or $tag eq 'menu' ) {\n\n            # Immeditately iterate over all c", 8192) = 8192
09:01:57.446834 read(8, "hildren\n            foreach my $c ( @{ $this->{'_content'} || next } ) {\n                next unless ref $c;\n                unshift @stack, $c;\n                $c->{'_bullet'} = '*' if $c->{'_tag'} eq 'li';\n            }\n\n        }\n        else {\n            foreach my $c ( @{ $this->{'_content'} || next } ) {\n                unshift @stack, $c if ref $c;\n            }\n        }\n    }\n    return;\n}\n\n\nsub has_insane_linkage {\n    my @pile = ( $_[0] );\n    my ( $c, $i, $p, $this );    # scratch\n\n    # Another iterative traverser; this time much simpler because\n    #  only in pre-order:\n    my %parent_of = ( $_[0], 'TOP-OF-SCAN' );\n    while (@pile) {\n        $this = shift @pile;\n        $c = $this->{'_content'} || next;\n        return ( $this, \"_content attribute is true but nonref.\" )\n            unless ref($c) eq 'ARRAY';\n        next unless @$c;\n        for ( $i = 0; $i < @$c; ++$i ) {\n            return ( $this, \"Child $i is undef\" )\n                unless defined $c->[$i];\n            if ( ref( $c->[$i] ) ) {\n                return ( $c->[$i], \"appears in its own content list\" )\n                    if $c->[$i] eq $this;\n                return ( $c->[$i],\n                    \"appears twice in the tree: once under $this, once under $parent_of{$c->[$i]}\"\n                ) if exists $parent_of{ $c->[$i] };\n                $parent_of{ $c->[$i] } = '' . $this;\n\n                # might as well just use the stringification of it.\n\n                return ( $c->[$i],\n                    \"_parent attribute is wrong (not defined)\" )\n                    unless defined( $p = $c->[$i]{'_parent'} );\n                return ( $c->[$i], \"_parent attribute is wrong (nonref)\" )\n                    unless ref($p);\n                return ( $c->[$i],\n                    \"_parent attribute is wrong (is $p; should be $this)\" )\n                    unless $p eq $this;\n            }\n        }\n        unshift @pile, grep ref($_), @$c;\n\n        # queue up more things on the pile stack\n    }\n    return;    #okay\n}\n\nsub _asserts_fail {    # to be run on trusted documents only\n    my (@pile) = ( $_[0] );\n    my ( @errors, $this, $id, $assert, $parent, $rv );\n    while (@pile) {\n        $this = shift @pile;\n        if ( defined( $assert = $this->{'assert'} ) ) {\n            $id = ( $this->{'id'} ||= $this->address )\n                ;      # don't use '0' as an ID, okay?\n            unless ( ref($assert) ) {\n\n                package main;\n## no critic\n                $assert = $this->{'assert'} = (\n                    $assert =~ m/\\bsub\\b/\n                    ? eval($assert)\n                    : eval(\"sub {  $assert\\n}\")\n                );\n## use critic\n                if ($@) {\n                    push @errors,\n                        [ $this, \"assertion at $id broke in eval: $@\" ];\n                    $assert = $this->{'assert'} = sub { };\n                }\n            }\n            $parent = $this->{'_parent'};\n            $rv     = undef;\n            eval {\n                $rv = $assert->(\n                    $this, $this->{'_tag'}, $this->{'_id'},    # 0,1,2\n                    $parent\n                    ? ( $parent, $parent->{'_tag'}, $parent->{'id'} )\n                    : ()                                       # 3,4,5\n                );\n            };\n            if ($@) {\n                push @errors, [ $this, \"assertion at $id died: $@\" ];\n            }\n            elsif ( !$rv ) {\n                push @errors, [ $this, \"assertion at $id failed\" ];\n            }\n\n            # else OK\n        }\n        push @pile, grep ref($_), @{ $this->{'_content'} || next };\n    }\n    return @errors;\n}\n\n## _valid_name\n#  validate XML style attribute names\n#  http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-Name\n\nsub _valid_name {\n    my $self = shift;\n    my $attr = shift\n        or Carp::croak(\"sub valid_name requires an attribute name\");\n\n    return (0) unless ( $attr =~ /^$START_CHAR$NAME_CHAR+$/ );\n\n    return (1);\n}\n\n\nsub element_class {\n    $_[0]->{_element_class} || __PACKAGE__;\n}\n\n1;\n\n\n1;\n\n__END__\n=pod\n\n=head1 NAME\n\nHTML::Element - Class for objects that represent HTML elements\n\n=head1 VERSION\n\nThis document describes version 5.02 of\nHTML::Element, released June 27, 2012\nas part of L<HTML-Tree|HTML::Tree>.\n\n=head1 SYNOPSIS\n\n    use HTML::Element;\n    $a = HTML::Element->new('a', href => 'http://www.perl.com/');\n    $a->push_content(\"The Perl Homepage\");\n\n    $tag = $a->tag;\n    print \"$tag starts out as:\",  $a->starttag, \"\\n\";\n    print \"$tag ends as:\",  $a->endtag, \"\\n\";\n    print \"$tag\\'s href attribute is: \", $a->attr('href'), \"\\n\";\n\n    $links_r = $a->extract_links();\n    print \"Hey, I found \", scalar(@$links_r), \" links.\\n\";\n\n    print \"And that, as HTML, is: \", $a->as_HTML, \"\\n\";\n    $a = $a->delete;\n\n=head1 DESCRIPTION\n\n(This class is part of the L<HTML::Tree|HTML::Tree> dist.)\n\nObjects of the HTML::Element class can be used to represent elements\nof HTML document trees.  These objects have attributes, notably attributes that\ndesignates each element's parent and content.  The content is an array\nof text segments and other HTML::Element objects.  A tree with HTML::Element\nobjects as nodes can represent the syntax tree for a HTML document.\n\n=head1 HOW WE REPRESENT TREES\n\nConsider this HTML document:\n\n  <html lang='en-US'>\n    <head>\n      <title>Stuff</title>\n      <meta name='author' content='Jojo'>\n    </head>\n    <body>\n     <h1>I like potatoes!</h1>\n    </body>\n  </html>\n\nBuilding a syntax tree out of it makes a tree-structure in memory\nthat could be diagrammed as:\n\n                     html (lang='en-US')\n                      / \\\n                    /     \\\n                  /         \\\n                head        body\n               /\\               \\\n             /    \\               \\\n           /        \\               \\\n         title     meta              h1\n          |       (name='author',     |\n       \"Stuff\"    content='Jojo')    \"I like potatoes\"\n\nThis is the traditional way to diagram a tree, with the \"root\" at the\ntop, and it's this kind of diagram that people have in mind when they\nsay, for example, that \"the meta element is under the head element\ninstead of under the body element\".  (The same is also said with\n\"inside\" instead of \"under\" -- the use of \"inside\" makes more sense\nwhen you're looking at the HTML source.)\n\nAnother way to represent the above tree is with indenting:\n\n  html (attributes: lang='en-US')\n    head\n      title\n        \"Stuff\"\n      meta (attributes: name='author' content='Jojo')\n    body\n      h1\n        \"I like potatoes\"\n\nIncidentally, diagramming with indenting works much better for very\nlarge trees, and is easier for a program to generate.  The C<< $tree->dump >>\nmethod uses indentation just that way.\n\nHowever you diagram the tree, it's stored the same in memory -- it's a\nnetwork of objects, each of which has attributes like so:\n\n  element #1:  _tag: 'html'\n               _parent: none\n               _content: [element #2, element #5]\n               lang: 'en-US'\n\n  element #2:  _tag: 'head'\n               _parent: element #1\n               _content: [element #3, element #4]\n\n  element #3:  _tag: 'title'\n               _parent: element #2\n               _content: [text segment \"Stuff\"]\n\n  element #4   _tag: 'meta'\n               _parent: element #2\n               _content: none\n               name: author\n               content: Jojo\n\n  element #5   _tag: 'body'\n               _parent: element #1\n               _content: [element #6]\n\n  element #6   _tag: 'h1'\n               _parent: element #5\n               _content: [text segment \"I like potatoes\"]\n\nThe \"treeness\" of the tree-structure that these elements comprise is\nnot an aspect of any particular object, but is emergent from the\nrelatedness attributes (_parent and _content) of these element-objects\nand from how you use them to get from element to element.\n\nWhile you could access the content of a tree by writing code that says\n\"access the 'src' attribute of the root's I<first> child's I<seventh>\nchild's I<third> child\", you're more likely to have to scan the contents\nof a tree, looking for whatever nodes, or kinds of nodes, you want to\ndo something with.  Th", 8192) = 8192
09:01:57.447305 brk(0x1ebb000)          = 0x1ebb000
09:01:57.447655 lseek(8, 85969, SEEK_SET) = 85969
09:01:57.447703 lseek(8, 0, SEEK_CUR)   = 85969
09:01:57.447748 close(8)                = 0
09:01:57.448379 read(7, "own',      @_ ); }\nsub ignore_text         { shift->_elem( '_ignore_text',         @_ ); }\nsub ignore_ignorable_whitespace { shift->_elem( '_tighten',            @_ ); }\nsub store_comments              { shift->_elem( '_store_comments',     @_ ); }\nsub store_declarations          { shift->_elem( '_store_declarations', @_ ); }\nsub store_pis                   { shift->_elem( '_store_pis',          @_ ); }\nsub warn                        { shift->_elem( '_warn',               @_ ); }\n\nsub no_expand_entities {\n    shift->_elem( '_no_expand_entities', @_ );\n    $HTML::Element::encoded_content = @_;\n}\n\n#==========================================================================\n\nsub warning {\n    my $self = shift;\n    CORE::warn(\"HTML::Parse: $_[0]\\n\") if $self->{'_warn'};\n\n    # should maybe say HTML::TreeBuilder instead\n}\n\n#==========================================================================\n\n{\n\n    # To avoid having to rebuild these lists constantly...\n    my $_Closed_by_structurals = [qw(p h1 h2 h3 h4 h5 h6 pre textarea)];\n    my $indent;\n\n    sub start {\n        return if $_[0]{'_stunted'};\n\n        # Accept a signal from HTML::Parser for start-tags.\n        my ( $self, $tag, $attr ) = @_;\n\n        # Parser passes more, actually:\n        #   $self->start($tag, $attr, $attrseq, $origtext)\n        # But we can merrily ignore $attrseq and $origtext.\n\n        if ( $tag eq 'x-html' ) {\n            print \"Ignoring open-x-html tag.\\n\" if DEBUG;\n\n            # inserted by some lame code-generators.\n            return;    # bypass tweaking.\n        }\n\n        $tag =~ s{/$}{}s;    # So <b/> turns into <b>.  Silently forgive.\n\n        unless ( $tag =~ m/^[-_a-zA-Z0-9:%]+$/s ) {\n            DEBUG and print \"Start-tag name $tag is no good.  Skipping.\\n\";\n            return;\n\n            # This avoids having Element's new() throw an exception.\n        }\n\n        my $ptag = ( my $pos = $self->{'_pos'} || $self )->{'_tag'};\n        my $already_inserted;\n\n        #my($indent);\n        if (DEBUG) {\n\n       # optimization -- don't figure out indenting unless we're in debug mode\n            my @lineage = $pos->lineage;\n            $indent = '  ' x ( 1 + @lineage );\n            print $indent, \"Proposing a new \\U$tag\\E under \",\n                join( '/', map $_->{'_tag'}, reverse( $pos, @lineage ) )\n                || 'Root',\n                \".\\n\";\n\n            #} else {\n            #  $indent = ' ';\n        }\n\n        #print $indent, \"POS: $pos ($ptag)\\n\" if DEBUG > 2;\n        # $attr = {%$attr};\n\n        foreach my $k ( keys %$attr ) {\n\n            # Make sure some stooge doesn't have \"<span _content='pie'>\".\n            # That happens every few million Web pages.\n            $attr->{ ' ' . $k } = delete $attr->{$k}\n                if length $k and substr( $k, 0, 1 ) eq '_';\n\n            # Looks bad, but is fine for round-tripping.\n        }\n\n        my $e = $self->element_class->new( $tag, %$attr );\n\n        # Make a new element object.\n        # (Only rarely do we end up just throwing it away later in this call.)\n\n      # Some prep -- custom messiness for those damned tables, and strict P's.\n        if ( $self->{'_implicit_tags'} ) {    # wallawallawalla!\n\n            unless ( $HTML::TreeBuilder::isTableElement{$tag} ) {\n                if ( $ptag eq 'table' ) {\n                    print $indent,\n                        \" * Phrasal \\U$tag\\E right under TABLE makes implicit TR and TD\\n\"\n                        if DEBUG > 1;\n                    $self->insert_element( 'tr', 1 );\n                    $pos = $self->insert_element( 'td', 1 )\n                        ;                     # yes, needs updating\n                }\n                elsif ( $ptag eq 'tr' ) {\n                    print $indent,\n                        \" * Phrasal \\U$tag\\E right under TR makes an implicit TD\\n\"\n                        if DEBUG > 1;\n                    $pos = $self->insert_element( 'td', 1 )\n                        ;                     # yes, needs updating\n                }\n                $ptag = $pos->{'_tag'};       # yes, needs updating\n            }\n\n            # end of table-implication block.\n\n            # Now maybe do a little dance to enforce P-strictness.\n            # This seems like it should be integrated with the big\n            # \"ALL HOPE...\" block, further below, but that doesn't\n            # seem feasable.\n            if (    $self->{'_p_strict'}\n                and $HTML::TreeBuilder::isKnown{$tag}\n                and not $HTML::Tagset::is_Possible_Strict_P_Content{$tag} )\n            {\n                my $here     = $pos;\n                my $here_tag = $ptag;\n                while (1) {\n                    if ( $here_tag eq 'p' ) {\n                        print $indent, \" * Inserting $tag closes strict P.\\n\"\n                            if DEBUG > 1;\n                        $self->end( \\q{p} );\n\n                    # NB: same as \\'q', but less confusing to emacs cperl-mode\n                        last;\n                    }\n\n                    #print(\"Lasting from $here_tag\\n\"),\n                    last\n                        if $HTML::TreeBuilder::isKnown{$here_tag}\n                            and\n                            not $HTML::Tagset::is_Possible_Strict_P_Content{\n                                $here_tag};\n\n               # Don't keep looking up the tree if we see something that can't\n               #  be strict-P content.\n\n                    $here_tag\n                        = ( $here = $here->{'_parent'} || last )->{'_tag'};\n                }    # end while\n                $ptag = ( $pos = $self->{'_pos'} || $self )\n                    ->{'_tag'};    # better update!\n            }\n\n            # end of strict-p block.\n        }\n\n       # And now, get busy...\n       #----------------------------------------------------------------------\n        if ( !$self->{'_implicit_tags'} ) {    # bimskalabim\n                                               # do nothing\n            print $indent, \" * _implicit_tags is off.  doing nothing\\n\"\n                if DEBUG > 1;\n\n       #----------------------------------------------------------------------\n        }\n        elsif ( $HTML::TreeBuilder::isHeadOrBodyElement{$tag} ) {\n            if ( $pos->is_inside('body') ) {    # all is well\n                print $indent,\n                    \" * ambilocal element \\U$tag\\E is fine under BODY.\\n\"\n                    if DEBUG > 1;\n            }\n            elsif ( $pos->is_inside('head') ) {\n                print $indent,\n                    \" * ambilocal element \\U$tag\\E is fine under HEAD.\\n\"\n                    if DEBUG > 1;\n            }\n            else {\n\n                # In neither head nor body!  mmmmm... put under head?\n\n                if ( $ptag eq 'html' ) {    # expected case\n                     # TODO?? : would there ever be a case where _head would be\n                     #  absent from a tree that would ever be accessed at this\n                     #  point?\n                    die \"Where'd my head go?\" unless ref $self->{'_head'};\n                    if ( $self->{'_head'}{'_implicit'} ) {\n                        print $indent,\n                            \" * ambilocal element \\U$tag\\E makes an implicit HEAD.\\n\"\n                            if DEBUG > 1;\n\n                        # or rather, points us at it.\n                        $self->{'_pos'}\n                            = $self->{'_head'};    # to insert under...\n                    }\n                    else {\n                        $self->warning(\n                            \"Ambilocal element <$tag> not under HEAD or BODY!?\"\n                        );\n\n                        # Put it under HEAD by default, I guess\n                        $self->{'_pos'}\n                            = $self->{'_head'};    # to insert under...\n                    }\n\n                }\n                else {\n\n             # Neither under head nor body, nor right under html... pass thru?\n                    $self->warning(\n                        \"Ambilocal element <$tag> neither under head nor body, nor right under html!?\"\n                    );\n                }\n            }\n\n       #---------------", 8192) = 8192
09:01:57.449044 brk(0x1edc000)          = 0x1edc000
09:01:57.449301 read(7, "-------------------------------------------------------\n        }\n        elsif ( $HTML::TreeBuilder::isBodyElement{$tag} ) {\n\n            # Ensure that we are within <body>\n            if ( $ptag eq 'body' ) {\n\n                # We're good.\n            }\n            elsif (\n                $HTML::TreeBuilder::isBodyElement{$ptag}    # glarg\n                and not $HTML::TreeBuilder::isHeadOrBodyElement{$ptag}\n                )\n            {\n\n              # Special case: Save ourselves a call to is_inside further down.\n              # If our $ptag is an isBodyElement element (but not an\n              # isHeadOrBodyElement element), then we must be under body!\n                print $indent, \" * Inferring that $ptag is under BODY.\\n\",\n                    if DEBUG > 3;\n\n                # I think this and the test for 'body' trap everything\n                # bodyworthy, except the case where the parent element is\n                # under an unknown element that's a descendant of body.\n            }\n            elsif ( $pos->is_inside('head') ) {\n                print $indent,\n                    \" * body-element \\U$tag\\E minimizes HEAD, makes implicit BODY.\\n\"\n                    if DEBUG > 1;\n                $ptag = (\n                    $pos = $self->{'_pos'}\n                        = $self->{'_body'}    # yes, needs updating\n                        || die \"Where'd my body go?\"\n                )->{'_tag'};                  # yes, needs updating\n            }\n            elsif ( !$pos->is_inside('body') ) {\n                print $indent,\n                    \" * body-element \\U$tag\\E makes implicit BODY.\\n\"\n                    if DEBUG > 1;\n                $ptag = (\n                    $pos = $self->{'_pos'}\n                        = $self->{'_body'}    # yes, needs updating\n                        || die \"Where'd my body go?\"\n                )->{'_tag'};                  # yes, needs updating\n            }\n\n            # else we ARE under body, so okay.\n\n            # Handle implicit endings and insert based on <tag> and position\n            # ... ALL HOPE ABANDON ALL YE WHO ENTER HERE ...\n            if (   $tag eq 'p'\n                or $tag eq 'h1'\n                or $tag eq 'h2'\n                or $tag eq 'h3'\n                or $tag eq 'h4'\n                or $tag eq 'h5'\n                or $tag eq 'h6'\n                or $tag eq 'form'\n\n                # Hm, should <form> really be here?!\n                )\n            {\n\n                # Can't have <p>, <h#> or <form> inside these\n                $self->end(\n                    $_Closed_by_structurals,\n                    @HTML::TreeBuilder::p_closure_barriers\n\n                        # used to be just li!\n                );\n\n            }\n            elsif ( $tag eq 'ol' or $tag eq 'ul' or $tag eq 'dl' ) {\n\n                # Can't have lists inside <h#> -- in the unlikely\n                #  event anyone tries to put them there!\n                if (   $ptag eq 'h1'\n                    or $ptag eq 'h2'\n                    or $ptag eq 'h3'\n                    or $ptag eq 'h4'\n                    or $ptag eq 'h5'\n                    or $ptag eq 'h6' )\n                {\n                    $self->end( \\$ptag );\n                }\n\n                # TODO: Maybe keep closing up the tree until\n                #  the ptag isn't any of the above?\n                # But anyone that says <h1><h2><ul>...\n                #  deserves what they get anyway.\n\n            }\n            elsif ( $tag eq 'li' ) {    # list item\n                    # Get under a list tag, one way or another\n                unless (\n                    exists $HTML::TreeBuilder::isList{$ptag}\n                    or $self->end( \\q{*}, keys %HTML::TreeBuilder::isList ) #'\n                    )\n                {\n                    print $indent,\n                        \" * inserting implicit UL for lack of containing \",\n                        join( '|', keys %HTML::TreeBuilder::isList ), \".\\n\"\n                        if DEBUG > 1;\n                    $self->insert_element( 'ul', 1 );\n                }\n\n            }\n            elsif ( $tag eq 'dt' or $tag eq 'dd' ) {\n\n                # Get under a DL, one way or another\n                unless ( $ptag eq 'dl' or $self->end( \\q{*}, 'dl' ) ) {    #'\n                    print $indent,\n                        \" * inserting implicit DL for lack of containing DL.\\n\"\n                        if DEBUG > 1;\n                    $self->insert_element( 'dl', 1 );\n                }\n\n            }\n            elsif ( $HTML::TreeBuilder::isFormElement{$tag} ) {\n                if ($self->{\n                        '_ignore_formies_outside_form'}  # TODO: document this\n                    and not $pos->is_inside('form')\n                    )\n                {\n                    print $indent,\n                        \" * ignoring \\U$tag\\E because not in a FORM.\\n\"\n                        if DEBUG > 1;\n                    return;                              # bypass tweaking.\n                }\n                if ( $tag eq 'option' ) {\n\n                    # return unless $ptag eq 'select';\n                    $self->end( \\q{option} );\n                    $ptag = ( $self->{'_pos'} || $self )->{'_tag'};\n                    unless ( $ptag eq 'select' or $ptag eq 'optgroup' ) {\n                        print $indent,\n                            \" * \\U$tag\\E makes an implicit SELECT.\\n\"\n                            if DEBUG > 1;\n                        $pos = $self->insert_element( 'select', 1 );\n\n                    # but not a very useful select -- has no 'name' attribute!\n                    # is $pos's value used after this?\n                    }\n                }\n            }\n            elsif ( $HTML::TreeBuilder::isTableElement{$tag} ) {\n                if ( !$pos->is_inside('table') ) {\n                    print $indent, \" * \\U$tag\\E makes an implicit TABLE\\n\"\n                        if DEBUG > 1;\n                    $self->insert_element( 'table', 1 );\n                }\n\n                if ( $tag eq 'td' or $tag eq 'th' ) {\n\n                    # Get under a tr one way or another\n                    unless (\n                        $ptag eq 'tr'    # either under a tr\n                        or $self->end( \\q{*}, 'tr',\n                            'table' )    #or we can get under one\n                        )\n                    {\n                        print $indent,\n                            \" * \\U$tag\\E under \\U$ptag\\E makes an implicit TR\\n\"\n                            if DEBUG > 1;\n                        $self->insert_element( 'tr', 1 );\n\n                        # presumably pos's value isn't used after this.\n                    }\n                }\n                else {\n                    $self->end( \\$tag, 'table' );    #'\n                }\n\n                # Hmm, I guess this is right.  To work it out:\n                #   tr closes any open tr (limited at a table)\n                #   thead closes any open thead (limited at a table)\n                #   tbody closes any open tbody (limited at a table)\n                #   tfoot closes any open tfoot (limited at a table)\n                #   colgroup closes any open colgroup (limited at a table)\n                #   col can try, but will always fail, at the enclosing table,\n                #     as col is empty, and therefore never open!\n                # But!\n                #   td closes any open td OR th (limited at a table)\n                #   th closes any open th OR td (limited at a table)\n                #   ...implementable as \"close to a tr, or make a tr\"\n\n            }\n            elsif ( $HTML::TreeBuilder::isPhraseMarkup{$tag} ) {\n                if ( $ptag eq 'body' and $self->{'_implicit_body_p_tag'} ) {\n                    print\n                        \" * Phrasal \\U$tag\\E right under BODY makes an implicit P\\n\"\n                        if DEBUG > 1;\n                    $pos = $self->insert_element( 'p', 1 );\n\n                    # is $pos's value used after this?\n                }\n            }\n\n            # End of implicit endings logic\n\n       # End of \"elsif ($HTML::TreeBuilder::isBodyElement{$tag}\"\n       #-----", 8192) = 8192
09:01:57.450035 read(7, "-----------------------------------------------------------------\n\n        }\n        elsif ( $HTML::TreeBuilder::isHeadElement{$tag} ) {\n            if ( $pos->is_inside('body') ) {\n                print $indent, \" * head element \\U$tag\\E found inside BODY!\\n\"\n                    if DEBUG;\n                $self->warning(\"Header element <$tag> in body\");    # [sic]\n            }\n            elsif ( !$pos->is_inside('head') ) {\n                print $indent,\n                    \" * head element \\U$tag\\E makes an implicit HEAD.\\n\"\n                    if DEBUG > 1;\n            }\n            else {\n                print $indent,\n                    \" * head element \\U$tag\\E goes inside existing HEAD.\\n\"\n                    if DEBUG > 1;\n            }\n            $self->{'_pos'} = $self->{'_head'} || die \"Where'd my head go?\";\n\n       #----------------------------------------------------------------------\n        }\n        elsif ( $tag eq 'html' ) {\n            if ( delete $self->{'_implicit'} ) {    # first time here\n                print $indent, \" * good! found the real HTML element!\\n\"\n                    if DEBUG > 1;\n            }\n            else {\n                print $indent, \" * Found a second HTML element\\n\"\n                    if DEBUG;\n                $self->warning(\"Found a nested <html> element\");\n            }\n\n            # in either case, migrate attributes to the real element\n            for ( keys %$attr ) {\n                $self->attr( $_, $attr->{$_} );\n            }\n            $self->{'_pos'} = undef;\n            return $self;    # bypass tweaking.\n\n       #----------------------------------------------------------------------\n        }\n        elsif ( $tag eq 'head' ) {\n            my $head = $self->{'_head'} || die \"Where'd my head go?\";\n            if ( delete $head->{'_implicit'} ) {    # first time here\n                print $indent, \" * good! found the real HEAD element!\\n\"\n                    if DEBUG > 1;\n            }\n            else {                                  # been here before\n                print $indent, \" * Found a second HEAD element\\n\"\n                    if DEBUG;\n                $self->warning(\"Found a second <head> element\");\n            }\n\n            # in either case, migrate attributes to the real element\n            for ( keys %$attr ) {\n                $head->attr( $_, $attr->{$_} );\n            }\n            return $self->{'_pos'} = $head;         # bypass tweaking.\n\n       #----------------------------------------------------------------------\n        }\n        elsif ( $tag eq 'body' ) {\n            my $body = $self->{'_body'} || die \"Where'd my body go?\";\n            if ( delete $body->{'_implicit'} ) {    # first time here\n                print $indent, \" * good! found the real BODY element!\\n\"\n                    if DEBUG > 1;\n            }\n            else {                                  # been here before\n                print $indent, \" * Found a second BODY element\\n\"\n                    if DEBUG;\n                $self->warning(\"Found a second <body> element\");\n            }\n\n            # in either case, migrate attributes to the real element\n            for ( keys %$attr ) {\n                $body->attr( $_, $attr->{$_} );\n            }\n            return $self->{'_pos'} = $body;         # bypass tweaking.\n\n       #----------------------------------------------------------------------\n        }\n        elsif ( $tag eq 'frameset' ) {\n            if (!( $self->{'_frameset_seen'}++ )    # first frameset seen\n                and !$self->{'_noframes_seen'}\n\n                # otherwise it'll be under the noframes already\n                and !$self->is_inside('body')\n                )\n            {\n\n           # The following is a bit of a hack.  We don't use the normal\n           #  insert_element because 1) we don't want it as _pos, but instead\n           #  right under $self, and 2), more importantly, that we don't want\n           #  this inserted at the /end/ of $self's content_list, but instead\n           #  in the middle of it, specifically right before the body element.\n           #\n                my $c    = $self->{'_content'} || die \"Contentless root?\";\n                my $body = $self->{'_body'}    || die \"Where'd my BODY go?\";\n                for ( my $i = 0; $i < @$c; ++$i ) {\n                    if ( $c->[$i] eq $body ) {\n                        splice( @$c, $i, 0, $self->{'_pos'} = $pos = $e );\n                        HTML::Element::_weaken($e->{'_parent'} = $self);\n                        $already_inserted = 1;\n                        print $indent,\n                            \" * inserting 'frameset' right before BODY.\\n\"\n                            if DEBUG > 1;\n                        last;\n                    }\n                }\n                die \"BODY not found in children of root?\"\n                    unless $already_inserted;\n            }\n\n        }\n        elsif ( $tag eq 'frame' ) {\n\n            # Okay, fine, pass thru.\n            # Should probably enforce that these should be under a frameset.\n            # But hey.  Ditto for enforcing that 'noframes' should be under\n            # a 'frameset', as the DTDs say.\n\n        }\n        elsif ( $tag eq 'noframes' ) {\n\n           # This basically assumes there'll be exactly one 'noframes' element\n           #  per document.  At least, only the first one gets to have the\n           #  body under it.  And if there are no noframes elements, then\n           #  the body pretty much stays where it is.  Is that ever a problem?\n            if ( $self->{'_noframes_seen'}++ ) {\n                print $indent, \" * ANOTHER noframes element?\\n\" if DEBUG;\n            }\n            else {\n                if ( $pos->is_inside('body') ) {\n                    print $indent, \" * 'noframes' inside 'body'.  Odd!\\n\"\n                        if DEBUG;\n\n               # In that odd case, we /can't/ make body a child of 'noframes',\n               # because it's an ancestor of the 'noframes'!\n                }\n                else {\n                    $e->push_content( $self->{'_body'}\n                            || die \"Where'd my body go?\" );\n                    print $indent, \" * Moving body to be under noframes.\\n\"\n                        if DEBUG;\n                }\n            }\n\n       #----------------------------------------------------------------------\n        }\n        else {\n\n            # unknown tag\n            if ( $self->{'_ignore_unknown'} ) {\n                print $indent, \" * Ignoring unknown tag \\U$tag\\E\\n\" if DEBUG;\n                $self->warning(\"Skipping unknown tag $tag\");\n                return;\n            }\n            else {\n                print $indent, \" * Accepting unknown tag \\U$tag\\E\\n\"\n                    if DEBUG;\n            }\n        }\n\n       #----------------------------------------------------------------------\n       # End of mumbo-jumbo\n\n        print $indent, \"(Attaching \", $e->{'_tag'}, \" under \",\n            ( $self->{'_pos'} || $self )->{'_tag'}, \")\\n\"\n\n            # because if _pos isn't defined, it goes under self\n            if DEBUG;\n\n        # The following if-clause is to delete /some/ ignorable whitespace\n        #  nodes, as we're making the tree.\n        # This'd be a node we'd catch later anyway, but we might as well\n        #  nip it in the bud now.\n        # This doesn't catch /all/ deletable WS-nodes, so we do have to call\n        #  the tightener later to catch the rest.\n\n        if ( $self->{'_tighten'} and !$self->{'_ignore_text'} )\n        {    # if tightenable\n            my ( $sibs, $par );\n            if (( $sibs = ( $par = $self->{'_pos'} || $self )->{'_content'} )\n                and @$sibs            # parent already has content\n                and !\n                ref( $sibs->[-1] )    # and the last one there is a text node\n                and $sibs->[-1] !~ m<[^\\n\\r\\f\\t ]>s  # and it's all whitespace\n\n                and (    # one of these has to be eligible...\n                    $HTML::TreeBuilder::canTighten{$tag}\n                    or (( @$sibs == 1 )\n                        ?    # WS is leftmost -- so parent matters\n                        $HTML::TreeBu", 8192) = 8192
09:01:57.450866 read(7, "ilder::canTighten{ $par->{'_tag'} }\n                        :    # WS is after another node -- it matters\n                        (   ref $sibs->[-2]\n                                and\n                                $HTML::TreeBuilder::canTighten{ $sibs->[-2]\n                                    {'_tag'} }\n                        )\n                    )\n                )\n\n                and !$par->is_inside( 'pre', 'xmp', 'textarea', 'plaintext' )\n\n                # we're clear\n                )\n            {\n                pop @$sibs;\n                print $indent, \"Popping a preceding all-WS node\\n\" if DEBUG;\n            }\n        }\n\n        $self->insert_element($e) unless $already_inserted;\n\n        if (DEBUG) {\n            if ( $self->{'_pos'} ) {\n                print $indent, \"(Current lineage of pos:  \\U$tag\\E under \",\n                    join(\n                    '/',\n                    reverse(\n\n                        # $self->{'_pos'}{'_tag'},  # don't list myself!\n                        $self->{'_pos'}->lineage_tag_names\n                    )\n                    ),\n                    \".)\\n\";\n            }\n            else {\n                print $indent, \"(Pos points nowhere!?)\\n\";\n            }\n        }\n\n        unless ( ( $self->{'_pos'} || '' ) eq $e ) {\n\n            # if it's an empty element -- i.e., if it didn't change the _pos\n            &{         $self->{\"_tweak_$tag\"}\n                    || $self->{'_tweak_*'}\n                    || return $e }( map $_, $e, $tag, $self )\n                ;    # make a list so the user can't clobber\n        }\n\n        return $e;\n    }\n}\n\n#==========================================================================\n\n{\n    my $indent;\n\n    sub end {\n        return if $_[0]{'_stunted'};\n\n       # Either: Acccept an end-tag signal from HTML::Parser\n       # Or: Method for closing currently open elements in some fairly complex\n       #  way, as used by other methods in this class.\n        my ( $self, $tag, @stop ) = @_;\n        if ( $tag eq 'x-html' ) {\n            print \"Ignoring close-x-html tag.\\n\" if DEBUG;\n\n            # inserted by some lame code-generators.\n            return;\n        }\n\n        unless ( ref($tag) or $tag =~ m/^[-_a-zA-Z0-9:%]+$/s ) {\n            DEBUG and print \"End-tag name $tag is no good.  Skipping.\\n\";\n            return;\n\n            # This avoids having Element's new() throw an exception.\n        }\n\n       # This method accepts two calling formats:\n       #  1) from Parser:  $self->end('tag_name', 'origtext')\n       #        in which case we shouldn't mistake origtext as a blocker tag\n       #  2) from myself:  $self->end(\\q{tagname1}, 'blk1', ... )\n       #     from myself:  $self->end(['tagname1', 'tagname2'], 'blk1',  ... )\n\n        # End the specified tag, but don't move above any of the blocker tags.\n        # The tag can also be a reference to an array.  Terminate the first\n        # tag found.\n\n        my $ptag = ( my $p = $self->{'_pos'} || $self )->{'_tag'};\n\n        # $p and $ptag are sort-of stratch\n\n        if ( ref($tag) ) {\n\n            # First param is a ref of one sort or another --\n            #  THE CALL IS COMING FROM INSIDE THE HOUSE!\n            $tag = $$tag if ref($tag) eq 'SCALAR';\n\n            # otherwise it's an arrayref.\n        }\n        else {\n\n            # the call came from Parser -- just ignore origtext\n            # except in a table ignore unmatched table tags RT #59980\n            @stop = $tag =~ /^t[hdr]\\z/ ? 'table' : ();\n        }\n\n        #my($indent);\n        if (DEBUG) {\n\n           # optimization -- don't figure out depth unless we're in debug mode\n            my @lineage_tags = $p->lineage_tag_names;\n            $indent = '  ' x ( 1 + @lineage_tags );\n\n            # now announce ourselves\n            print $indent, \"Ending \",\n                ref($tag) ? ( '[', join( ' ', @$tag ), ']' ) : \"\\U$tag\\E\",\n                scalar(@stop)\n                ? ( \" no higher than [\", join( ' ', @stop ), \"]\" )\n                : (), \".\\n\";\n\n            print $indent, \" (Current lineage: \", join( '/', @lineage_tags ),\n                \".)\\n\"\n                if DEBUG > 1;\n\n            if ( DEBUG > 3 ) {\n\n                #my(\n                # $package, $filename, $line, $subroutine,\n                # $hasargs, $wantarray, $evaltext, $is_require) = caller;\n                print $indent,\n                    \" (Called from \", ( caller(1) )[3], ' line ',\n                    ( caller(1) )[2],\n                    \")\\n\";\n            }\n\n            #} else {\n            #  $indent = ' ';\n        }\n\n        # End of if DEBUG\n\n        # Now actually do it\n        my @to_close;\n        if ( $tag eq '*' ) {\n\n        # Special -- close everything up to (but not including) the first\n        #  limiting tag, or return if none found.  Somewhat of a special case.\n        PARENT:\n            while ( defined $p ) {\n                $ptag = $p->{'_tag'};\n                print $indent, \" (Looking at $ptag.)\\n\" if DEBUG > 2;\n                for (@stop) {\n                    if ( $ptag eq $_ ) {\n                        print $indent,\n                            \" (Hit a $_; closing everything up to here.)\\n\"\n                            if DEBUG > 2;\n                        last PARENT;\n                    }\n                }\n                push @to_close, $p;\n                $p = $p->{'_parent'};    # no match so far? keep moving up\n                print $indent,\n                    \" (Moving on up to \", $p ? $p->{'_tag'} : 'nil', \")\\n\"\n                    if DEBUG > 1;\n            }\n            unless ( defined $p ) { # We never found what we were looking for.\n                print $indent, \" (We never found a limit.)\\n\" if DEBUG > 1;\n                return;\n            }\n\n            #print\n            #   $indent,\n            #   \" (To close: \", join('/', map $_->tag, @to_close), \".)\\n\"\n            #  if DEBUG > 4;\n\n            # Otherwise update pos and fall thru.\n            $self->{'_pos'} = $p;\n        }\n        elsif ( ref $tag ) {\n\n           # Close the first of any of the matching tags, giving up if you hit\n           #  any of the stop-tags.\n        PARENT:\n            while ( defined $p ) {\n                $ptag = $p->{'_tag'};\n                print $indent, \" (Looking at $ptag.)\\n\" if DEBUG > 2;\n                for (@$tag) {\n                    if ( $ptag eq $_ ) {\n                        print $indent, \" (Closing $_.)\\n\" if DEBUG > 2;\n                        last PARENT;\n                    }\n                }\n                for (@stop) {\n                    if ( $ptag eq $_ ) {\n                        print $indent,\n                            \" (Hit a limiting $_ -- bailing out.)\\n\"\n                            if DEBUG > 1;\n                        return;    # so it was all for naught\n                    }\n                }\n                push @to_close, $p;\n                $p = $p->{'_parent'};\n            }\n            return unless defined $p;    # We went off the top of the tree.\n               # Otherwise specified element was found; set pos to its parent.\n            push @to_close, $p;\n            $self->{'_pos'} = $p->{'_parent'};\n        }\n        else {\n\n            # Close the first of the specified tag, giving up if you hit\n            #  any of the stop-tags.\n            while ( defined $p ) {\n                $ptag = $p->{'_tag'};\n                print $indent, \" (Looking at $ptag.)\\n\" if DEBUG > 2;\n                if ( $ptag eq $tag ) {\n                    print $indent, \" (Closing $tag.)\\n\" if DEBUG > 2;\n                    last;\n                }\n                for (@stop) {\n                    if ( $ptag eq $_ ) {\n                        print $indent,\n                            \" (Hit a limiting $_ -- bailing out.)\\n\"\n                            if DEBUG > 1;\n                        return;    # so it was all for naught\n                    }\n                }\n                push @to_close, $p;\n                $p = $p->{'_parent'};\n            }\n            return unless defined $p;    # We went off the top of the tree.\n               # Otherwise specified element was found; set pos to its parent.\n            pus", 8192) = 8192
09:01:57.451516 brk(0x1efd000)          = 0x1efd000
09:01:57.451924 read(7, "h @to_close, $p;\n            $self->{'_pos'} = $p->{'_parent'};\n        }\n\n        $self->{'_pos'} = undef if $self eq ( $self->{'_pos'} || '' );\n        print $indent, \"(Pos now points to \",\n            $self->{'_pos'} ? $self->{'_pos'}{'_tag'} : '???', \".)\\n\"\n            if DEBUG > 1;\n\n        ### EXPENSIVE, because has to check that it's not under a pre\n        ### or a CDATA-parent.  That's one more method call per end()!\n        ### Might as well just do this at the end of the tree-parse, I guess,\n        ### at which point we'd be parsing top-down, and just not traversing\n        ### under pre's or CDATA-parents.\n        ##\n        ## Take this opportunity to nix any terminal whitespace nodes.\n        ## TODO: consider whether this (plus the logic in start(), above)\n        ## would ever leave any WS nodes in the tree.\n        ## If not, then there's no reason to have eof() call\n        ## delete_ignorable_whitespace on the tree, is there?\n        ##\n    #if(@to_close and $self->{'_tighten'} and !$self->{'_ignore_text'} and\n    #  ! $to_close[-1]->is_inside('pre', keys %HTML::Tagset::isCDATA_Parent)\n    #) {  # if tightenable\n    #  my($children, $e_tag);\n    #  foreach my $e (reverse @to_close) { # going top-down\n    #    last if 'pre' eq ($e_tag = $e->{'_tag'}) or\n    #     $HTML::Tagset::isCDATA_Parent{$e_tag};\n    #\n    #    if(\n    #      $children = $e->{'_content'}\n    #      and @$children      # has children\n    #      and !ref($children->[-1])\n    #      and $children->[-1] =~ m<^\\s+$>s # last node is all-WS\n    #      and\n    #        (\n    #         # has a tightable parent:\n    #         $HTML::TreeBuilder::canTighten{ $e_tag }\n    #         or\n    #          ( # has a tightenable left sibling:\n    #            @$children > 1 and\n    #            ref($children->[-2])\n    #            and $HTML::TreeBuilder::canTighten{ $children->[-2]{'_tag'} }\n    #          )\n    #        )\n    #    ) {\n    #      pop @$children;\n    #      #print $indent, \"Popping a terminal WS node from \", $e->{'_tag'},\n    #      #  \" (\", $e->address, \") while exiting.\\n\" if DEBUG;\n    #    }\n    #  }\n    #}\n\n        foreach my $e (@to_close) {\n\n            # Call the applicable callback, if any\n            $ptag = $e->{'_tag'};\n            &{         $self->{\"_tweak_$ptag\"}\n                    || $self->{'_tweak_*'}\n                    || next }( map $_, $e, $ptag, $self );\n            print $indent, \"Back from tweaking.\\n\" if DEBUG;\n            last\n                if $self->{ '_stunted'\n                    };    # in case one of the handlers called stunt\n        }\n        return @to_close;\n    }\n}\n\n#==========================================================================\n{\n    my ( $indent, $nugget );\n\n    sub text {\n        return if $_[0]{'_stunted'};\n\n        # Accept a \"here's a text token\" signal from HTML::Parser.\n        my ( $self, $text, $is_cdata ) = @_;\n\n        # the >3.0 versions of Parser may pass a cdata node.\n        # Thanks to Gisle Aas for pointing this out.\n\n        return unless length $text;    # I guess that's always right\n\n        my $ignore_text         = $self->{'_ignore_text'};\n        my $no_space_compacting = $self->{'_no_space_compacting'};\n        my $no_expand_entities  = $self->{'_no_expand_entities'};\n        my $pos                 = $self->{'_pos'} || $self;\n\n        HTML::Entities::decode($text)\n            unless $ignore_text\n                || $is_cdata\n                || $HTML::Tagset::isCDATA_Parent{ $pos->{'_tag'} }\n                || $no_expand_entities;\n\n        #my($indent, $nugget);\n        if (DEBUG) {\n\n           # optimization -- don't figure out depth unless we're in debug mode\n            my @lineage_tags = $pos->lineage_tag_names;\n            $indent = '  ' x ( 1 + @lineage_tags );\n\n            $nugget\n                = ( length($text) <= 25 )\n                ? $text\n                : ( substr( $text, 0, 25 ) . '...' );\n            $nugget =~ s<([\\x00-\\x1F])>\n                 <'\\\\x'.(unpack(\"H2\",$1))>eg;\n            print $indent, \"Proposing a new text node ($nugget) under \",\n                join( '/', reverse( $pos->{'_tag'}, @lineage_tags ) )\n                || 'Root',\n                \".\\n\";\n\n            #} else {\n            #  $indent = ' ';\n        }\n\n        my $ptag;\n        if ($HTML::Tagset::isCDATA_Parent{ $ptag = $pos->{'_tag'} }\n\n            #or $pos->is_inside('pre')\n            or $pos->is_inside( 'pre', 'textarea' )\n            )\n        {\n            return if $ignore_text;\n            $pos->push_content($text);\n        }\n        else {\n\n            # return unless $text =~ /\\S/;  # This is sometimes wrong\n\n            if ( !$self->{'_implicit_tags'} || $text !~ /[^\\n\\r\\f\\t ]/ ) {\n\n                # don't change anything\n            }\n            elsif ( $ptag eq 'head' or $ptag eq 'noframes' ) {\n                if ( $self->{'_implicit_body_p_tag'} ) {\n                    print $indent,\n                        \" * Text node under \\U$ptag\\E closes \\U$ptag\\E, implicates BODY and P.\\n\"\n                        if DEBUG > 1;\n                    $self->end( \\$ptag );\n                    $pos = $self->{'_body'}\n                        ? ( $self->{'_pos'}\n                            = $self->{'_body'} )    # expected case\n                        : $self->insert_element( 'body', 1 );\n                    $pos = $self->insert_element( 'p', 1 );\n                }\n                else {\n                    print $indent,\n                        \" * Text node under \\U$ptag\\E closes, implicates BODY.\\n\"\n                        if DEBUG > 1;\n                    $self->end( \\$ptag );\n                    $pos = $self->{'_body'}\n                        ? ( $self->{'_pos'}\n                            = $self->{'_body'} )    # expected case\n                        : $self->insert_element( 'body', 1 );\n                }\n            }\n            elsif ( $ptag eq 'html' ) {\n                if ( $self->{'_implicit_body_p_tag'} ) {\n                    print $indent,\n                        \" * Text node under HTML implicates BODY and P.\\n\"\n                        if DEBUG > 1;\n                    $pos = $self->{'_body'}\n                        ? ( $self->{'_pos'}\n                            = $self->{'_body'} )    # expected case\n                        : $self->insert_element( 'body', 1 );\n                    $pos = $self->insert_element( 'p', 1 );\n                }\n                else {\n                    print $indent,\n                        \" * Text node under HTML implicates BODY.\\n\"\n                        if DEBUG > 1;\n                    $pos = $self->{'_body'}\n                        ? ( $self->{'_pos'}\n                            = $self->{'_body'} )    # expected case\n                        : $self->insert_element( 'body', 1 );\n\n                    #print \"POS is $pos, \", $pos->{'_tag'}, \"\\n\";\n                }\n            }\n            elsif ( $ptag eq 'body' ) {\n                if ( $self->{'_implicit_body_p_tag'} ) {\n                    print $indent, \" * Text node under BODY implicates P.\\n\"\n                        if DEBUG > 1;\n                    $pos = $self->insert_element( 'p', 1 );\n                }\n            }\n            elsif ( $ptag eq 'table' ) {\n                print $indent,\n                    \" * Text node under TABLE implicates TR and TD.\\n\"\n                    if DEBUG > 1;\n                $self->insert_element( 'tr', 1 );\n                $pos = $self->insert_element( 'td', 1 );\n\n                # double whammy!\n            }\n            elsif ( $ptag eq 'tr' ) {\n                print $indent, \" * Text node under TR implicates TD.\\n\"\n                    if DEBUG > 1;\n                $pos = $self->insert_element( 'td', 1 );\n            }\n\n            # elsif (\n            #       # $ptag eq 'li'   ||\n            #       # $ptag eq 'dd'   ||\n            #         $ptag eq 'form') {\n            #    $pos = $self->insert_element('p', 1);\n            #}\n\n            # Whatever we've done above should have had the side\n            # effect of updating $self->{'_pos'}\n\n            #print \"POS is now $pos, \", $pos->{'_tag'}, \"\\n\";\n\n            return if $ignore_text;\n  ", 8192) = 8192
09:01:57.452729 read(7, "          $text =~ s/[\\n\\r\\f\\t ]+/ /g    # canonical space\n                unless $no_space_compacting;\n\n            print $indent, \" (Attaching text node ($nugget) under \",\n\n           # was: $self->{'_pos'} ? $self->{'_pos'}{'_tag'} : $self->{'_tag'},\n                $pos->{'_tag'}, \").\\n\"\n                if DEBUG > 1;\n\n            $pos->push_content($text);\n        }\n\n        &{ $self->{'_tweak_~text'} || return }( $text, $pos,\n            $pos->{'_tag'} . '' );\n\n        # Note that this is very exceptional -- it doesn't fall back to\n        #  _tweak_*, and it gives its tweak different arguments.\n        return;\n    }\n}\n\n#==========================================================================\n\n# TODO: test whether comment(), declaration(), and process(), do the right\n#  thing as far as tightening and whatnot.\n# Also, currently, doctypes and comments that appear before head or body\n#  show up in the tree in the wrong place.  Something should be done about\n#  this.  Tricky.  Maybe this whole business of pre-making the body and\n#  whatnot is wrong.\n\nsub comment {\n    return if $_[0]{'_stunted'};\n\n    # Accept a \"here's a comment\" signal from HTML::Parser.\n\n    my ( $self, $text ) = @_;\n    my $pos = $self->{'_pos'} || $self;\n    return\n        unless $self->{'_store_comments'}\n            || $HTML::Tagset::isCDATA_Parent{ $pos->{'_tag'} };\n\n    if (DEBUG) {\n        my @lineage_tags = $pos->lineage_tag_names;\n        my $indent = '  ' x ( 1 + @lineage_tags );\n\n        my $nugget\n            = ( length($text) <= 25 )\n            ? $text\n            : ( substr( $text, 0, 25 ) . '...' );\n        $nugget =~ s<([\\x00-\\x1F])>\n                 <'\\\\x'.(unpack(\"H2\",$1))>eg;\n        print $indent, \"Proposing a Comment ($nugget) under \",\n            join( '/', reverse( $pos->{'_tag'}, @lineage_tags ) ) || 'Root',\n            \".\\n\";\n    }\n\n    ( my $e = $self->element_class->new('~comment') )->{'text'} = $text;\n    $pos->push_content($e);\n    ++( $self->{'_element_count'} );\n\n    &{         $self->{'_tweak_~comment'}\n            || $self->{'_tweak_*'}\n            || return $e }( map $_, $e, '~comment', $self );\n\n    return $e;\n}\n\nsub declaration {\n    return if $_[0]{'_stunted'};\n\n    # Accept a \"here's a markup declaration\" signal from HTML::Parser.\n\n    my ( $self, $text ) = @_;\n    my $pos = $self->{'_pos'} || $self;\n\n    if (DEBUG) {\n        my @lineage_tags = $pos->lineage_tag_names;\n        my $indent = '  ' x ( 1 + @lineage_tags );\n\n        my $nugget\n            = ( length($text) <= 25 )\n            ? $text\n            : ( substr( $text, 0, 25 ) . '...' );\n        $nugget =~ s<([\\x00-\\x1F])>\n                 <'\\\\x'.(unpack(\"H2\",$1))>eg;\n        print $indent, \"Proposing a Declaration ($nugget) under \",\n            join( '/', reverse( $pos->{'_tag'}, @lineage_tags ) ) || 'Root',\n            \".\\n\";\n    }\n    ( my $e = $self->element_class->new('~declaration') )->{'text'} = $text;\n\n    $self->{_decl} = $e;\n    return $e;\n}\n\n#==========================================================================\n\nsub process {\n    return if $_[0]{'_stunted'};\n\n    # Accept a \"here's a PI\" signal from HTML::Parser.\n\n    return unless $_[0]->{'_store_pis'};\n    my ( $self, $text ) = @_;\n    my $pos = $self->{'_pos'} || $self;\n\n    if (DEBUG) {\n        my @lineage_tags = $pos->lineage_tag_names;\n        my $indent = '  ' x ( 1 + @lineage_tags );\n\n        my $nugget\n            = ( length($text) <= 25 )\n            ? $text\n            : ( substr( $text, 0, 25 ) . '...' );\n        $nugget =~ s<([\\x00-\\x1F])>\n                 <'\\\\x'.(unpack(\"H2\",$1))>eg;\n        print $indent, \"Proposing a PI ($nugget) under \",\n            join( '/', reverse( $pos->{'_tag'}, @lineage_tags ) ) || 'Root',\n            \".\\n\";\n    }\n    ( my $e = $self->element_class->new('~pi') )->{'text'} = $text;\n    $pos->push_content($e);\n    ++( $self->{'_element_count'} );\n\n    &{ $self->{'_tweak_~pi'} || $self->{'_tweak_*'} || return $e }( map $_,\n        $e, '~pi', $self );\n\n    return $e;\n}\n\n#==========================================================================\n\n#When you call $tree->parse_file($filename), and the\n#tree's ignore_ignorable_whitespace attribute is on (as it is\n#by default), HTML::TreeBuilder's logic will manage to avoid\n#creating some, but not all, nodes that represent ignorable\n#whitespace.  However, at the end of its parse, it traverses the\n#tree and deletes any that it missed.  (It does this with an\n#around-method around HTML::Parser's eof method.)\n#\n#However, with $tree->parse($content), the cleanup-traversal step\n#doesn't happen automatically -- so when you're done parsing all\n#content for a document (regardless of whether $content is the only\n#bit, or whether it's just another chunk of content you're parsing into\n#the tree), call $tree->eof() to signal that you're at the end of the\n#text you're inputting to the tree.  Besides properly cleaning any bits\n#of ignorable whitespace from the tree, this will also ensure that\n#HTML::Parser's internal buffer is flushed.\n\nsub eof {\n\n    # Accept an \"end-of-file\" signal from HTML::Parser, or thrown by the user.\n\n    return if $_[0]->{'_done'};    # we've already been here\n\n    return $_[0]->SUPER::eof() if $_[0]->{'_stunted'};\n\n    my $x = $_[0];\n    print \"EOF received.\\n\" if DEBUG;\n    my (@rv);\n    if (wantarray) {\n\n        # I don't think this makes any difference for this particular\n        #  method, but let's be scrupulous, for once.\n        @rv = $x->SUPER::eof();\n    }\n    else {\n        $rv[0] = $x->SUPER::eof();\n    }\n\n    $x->end('html') unless $x eq ( $x->{'_pos'} || $x );\n\n    # That SHOULD close everything, and will run the appropriate tweaks.\n    # We /could/ be running under some insane mode such that there's more\n    #  than one HTML element, but really, that's just insane to do anyhow.\n\n    unless ( $x->{'_implicit_tags'} ) {\n\n        # delete those silly implicit head and body in case we put\n        # them there in implicit tags mode\n        foreach my $node ( $x->{'_head'}, $x->{'_body'} ) {\n            $node->replace_with_content\n                if defined $node\n                    and ref $node\n                    and $node->{'_implicit'}\n                    and $node->{'_parent'};\n\n            # I think they should be empty anyhow, since the only\n            # logic that'd insert under them can apply only, I think,\n            # in the case where _implicit_tags is on\n        }\n\n        # this may still leave an implicit 'html' at the top, but there's\n        # nothing we can do about that, is there?\n    }\n\n    $x->delete_ignorable_whitespace()\n\n        # this's why we trap this -- an after-method\n        if $x->{'_tighten'} and !$x->{'_ignore_text'};\n    $x->{'_done'} = 1;\n\n    return @rv if wantarray;\n    return $rv[0];\n}\n\n#==========================================================================\n\n# TODO: document\n\nsub stunt {\n    my $self = $_[0];\n    print \"Stunting the tree.\\n\" if DEBUG;\n    $self->{'_done'} = 1;\n\n    if ( $HTML::Parser::VERSION < 3 ) {\n\n        #This is a MEAN MEAN HACK.  And it works most of the time!\n        $self->{'_buf'} = '';\n        my $fh = *HTML::Parser::F{IO};\n\n        # the local'd FH used by parse_file loop\n        if ( defined $fh ) {\n            print \"Closing Parser's filehandle $fh\\n\" if DEBUG;\n            close($fh);\n        }\n\n      # But if they called $tree->parse_file($filehandle)\n      #  or $tree->parse_file(*IO), then there will be no *HTML::Parser::F{IO}\n      #  to close.  Ahwell.  Not a problem for most users these days.\n\n    }\n    else {\n        $self->SUPER::eof();\n\n        # Under 3+ versions, calling eof from inside a parse will abort the\n        #  parse / parse_file\n    }\n\n    # In the off chance that the above didn't work, we'll throw\n    #  this flag to make any future events be no-ops.\n    $self->stunted(1);\n    return;\n}\n\n# TODO: document\nsub stunted { shift->_elem( '_stunted', @_ ); }\nsub done    { shift->_elem( '_done',    @_ ); }\n\n#==========================================================================\n\nsub delete {\n\n    # Override Element's delete method.\n    # This does most, if not all, of what Element's delete does anyway.\n    # De", 8192) = 8192
09:01:57.453677 brk(0x1f1e000)          = 0x1f1e000
09:01:57.453769 read(7, "letes content, including content in some special attributes.\n    # But doesn't empty out the hash.\n\n    $_[0]->{'_element_count'} = 1;    # never hurts to be scrupulously correct\n\n    delete @{ $_[0] }{ '_body', '_head', '_pos' };\n    for (\n        @{ delete( $_[0]->{'_content'} ) || [] },    # all/any content\n\n     #       delete @{$_[0]}{'_body', '_head', '_pos'}\n     # ...and these, in case these elements don't appear in the\n     #   content, which is possible.  If they did appear (as they\n     #   usually do), then calling $_->delete on them again is harmless.\n     #  I don't think that's such a hot idea now.  Thru creative reattachment,\n     #  those could actually now point to elements in OTHER trees (which we do\n     #  NOT want to delete!).\n## Reasoned out:\n  #  If these point to elements not in the content list of any element in this\n  #   tree, but not in the content list of any element in any OTHER tree, then\n  #   just deleting these will make their refcounts hit zero.\n  #  If these point to elements in the content lists of elements in THIS tree,\n  #   then we'll get to deleting them when we delete from the top.\n  #  If these point to elements in the content lists of elements in SOME OTHER\n  #   tree, then they're not to be deleted.\n        )\n    {\n        $_->delete\n            if defined $_ and ref $_    #  Make sure it's an object.\n                and $_ ne $_[0];    #  And avoid hitting myself, just in case!\n    }\n\n    $_[0]->detach if $_[0]->{'_parent'} and $_[0]->{'_parent'}{'_content'};\n\n    # An 'html' element having a parent is quite unlikely.\n\n    return;\n}\n\nsub tighten_up {                    # legacy\n    shift->delete_ignorable_whitespace(@_);\n}\n\nsub elementify {\n\n    # Rebless this object down into the normal element class.\n    my $self     = $_[0];\n    my $to_class = $self->element_class;\n    delete @{$self}{\n        grep {\n            ;\n            length $_ and substr( $_, 0, 1 ) eq '_'\n\n                # The private attributes that we'll retain:\n                and $_ ne '_tag'\n                and $_ ne '_parent'\n                and $_ ne '_content'\n                and $_ ne '_implicit'\n                and $_ ne '_pos'\n                and $_ ne '_element_class'\n            } keys %$self\n        };\n    bless $self, $to_class;    # Returns the same object we were fed\n}\n\nsub element_class {\n    return 'HTML::Element' if not ref $_[0];\n    return $_[0]->{_element_class} || 'HTML::Element';\n}\n\n#--------------------------------------------------------------------------\n\nsub guts {\n    my @out;\n    my @stack       = ( $_[0] );\n    my $destructive = $_[1];\n    my $this;\n    while (@stack) {\n        $this = shift @stack;\n        if ( !ref $this ) {\n            push @out, $this;    # yes, it can include text nodes\n        }\n        elsif ( !$this->{'_implicit'} ) {\n            push @out, $this;\n            delete $this->{'_parent'} if $destructive;\n        }\n        else {\n\n            # it's an implicit node.  Delete it and recurse\n            delete $this->{'_parent'} if $destructive;\n            unshift @stack,\n                @{\n                (   $destructive\n                    ? delete( $this->{'_content'} )\n                    : $this->{'_content'}\n                    )\n                    || []\n                };\n        }\n    }\n\n    # Doesn't call a real $root->delete on the (when implicit) root,\n    #  but I don't think it needs to.\n\n    return @out if wantarray;    # one simple normal case.\n    return unless @out;\n    return $out[0] if @out == 1 and ref( $out[0] );\n    my $x = HTML::Element->new( 'div', '_implicit' => 1 );\n    $x->push_content(@out);\n    return $x;\n}\n\nsub disembowel { $_[0]->guts(1) }\n\n#--------------------------------------------------------------------------\n1;\n\n\n__END__\n=pod\n\n=head1 NAME\n\nHTML::TreeBuilder - Parser that builds a HTML syntax tree\n\n=head1 VERSION\n\nThis document describes version 5.02 of\nHTML::TreeBuilder, released June 27, 2012\nas part of L<HTML-Tree|HTML::Tree>.\n\n=head1 SYNOPSIS\n\n  use HTML::TreeBuilder 5 -weak; # Ensure weak references in use\n\n  foreach my $file_name (@ARGV) {\n    my $tree = HTML::TreeBuilder->new; # empty tree\n    $tree->parse_file($file_name);\n    print \"Hey, here's a dump of the parse tree of $file_name:\\n\";\n    $tree->dump; # a method we inherit from HTML::Element\n    print \"And here it is, bizarrely rerendered as HTML:\\n\",\n      $tree->as_HTML, \"\\n\";\n\n    # Now that we're done with it, we must destroy it.\n    # $tree = $tree->delete; # Not required with weak references\n  }\n\n=head1 DESCRIPTION\n\n(This class is part of the L<HTML::Tree|HTML::Tree> dist.)\n\nThis class is for HTML syntax trees that get built out of HTML\nsource.  The way to use it is to:\n\n1. start a new (empty) HTML::TreeBuilder object,\n\n2. then use one of the methods from HTML::Parser (presumably with\nC<< $tree->parse_file($filename) >> for files, or with\nC<< $tree->parse($document_content) >> and C<< $tree->eof >> if you've got\nthe content in a string) to parse the HTML\ndocument into the tree C<$tree>.\n\n(You can combine steps 1 and 2 with the \"new_from_file\" or\n\"new_from_content\" methods.)\n\n2b. call C<< $root->elementify() >> if you want.\n\n3. do whatever you need to do with the syntax tree, presumably\ninvolving traversing it looking for some bit of information in it,\n\n4. previous versions of HTML::TreeBuilder required you to call\nC<< $tree->delete() >> to erase the contents of the tree from memory\nwhen you're done with the tree.  This is not normally required anymore.\nSee L<HTML::Element/\"Weak References\"> for details.\n\n=head1 ATTRIBUTES\n\nMost of the following attributes native to HTML::TreeBuilder control how\nparsing takes place; they should be set I<before> you try parsing into\nthe given object.  You can set the attributes by passing a TRUE or\nFALSE value as argument.  E.g., C<< $root->implicit_tags >> returns\nthe current setting for the C<implicit_tags> option,\nC<< $root->implicit_tags(1) >> turns that option on,\nand C<< $root->implicit_tags(0) >> turns it off.\n\n=head2 implicit_tags\n\nSetting this attribute to true will instruct the parser to try to\ndeduce implicit elements and implicit end tags.  If it is false you\nget a parse tree that just reflects the text as it stands, which is\nunlikely to be useful for anything but quick and dirty parsing.\n(In fact, I'd be curious to hear from anyone who finds it useful to\nhave C<implicit_tags> set to false.)\nDefault is true.\n\nImplicit elements have the L<HTML::Element/implicit> attribute set.\n\n=head2 implicit_body_p_tag\n\nThis controls an aspect of implicit element behavior, if C<implicit_tags>\nis on:  If a text element (PCDATA) or a phrasal element (such as\nC<< <em> >>) is to be inserted under C<< <body> >>, two things\ncan happen: if C<implicit_body_p_tag> is true, it's placed under a new,\nimplicit C<< <p> >> tag.  (Past DTDs suggested this was the only\ncorrect behavior, and this is how past versions of this module\nbehaved.)  But if C<implicit_body_p_tag> is false, nothing is implicated\n-- the PCDATA or phrasal element is simply placed under\nC<< <body> >>.  Default is false.\n\n=head2 no_expand_entities\n\nThis attribute controls whether entities are decoded during the initial\nparse of the source. Enable this if you don't want entities decoded to\ntheir character value. e.g. '&amp;' is decoded to '&' by default, but\nwill be unchanged if this is enabled.\nDefault is false (entities will be decoded.)\n\n=head2 ignore_unknown\n\nThis attribute controls whether unknown tags should be represented as\nelements in the parse tree, or whether they should be ignored.\nDefault is true (to ignore unknown tags.)\n\n=head2 ignore_text\n\nDo not represent the text content of elements.  This saves space if\nall you want is to examine the structure of the document.  Default is\nfalse.\n\n=head2 ignore_ignorable_whitespace\n\nIf set to true, TreeBuilder will try to avoid\ncreating ignorable whitespace text nodes in the tree.  Default is\ntrue.  (In fact, I'd be interested in hearing if there's ever a case\nwhere you need this off, or where leaving it on leads to incorrect\nbehavior.)\n\n=head2 no_space_compacting\n\nThis determines whether TreeBuilder compacts all whitespace strings\nin the ", 8192) = 8192
09:01:57.454448 lseek(7, 61135, SEEK_SET) = 61135
09:01:57.454498 lseek(7, 0, SEEK_CUR)   = 61135
09:01:57.454544 close(7)                = 0
09:01:57.454651 stat("modules/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.454705 stat("modules/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.454757 stat("modules/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.454805 stat("modules/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.454854 stat("/etc/perl/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.454903 stat("/etc/perl/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.454953 stat("/usr/local/lib/perl/5.14.2/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.455005 stat("/usr/local/lib/perl/5.14.2/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.455056 stat("/usr/local/share/perl/5.14.2/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.455107 stat("/usr/local/share/perl/5.14.2/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.455158 stat("/usr/lib/perl5/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.455208 stat("/usr/lib/perl5/JSON.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.455259 stat("/usr/share/perl5/JSON.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.455310 stat("/usr/share/perl5/JSON.pm", {st_mode=S_IFREG|0644, st_size=67811, ...}) = 0
09:01:57.455371 open("/usr/share/perl5/JSON.pm", O_RDONLY) = 7
09:01:57.455425 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.455473 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.455534 read(7, "package JSON;\n\n\nuse strict;\nuse Carp ();\nuse base qw(Exporter);\n@JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);\n\nBEGIN {\n    $JSON::VERSION = '2.53';\n    $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);\n    $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };\n}\n\nmy $Module_XS  = 'JSON::XS';\nmy $Module_PP  = 'JSON::PP';\nmy $Module_bp  = 'JSON::backportPP'; # included in JSON distribution\nmy $PP_Version = '2.27200';\nmy $XS_Version = '2.27';\n\n\n# XS and PP common methods\n\nmy @PublicMethods = qw/\n    ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref \n    allow_blessed convert_blessed filter_json_object filter_json_single_key_object \n    shrink max_depth max_size encode decode decode_prefix allow_unknown\n/;\n\nmy @Properties = qw/\n    ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref\n    allow_blessed convert_blessed shrink max_depth max_size allow_unknown\n/;\n\nmy @XSOnlyMethods = qw//; # Currently nothing\n\nmy @PPOnlyMethods = qw/\n    indent_length sort_by\n    allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed\n/; # JSON::PP specific\n\n\n# used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)\nmy $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.\nmy $_INSTALL_ONLY      = 2; # Don't call _set_methods()\nmy $_ALLOW_UNSUPPORTED = 0;\nmy $_UNIV_CONV_BLESSED = 0;\nmy $_USSING_bpPP       = 0;\n\n\n# Check the environment variable to decide worker module. \n\nunless ($JSON::Backend) {\n    $JSON::DEBUG and  Carp::carp(\"Check used worker module...\");\n\n    my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;\n\n    if ($backend eq '1' or $backend =~ /JSON::XS\\s*,\\s*JSON::PP/) {\n        _load_xs($_INSTALL_DONT_DIE) or _load_pp();\n    }\n    elsif ($backend eq '0' or $backend eq 'JSON::PP') {\n        _load_pp();\n    }\n    elsif ($backend eq '2' or $backend eq 'JSON::XS') {\n        _load_xs();\n    }\n    elsif ($backend eq 'JSON::backportPP') {\n        $_USSING_bpPP = 1;\n        _load_pp();\n    }\n    else {\n        Carp::croak \"The value of environmental variable 'PERL_JSON_BACKEND' is invalid.\";\n    }\n}\n\n\nsub import {\n    my $pkg = shift;\n    my @what_to_export;\n    my $no_export;\n\n    for my $tag (@_) {\n        if ($tag eq '-support_by_pp') {\n            if (!$_ALLOW_UNSUPPORTED++) {\n                JSON::Backend::XS\n                    ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);\n            }\n            next;\n        }\n        elsif ($tag eq '-no_export') {\n            $no_export++, next;\n        }\n        elsif ( $tag eq '-convert_blessed_universally' ) {\n            eval q|\n                require B;\n                *UNIVERSAL::TO_JSON = sub {\n                    my $b_obj = B::svref_2object( $_[0] );\n                    return    $b_obj->isa('B::HV') ? { %{ $_[0] } }\n                            : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]\n                            : undef\n                            ;\n                }\n            | if ( !$_UNIV_CONV_BLESSED++ );\n            next;\n        }\n        push @what_to_export, $tag;\n    }\n\n    return if ($no_export);\n\n    __PACKAGE__->export_to_level(1, $pkg, @what_to_export);\n}\n\n\n# OBSOLETED\n\nsub jsonToObj {\n    my $alternative = 'from_json';\n    if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {\n        shift @_; $alternative = 'decode';\n    }\n    Carp::carp \"'jsonToObj' will be obsoleted. Please use '$alternative' instead.\";\n    return JSON::from_json(@_);\n};\n\nsub objToJson {\n    my $alternative = 'to_json';\n    if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {\n        shift @_; $alternative = 'encode';\n    }\n    Carp::carp \"'objToJson' will be obsoleted. Please use '$alternative' instead.\";\n    JSON::to_json(@_);\n};\n\n\n# INTERFACES\n\nsub to_json ($@) {\n    if (\n        ref($_[0]) eq 'JSON'\n        or (@_ > 2 and $_[0] eq 'JSON')\n    ) {\n        Carp::croak \"to_json should not be called as a method.\";\n    }\n    my $json = new JSON;\n\n    if (@_ == 2 and ref $_[1] eq 'HASH') {\n        my $opt  = $_[1];\n        for my $method (keys %$opt) {\n            $json->$method( $opt->{$method} );\n        }\n    }\n\n    $json->encode($_[0]);\n}\n\n\nsub from_json ($@) {\n    if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {\n        Carp::croak \"from_json should not be called as a method.\";\n    }\n    my $json = new JSON;\n\n    if (@_ == 2 and ref $_[1] eq 'HASH') {\n        my $opt  = $_[1];\n        for my $method (keys %$opt) {\n            $json->$method( $opt->{$method} );\n        }\n    }\n\n    return $json->decode( $_[0] );\n}\n\n\nsub true  { $JSON::true  }\n\nsub false { $JSON::false }\n\nsub null  { undef; }\n\n\nsub require_xs_version { $XS_Version; }\n\nsub backend {\n    my $proto = shift;\n    $JSON::Backend;\n}\n\n#*module = *backend;\n\n\nsub is_xs {\n    return $_[0]->module eq $Module_XS;\n}\n\n\nsub is_pp {\n    return not $_[0]->xs;\n}\n\n\nsub pureperl_only_methods { @PPOnlyMethods; }\n\n\nsub property {\n    my ($self, $name, $value) = @_;\n\n    if (@_ == 1) {\n        my %props;\n        for $name (@Properties) {\n            my $method = 'get_' . $name;\n            if ($name eq 'max_size') {\n                my $value = $self->$method();\n                $props{$name} = $value == 1 ? 0 : $value;\n                next;\n            }\n            $props{$name} = $self->$method();\n        }\n        return \\%props;\n    }\n    elsif (@_ > 3) {\n        Carp::croak('property() can take only the option within 2 arguments.');\n    }\n    elsif (@_ == 2) {\n        if ( my $method = $self->can('get_' . $name) ) {\n            if ($name eq 'max_size') {\n                my $value = $self->$method();\n                return $value == 1 ? 0 : $value;\n            }\n            $self->$method();\n        }\n    }\n    else {\n        $self->$name($value);\n    }\n\n}\n\n\n\n# INTERNAL\n\nsub _load_xs {\n    my $opt = shift;\n\n    $JSON::DEBUG and Carp::carp \"Load $Module_XS.\";\n\n    # if called after install module, overload is disable.... why?\n    JSON::Boolean::_overrride_overload($Module_XS);\n    JSON::Boolean::_overrride_overload($Module_PP);\n\n    eval qq|\n        use $Module_XS $XS_Version ();\n    |;\n\n    if ($@) {\n        if (defined $opt and $opt & $_INSTALL_DONT_DIE) {\n            $JSON::DEBUG and Carp::carp \"Can't load $Module_XS...($@)\";\n            return 0;\n        }\n        Carp::croak $@;\n    }\n\n    unless (defined $opt and $opt & $_INSTALL_ONLY) {\n        _set_module( $JSON::Backend = $Module_XS );\n        my $data = join(\"\", <DATA>); # this code is from Jcode 2.xx.\n        close(DATA);\n        eval $data;\n        JSON::Backend::XS->init;\n    }\n\n    return 1;\n};\n\n\nsub _load_pp {\n    my $opt = shift;\n    my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;\n\n    $JSON::DEBUG and Carp::carp \"Load $backend.\";\n\n    # if called after install module, overload is disable.... why?\n    JSON::Boolean::_overrride_overload($Module_XS);\n    JSON::Boolean::_overrride_overload($backend);\n\n    if ( $_USSING_bpPP ) {\n        eval qq| require $backend |;\n    }\n    else {\n        eval qq| use $backend $PP_Version () |;\n    }\n\n    if ($@) {\n        if ( $backend eq $Module_PP ) {\n            $JSON::DEBUG and Carp::carp \"Can't load $Module_PP ($@), so try to load $Module_bp\";\n            $_USSING_bpPP++;\n            $backend = $Module_bp;\n            JSON::Boolean::_overrride_overload($backend);\n            local $^W; # if PP installed but invalid version, backportPP redifines methods.\n            eval qq| require $Module_bp |;\n        }\n        Carp::croak $@ if $@;\n    }\n\n    unless (defined $opt and $opt & $_INSTALL_ONLY) {\n        _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'\n        JSON::Backend::PP->init;\n    }\n};\n\n\nsub _set_module {\n    return if defined $JSON::true;\n\n    my $module = shift;\n\n    local $^W;\n    no strict qw(refs);\n\n    $JSON::true  = ${\"$module\\::true\"};\n    $JSON::false = ${\"$module\\::false\"};\n\n    push @JSON::ISA, $module;\n    push @{\"$module\\::Boolean::ISA\"}, qw(JSON::Boolean);\n\n    *{\"JSON::is_bool\"} = \\&{\"$module\\::is_bool\"};\n\n    for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethod", 8192) = 8192
09:01:57.456530 brk(0x1f3f000)          = 0x1f3f000
09:01:57.456892 read(7, "s) {\n        *{\"JSON::$method\"} = sub {\n            Carp::carp(\"$method is not supported in $module.\");\n            $_[0];\n        };\n    }\n\n    return 1;\n}\n\n\n\n#\n# JSON Boolean\n#\n\npackage JSON::Boolean;\n\nmy %Installed;\n\nsub _overrride_overload {\n    return if ($Installed{ $_[0] }++);\n\n    my $boolean = $_[0] . '::Boolean';\n\n    eval sprintf(q|\n        package %s;\n        use overload (\n            '\"\"' => sub { ${$_[0]} == 1 ? 'true' : 'false' },\n            'eq' => sub {\n                my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);\n                if ($op eq 'true' or $op eq 'false') {\n                    return \"$obj\" eq 'true' ? 'true' eq $op : 'false' eq $op;\n                }\n                else {\n                    return $obj ? 1 == $op : 0 == $op;\n                }\n            },\n        );\n    |, $boolean);\n\n    if ($@) { Carp::croak $@; }\n\n    return 1;\n}\n\n\n#\n# Helper classes for Backend Module (PP)\n#\n\npackage JSON::Backend::PP;\n\nsub init {\n    local $^W;\n    no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.\n    *{\"JSON::decode_json\"} = \\&{\"JSON::PP::decode_json\"};\n    *{\"JSON::encode_json\"} = \\&{\"JSON::PP::encode_json\"};\n    *{\"JSON::PP::is_xs\"}  = sub { 0 };\n    *{\"JSON::PP::is_pp\"}  = sub { 1 };\n    return 1;\n}\n\n#\n# To save memory, the below lines are read only when XS backend is used.\n#\n\npackage JSON;\n\n1;\n__DATA__\n\n\n#\n# Helper classes for Backend Module (XS)\n#\n\npackage JSON::Backend::XS;\n\nuse constant INDENT_LENGTH_FLAG => 15 << 12;\n\nuse constant UNSUPPORTED_ENCODE_FLAG => {\n    ESCAPE_SLASH      => 0x00000010,\n    ALLOW_BIGNUM      => 0x00000020,\n    AS_NONBLESSED     => 0x00000040,\n    EXPANDED          => 0x10000000, # for developer's\n};\n\nuse constant UNSUPPORTED_DECODE_FLAG => {\n    LOOSE             => 0x00000001,\n    ALLOW_BIGNUM      => 0x00000002,\n    ALLOW_BAREKEY     => 0x00000004,\n    ALLOW_SINGLEQUOTE => 0x00000008,\n    EXPANDED          => 0x20000000, # for developer's\n};\n\n\nsub init {\n    local $^W;\n    no strict qw(refs);\n    *{\"JSON::decode_json\"} = \\&{\"JSON::XS::decode_json\"};\n    *{\"JSON::encode_json\"} = \\&{\"JSON::XS::encode_json\"};\n    *{\"JSON::XS::is_xs\"}  = sub { 1 };\n    *{\"JSON::XS::is_pp\"}  = sub { 0 };\n    return 1;\n}\n\n\nsub support_by_pp {\n    my ($class, @methods) = @_;\n\n    local $^W;\n    no strict qw(refs);\n\n    my $JSON_XS_encode_orignal     = \\&JSON::XS::encode;\n    my $JSON_XS_decode_orignal     = \\&JSON::XS::decode;\n    my $JSON_XS_incr_parse_orignal = \\&JSON::XS::incr_parse;\n\n    *JSON::XS::decode     = \\&JSON::Backend::XS::Supportable::_decode;\n    *JSON::XS::encode     = \\&JSON::Backend::XS::Supportable::_encode;\n    *JSON::XS::incr_parse = \\&JSON::Backend::XS::Supportable::_incr_parse;\n\n    *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;\n    *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;\n    *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;\n\n    push @JSON::Backend::XS::Supportable::ISA, 'JSON';\n\n    my $pkg = 'JSON::Backend::XS::Supportable';\n\n    *{JSON::new} = sub {\n        my $proto = new JSON::XS; $$proto = 0;\n        bless  $proto, $pkg;\n    };\n\n\n    for my $method (@methods) {\n        my $flag = uc($method);\n        my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);\n           $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);\n\n        next unless($type);\n\n        $pkg->_make_unsupported_method($method => $type);\n    }\n\n    push @{\"JSON::XS::Boolean::ISA\"}, qw(JSON::PP::Boolean);\n    push @{\"JSON::PP::Boolean::ISA\"}, qw(JSON::Boolean);\n\n    $JSON::DEBUG and Carp::carp(\"set -support_by_pp mode.\");\n\n    return 1;\n}\n\n\n\n\n#\n# Helper classes for XS\n#\n\npackage JSON::Backend::XS::Supportable;\n\n$Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;\n\nsub _make_unsupported_method {\n    my ($pkg, $method, $type) = @_;\n\n    local $^W;\n    no strict qw(refs);\n\n    *{\"$pkg\\::$method\"} = sub {\n        local $^W;\n        if (defined $_[1] ? $_[1] : 1) {\n            ${$_[0]} |= $type;\n        }\n        else {\n            ${$_[0]} &= ~$type;\n        }\n        $_[0];\n    };\n\n    *{\"$pkg\\::get_$method\"} = sub {\n        ${$_[0]} & $type ? 1 : '';\n    };\n\n}\n\n\nsub _set_for_pp {\n    JSON::_load_pp( $_INSTALL_ONLY );\n\n    my $type  = shift;\n    my $pp    = new JSON::PP;\n    my $prop = $_[0]->property;\n\n    for my $name (keys %$prop) {\n        $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );\n    }\n\n    my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG\n                                        : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;\n    my $flags       = ${$_[0]} || 0;\n\n    for my $name (keys %$unsupported) {\n        next if ($name eq 'EXPANDED'); # for developer's\n        my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;\n        my $method = lc $name;\n        $pp->$method($enable);\n    }\n\n    $pp->indent_length( $_[0]->get_indent_length );\n\n    return $pp;\n}\n\nsub _encode { # using with PP encod\n    if (${$_[0]}) {\n        _set_for_pp('encode' => @_)->encode($_[1]);\n    }\n    else {\n        $_[0]->_original_encode( $_[1] );\n    }\n}\n\n\nsub _decode { # if unsupported-flag is set, use PP\n    if (${$_[0]}) {\n        _set_for_pp('decode' => @_)->decode($_[1]);\n    }\n    else {\n        $_[0]->_original_decode( $_[1] );\n    }\n}\n\n\nsub decode_prefix { # if unsupported-flag is set, use PP\n    _set_for_pp('decode' => @_)->decode_prefix($_[1]);\n}\n\n\nsub _incr_parse {\n    if (${$_[0]}) {\n        _set_for_pp('decode' => @_)->incr_parse($_[1]);\n    }\n    else {\n        $_[0]->_original_incr_parse( $_[1] );\n    }\n}\n\n\nsub get_indent_length {\n    ${$_[0]} << 4 >> 16;\n}\n\n\nsub indent_length {\n    my $length = $_[1];\n\n    if (!defined $length or $length > 15 or $length < 0) {\n        Carp::carp \"The acceptable range of indent_length() is 0 to 15.\";\n    }\n    else {\n        local $^W;\n        $length <<= 12;\n        ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;\n        ${$_[0]} |= $length;\n        *JSON::XS::encode = \\&JSON::Backend::XS::Supportable::_encode;\n    }\n\n    $_[0];\n}\n\n\n1;\n__END__\n\n=head1 NAME\n\nJSON - JSON (JavaScript Object Notation) encoder/decoder\n\n=head1 SYNOPSIS\n\n use JSON; # imports encode_json, decode_json, to_json and from_json.\n \n # simple and fast interfaces (expect/generate UTF-8)\n \n $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;\n $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;\n \n # OO-interface\n \n $json = JSON->new->allow_nonref;\n \n $json_text   = $json->encode( $perl_scalar );\n $perl_scalar = $json->decode( $json_text );\n \n $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing\n \n # If you want to use PP only support features, call with '-support_by_pp'\n # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.\n \n use JSON -support_by_pp;\n \n # option-acceptable interfaces (expect/generate UNICODE by default)\n \n $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );\n $perl_scalar = from_json( $json_text, { utf8  => 1 } );\n \n # Between (en|de)code_json and (to|from)_json, if you want to write\n # a code which communicates to an outer world (encoded in UTF-8),\n # recommend to use (en|de)code_json.\n \n=head1 VERSION\n\n    2.53\n\nThis version is compatible with JSON::XS B<2.27> and later.\n\n\n=head1 NOTE\n\nJSON::PP was inculded in C<JSON> distribution.\nIt comes to be a perl core module in Perl 5.14.\nAnd L<JSON::PP> will be split away it.\n\nC<JSON> distribution will inculde yet another JSON::PP modules.\nThey are JSNO::backportPP and so on. JSON.pm should work as it did at all.\n\n=head1 DESCRIPTION\n\n ************************** CAUTION ********************************\n * This is 'JSON module version 2' and there are many differences  *\n * to version 1.xx                                                 *\n * Please check your applications useing old version.              *\n *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *\n *******************************************************************\n\nJSON (JavaScript Object Notation) is a simple data format.\nSee to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).\n\nThis module converts Perl data structur", 8192) = 8192
09:01:57.457449 fcntl(7, F_SETFD, FD_CLOEXEC) = 0
09:01:57.457755 stat("modules/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.457807 stat("modules/JSON/XS.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:57.457888 stat("modules/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.457937 stat("modules/JSON/XS.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:57.457985 stat("/etc/perl/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.458043 stat("/etc/perl/JSON/XS.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:57.458098 stat("/usr/local/lib/perl/5.14.2/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.458150 stat("/usr/local/lib/perl/5.14.2/JSON/XS.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:57.458201 stat("/usr/local/share/perl/5.14.2/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.458253 stat("/usr/local/share/perl/5.14.2/JSON/XS.pm", 0x7ffe1233b5c0) = -1 ENOENT (No such file or directory)
09:01:57.458304 stat("/usr/lib/perl5/JSON/XS.pmc", 0x7ffe1233b670) = -1 ENOENT (No such file or directory)
09:01:57.458355 stat("/usr/lib/perl5/JSON/XS.pm", {st_mode=S_IFREG|0644, st_size=57156, ...}) = 0
09:01:57.458414 open("/usr/lib/perl5/JSON/XS.pm", O_RDONLY) = 8
09:01:57.458468 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b350) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.458515 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.458592 read(8, "=head1 NAME\n\nJSON::XS - JSON serialising/deserialising, done correctly and fast\n\n=encoding utf-8\n\nJSON::XS - \346\255\243\343\201\227\343\201\217\343\201\246\351\253\230\351\200\237\343\201\252 JSON \343\202\267\343\203\252\343\202\242\343\203\251\343\202\244\343\202\266/\343\203\207\343\202\267\343\203\252\343\202\242\343\203\251\343\202\244\343\202\266\n           (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)\n\n=head1 SYNOPSIS\n\n use JSON::XS;\n\n # exported functions, they croak on error\n # and expect/generate UTF-8\n\n $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;\n $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;\n\n # OO-interface\n\n $coder = JSON::XS->new->ascii->pretty->allow_nonref;\n $pretty_printed_unencoded = $coder->encode ($perl_scalar);\n $perl_scalar = $coder->decode ($unicode_json_text);\n\n # Note that JSON version 2.0 and above will automatically use JSON::XS\n # if available, at virtually no speed overhead either, so you should\n # be able to just:\n \n use JSON;\n\n # and do the same things, except that you have a pure-perl fallback now.\n\n=head1 DESCRIPTION\n\nThis module converts Perl data structures to JSON and vice versa. Its\nprimary goal is to be I<correct> and its secondary goal is to be\nI<fast>. To reach the latter goal it was written in C.\n\nBeginning with version 2.0 of the JSON module, when both JSON and\nJSON::XS are installed, then JSON will fall back on JSON::XS (this can be\noverridden) with no overhead due to emulation (by inheriting constructor\nand methods). If JSON::XS is not available, it will fall back to the\ncompatible JSON::PP module as backend, so using JSON instead of JSON::XS\ngives you a portable JSON API that can be fast when you need and doesn't\nrequire a C compiler when that is a problem.\n\nAs this is the n-th-something JSON module on CPAN, what was the reason\nto write yet another JSON module? While it seems there are many JSON\nmodules, none of them correctly handle all corner cases, and in most cases\ntheir maintainers are unresponsive, gone missing, or not listening to bug\nreports for other reasons.\n\nSee MAPPING, below, on how JSON::XS maps perl values to JSON values and\nvice versa.\n\n=head2 FEATURES\n\n=over 4\n\n=item * correct Unicode handling\n\nThis module knows how to handle Unicode, documents how and when it does\nso, and even documents what \"correct\" means.\n\n=item * round-trip integrity\n\nWhen you serialise a perl data structure using only data types supported\nby JSON and Perl, the deserialised data structure is identical on the Perl\nlevel. (e.g. the string \"2.0\" doesn't suddenly become \"2\" just because\nit looks like a number). There I<are> minor exceptions to this, read the\nMAPPING section below to learn about those.\n\n=item * strict checking of JSON correctness\n\nThere is no guessing, no generating of illegal JSON texts by default,\nand only JSON is accepted as input by default (the latter is a security\nfeature).\n\n=item * fast\n\nCompared to other JSON modules and other serialisers such as Storable,\nthis module usually compares favourably in terms of speed, too.\n\n=item * simple to use\n\nThis module has both a simple functional interface as well as an object\noriented interface interface.\n\n=item * reasonably versatile output formats\n\nYou can choose between the most compact guaranteed-single-line format\npossible (nice for simple line-based protocols), a pure-ASCII format\n(for when your transport is not 8-bit clean, still supports the whole\nUnicode range), or a pretty-printed format (for when you want to read that\nstuff). Or you can combine those features in whatever way you like.\n\n=back\n\n=cut\n\npackage JSON::XS;\n\nuse common::sense;\n\nour $VERSION = '2.32';\nour @ISA = qw(Exporter);\n\nour @EXPORT = qw(encode_json decode_json to_json from_json);\n\nsub to_json($) {\n   require Carp;\n   Carp::croak (\"JSON::XS::to_json has been renamed to encode_json, either downgrade to pre-2.0 versions of JSON::XS or rename the call\");\n}\n\nsub from_json($) {\n   require Carp;\n   Carp::croak (\"JSON::XS::from_json has been renamed to decode_json, either downgrade to pre-2.0 versions of JSON::XS or rename the call\");\n}\n\nuse Exporter;\nuse XSLoader;\n\n=head1 FUNCTIONAL INTERFACE\n\nThe following convenience methods are provided by this module. They are\nexported by default:\n\n=over 4\n\n=item $json_text = encode_json $perl_scalar\n\nConverts the given Perl data structure to a UTF-8 encoded, binary string\n(that is, the string contains octets only). Croaks on error.\n\nThis function call is functionally identical to:\n\n   $json_text = JSON::XS->new->utf8->encode ($perl_scalar)\n\nExcept being faster.\n\n=item $perl_scalar = decode_json $json_text\n\nThe opposite of C<encode_json>: expects an UTF-8 (binary) string and tries\nto parse that as an UTF-8 encoded JSON text, returning the resulting\nreference. Croaks on error.\n\nThis function call is functionally identical to:\n\n   $perl_scalar = JSON::XS->new->utf8->decode ($json_text)\n\nExcept being faster.\n\n=item $is_boolean = JSON::XS::is_bool $scalar\n\nReturns true if the passed scalar represents either JSON::XS::true or\nJSON::XS::false, two constants that act like C<1> and C<0>, respectively\nand are used to represent JSON C<true> and C<false> values in Perl.\n\nSee MAPPING, below, for more information on how JSON values are mapped to\nPerl.\n\n=back\n\n\n=head1 A FEW NOTES ON UNICODE AND PERL\n\nSince this often leads to confusion, here are a few very clear words on\nhow Unicode works in Perl, modulo bugs.\n\n=over 4\n\n=item 1. Perl strings can store characters with ordinal values > 255.\n\nThis enables you to store Unicode characters as single characters in a\nPerl string - very natural.\n\n=item 2. Perl does I<not> associate an encoding with your strings.\n\n... until you force it to, e.g. when matching it against a regex, or\nprinting the scalar to a file, in which case Perl either interprets your\nstring as locale-encoded text, octets/binary, or as Unicode, depending\non various settings. In no case is an encoding stored together with your\ndata, it is I<use> that decides encoding, not any magical meta data.\n\n=item 3. The internal utf-8 flag has no meaning with regards to the\nencoding of your string.\n\nJust ignore that flag unless you debug a Perl bug, a module written in\nXS or want to dive into the internals of perl. Otherwise it will only\nconfuse you, as, despite the name, it says nothing about how your string\nis encoded. You can have Unicode strings with that flag set, with that\nflag clear, and you can have binary data with that flag set and that flag\nclear. Other possibilities exist, too.\n\nIf you didn't know about that flag, just the better, pretend it doesn't\nexist.\n\n=item 4. A \"Unicode String\" is simply a string where each character can be\nvalidly interpreted as a Unicode code point.\n\nIf you have UTF-8 encoded data, it is no longer a Unicode string, but a\nUnicode string encoded in UTF-8, giving you a binary string.\n\n=item 5. A string containing \"high\" (> 255) character values is I<not> a UTF-8 string.\n\nIt's a fact. Learn to live with it.\n\n=back\n\nI hope this helps :)\n\n\n=head1 OBJECT-ORIENTED INTERFACE\n\nThe object oriented interface lets you configure your own encoding or\ndecoding style, within the limits of supported formats.\n\n=over 4\n\n=item $json = new JSON::XS\n\nCreates a new JSON::XS object that can be used to de/encode JSON\nstrings. All boolean flags described below are by default I<disabled>.\n\nThe mutators for flags all return the JSON object again and thus calls can\nbe chained:\n\n   my $json = JSON::XS->new->utf8->space_after->encode ({a => [1,2]})\n   => {\"a\": [1, 2]}\n\n=item $json = $json->ascii ([$enable])\n\n=item $enabled = $json->get_ascii\n\nIf C<$enable> is true (or missing), then the C<encode> method will not\ngenerate characters outside the code range C<0..127> (which is ASCII). Any\nUnicode characters outside that range will be escaped using either a\nsingle \\uXXXX (BMP characters) or a double \\uHHHH\\uLLLLL escape sequence,\nas per RFC4627. The resulting encoded JSON text can be treated as a native\nUnicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,\nor any other superset of ASCII.\n\nIf C<$enable> is false, then the C<encode> method will not escape Unicode\ncharacters unless required by the JSON syntax or other flags. This results\nin a faster and more compact format.\n\nSee also the section I<ENCODING/CODESET FLAG NOTES> later in this\ndocument.\n\nThe main use for this fl", 8192) = 8192
09:01:57.459020 stat("modules/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459073 stat("modules/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459122 stat("modules/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459170 stat("modules/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459219 stat("/etc/perl/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459269 stat("/etc/perl/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459318 stat("/usr/local/lib/perl/5.14.2/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459369 stat("/usr/local/lib/perl/5.14.2/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459419 stat("/usr/local/share/perl/5.14.2/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459470 stat("/usr/local/share/perl/5.14.2/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459520 stat("/usr/lib/perl5/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459570 stat("/usr/lib/perl5/common/sense.pm", 0x7ffe1233af90) = -1 ENOENT (No such file or directory)
09:01:57.459625 stat("/usr/share/perl5/common/sense.pmc", 0x7ffe1233b040) = -1 ENOENT (No such file or directory)
09:01:57.459676 stat("/usr/share/perl5/common/sense.pm", {st_mode=S_IFREG|0644, st_size=16409, ...}) = 0
09:01:57.459735 open("/usr/share/perl5/common/sense.pm", O_RDONLY) = 9
09:01:57.459788 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad20) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.459836 lseek(9, 0, SEEK_CUR)   = 0
09:01:57.459895 brk(0x1f61000)          = 0x1f61000
09:01:57.459948 read(9, "\n=head1 NAME\n\ncommon::sense - save a tree AND a kitten, use common::sense!\n\n=head1 SYNOPSIS\n\n   use common::sense;\n\n   # Supposed to be mostly the same, with much lower memory usage, as:\n  \n   # use utf8;\n   # use strict qw(vars subs);\n   # use feature qw(say state switch);\n   # use feature qw(unicode_strings unicode_eval current_sub fc evalbytes);\n   # no feature qw(array_base);\n   # no warnings;\n   # use warnings qw(FATAL closed threads internal debugging pack\n   #                 portable prototype inplace io pipe unpack malloc\n   #                 deprecated glob digit printf layer\n   #                 reserved taint closure semicolon);\n   # no warnings qw(exec newline unopened);\n\n=head1 DESCRIPTION\n\n   \342\200\234Nothing is more fairly distributed than common sense: no one thinks\n   he needs more of it than he already has.\342\200\235\n\n   \342\200\223 Ren\303\251 Descartes\n\nThis module implements some sane defaults for Perl programs, as defined by\ntwo typical (or not so typical - use your common sense) specimens of Perl\ncoders. In fact, after working out details on which warnings and strict\nmodes to enable and make fatal, we found that we (and our code written so\nfar, and others) fully agree on every option, even though we never used\nwarnings before, so it seems this module indeed reflects a \"common\" sense\namong some long-time Perl coders.\n\nThe basic philosophy behind the choices made in common::sense can be\nsummarised as: \"enforcing strict policies to catch as many bugs as\npossible, while at the same time, not limiting the expressive power\navailable to the programmer\".\n\nTwo typical examples of how this philosophy is applied in practise is the\nhandling of uninitialised and malloc warnings:\n\n=over 4\n\n=item I<uninitialised>\n\nC<undef> is a well-defined feature of perl, and enabling warnings for\nusing it rarely catches any bugs, but considerably limits you in what you\ncan do, so uninitialised warnings are disabled.\n\n=item I<malloc>\n\nFreeing something twice on the C level is a serious bug, usually causing\nmemory corruption. It often leads to side effects much later in the\nprogram and there are no advantages to not reporting this, so malloc\nwarnings are fatal by default.\n\n=back\n\nUnfortunately, there is no fine-grained warning control in perl, so often\nwhole groups of useful warnings had to be excluded because of a single\nuseless warning (for example, perl puts an arbitrary limit on the length\nof text you can match with some regexes before emitting a warning, making\nthe whole C<regexp> category useless).\n\nWhat follows is a more thorough discussion of what this module does,\nand why it does it, and what the advantages (and disadvantages) of this\napproach are.\n\n=head1 RATIONALE\n\n=over 4\n\n=item use utf8\n\nWhile it's not common sense to write your programs in UTF-8, it's quickly\nbecoming the most common encoding, is the designated future default\nencoding for perl sources, and the most convenient encoding available\n(you can do really nice quoting tricks...). Experience has shown that our\nprograms were either all pure ascii or utf-8, both of which will stay the\nsame.\n\nThere are few drawbacks to enabling UTF-8 source code by default (mainly\nsome speed hits due to bugs in older versions of perl), so this module\nenables UTF-8 source code encoding by default.\n\n\n=item use strict qw(subs vars)\n\nUsing C<use strict> is definitely common sense, but C<use strict\n'refs'> definitely overshoots its usefulness. After almost two\ndecades of Perl hacking, we decided that it does more harm than being\nuseful. Specifically, constructs like these:\n\n   @{ $var->[0] }\n\nMust be written like this (or similarly), when C<use strict 'refs'> is in\nscope, and C<$var> can legally be C<undef>:\n\n   @{ $var->[0] || [] }\n\nThis is annoying, and doesn't shield against obvious mistakes such as\nusing C<\"\">, so one would even have to write (at least for the time\nbeing):\n\n   @{ defined $var->[0] ? $var->[0] : [] }\n\n... which nobody with a bit of common sense would consider\nwriting: clear code is clearly something else.\n\nCuriously enough, sometimes perl is not so strict, as this works even with\nC<use strict> in scope:\n\n   for (@{ $var->[0] }) { ...\n\nIf that isn't hypocrisy! And all that from a mere program!\n\n\n=item use feature qw(say state given ...)\n\nWe found it annoying that we always have to enable extra features. If\nsomething breaks because it didn't anticipate future changes, so be\nit. 5.10 broke almost all our XS modules and nobody cared either (or at\nleast I know of nobody who really complained about gratuitous changes -\nas opposed to bugs).\n\nFew modules that are not actively maintained work with newer versions of\nPerl, regardless of use feature or not, so a new major perl release means\nchanges to many modules - new keywords are just the tip of the iceberg.\n\nIf your code isn't alive, it's dead, Jim - be an active maintainer.\n\nBut nobody forces you to use those extra features in modules meant for\nolder versions of perl - common::sense of course works there as well.\nThere is also an important other mode where having additional features by\ndefault is useful: commandline hacks and internal use scripts: See \"much\nreduced typing\", below.\n\nThere is one notable exception: C<unicode_eval> is not enabled by\ndefault. In our opinion, C<use feature> had one main effect - newer perl\nversions don't value backwards compatibility and the ability to write\nmodules for multiple perl versions much, after all, you can use feature.\n\nC<unicode_eval> doesn't add a new feature, it breaks an existing function.\n\n=item no warnings, but a lot of new errors\n\nAh, the dreaded warnings. Even worse, the horribly dreaded C<-w>\nswitch: Even though we don't care if other people use warnings (and\ncertainly there are useful ones), a lot of warnings simply go against the\nspirit of Perl.\n\nMost prominently, the warnings related to C<undef>. There is nothing wrong\nwith C<undef>: it has well-defined semantics, it is useful, and spitting\nout warnings you never asked for is just evil.\n\nThe result was that every one of our modules did C<no warnings> in the\npast, to avoid somebody accidentally using and forcing his bad standards\non our code. Of course, this switched off all warnings, even the useful\nones. Not a good situation. Really, the C<-w> switch should only enable\nwarnings for the main program only.\n\nFunnily enough, L<perllexwarn> explicitly mentions C<-w> (and not in a\nfavourable way, calling it outright \"wrong\"), but standard utilities, such\nas L<prove>, or MakeMaker when running C<make test>, still enable them\nblindly.\n\nFor version 2 of common::sense, we finally sat down a few hours and went\nthrough I<every single warning message>, identifiying - according to\ncommon sense - all the useful ones.\n\nThis resulted in the rather impressive list in the SYNOPSIS. When we\nweren't sure, we didn't include the warning, so the list might grow in\nthe future (we might have made a mistake, too, so the list might shrink\nas well).\n\nNote the presence of C<FATAL> in the list: we do not think that the\nconditions caught by these warnings are worthy of a warning, we I<insist>\nthat they are worthy of I<stopping> your program, I<instantly>. They are\nI<bugs>!\n\nTherefore we consider C<common::sense> to be much stricter than C<use\nwarnings>, which is good if you are into strict things (we are not,\nactually, but these things tend to be subjective).\n\nAfter deciding on the list, we ran the module against all of our code that\nuses C<common::sense> (that is almost all of our code), and found only one\noccurence where one of them caused a problem: one of elmex's (unreleased)\nmodules contained:\n\n   $fmt =~ s/([^\\s\\[]*)\\[( [^\\]]* )\\]/\\x0$1\\x1$2\\x0/xgo;\n\nWe quickly agreed that indeed the code should be changed, even though it\nhappened to do the right thing when the warning was switched off.\n\n\n=item much reduced typing\n\nEspecially with version 2.0 of common::sense, the amount of boilerplate\ncode you need to add to gte I<this> policy is daunting. Nobody would write\nthis out in throwaway scripts, commandline hacks or in quick internal-use\nscripts.\n\nBy using common::sense you get a defined set of policies (ours, but maybe\nyours, too, if you accept them), and they are easy to apply to your\nscr", 8192) = 8192
09:01:57.460358 read(9, "ipts: typing C<use common::sense;> is even shorter than C<use warnings;\nuse strict; use feature ...>.\n\nAnd you can immediately use the features of your installed perl, which\nis more difficult in code you release, but not usually an issue for\ninternal-use code (downgrades of your production perl should be rare,\nright?).\n\n\n=item mucho reduced memory usage\n\nJust using all those pragmas mentioned in the SYNOPSIS together wastes\n<blink>I<< B<776> kilobytes >></blink> of precious memory in my perl, for\nI<every single perl process using our code>, which on our machines, is a\nlot. In comparison, this module only uses I<< B<four> >> kilobytes (I even\nhad to write it out so it looks like more) of memory on the same platform.\n\nThe money/time/effort/electricity invested in these gigabytes (probably\npetabytes globally!) of wasted memory could easily save 42 trees, and a\nkitten!\n\nUnfortunately, until everybods applies more common sense, there will still\noften be modules that pull in the monster pragmas. But one can hope...\n\n=cut\n\npackage common::sense;\n\nour $VERSION = '3.6';\n\n# overload should be included\n\nsub import {\n   local $^W; # work around perl 5.16 spewing out warnings for next statement\n   # use warnings\n   ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ \"\\x3c\\x3f\\x33\\x00\\x0f\\xf0\\x0f\\xc0\\xf0\\xfc\\x33\\x00\\x00\";\n   # use strict, use utf8; use feature;\n   $^H |= 0x820e00;\n   @^H{qw(feature_unicode feature_say feature_state feature_switch)} = (1) x 4;\n}\n\n1;\n\n=back\n\n=head1 THERE IS NO 'no common::sense'!!!! !!!! !!\n\nThis module doesn't offer an unimport. First of all, it wastes even more\nmemory, second, and more importantly, who with even a bit of common sense\nwould want no common sense?\n\n=head1 STABILITY AND FUTURE VERSIONS\n\nFuture versions might change just about everything in this module. We\nmight test our modules and upload new ones working with newer versions of\nthis module, and leave you standing in the rain because we didn't tell\nyou. In fact, we did so when switching from 1.0 to 2.0, which enabled gobs\nof warnings, and made them FATAL on top.\n\nMaybe we will load some nifty modules that try to emulate C<say> or so\nwith perls older than 5.10 (this module, of course, should work with older\nperl versions - supporting 5.8 for example is just common sense at this\ntime. Maybe not in the future, but of course you can trust our common\nsense to be consistent with, uhm, our opinion).\n\n=head1 WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE\n\napeiron\n\n   \"... wow\"\n   \"I hope common::sense is a joke.\"\n\ncrab\n\n   \"i wonder how it would be if joerg schilling wrote perl modules.\"\n\nAdam Kennedy\n\n   \"Very interesting, efficient, and potentially something I'd use all the time.\"\n   [...]\n   \"So no common::sense for me, alas.\"\n\nH.Merijn Brand\n\n   \"Just one more reason to drop JSON::XS from my distribution list\"\n\nPista Palo\n\n   \"Something in short supply these days...\"\n\nSteffen Schwigon\n\n   \"This module is quite for sure *not* just a repetition of all the other\n   'use strict, use warnings'-approaches, and it's also not the opposite.\n   [...] And for its chosen middle-way it's also not the worst name ever.\n   And everything is documented.\"\n\nBKB\n\n   \"[Deleted - thanks to Steffen Schwigon for pointing out this review was\n   in error.]\"\n\nSomni\n\n   \"the arrogance of the guy\"\n   \"I swear he tacked somenoe else's name onto the module\n   just so he could use the royal 'we' in the documentation\"\n\nAnonymous Monk\n\n   \"You just gotta love this thing, its got META.json!!!\"\n\ndngor\n\n   \"Heh.  '\"<elmex at ta-sa.org>\"'  The quotes are semantic\n   distancing from that e-mail address.\"\n\nJerad Pierce\n\n   \"Awful name (not a proper pragma), and the SYNOPSIS doesn't tell you\n   anything either. Nor is it clear what features have to do with \"common\n   sense\" or discipline.\"\n\nacme\n\n   \"THERE IS NO 'no common::sense'!!!! !!!! !!\"\n\napeiron (meta-comment about us commenting^Wquoting his comment)\n\n   \"How about quoting this: get a clue, you fucktarded amoeba.\"\n\nquanth\n\n   \"common sense is beautiful, json::xs is fast, Anyevent, EV are fast and\n   furious. I love mlehmannware ;)\"\n\napeiron\n\n   \"... it's mlehmann's view of what common sense is. His view of common\n   sense is certainly uncommon, insofar as anyone with a clue disagrees\n   with him.\"\n\napeiron (another meta-comment)\n\n   \"apeiron wonders if his little informant is here to steal more quotes\"\n\new73\n\n   \"... I never got past the SYNOPSIS before calling it shit.\"\n   [...]\n   How come no one ever quotes me. :(\"\n\nchip (not willing to explain his cryptic questions about links in Changes files)\n\n   \"I'm willing to ask the question I've asked. I'm not willing to go\n   through the whole dance you apparently have choreographed. Either\n   answer the completely obvious question, or tell me to fuck off again.\"\n\n=head1 FREQUENTLY ASKED QUESTIONS\n\nOr frequently-come-up confusions.\n\n=over 4\n\n=item Is this module meant to be serious?\n\nYes, we would have put it under the C<Acme::> namespace otherwise.\n\n=item But the manpage is written in a funny/stupid/... way?\n\nThis was meant to make it clear that our common sense is a subjective\nthing and other people can use their own notions, taking the steam out\nof anybody who might be offended (as some people are always offended no\nmatter what you do).\n\nThis was a failure.\n\nBut we hope the manpage still is somewhat entertaining even though it\nexplains boring rationale.\n\n=item Why do you impose your conventions on my code?\n\nFor some reason people keep thinking that C<common::sense> imposes\nprocess-wide limits, even though the SYNOPSIS makes it clear that it works\nlike other similar modules - i.e. only within the scope that C<use>s them.\n\nSo, no, we don't - nobody is forced to use this module, and using a module\nthat relies on common::sense does not impose anything on you.\n\n=item Why do you think only your notion of common::sense is valid?\n\nWell, we don't, and have clearly written this in the documentation to\nevery single release. We were just faster than anybody else w.r.t. to\ngrabbing the namespace.\n\n=item But everybody knows that you have to use strict and use warnings,\nwhy do you disable them?\n\nWell, we don't do this either - we selectively disagree with the\nusefulness of some warnings over others. This module is aimed at\nexperienced Perl programmers, not people migrating from other languages\nwho might be surprised about stuff such as C<undef>. On the other hand,\nthis does not exclude the usefulness of this module for total newbies, due\nto its strictness in enforcing policy, while at the same time not limiting\nthe expressive power of perl.\n\nThis module is considerably I<more> strict than the canonical C<use\nstrict; use warnings>, as it makes all its warnings fatal in nature, so\nyou can not get away with as many things as with the canonical approach.\n\nThis was not implemented in version 1.0 because of the daunting number\nof warning categories and the difficulty in getting exactly the set of\nwarnings you wish (i.e. look at the SYNOPSIS in how complicated it is to\nget a specific set of warnings - it is not reasonable to put this into\nevery module, the maintenance effort would be enourmous).\n\n=item But many modules C<use strict> or C<use warnings>, so the memory\nsavings do not apply?\n\nI suddenly feel sad...\n\nBut yes, that's true. Fortunately C<common::sense> still uses only a\nminiscule amount of RAM.\n\n=item But it adds another dependency to your modules!\n\nIt's a fact, yeah. But it's trivial to install, most popular modules have\nmany more dependencies and we consider dependencies a good thing - it\nleads to better APIs, more thought about interworking of modules and so\non.\n\n=item Why do you use JSON and not YAML for your META.yml?\n\nThis is not true - YAML supports a large subset of JSON, and this subset\nis what META.yml is written in, so it would be correct to say \"the\nMETA.yml is written in a common subset of YAML and JSON\".\n\nThe META.yml follows the YAML, JSON and META.yml specifications, and is\ncorrectly parsed by CPAN, so if you have trouble with it, the problem is\nlikely on your side.\n\n=item But! But!\n\nYeah, we know.\n\n=back\n\n=head1 AUTHOR\n\n Marc Lehmann <schmorp@schmorp.de>\n http://home.schmorp.de/\n\n Robin Redeker, \"<elme", 8192) = 8192
09:01:57.460823 read(9, "x at ta-sa.org>\".\n\n=cut\n\n", 8192) = 25
09:01:57.460876 read(9, "", 8192)       = 0
09:01:57.460923 close(9)                = 0
09:01:57.461094 read(8, "ag is to produce JSON texts that can be\ntransmitted over a 7-bit channel, as the encoded JSON texts will not\ncontain any 8 bit characters.\n\n  JSON::XS->new->ascii (1)->encode ([chr 0x10401])\n  => [\"\\ud801\\udc01\"]\n\n=item $json = $json->latin1 ([$enable])\n\n=item $enabled = $json->get_latin1\n\nIf C<$enable> is true (or missing), then the C<encode> method will encode\nthe resulting JSON text as latin1 (or iso-8859-1), escaping any characters\noutside the code range C<0..255>. The resulting string can be treated as a\nlatin1-encoded JSON text or a native Unicode string. The C<decode> method\nwill not be affected in any way by this flag, as C<decode> by default\nexpects Unicode, which is a strict superset of latin1.\n\nIf C<$enable> is false, then the C<encode> method will not escape Unicode\ncharacters unless required by the JSON syntax or other flags.\n\nSee also the section I<ENCODING/CODESET FLAG NOTES> later in this\ndocument.\n\nThe main use for this flag is efficiently encoding binary data as JSON\ntext, as most octets will not be escaped, resulting in a smaller encoded\nsize. The disadvantage is that the resulting JSON text is encoded\nin latin1 (and must correctly be treated as such when storing and\ntransferring), a rare encoding for JSON. It is therefore most useful when\nyou want to store data structures known to contain binary data efficiently\nin files or databases, not when talking to other JSON encoders/decoders.\n\n  JSON::XS->new->latin1->encode ([\"\\x{89}\\x{abc}\"]\n  => [\"\\x{89}\\\\u0abc\"]    # (perl syntax, U+abc escaped, U+89 not)\n\n=item $json = $json->utf8 ([$enable])\n\n=item $enabled = $json->get_utf8\n\nIf C<$enable> is true (or missing), then the C<encode> method will encode\nthe JSON result into UTF-8, as required by many protocols, while the\nC<decode> method expects to be handled an UTF-8-encoded string.  Please\nnote that UTF-8-encoded strings do not contain any characters outside the\nrange C<0..255>, they are thus useful for bytewise/binary I/O. In future\nversions, enabling this option might enable autodetection of the UTF-16\nand UTF-32 encoding families, as described in RFC4627.\n\nIf C<$enable> is false, then the C<encode> method will return the JSON\nstring as a (non-encoded) Unicode string, while C<decode> expects thus a\nUnicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs\nto be done yourself, e.g. using the Encode module.\n\nSee also the section I<ENCODING/CODESET FLAG NOTES> later in this\ndocument.\n\nExample, output UTF-16BE-encoded JSON:\n\n  use Encode;\n  $jsontext = encode \"UTF-16BE\", JSON::XS->new->encode ($object);\n\nExample, decode UTF-32LE-encoded JSON:\n\n  use Encode;\n  $object = JSON::XS->new->decode (decode \"UTF-32LE\", $jsontext);\n\n=item $json = $json->pretty ([$enable])\n\nThis enables (or disables) all of the C<indent>, C<space_before> and\nC<space_after> (and in the future possibly more) flags in one call to\ngenerate the most readable (or most compact) form possible.\n\nExample, pretty-print some simple structure:\n\n   my $json = JSON::XS->new->pretty(1)->encode ({a => [1,2]})\n   =>\n   {\n      \"a\" : [\n         1,\n         2\n      ]\n   }\n\n=item $json = $json->indent ([$enable])\n\n=item $enabled = $json->get_indent\n\nIf C<$enable> is true (or missing), then the C<encode> method will use a multiline\nformat as output, putting every array member or object/hash key-value pair\ninto its own line, indenting them properly.\n\nIf C<$enable> is false, no newlines or indenting will be produced, and the\nresulting JSON text is guaranteed not to contain any C<newlines>.\n\nThis setting has no effect when decoding JSON texts.\n\n=item $json = $json->space_before ([$enable])\n\n=item $enabled = $json->get_space_before\n\nIf C<$enable> is true (or missing), then the C<encode> method will add an extra\noptional space before the C<:> separating keys from values in JSON objects.\n\nIf C<$enable> is false, then the C<encode> method will not add any extra\nspace at those places.\n\nThis setting has no effect when decoding JSON texts. You will also\nmost likely combine this setting with C<space_after>.\n\nExample, space_before enabled, space_after and indent disabled:\n\n   {\"key\" :\"value\"}\n\n=item $json = $json->space_after ([$enable])\n\n=item $enabled = $json->get_space_after\n\nIf C<$enable> is true (or missing), then the C<encode> method will add an extra\noptional space after the C<:> separating keys from values in JSON objects\nand extra whitespace after the C<,> separating key-value pairs and array\nmembers.\n\nIf C<$enable> is false, then the C<encode> method will not add any extra\nspace at those places.\n\nThis setting has no effect when decoding JSON texts.\n\nExample, space_before and indent disabled, space_after enabled:\n\n   {\"key\": \"value\"}\n\n=item $json = $json->relaxed ([$enable])\n\n=item $enabled = $json->get_relaxed\n\nIf C<$enable> is true (or missing), then C<decode> will accept some\nextensions to normal JSON syntax (see below). C<encode> will not be\naffected in anyway. I<Be aware that this option makes you accept invalid\nJSON texts as if they were valid!>. I suggest only to use this option to\nparse application-specific files written by humans (configuration files,\nresource files etc.)\n\nIf C<$enable> is false (the default), then C<decode> will only accept\nvalid JSON texts.\n\nCurrently accepted extensions are:\n\n=over 4\n\n=item * list items can have an end-comma\n\nJSON I<separates> array elements and key-value pairs with commas. This\ncan be annoying if you write JSON texts manually and want to be able to\nquickly append elements, so this extension accepts comma at the end of\nsuch items not just between them:\n\n   [\n      1,\n      2, <- this comma not normally allowed\n   ]\n   {\n      \"k1\": \"v1\",\n      \"k2\": \"v2\", <- this comma not normally allowed\n   }\n\n=item * shell-style '#'-comments\n\nWhenever JSON allows whitespace, shell-style comments are additionally\nallowed. They are terminated by the first carriage-return or line-feed\ncharacter, after which more white-space and comments are allowed.\n\n  [\n     1, # this comment not allowed in JSON\n        # neither this one...\n  ]\n\n=back\n\n=item $json = $json->canonical ([$enable])\n\n=item $enabled = $json->get_canonical\n\nIf C<$enable> is true (or missing), then the C<encode> method will output JSON objects\nby sorting their keys. This is adding a comparatively high overhead.\n\nIf C<$enable> is false, then the C<encode> method will output key-value\npairs in the order Perl stores them (which will likely change between runs\nof the same script).\n\nThis option is useful if you want the same data structure to be encoded as\nthe same JSON text (given the same overall settings). If it is disabled,\nthe same hash might be encoded differently even if contains the same data,\nas key-value pairs have no inherent ordering in Perl.\n\nThis setting has no effect when decoding JSON texts.\n\nThis setting has currently no effect on tied hashes.\n\n=item $json = $json->allow_nonref ([$enable])\n\n=item $enabled = $json->get_allow_nonref\n\nIf C<$enable> is true (or missing), then the C<encode> method can convert a\nnon-reference into its corresponding string, number or null JSON value,\nwhich is an extension to RFC4627. Likewise, C<decode> will accept those JSON\nvalues instead of croaking.\n\nIf C<$enable> is false, then the C<encode> method will croak if it isn't\npassed an arrayref or hashref, as JSON texts must either be an object\nor array. Likewise, C<decode> will croak if given something that is not a\nJSON object or array.\n\nExample, encode a Perl scalar as JSON value with enabled C<allow_nonref>,\nresulting in an invalid JSON text:\n\n   JSON::XS->new->allow_nonref->encode (\"Hello, World!\")\n   => \"Hello, World!\"\n\n=item $json = $json->allow_unknown ([$enable])\n\n=item $enabled = $json->get_allow_unknown\n\nIf C<$enable> is true (or missing), then C<encode> will I<not> throw an\nexception when it encounters values it cannot represent in JSON (for\nexample, filehandles) but instead will encode a JSON C<null> value. Note\nthat blessed objects are not included here and are handled separately by\nc<allow_nonref>.\n\nIf C<$enable> is false (the default), then C<encode> will throw an\nexception when it encounters anything it cannot encode as JSON.\n\nThis option does not affect C<decode> in", 8192) = 8192
09:01:57.461514 read(8, " any way, and it is recommended to\nleave it off unless you know your communications partner.\n\n=item $json = $json->allow_blessed ([$enable])\n\n=item $enabled = $json->get_allow_blessed\n\nIf C<$enable> is true (or missing), then the C<encode> method will not\nbarf when it encounters a blessed reference. Instead, the value of the\nB<convert_blessed> option will decide whether C<null> (C<convert_blessed>\ndisabled or no C<TO_JSON> method found) or a representation of the\nobject (C<convert_blessed> enabled and C<TO_JSON> method found) is being\nencoded. Has no effect on C<decode>.\n\nIf C<$enable> is false (the default), then C<encode> will throw an\nexception when it encounters a blessed object.\n\n=item $json = $json->convert_blessed ([$enable])\n\n=item $enabled = $json->get_convert_blessed\n\nIf C<$enable> is true (or missing), then C<encode>, upon encountering a\nblessed object, will check for the availability of the C<TO_JSON> method\non the object's class. If found, it will be called in scalar context\nand the resulting scalar will be encoded instead of the object. If no\nC<TO_JSON> method is found, the value of C<allow_blessed> will decide what\nto do.\n\nThe C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>\nreturns other blessed objects, those will be handled in the same\nway. C<TO_JSON> must take care of not causing an endless recursion cycle\n(== crash) in this case. The name of C<TO_JSON> was chosen because other\nmethods called by the Perl core (== not by the user of the object) are\nusually in upper case letters and to avoid collisions with any C<to_json>\nfunction or method.\n\nThis setting does not yet influence C<decode> in any way, but in the\nfuture, global hooks might get installed that influence C<decode> and are\nenabled by this setting.\n\nIf C<$enable> is false, then the C<allow_blessed> setting will decide what\nto do when a blessed object is found.\n\n=item $json = $json->filter_json_object ([$coderef->($hashref)])\n\nWhen C<$coderef> is specified, it will be called from C<decode> each\ntime it decodes a JSON object. The only argument is a reference to the\nnewly-created hash. If the code references returns a single scalar (which\nneed not be a reference), this value (i.e. a copy of that scalar to avoid\naliasing) is inserted into the deserialised data structure. If it returns\nan empty list (NOTE: I<not> C<undef>, which is a valid scalar), the\noriginal deserialised hash will be inserted. This setting can slow down\ndecoding considerably.\n\nWhen C<$coderef> is omitted or undefined, any existing callback will\nbe removed and C<decode> will not change the deserialised hash in any\nway.\n\nExample, convert all JSON objects into the integer 5:\n\n   my $js = JSON::XS->new->filter_json_object (sub { 5 });\n   # returns [5]\n   $js->decode ('[{}]')\n   # throw an exception because allow_nonref is not enabled\n   # so a lone 5 is not allowed.\n   $js->decode ('{\"a\":1, \"b\":2}');\n\n=item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])\n\nWorks remotely similar to C<filter_json_object>, but is only called for\nJSON objects having a single key named C<$key>.\n\nThis C<$coderef> is called before the one specified via\nC<filter_json_object>, if any. It gets passed the single value in the JSON\nobject. If it returns a single value, it will be inserted into the data\nstructure. If it returns nothing (not even C<undef> but the empty list),\nthe callback from C<filter_json_object> will be called next, as if no\nsingle-key callback were specified.\n\nIf C<$coderef> is omitted or undefined, the corresponding callback will be\ndisabled. There can only ever be one callback for a given key.\n\nAs this callback gets called less often then the C<filter_json_object>\none, decoding speed will not usually suffer as much. Therefore, single-key\nobjects make excellent targets to serialise Perl objects into, especially\nas single-key JSON objects are as close to the type-tagged value concept\nas JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not\nsupport this in any way, so you need to make sure your data never looks\nlike a serialised Perl hash.\n\nTypical names for the single object key are C<__class_whatever__>, or\nC<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even\nthings like C<__class_md5sum(classname)__>, to reduce the risk of clashing\nwith real hashes.\n\nExample, decode JSON objects of the form C<< { \"__widget__\" => <id> } >>\ninto the corresponding C<< $WIDGET{<id>} >> object:\n\n   # return whatever is in $WIDGET{5}:\n   JSON::XS\n      ->new\n      ->filter_json_single_key_object (__widget__ => sub {\n            $WIDGET{ $_[0] }\n         })\n      ->decode ('{\"__widget__\": 5')\n\n   # this can be used with a TO_JSON method in some \"widget\" class\n   # for serialisation to json:\n   sub WidgetBase::TO_JSON {\n      my ($self) = @_;\n\n      unless ($self->{id}) {\n         $self->{id} = ..get..some..id..;\n         $WIDGET{$self->{id}} = $self;\n      }\n\n      { __widget__ => $self->{id} }\n   }\n\n=item $json = $json->shrink ([$enable])\n\n=item $enabled = $json->get_shrink\n\nPerl usually over-allocates memory a bit when allocating space for\nstrings. This flag optionally resizes strings generated by either\nC<encode> or C<decode> to their minimum size possible. This can save\nmemory when your JSON texts are either very very long or you have many\nshort strings. It will also try to downgrade any strings to octet-form\nif possible: perl stores strings internally either in an encoding called\nUTF-X or in octet-form. The latter cannot store everything but uses less\nspace in general (and some buggy Perl or C code might even rely on that\ninternal representation being used).\n\nThe actual definition of what shrink does might change in future versions,\nbut it will always try to save space at the expense of time.\n\nIf C<$enable> is true (or missing), the string returned by C<encode> will\nbe shrunk-to-fit, while all strings generated by C<decode> will also be\nshrunk-to-fit.\n\nIf C<$enable> is false, then the normal perl allocation algorithms are used.\nIf you work with your data, then this is likely to be faster.\n\nIn the future, this setting might control other things, such as converting\nstrings that look like integers or floats into integers or floats\ninternally (there is no difference on the Perl level), saving space.\n\n=item $json = $json->max_depth ([$maximum_nesting_depth])\n\n=item $max_depth = $json->get_max_depth\n\nSets the maximum nesting level (default C<512>) accepted while encoding\nor decoding. If a higher nesting level is detected in JSON text or a Perl\ndata structure, then the encoder and decoder will stop and croak at that\npoint.\n\nNesting level is defined by number of hash- or arrayrefs that the encoder\nneeds to traverse to reach a given point or the number of C<{> or C<[>\ncharacters without their matching closing parenthesis crossed to reach a\ngiven character in a string.\n\nSetting the maximum depth to one disallows any nesting, so that ensures\nthat the object is only a single hash/object or array.\n\nIf no argument is given, the highest possible setting will be used, which\nis rarely useful.\n\nNote that nesting is implemented by recursion in C. The default value has\nbeen chosen to be as large as typical operating systems allow without\ncrashing.\n\nSee SECURITY CONSIDERATIONS, below, for more info on why this is useful.\n\n=item $json = $json->max_size ([$maximum_string_size])\n\n=item $max_size = $json->get_max_size\n\nSet the maximum length a JSON text may have (in bytes) where decoding is\nbeing attempted. The default is C<0>, meaning no limit. When C<decode>\nis called on a string that is longer then this many bytes, it will not\nattempt to decode the string but throw an exception. This setting has no\neffect on C<encode> (yet).\n\nIf no argument is given, the limit check will be deactivated (same as when\nC<0> is specified).\n\nSee SECURITY CONSIDERATIONS, below, for more info on why this is useful.\n\n=item $json_text = $json->encode ($perl_scalar)\n\nConverts the given Perl data structure (a simple scalar or a reference\nto a hash or array) to its JSON representation. Simple scalars will be\nconverted into JSON string or number sequences, while references to arrays\nbecome JSON arrays ", 8192) = 8192
09:01:57.461925 read(8, "and references to hashes become JSON objects. Undefined\nPerl values (e.g. C<undef>) become JSON C<null> values. Neither C<true>\nnor C<false> values will be generated.\n\n=item $perl_scalar = $json->decode ($json_text)\n\nThe opposite of C<encode>: expects a JSON text and tries to parse it,\nreturning the resulting simple scalar or reference. Croaks on error.\n\nJSON numbers and strings become simple Perl scalars. JSON arrays become\nPerl arrayrefs and JSON objects become Perl hashrefs.\nC<true> becomes JSON::XS::true (equals 1 numerically and as a string),\nC<false> becomes JSON::XS::false (equals 0) and C<null> becomes C<undef>.\n\n=item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)\n\nThis works like the C<decode> method, but instead of raising an exception\nwhen there is trailing garbage after the first JSON object, it will\nsilently stop parsing there and return the number of characters consumed\nso far.\n\nThis is useful if your JSON texts are not delimited by an outer protocol\n(which is not the brightest thing to do in the first place) and you need\nto know where the JSON text ends.\n\n   JSON::XS->new->decode_prefix (\"[1] the tail\")\n   => ([], 3)\n\n=back\n\n\n=head1 INCREMENTAL PARSING\n\nIn some cases, there is the need for incremental parsing of JSON\ntexts. While this module always has to keep both JSON text and resulting\nPerl data structure in memory at one time, it does allow you to parse a\nJSON stream incrementally. It does so by accumulating text until it has\na full JSON object, which it then can decode. This process is similar to\nusing C<decode_prefix> to see if a full JSON object is available, but\nis much more efficient (and can be implemented with a minimum of method\ncalls).\n\nJSON::XS will only attempt to parse the JSON text once it is sure it\nhas enough text to get a decisive result, using a very simple but\ntruly incremental parser. This means that it sometimes won't stop as\nearly as the full parser, for example, it doesn't detect mismatched\nparentheses. The only thing it guarantees is that it starts decoding as\nsoon as a syntactically valid JSON text has been seen. This means you need\nto set resource limits (e.g. C<max_size>) to ensure the parser will stop\nparsing in the presence if syntax errors.\n\nThe following methods implement this incremental parser.\n\n=over 4\n\n=item [void, scalar or list context] = $json->incr_parse ([$string])\n\nThis is the central parsing function. It can both append new text and\nextract objects from the stream accumulated so far (both of these\nfunctions are optional).\n\nIf C<$string> is given, then this string is appended to the already\nexisting JSON fragment stored in the C<$json> object.\n\nAfter that, if the function is called in void context, it will simply\nreturn without doing anything further. This can be used to add more text\nin as many chunks as you want.\n\nIf the method is called in scalar context, then it will try to extract\nexactly I<one> JSON object. If that is successful, it will return this\nobject, otherwise it will return C<undef>. If there is a parse error,\nthis method will croak just as C<decode> would do (one can then use\nC<incr_skip> to skip the errornous part). This is the most common way of\nusing the method.\n\nAnd finally, in list context, it will try to extract as many objects\nfrom the stream as it can find and return them, or the empty list\notherwise. For this to work, there must be no separators between the JSON\nobjects or arrays, instead they must be concatenated back-to-back. If\nan error occurs, an exception will be raised as in the scalar context\ncase. Note that in this case, any previously-parsed JSON texts will be\nlost.\n\nExample: Parse some JSON arrays/objects in a given string and return\nthem.\n\n   my @objs = JSON::XS->new->incr_parse (\"[5][7][1,2]\");\n\n=item $lvalue_string = $json->incr_text\n\nThis method returns the currently stored JSON fragment as an lvalue, that\nis, you can manipulate it. This I<only> works when a preceding call to\nC<incr_parse> in I<scalar context> successfully returned an object. Under\nall other circumstances you must not call this function (I mean it.\nalthough in simple tests it might actually work, it I<will> fail under\nreal world conditions). As a special exception, you can also call this\nmethod before having parsed anything.\n\nThis function is useful in two cases: a) finding the trailing text after a\nJSON object or b) parsing multiple JSON objects separated by non-JSON text\n(such as commas).\n\n=item $json->incr_skip\n\nThis will reset the state of the incremental parser and will remove\nthe parsed text from the input buffer so far. This is useful after\nC<incr_parse> died, in which case the input buffer and incremental parser\nstate is left unchanged, to skip the text parsed so far and to reset the\nparse state.\n\nThe difference to C<incr_reset> is that only text until the parse error\noccured is removed.\n\n=item $json->incr_reset\n\nThis completely resets the incremental parser, that is, after this call,\nit will be as if the parser had never parsed anything.\n\nThis is useful if you want to repeatedly parse JSON objects and want to\nignore any trailing data, which means you have to reset the parser after\neach successful decode.\n\n=back\n\n=head2 LIMITATIONS\n\nAll options that affect decoding are supported, except\nC<allow_nonref>. The reason for this is that it cannot be made to\nwork sensibly: JSON objects and arrays are self-delimited, i.e. you can concatenate\nthem back to back and still decode them perfectly. This does not hold true\nfor JSON numbers, however.\n\nFor example, is the string C<1> a single JSON number, or is it simply the\nstart of C<12>? Or is C<12> a single JSON number, or the concatenation\nof C<1> and C<2>? In neither case you can tell, and this is why JSON::XS\ntakes the conservative route and disallows this case.\n\n=head2 EXAMPLES\n\nSome examples will make all this clearer. First, a simple example that\nworks similarly to C<decode_prefix>: We want to decode the JSON object at\nthe start of a string and identify the portion after the JSON object:\n\n   my $text = \"[1,2,3] hello\";\n\n   my $json = new JSON::XS;\n\n   my $obj = $json->incr_parse ($text)\n      or die \"expected JSON object or array at beginning of string\";\n\n   my $tail = $json->incr_text;\n   # $tail now contains \" hello\"\n\nEasy, isn't it?\n\nNow for a more complicated example: Imagine a hypothetical protocol where\nyou read some requests from a TCP stream, and each request is a JSON\narray, without any separation between them (in fact, it is often useful to\nuse newlines as \"separators\", as these get interpreted as whitespace at\nthe start of the JSON text, which makes it possible to test said protocol\nwith C<telnet>...).\n\nHere is how you'd do it (it is trivial to write this in an event-based\nmanner):\n\n   my $json = new JSON::XS;\n\n   # read some data from the socket\n   while (sysread $socket, my $buf, 4096) {\n\n      # split and decode as many requests as possible\n      for my $request ($json->incr_parse ($buf)) {\n         # act on the $request\n      }\n   }\n\nAnother complicated example: Assume you have a string with JSON objects\nor arrays, all separated by (optional) comma characters (e.g. C<[1],[2],\n[3]>). To parse them, we have to skip the commas between the JSON texts,\nand here is where the lvalue-ness of C<incr_text> comes in useful:\n\n   my $text = \"[1],[2], [3]\";\n   my $json = new JSON::XS;\n\n   # void context, so no parsing done\n   $json->incr_parse ($text);\n\n   # now extract as many objects as possible. note the\n   # use of scalar context so incr_text can be called.\n   while (my $obj = $json->incr_parse) {\n      # do something with $obj\n\n      # now skip the optional comma\n      $json->incr_text =~ s/^ \\s* , //x;\n   }\n\nNow lets go for a very complex example: Assume that you have a gigantic\nJSON array-of-objects, many gigabytes in size, and you want to parse it,\nbut you cannot load it into memory fully (this has actually happened in\nthe real world :).\n\nWell, you lost, you have to implement your own JSON parser. But JSON::XS\ncan still help you: You implement a (very simple) array parser and let\nJSON decode the array elements, which are all full JSON objects on their\nown (this wouldn't work if the array elements c", 8192) = 8192
09:01:57.462362 read(8, "ould be JSON numbers, for\nexample):\n\n   my $json = new JSON::XS;\n\n   # open the monster\n   open my $fh, \"<bigfile.json\"\n      or die \"bigfile: $!\";\n\n   # first parse the initial \"[\"\n   for (;;) {\n      sysread $fh, my $buf, 65536\n         or die \"read error: $!\";\n      $json->incr_parse ($buf); # void context, so no parsing\n\n      # Exit the loop once we found and removed(!) the initial \"[\".\n      # In essence, we are (ab-)using the $json object as a simple scalar\n      # we append data to.\n      last if $json->incr_text =~ s/^ \\s* \\[ //x;\n   }\n\n   # now we have the skipped the initial \"[\", so continue\n   # parsing all the elements.\n   for (;;) {\n      # in this loop we read data until we got a single JSON object\n      for (;;) {\n         if (my $obj = $json->incr_parse) {\n            # do something with $obj\n            last;\n         }\n\n         # add more data\n         sysread $fh, my $buf, 65536\n            or die \"read error: $!\";\n         $json->incr_parse ($buf); # void context, so no parsing\n      }\n\n      # in this loop we read data until we either found and parsed the\n      # separating \",\" between elements, or the final \"]\"\n      for (;;) {\n         # first skip whitespace\n         $json->incr_text =~ s/^\\s*//;\n\n         # if we find \"]\", we are done\n         if ($json->incr_text =~ s/^\\]//) {\n            print \"finished.\\n\";\n            exit;\n         }\n\n         # if we find \",\", we can continue with the next element\n         if ($json->incr_text =~ s/^,//) {\n            last;\n         }\n\n         # if we find anything else, we have a parse error!\n         if (length $json->incr_text) {\n            die \"parse error near \", $json->incr_text;\n         }\n\n         # else add more data\n         sysread $fh, my $buf, 65536\n            or die \"read error: $!\";\n         $json->incr_parse ($buf); # void context, so no parsing\n      }\n\nThis is a complex example, but most of the complexity comes from the fact\nthat we are trying to be correct (bear with me if I am wrong, I never ran\nthe above example :).\n\n\n\n=head1 MAPPING\n\nThis section describes how JSON::XS maps Perl values to JSON values and\nvice versa. These mappings are designed to \"do the right thing\" in most\ncircumstances automatically, preserving round-tripping characteristics\n(what you put in comes out as something equivalent).\n\nFor the more enlightened: note that in the following descriptions,\nlowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>\nrefers to the abstract Perl language itself.\n\n\n=head2 JSON -> PERL\n\n=over 4\n\n=item object\n\nA JSON object becomes a reference to a hash in Perl. No ordering of object\nkeys is preserved (JSON does not preserve object key ordering itself).\n\n=item array\n\nA JSON array becomes a reference to an array in Perl.\n\n=item string\n\nA JSON string becomes a string scalar in Perl - Unicode codepoints in JSON\nare represented by the same codepoints in the Perl string, so no manual\ndecoding is necessary.\n\n=item number\n\nA JSON number becomes either an integer, numeric (floating point) or\nstring scalar in perl, depending on its range and any fractional parts. On\nthe Perl level, there is no difference between those as Perl handles all\nthe conversion details, but an integer may take slightly less memory and\nmight represent more values exactly than floating point numbers.\n\nIf the number consists of digits only, JSON::XS will try to represent\nit as an integer value. If that fails, it will try to represent it as\na numeric (floating point) value if that is possible without loss of\nprecision. Otherwise it will preserve the number as a string value (in\nwhich case you lose roundtripping ability, as the JSON number will be\nre-encoded toa JSON string).\n\nNumbers containing a fractional or exponential part will always be\nrepresented as numeric (floating point) values, possibly at a loss of\nprecision (in which case you might lose perfect roundtripping ability, but\nthe JSON number will still be re-encoded as a JSON number).\n\nNote that precision is not accuracy - binary floating point values cannot\nrepresent most decimal fractions exactly, and when converting from and to\nfloating point, JSON::XS only guarantees precision up to but not including\nthe leats significant bit.\n\n=item true, false\n\nThese JSON atoms become C<JSON::XS::true> and C<JSON::XS::false>,\nrespectively. They are overloaded to act almost exactly like the numbers\nC<1> and C<0>. You can check whether a scalar is a JSON boolean by using\nthe C<JSON::XS::is_bool> function.\n\n=item null\n\nA JSON null atom becomes C<undef> in Perl.\n\n=back\n\n\n=head2 PERL -> JSON\n\nThe mapping from Perl to JSON is slightly more difficult, as Perl is a\ntruly typeless language, so we can only guess which JSON type is meant by\na Perl value.\n\n=over 4\n\n=item hash references\n\nPerl hash references become JSON objects. As there is no inherent ordering\nin hash keys (or JSON objects), they will usually be encoded in a\npseudo-random order that can change between runs of the same program but\nstays generally the same within a single run of a program. JSON::XS can\noptionally sort the hash keys (determined by the I<canonical> flag), so\nthe same datastructure will serialise to the same JSON text (given same\nsettings and version of JSON::XS), but this incurs a runtime overhead\nand is only rarely useful, e.g. when you want to compare some JSON text\nagainst another for equality.\n\n=item array references\n\nPerl array references become JSON arrays.\n\n=item other references\n\nOther unblessed references are generally not allowed and will cause an\nexception to be thrown, except for references to the integers C<0> and\nC<1>, which get turned into C<false> and C<true> atoms in JSON. You can\nalso use C<JSON::XS::false> and C<JSON::XS::true> to improve readability.\n\n   encode_json [\\0, JSON::XS::true]      # yields [false,true]\n\n=item JSON::XS::true, JSON::XS::false\n\nThese special values become JSON true and JSON false values,\nrespectively. You can also use C<\\1> and C<\\0> directly if you want.\n\n=item blessed objects\n\nBlessed objects are not directly representable in JSON. See the\nC<allow_blessed> and C<convert_blessed> methods on various options on\nhow to deal with this: basically, you can choose between throwing an\nexception, encoding the reference as if it weren't blessed, or provide\nyour own serialiser method.\n\n=item simple scalars\n\nSimple Perl scalars (any scalar that is not a reference) are the most\ndifficult objects to encode: JSON::XS will encode undefined scalars as\nJSON C<null> values, scalars that have last been used in a string context\nbefore encoding as JSON strings, and anything else as number value:\n\n   # dump as number\n   encode_json [2]                      # yields [2]\n   encode_json [-3.0e17]                # yields [-3e+17]\n   my $value = 5; encode_json [$value]  # yields [5]\n\n   # used as string, so dump as string\n   print $value;\n   encode_json [$value]                 # yields [\"5\"]\n\n   # undef becomes null\n   encode_json [undef]                  # yields [null]\n\nYou can force the type to be a JSON string by stringifying it:\n\n   my $x = 3.1; # some variable containing a number\n   \"$x\";        # stringified\n   $x .= \"\";    # another, more awkward way to stringify\n   print $x;    # perl does it for you, too, quite often\n\nYou can force the type to be a JSON number by numifying it:\n\n   my $x = \"3\"; # some variable containing a string\n   $x += 0;     # numify it, ensuring it will be dumped as a number\n   $x *= 1;     # same thing, the choice is yours.\n\nYou can not currently force the type in other, less obscure, ways. Tell me\nif you need this capability (but don't forget to explain why it's needed\n:).\n\nNote that numerical precision has the same meaning as under Perl (so\nbinary to decimal conversion follows the same rules as in Perl, which\ncan differ to other languages). Also, your perl interpreter might expose\nextensions to the floating point numbers of your platform, such as\ninfinities or NaN's - these cannot be represented in JSON, and it is an\nerror to pass those in.\n\n=back\n\n\n=head1 ENCODING/CODESET FLAG NOTES\n\nThe interested reader might have seen a number of flags that signify\nencodings or codesets - C<utf8>, C<latin1> and C<", 8192) = 8192
09:01:57.462770 read(8, "ascii>. There seems to be\nsome confusion on what these do, so here is a short comparison:\n\nC<utf8> controls whether the JSON text created by C<encode> (and expected\nby C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only\ncontrol whether C<encode> escapes character values outside their respective\ncodeset range. Neither of these flags conflict with each other, although\nsome combinations make less sense than others.\n\nCare has been taken to make all flags symmetrical with respect to\nC<encode> and C<decode>, that is, texts encoded with any combination of\nthese flag values will be correctly decoded when the same flags are used\n- in general, if you use different flag settings while encoding vs. when\ndecoding you likely have a bug somewhere.\n\nBelow comes a verbose discussion of these flags. Note that a \"codeset\" is\nsimply an abstract set of character-codepoint pairs, while an encoding\ntakes those codepoint numbers and I<encodes> them, in our case into\noctets. Unicode is (among other things) a codeset, UTF-8 is an encoding,\nand ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at\nthe same time, which can be confusing.\n\n=over 4\n\n=item C<utf8> flag disabled\n\nWhen C<utf8> is disabled (the default), then C<encode>/C<decode> generate\nand expect Unicode strings, that is, characters with high ordinal Unicode\nvalues (> 255) will be encoded as such characters, and likewise such\ncharacters are decoded as-is, no canges to them will be done, except\n\"(re-)interpreting\" them as Unicode codepoints or Unicode characters,\nrespectively (to Perl, these are the same thing in strings unless you do\nfunny/weird/dumb stuff).\n\nThis is useful when you want to do the encoding yourself (e.g. when you\nwant to have UTF-16 encoded JSON texts) or when some other layer does\nthe encoding for you (for example, when printing to a terminal using a\nfilehandle that transparently encodes to UTF-8 you certainly do NOT want\nto UTF-8 encode your data first and have Perl encode it another time).\n\n=item C<utf8> flag enabled\n\nIf the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all\ncharacters using the corresponding UTF-8 multi-byte sequence, and will\nexpect your input strings to be encoded as UTF-8, that is, no \"character\"\nof the input string must have any value > 255, as UTF-8 does not allow\nthat.\n\nThe C<utf8> flag therefore switches between two modes: disabled means you\nwill get a Unicode string in Perl, enabled means you get an UTF-8 encoded\noctet/binary string in Perl.\n\n=item C<latin1> or C<ascii> flags enabled\n\nWith C<latin1> (or C<ascii>) enabled, C<encode> will escape characters\nwith ordinal values > 255 (> 127 with C<ascii>) and encode the remaining\ncharacters as specified by the C<utf8> flag.\n\nIf C<utf8> is disabled, then the result is also correctly encoded in those\ncharacter sets (as both are proper subsets of Unicode, meaning that a\nUnicode string with all character values < 256 is the same thing as a\nISO-8859-1 string, and a Unicode string with all character values < 128 is\nthe same thing as an ASCII string in Perl).\n\nIf C<utf8> is enabled, you still get a correct UTF-8-encoded string,\nregardless of these flags, just some more characters will be escaped using\nC<\\uXXXX> then before.\n\nNote that ISO-8859-1-I<encoded> strings are not compatible with UTF-8\nencoding, while ASCII-encoded strings are. That is because the ISO-8859-1\nencoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being\na subset of Unicode), while ASCII is.\n\nSurprisingly, C<decode> will ignore these flags and so treat all input\nvalues as governed by the C<utf8> flag. If it is disabled, this allows you\nto decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of\nUnicode. If it is enabled, you can correctly decode UTF-8 encoded strings.\n\nSo neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -\nthey only govern when the JSON output engine escapes a character or not.\n\nThe main use for C<latin1> is to relatively efficiently store binary data\nas JSON, at the expense of breaking compatibility with most JSON decoders.\n\nThe main use for C<ascii> is to force the output to not contain characters\nwith values > 127, which means you can interpret the resulting string\nas UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and\n8-bit-encoding, and still get the same data structure back. This is useful\nwhen your channel for JSON transfer is not 8-bit clean or the encoding\nmight be mangled in between (e.g. in mail), and works because ASCII is a\nproper subset of most 8-bit and multibyte encodings in use in the world.\n\n=back\n\n\n=head2 JSON and ECMAscript\n\nJSON syntax is based on how literals are represented in javascript (the\nnot-standardised predecessor of ECMAscript) which is presumably why it is\ncalled \"JavaScript Object Notation\".\n\nHowever, JSON is not a subset (and also not a superset of course) of\nECMAscript (the standard) or javascript (whatever browsers actually\nimplement).\n\nIf you want to use javascript's C<eval> function to \"parse\" JSON, you\nmight run into parse errors for valid JSON texts, or the resulting data\nstructure might not be queryable:\n\nOne of the problems is that U+2028 and U+2029 are valid characters inside\nJSON strings, but are not allowed in ECMAscript string literals, so the\nfollowing Perl fragment will not output something that can be guaranteed\nto be parsable by javascript's C<eval>:\n\n   use JSON::XS;\n\n   print encode_json [chr 0x2028];\n\nThe right fix for this is to use a proper JSON parser in your javascript\nprograms, and not rely on C<eval> (see for example Douglas Crockford's\nF<json2.js> parser).\n\nIf this is not an option, you can, as a stop-gap measure, simply encode to\nASCII-only JSON:\n\n   use JSON::XS;\n\n   print JSON::XS->new->ascii->encode ([chr 0x2028]);\n\nNote that this will enlarge the resulting JSON text quite a bit if you\nhave many non-ASCII characters. You might be tempted to run some regexes\nto only escape U+2028 and U+2029, e.g.:\n\n   # DO NOT USE THIS!\n   my $json = JSON::XS->new->utf8->encode ([chr 0x2028]);\n   $json =~ s/\\xe2\\x80\\xa8/\\\\u2028/g; # escape U+2028\n   $json =~ s/\\xe2\\x80\\xa9/\\\\u2029/g; # escape U+2029\n   print $json;\n\nNote that I<this is a bad idea>: the above only works for U+2028 and\nU+2029 and thus only for fully ECMAscript-compliant parsers. Many existing\njavascript implementations, however, have issues with other characters as\nwell - using C<eval> naively simply I<will> cause problems.\n\nAnother problem is that some javascript implementations reserve\nsome property names for their own purposes (which probably makes\nthem non-ECMAscript-compliant). For example, Iceweasel reserves the\nC<__proto__> property name for its own purposes.\n\nIf that is a problem, you could parse try to filter the resulting JSON\noutput for these property strings, e.g.:\n\n   $json =~ s/\"__proto__\"\\s*:/\"__proto__renamed\":/g;\n\nThis works because C<__proto__> is not valid outside of strings, so every\noccurence of C<\"__proto__\"\\s*:> must be a string used as property name.\n\nIf you know of other incompatibilities, please let me know.\n\n\n=head2 JSON and YAML\n\nYou often hear that JSON is a subset of YAML. This is, however, a mass\nhysteria(*) and very far from the truth (as of the time of this writing),\nso let me state it clearly: I<in general, there is no way to configure\nJSON::XS to output a data structure as valid YAML> that works in all\ncases.\n\nIf you really must use JSON::XS to generate YAML, you should use this\nalgorithm (subject to change in future versions):\n\n   my $to_yaml = JSON::XS->new->utf8->space_after (1);\n   my $yaml = $to_yaml->encode ($ref) . \"\\n\";\n\nThis will I<usually> generate JSON texts that also parse as valid\nYAML. Please note that YAML has hardcoded limits on (simple) object key\nlengths that JSON doesn't have and also has different and incompatible\nunicode character escape syntax, so you should make sure that your hash\nkeys are noticeably shorter than the 1024 \"stream characters\" YAML allows\nand that you do not have characters with codepoint values outside the\nUnicode BMP (basic multilingual page). YAML also does not allow C<\\/>\nsequences in strings (which JSON::XS does not I<currently> gene", 8192) = 8192
09:01:57.463176 read(8, "rate, but\nother JSON generators might).\n\nThere might be other incompatibilities that I am not aware of (or the YAML\nspecification has been changed yet again - it does so quite often). In\ngeneral you should not try to generate YAML with a JSON generator or vice\nversa, or try to parse JSON with a YAML parser or vice versa: chances are\nhigh that you will run into severe interoperability problems when you\nleast expect it.\n\n=over 4\n\n=item (*)\n\nI have been pressured multiple times by Brian Ingerson (one of the\nauthors of the YAML specification) to remove this paragraph, despite him\nacknowledging that the actual incompatibilities exist. As I was personally\nbitten by this \"JSON is YAML\" lie, I refused and said I will continue to\neducate people about these issues, so others do not run into the same\nproblem again and again. After this, Brian called me a (quote)I<complete\nand worthless idiot>(unquote).\n\nIn my opinion, instead of pressuring and insulting people who actually\nclarify issues with YAML and the wrong statements of some of its\nproponents, I would kindly suggest reading the JSON spec (which is not\nthat difficult or long) and finally make YAML compatible to it, and\neducating users about the changes, instead of spreading lies about the\nreal compatibility for many I<years> and trying to silence people who\npoint out that it isn't true.\n\nAddendum/2009: the YAML 1.2 spec is still incompatible with JSON, even\nthough the incompatibilities have been documented (and are known to Brian)\nfor many years and the spec makes explicit claims that YAML is a superset\nof JSON. It would be so easy to fix, but apparently, bullying people and\ncorrupting userdata is so much easier.\n\n=back\n\n\n=head2 SPEED\n\nIt seems that JSON::XS is surprisingly fast, as shown in the following\ntables. They have been generated with the help of the C<eg/bench> program\nin the JSON::XS distribution, to make it easy to compare on your own\nsystem.\n\nFirst comes a comparison between various modules using\na very short single-line JSON string (also available at\nL<http://dist.schmorp.de/misc/json/short.json>).\n\n   {\"method\": \"handleMessage\", \"params\": [\"user1\",\n   \"we were just talking\"], \"id\": null, \"array\":[1,11,234,-5,1e5,1e7,\n   1,  0]}\n\nIt shows the number of encodes/decodes per second (JSON::XS uses\nthe functional interface, while JSON::XS/2 uses the OO interface\nwith pretty-printing and hashkey sorting enabled, JSON::XS/3 enables\nshrink. JSON::DWIW/DS uses the deserialise function, while JSON::DWIW::FJ\nuses the from_json method). Higher is better:\n\n   module        |     encode |     decode |\n   --------------|------------|------------|\n   JSON::DWIW/DS |  86302.551 | 102300.098 |\n   JSON::DWIW/FJ |  86302.551 |  75983.768 |\n   JSON::PP      |  15827.562 |   6638.658 |\n   JSON::Syck    |  63358.066 |  47662.545 |\n   JSON::XS      | 511500.488 | 511500.488 |\n   JSON::XS/2    | 291271.111 | 388361.481 |\n   JSON::XS/3    | 361577.931 | 361577.931 |\n   Storable      |  66788.280 | 265462.278 |\n   --------------+------------+------------+\n\nThat is, JSON::XS is almost six times faster than JSON::DWIW on encoding,\nabout five times faster on decoding, and over thirty to seventy times\nfaster than JSON's pure perl implementation. It also compares favourably\nto Storable for small amounts of data.\n\nUsing a longer test string (roughly 18KB, generated from Yahoo! Locals\nsearch API (L<http://dist.schmorp.de/misc/json/long.json>).\n\n   module        |     encode |     decode |\n   --------------|------------|------------|\n   JSON::DWIW/DS |   1647.927 |   2673.916 |\n   JSON::DWIW/FJ |   1630.249 |   2596.128 |\n   JSON::PP      |    400.640 |     62.311 |\n   JSON::Syck    |   1481.040 |   1524.869 |\n   JSON::XS      |  20661.596 |   9541.183 |\n   JSON::XS/2    |  10683.403 |   9416.938 |\n   JSON::XS/3    |  20661.596 |   9400.054 |\n   Storable      |  19765.806 |  10000.725 |\n   --------------+------------+------------+\n\nAgain, JSON::XS leads by far (except for Storable which non-surprisingly\ndecodes a bit faster).\n\nOn large strings containing lots of high Unicode characters, some modules\n(such as JSON::PC) seem to decode faster than JSON::XS, but the result\nwill be broken due to missing (or wrong) Unicode handling. Others refuse\nto decode or encode properly, so it was impossible to prepare a fair\ncomparison table for that case.\n\n\n=head1 SECURITY CONSIDERATIONS\n\nWhen you are using JSON in a protocol, talking to untrusted potentially\nhostile creatures requires relatively few measures.\n\nFirst of all, your JSON decoder should be secure, that is, should not have\nany buffer overflows. Obviously, this module should ensure that and I am\ntrying hard on making that true, but you never know.\n\nSecond, you need to avoid resource-starving attacks. That means you should\nlimit the size of JSON texts you accept, or make sure then when your\nresources run out, that's just fine (e.g. by using a separate process that\ncan crash safely). The size of a JSON text in octets or characters is\nusually a good indication of the size of the resources required to decode\nit into a Perl structure. While JSON::XS can check the size of the JSON\ntext, it might be too late when you already have it in memory, so you\nmight want to check the size before you accept the string.\n\nThird, JSON::XS recurses using the C stack when decoding objects and\narrays. The C stack is a limited resource: for instance, on my amd64\nmachine with 8MB of stack size I can decode around 180k nested arrays but\nonly 14k nested JSON objects (due to perl itself recursing deeply on croak\nto free the temporary). If that is exceeded, the program crashes. To be\nconservative, the default nesting limit is set to 512. If your process\nhas a smaller stack, you should adjust this setting accordingly with the\nC<max_depth> method.\n\nSomething else could bomb you, too, that I forgot to think of. In that\ncase, you get to keep the pieces. I am always open for hints, though...\n\nAlso keep in mind that JSON::XS might leak contents of your Perl data\nstructures in its error messages, so when you serialise sensitive\ninformation you might want to make sure that exceptions thrown by JSON::XS\nwill not end up in front of untrusted eyes.\n\nIf you are using JSON::XS to return packets to consumption\nby JavaScript scripts in a browser you should have a look at\nL<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to\nsee whether you are vulnerable to some common attack vectors (which really\nare browser design bugs, but it is still you who will have to deal with\nit, as major browser developers care only for features, not about getting\nsecurity right).\n\n\n=head1 THREADS\n\nThis module is I<not> guaranteed to be thread safe and there are no\nplans to change this until Perl gets thread support (as opposed to the\nhorribly slow so-called \"threads\" which are simply slow and bloated\nprocess simulations - use fork, it's I<much> faster, cheaper, better).\n\n(It might actually work, but you have been warned).\n\n\n=head1 BUGS\n\nWhile the goal of this module is to be correct, that unfortunately does\nnot mean it's bug-free, only that I think its design is bug-free. If you\nkeep reporting bugs they will be fixed swiftly, though.\n\nPlease refrain from using rt.cpan.org or any other bug reporting\nservice. I put the contact address into my modules for a reason.\n\n=cut\n\nour $true  = do { bless \\(my $dummy = 1), \"JSON::XS::Boolean\" };\nour $false = do { bless \\(my $dummy = 0), \"JSON::XS::Boolean\" };\n\nsub true()  { $true  }\nsub false() { $false }\n\nsub is_bool($) {\n   UNIVERSAL::isa $_[0], \"JSON::XS::Boolean\"\n#      or UNIVERSAL::isa $_[0], \"JSON::Literal\"\n}\n\nXSLoader::load \"JSON::XS\", $VERSION;\n\npackage JSON::XS::Boolean;\n\nuse overload\n   \"0+\"     => sub { ${$_[0]} },\n   \"++\"     => sub { $_[0] = ${$_[0]} + 1 },\n   \"--\"     => sub { $_[0] = ${$_[0]} - 1 },\n   fallback => 1;\n\n1;\n\n=head1 SEE ALSO\n\nThe F<json_xs> command line utility for quick experiments.\n\n=head1 AUTHOR\n\n Marc Lehmann <schmorp@schmorp.de>\n http://home.schmorp.de/\n\n=cut\n\n", 8192) = 8004
09:01:57.463762 read(8, "", 8192)       = 0
09:01:57.463813 close(8)                = 0
09:01:57.463928 stat("/usr/lib/perl5/auto/JSON/XS/XS.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.463992 stat("/usr/lib/perl5/auto/JSON/XS/XS.so", {st_mode=S_IFREG|0644, st_size=56936, ...}) = 0
09:01:57.464050 stat("/usr/lib/perl5/auto/JSON/XS/XS.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
09:01:57.464130 open("/usr/lib/perl5/auto/JSON/XS/XS.so", O_RDONLY) = 8
09:01:57.464182 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000(\0\0\0\0\0\0@\0\0\0\0\0\0\0\350\327\0\0\0\0\0\0\0\0\0\0@\0008\0\6\0@\0\32\0\31\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\321\0\0\0\0\0\0\354\321\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\360\321\0\0\0\0\0\0\360\321 \0\0\0\0\0\360\321 \0\0\0\0\0(\5\0\0\0\0\0\0p\6\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\30\322\0\0\0\0\0\0\30\322 \0\0\0\0\0\30\322 \0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0\220\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\260\307\0\0\0\0\0\0\260\307\0\0\0\0\0\0\260\307\0\0\0\0\0\0<\1\0\0\0\0\0\0<\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\246\317\233R\323\10\323o\t*\324\31468\320\247\315\222\350\n\0\0\0\0a\0\0\0q\0\0\0\0\0\0\0\0\0\0\0T\0\0\0\0\0\0\0G\0\0\0001\0\0\0<\0\0\0\0\0\0\0\0\0\0\0\21\0\0\0\0\0\0\0'\0\0\0?\0\0\0H\0\0\0M\0\0\0e\0\0\0\0\0\0\0`\0\0\0\0\0\0\0\0\0\0\0C\0\0\0Y\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0_\0\0\0O\0\0\0;\0\0\0o\0\0\0m\0\0\0\0\0\0\0\31\0\0\0A\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0I\0\0\0\33\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\0\0\0\0>\0\0\0#\0\0\0S\0\0\0\f\0\0\0R\0\0\0@\0\0\0n\0\0\0000\0\0\0E\0\0\0f\0\0\0a\0\0\0L\0\0\0\"\0\0\0\34\0\0\0\23\0\0\0\0\0\0\0D\0\0\0Z\0\0\0\0\0\0\0[\0\0\0\0\0\0\0\0\0\0\0K\0\0\0\r\0\0\0c\0\0\0\0\0\0\0\0\0\0\0X\0\0\0\17\0\0\0$\0\0\0F\0\0\0=\0\0\0\0\0\0\0k\0\0\0-\0\0\0\0\0\0\0%\0\0\0:\0\0\0004\0\0\0Q\0\0\0d\0\0\0U\0\0\0\0\0\0\0^\0\0\0\0\0\0\0009\0\0\0g\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0\0\0", 832) = 832
09:01:57.464320 fstat(8, {st_mode=S_IFREG|0644, st_size=56936, ...}) = 0
09:01:57.464378 mmap(NULL, 2152544, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f74315ef000
09:01:57.464429 mprotect(0x7f74315fd000, 2093056, PROT_NONE) = 0
09:01:57.464478 mmap(0x7f74317fc000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0xd000) = 0x7f74317fc000
09:01:57.464534 close(8)                = 0
09:01:57.464708 stat("modules/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.464759 stat("modules/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.464810 stat("modules/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.464857 stat("modules/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.464905 stat("/etc/perl/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.464954 stat("/etc/perl/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.465003 stat("/usr/local/lib/perl/5.14.2/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.465053 stat("/usr/local/lib/perl/5.14.2/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.465103 stat("/usr/local/share/perl/5.14.2/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.465152 stat("/usr/local/share/perl/5.14.2/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.465203 stat("/usr/lib/perl5/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.465251 stat("/usr/lib/perl5/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.465300 stat("/usr/share/perl5/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.465348 stat("/usr/share/perl5/attributes.pm", 0x7ffe1233af70) = -1 ENOENT (No such file or directory)
09:01:57.465397 stat("/usr/lib/perl/5.14/attributes.pmc", 0x7ffe1233b020) = -1 ENOENT (No such file or directory)
09:01:57.465449 stat("/usr/lib/perl/5.14/attributes.pm", {st_mode=S_IFREG|0644, st_size=2673, ...}) = 0
09:01:57.465508 open("/usr/lib/perl/5.14/attributes.pm", O_RDONLY) = 8
09:01:57.465562 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233ad00) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.465608 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.465677 read(8, "package attributes;\n\nour $VERSION = 0.14;\n\n@EXPORT_OK = qw(get reftype);\n@EXPORT = ();\n%EXPORT_TAGS = (ALL => [@EXPORT, @EXPORT_OK]);\n\nuse strict;\n\nsub croak {\n    require Carp;\n    goto &Carp::croak;\n}\n\nsub carp {\n    require Carp;\n    goto &Carp::carp;\n}\n\nmy %deprecated;\n$deprecated{CODE} = qr/\\A-?(locked)\\z/;\n$deprecated{ARRAY} = $deprecated{HASH} = $deprecated{SCALAR}\n    = qr/\\A-?(unique)\\z/;\n\nsub _modify_attrs_and_deprecate {\n    my $svtype = shift;\n    # Now that we've removed handling of locked from the XS code, we need to\n    # remove it here, else it ends up in @badattrs. (If we do the deprecation in\n    # XS, we can't control the warning based on *our* caller's lexical settings,\n    # and the warned line is in this package)\n    grep {\n\t$deprecated{$svtype} && /$deprecated{$svtype}/ ? do {\n\t    require warnings;\n\t    warnings::warnif('deprecated', \"Attribute \\\"$1\\\" is deprecated\");\n\t    0;\n\t} : 1\n    } _modify_attrs(@_);\n}\n\nsub import {\n    @_ > 2 && ref $_[2] or do {\n\trequire Exporter;\n\tgoto &Exporter::import;\n    };\n    my (undef,$home_stash,$svref,@attrs) = @_;\n\n    my $svtype = uc reftype($svref);\n    my $pkgmeth;\n    $pkgmeth = UNIVERSAL::can($home_stash, \"MODIFY_${svtype}_ATTRIBUTES\")\n\tif defined $home_stash && $home_stash ne '';\n    my @badattrs;\n    if ($pkgmeth) {\n\tmy @pkgattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);\n\t@badattrs = $pkgmeth->($home_stash, $svref, @pkgattrs);\n\tif (!@badattrs && @pkgattrs) {\n            require warnings;\n\t    return unless warnings::enabled('reserved');\n\t    @pkgattrs = grep { m/\\A[[:lower:]]+(?:\\z|\\()/ } @pkgattrs;\n\t    if (@pkgattrs) {\n\t\tfor my $attr (@pkgattrs) {\n\t\t    $attr =~ s/\\(.+\\z//s;\n\t\t}\n\t\tmy $s = ((@pkgattrs == 1) ? '' : 's');\n\t\tcarp \"$svtype package attribute$s \" .\n\t\t    \"may clash with future reserved word$s: \" .\n\t\t    join(' : ' , @pkgattrs);\n\t    }\n\t}\n    }\n    else {\n\t@badattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);\n    }\n    if (@badattrs) {\n\tcroak \"Invalid $svtype attribute\" .\n\t    (( @badattrs == 1 ) ? '' : 's') .\n\t    \": \" .\n\t    join(' : ', @badattrs);\n    }\n}\n\nsub get ($) {\n    @_ == 1  && ref $_[0] or\n\tcroak 'Usage: '.__PACKAGE__.'::get $ref';\n    my $svref = shift;\n    my $svtype = uc reftype($svref);\n    my $stash = _guess_stash($svref);\n    $stash = caller unless defined $stash;\n    my $pkgmeth;\n    $pkgmeth = UNIVERSAL::can($stash, \"FETCH_${svtype}_ATTRIBUTES\")\n\tif defined $stash && $stash ne '';\n    return $pkgmeth ?\n\t\t(_fetch_attrs($svref), $pkgmeth->($stash, $svref)) :\n\t\t(_fetch_attrs($svref))\n\t;\n}\n\nsub require_version { goto &UNIVERSAL::VERSION }\n\nrequire XSLoader;\nXSLoader::load();\n\n1;\n__END__\n#The POD goes here\n\n", 8192) = 2673
09:01:57.466251 lseek(8, 2653, SEEK_SET) = 2653
09:01:57.466301 lseek(8, 0, SEEK_CUR)   = 2653
09:01:57.466346 close(8)                = 0
09:01:57.466439 stat("/usr/lib/perl/5.14/auto/attributes/attributes.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.466498 stat("/usr/lib/perl/5.14/auto/attributes/attributes.so", {st_mode=S_IFREG|0644, st_size=10328, ...}) = 0
09:01:57.466558 stat("/usr/lib/perl/5.14/auto/attributes/attributes.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.466621 open("/usr/lib/perl/5.14/auto/attributes/attributes.so", O_RDONLY) = 8
09:01:57.466674 read(8, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360\f\0\0\0\0\0\0@\0\0\0\0\0\0\0\230!\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\31\0\0\0\0\0\0\\\31\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\270\35\0\0\0\0\0\0\270\35 \0\0\0\0\0\270\35 \0\0\0\0\0\340\2\0\0\0\0\0\0\350\2\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320\35\0\0\0\0\0\0\320\35 \0\0\0\0\0\320\35 \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\270\27\0\0\0\0\0\0\270\27\0\0\0\0\0\0\270\27\0\0\0\0\0\0<\0\0\0\0\0\0\0<\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\270\35\0\0\0\0\0\0\270\35 \0\0\0\0\0\270\35 \0\0\0\0\0H\2\0\0\0\0\0\0H\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0{\323Vv\3437\310\274\361\241i\353\32\223\26O\333\367\31\225\0\0\0\0\21\0\0\0\"\0\0\0\0\0\0\0\26\0\0\0\10\0\0\0\25\0\0\0\33\0\0\0\5\0\0\0\31\0\0\0\36\0\0\0\20\0\0\0\37\0\0\0\0\0\0\0\35\0\0\0!\0\0\0\22\0\0\0\27\0\0\0\34\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\t\0\0\0\2\0\0\0\0\0\0\0\f\0\0\0\4\0\0\0 \0\0\0\r\0\0\0\32\0\0\0\16\0\0\0\21\0\0\0\23\0\0\0\6\0\0\0\24\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\0\0\0\0\0\0\0\3\0\0\0\30\0\0\0\1\0\0\0\6\0\0\0\310\342 \241P\fP\t\30\0\0\0\33\0\0\0 \0\0\0BE\325\354*\376\26\225\273\343\222|t\303\250\\\34y\365\233\330qX\34\210ac1\271\215\361\16\352\323\357\16\237\311\375\202\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\n\0\260\v\0\0\0\0\0\0", 832) = 832
09:01:57.466814 fstat(8, {st_mode=S_IFREG|0644, st_size=10328, ...}) = 0
09:01:57.466870 mmap(NULL, 2105504, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0x7f74313ec000
09:01:57.466919 mprotect(0x7f74313ee000, 2093056, PROT_NONE) = 0
09:01:57.466967 mmap(0x7f74315ed000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x1000) = 0x7f74315ed000
09:01:57.467023 close(8)                = 0
09:01:57.467078 mprotect(0x7f74315ed000, 4096, PROT_READ) = 0
09:01:57.467309 read(7, "es to JSON and vice versa using either\nL<JSON::XS> or L<JSON::PP>.\n\nJSON::XS is the fastest and most proper JSON module on CPAN which must be\ncompiled and installed in your environment.\nJSON::PP is a pure-Perl module which is bundled in this distribution and\nhas a strong compatibility to JSON::XS.\n\nThis module try to use JSON::XS by default and fail to it, use JSON::PP instead.\nSo its features completely depend on JSON::XS or JSON::PP.\n\nSee to L<BACKEND MODULE DECISION>.\n\nTo distinguish the module name 'JSON' and the format type JSON,\nthe former is quoted by CE<lt>E<gt> (its results vary with your using media),\nand the latter is left just as it is.\n\nModule name : C<JSON>\n\nFormat type : JSON\n\n=head2 FEATURES\n\n=over\n\n=item * correct unicode handling\n\nThis module (i.e. backend modules) knows how to handle Unicode, documents\nhow and when it does so, and even documents what \"correct\" means.\n\nEven though there are limitations, this feature is available since Perl version 5.6.\n\nJSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions\nC<JSON> sholud call JSON::PP as the backend which can be used since Perl 5.005.\n\nWith Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,\nJSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.\nSee to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.\n\nSee also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>\nand L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.\n\n\n=item * round-trip integrity\n\nWhen you serialise a perl data structure using only data types supported\nby JSON and Perl, the deserialised data structure is identical on the Perl\nlevel. (e.g. the string \"2.0\" doesn't suddenly become \"2\" just because\nit looks like a number). There I<are> minor exceptions to this, read the\nL</MAPPING> section below to learn about those.\n\n\n=item * strict checking of JSON correctness\n\nThere is no guessing, no generating of illegal JSON texts by default,\nand only JSON is accepted as input by default (the latter is a security\nfeature).\n\nSee to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.\n\n=item * fast\n\nThis module returns a JSON::XS object itself if available.\nCompared to other JSON modules and other serialisers such as Storable,\nJSON::XS usually compares favourably in terms of speed, too.\n\nIf not available, C<JSON> returns a JSON::PP object instead of JSON::XS and\nit is very slow as pure-Perl.\n\n=item * simple to use\n\nThis module has both a simple functional interface as well as an\nobject oriented interface interface.\n\n=item * reasonably versatile output formats\n\nYou can choose between the most compact guaranteed-single-line format possible\n(nice for simple line-based protocols), a pure-ASCII format (for when your transport\nis not 8-bit clean, still supports the whole Unicode range), or a pretty-printed\nformat (for when you want to read that stuff). Or you can combine those features\nin whatever way you like.\n\n=back\n\n=head1 FUNCTIONAL INTERFACE\n\nSome documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.\nC<to_json> and C<from_json> are additional functions.\n\n=head2 encode_json\n\n    $json_text = encode_json $perl_scalar\n\nConverts the given Perl data structure to a UTF-8 encoded, binary string.\n\nThis function call is functionally identical to:\n\n    $json_text = JSON->new->utf8->encode($perl_scalar)\n\n=head2 decode_json\n\n    $perl_scalar = decode_json $json_text\n\nThe opposite of C<encode_json>: expects an UTF-8 (binary) string and tries\nto parse that as an UTF-8 encoded JSON text, returning the resulting\nreference.\n\nThis function call is functionally identical to:\n\n    $perl_scalar = JSON->new->utf8->decode($json_text)\n\n\n=head2 to_json\n\n   $json_text = to_json($perl_scalar)\n\nConverts the given Perl data structure to a json string.\n\nThis function call is functionally identical to:\n\n   $json_text = JSON->new->encode($perl_scalar)\n\nTakes a hash reference as the second.\n\n   $json_text = to_json($perl_scalar, $flag_hashref)\n\nSo,\n\n   $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})\n\nequivalent to:\n\n   $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)\n\nIf you want to write a modern perl code which communicates to outer world,\nyou should use C<encode_json> (supposed that JSON data are encoded in UTF-8).\n\n=head2 from_json\n\n   $perl_scalar = from_json($json_text)\n\nThe opposite of C<to_json>: expects a json string and tries\nto parse it, returning the resulting reference.\n\nThis function call is functionally identical to:\n\n    $perl_scalar = JSON->decode($json_text)\n\nTakes a hash reference as the second.\n\n    $perl_scalar = from_json($json_text, $flag_hashref)\n\nSo,\n\n    $perl_scalar = from_json($json_text, {utf8 => 1})\n\nequivalent to:\n\n    $perl_scalar = JSON->new->utf8(1)->decode($json_text)\n\nIf you want to write a modern perl code which communicates to outer world,\nyou should use C<decode_json> (supposed that JSON data are encoded in UTF-8).\n\n=head2 JSON::is_bool\n\n    $is_boolean = JSON::is_bool($scalar)\n\nReturns true if the passed scalar represents either JSON::true or\nJSON::false, two constants that act like C<1> and C<0> respectively\nand are also used to represent JSON C<true> and C<false> in Perl strings.\n\n=head2 JSON::true\n\nReturns JSON true value which is blessed object.\nIt C<isa> JSON::Boolean object.\n\n=head2 JSON::false\n\nReturns JSON false value which is blessed object.\nIt C<isa> JSON::Boolean object.\n\n=head2 JSON::null\n\nReturns C<undef>.\n\nSee L<MAPPING>, below, for more information on how JSON values are mapped to\nPerl.\n\n=head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER\n\nThis section supposes that your perl vresion is 5.8 or later.\n\nIf you know a JSON text from an outer world - a network, a file content, and so on,\nis encoded in UTF-8, you should use C<decode_json> or C<JSON> module object\nwith C<utf8> enable. And the decoded result will contain UNICODE characters.\n\n  # from network\n  my $json        = JSON->new->utf8;\n  my $json_text   = CGI->new->param( 'json_data' );\n  my $perl_scalar = $json->decode( $json_text );\n  \n  # from file content\n  local $/;\n  open( my $fh, '<', 'json.data' );\n  $json_text   = <$fh>;\n  $perl_scalar = decode_json( $json_text );\n\nIf an outer data is not encoded in UTF-8, firstly you should C<decode> it.\n\n  use Encode;\n  local $/;\n  open( my $fh, '<', 'json.data' );\n  my $encoding = 'cp932';\n  my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE\n  \n  # or you can write the below code.\n  #\n  # open( my $fh, \"<:encoding($encoding)\", 'json.data' );\n  # $unicode_json_text = <$fh>;\n\nIn this case, C<$unicode_json_text> is of course UNICODE string.\nSo you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.\nInstead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.\n\n  $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );\n  # or\n  $perl_scalar = from_json( $unicode_json_text );\n\nOr C<encode 'utf8'> and C<decode_json>:\n\n  $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );\n  # this way is not efficient.\n\nAnd now, you want to convert your C<$perl_scalar> into JSON data and\nsend it to an outer world - a network or a file content, and so on.\n\nYour data usually contains UNICODE strings and you want the converted data to be encoded\nin UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.\n\n  print encode_json( $perl_scalar ); # to a network? file? or display?\n  # or\n  print $json->utf8->encode( $perl_scalar );\n\nIf C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings\nfor some reason, then its characters are regarded as B<latin1> for perl\n(because it does not concern with your $encoding).\nYou B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.\nInstead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.\nNote that the resulted text is a UNICODE string but no problem to print it.\n\n  # $perl_scalar contains $encoding encoded string values\n  $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );\n  # or \n  $unicode_json_text = to_json( $perl_scalar );\n  # $unicode_json_text consists of character", 8192) = 8192
09:01:57.467719 brk(0x1f82000)          = 0x1f82000
09:01:57.467797 read(7, "s less than 0x100\n  print $unicode_json_text;\n\nOr C<decode $encoding> all string values and C<encode_json>:\n\n  $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );\n  # ... do it to each string values, then encode_json\n  $json_text = encode_json( $perl_scalar );\n\nThis method is a proper way but probably not efficient.\n\nSee to L<Encode>, L<perluniintro>.\n\n\n=head1 COMMON OBJECT-ORIENTED INTERFACE\n\n=head2 new\n\n    $json = new JSON\n\nReturns a new C<JSON> object inherited from either JSON::XS or JSON::PP\nthat can be used to de/encode JSON strings.\n\nAll boolean flags described below are by default I<disabled>.\n\nThe mutators for flags all return the JSON object again and thus calls can\nbe chained:\n\n   my $json = JSON->new->utf8->space_after->encode({a => [1,2]})\n   => {\"a\": [1, 2]}\n\n=head2 ascii\n\n    $json = $json->ascii([$enable])\n    \n    $enabled = $json->get_ascii\n\nIf $enable is true (or missing), then the encode method will not generate characters outside\nthe code range 0..127. Any Unicode characters outside that range will be escaped using either\na single \\uXXXX or a double \\uHHHH\\uLLLLL escape sequence, as per RFC4627.\n\nIf $enable is false, then the encode method will not escape Unicode characters unless\nrequired by the JSON syntax or other flags. This results in a faster and more compact format.\n\nThis feature depends on the used Perl version and environment.\n\nSee to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.\n\n  JSON->new->ascii(1)->encode([chr 0x10401])\n  => [\"\\ud801\\udc01\"]\n\n=head2 latin1\n\n    $json = $json->latin1([$enable])\n    \n    $enabled = $json->get_latin1\n\nIf $enable is true (or missing), then the encode method will encode the resulting JSON\ntext as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.\n\nIf $enable is false, then the encode method will not escape Unicode characters\nunless required by the JSON syntax or other flags.\n\n  JSON->new->latin1->encode ([\"\\x{89}\\x{abc}\"]\n  => [\"\\x{89}\\\\u0abc\"]    # (perl syntax, U+abc escaped, U+89 not)\n\n=head2 utf8\n\n    $json = $json->utf8([$enable])\n    \n    $enabled = $json->get_utf8\n\nIf $enable is true (or missing), then the encode method will encode the JSON result\ninto UTF-8, as required by many protocols, while the decode method expects to be handled\nan UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any\ncharacters outside the range 0..255, they are thus useful for bytewise/binary I/O.\n\nIn future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32\nencoding families, as described in RFC4627.\n\nIf $enable is false, then the encode method will return the JSON string as a (non-encoded)\nUnicode string, while decode expects thus a Unicode string. Any decoding or encoding\n(e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.\n\n\nExample, output UTF-16BE-encoded JSON:\n\n  use Encode;\n  $jsontext = encode \"UTF-16BE\", JSON::XS->new->encode ($object);\n\nExample, decode UTF-32LE-encoded JSON:\n\n  use Encode;\n  $object = JSON::XS->new->decode (decode \"UTF-32LE\", $jsontext);\n\nSee to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.\n\n\n=head2 pretty\n\n    $json = $json->pretty([$enable])\n\nThis enables (or disables) all of the C<indent>, C<space_before> and\nC<space_after> (and in the future possibly more) flags in one call to\ngenerate the most readable (or most compact) form possible.\n\nEquivalent to:\n\n   $json->indent->space_before->space_after\n\nThe indent space length is three and JSON::XS cannot change the indent\nspace length.\n\n=head2 indent\n\n    $json = $json->indent([$enable])\n    \n    $enabled = $json->get_indent\n\nIf C<$enable> is true (or missing), then the C<encode> method will use a multiline\nformat as output, putting every array member or object/hash key-value pair\ninto its own line, identing them properly.\n\nIf C<$enable> is false, no newlines or indenting will be produced, and the\nresulting JSON text is guarenteed not to contain any C<newlines>.\n\nThis setting has no effect when decoding JSON texts.\n\nThe indent space length is three.\nWith JSON::PP, you can also access C<indent_length> to change indent space length.\n\n\n=head2 space_before\n\n    $json = $json->space_before([$enable])\n    \n    $enabled = $json->get_space_before\n\nIf C<$enable> is true (or missing), then the C<encode> method will add an extra\noptional space before the C<:> separating keys from values in JSON objects.\n\nIf C<$enable> is false, then the C<encode> method will not add any extra\nspace at those places.\n\nThis setting has no effect when decoding JSON texts.\n\nExample, space_before enabled, space_after and indent disabled:\n\n   {\"key\" :\"value\"}\n\n\n=head2 space_after\n\n    $json = $json->space_after([$enable])\n    \n    $enabled = $json->get_space_after\n\nIf C<$enable> is true (or missing), then the C<encode> method will add an extra\noptional space after the C<:> separating keys from values in JSON objects\nand extra whitespace after the C<,> separating key-value pairs and array\nmembers.\n\nIf C<$enable> is false, then the C<encode> method will not add any extra\nspace at those places.\n\nThis setting has no effect when decoding JSON texts.\n\nExample, space_before and indent disabled, space_after enabled:\n\n   {\"key\": \"value\"}\n\n\n=head2 relaxed\n\n    $json = $json->relaxed([$enable])\n    \n    $enabled = $json->get_relaxed\n\nIf C<$enable> is true (or missing), then C<decode> will accept some\nextensions to normal JSON syntax (see below). C<encode> will not be\naffected in anyway. I<Be aware that this option makes you accept invalid\nJSON texts as if they were valid!>. I suggest only to use this option to\nparse application-specific files written by humans (configuration files,\nresource files etc.)\n\nIf C<$enable> is false (the default), then C<decode> will only accept\nvalid JSON texts.\n\nCurrently accepted extensions are:\n\n=over 4\n\n=item * list items can have an end-comma\n\nJSON I<separates> array elements and key-value pairs with commas. This\ncan be annoying if you write JSON texts manually and want to be able to\nquickly append elements, so this extension accepts comma at the end of\nsuch items not just between them:\n\n   [\n      1,\n      2, <- this comma not normally allowed\n   ]\n   {\n      \"k1\": \"v1\",\n      \"k2\": \"v2\", <- this comma not normally allowed\n   }\n\n=item * shell-style '#'-comments\n\nWhenever JSON allows whitespace, shell-style comments are additionally\nallowed. They are terminated by the first carriage-return or line-feed\ncharacter, after which more white-space and comments are allowed.\n\n  [\n     1, # this comment not allowed in JSON\n        # neither this one...\n  ]\n\n=back\n\n\n=head2 canonical\n\n    $json = $json->canonical([$enable])\n    \n    $enabled = $json->get_canonical\n\nIf C<$enable> is true (or missing), then the C<encode> method will output JSON objects\nby sorting their keys. This is adding a comparatively high overhead.\n\nIf C<$enable> is false, then the C<encode> method will output key-value\npairs in the order Perl stores them (which will likely change between runs\nof the same script).\n\nThis option is useful if you want the same data structure to be encoded as\nthe same JSON text (given the same overall settings). If it is disabled,\nthe same hash might be encoded differently even if contains the same data,\nas key-value pairs have no inherent ordering in Perl.\n\nThis setting has no effect when decoding JSON texts.\n\n=head2 allow_nonref\n\n    $json = $json->allow_nonref([$enable])\n    \n    $enabled = $json->get_allow_nonref\n\nIf C<$enable> is true (or missing), then the C<encode> method can convert a\nnon-reference into its corresponding string, number or null JSON value,\nwhich is an extension to RFC4627. Likewise, C<decode> will accept those JSON\nvalues instead of croaking.\n\nIf C<$enable> is false, then the C<encode> method will croak if it isn't\npassed an arrayref or hashref, as JSON texts must either be an object\nor array. Likewise, C<decode> will croak if given something that is not a\nJSON object or array.\n\n   JSON->new->allow_nonref->encode (\"Hello, World!\")\n   => \"Hello, World!\"\n\n=head2 allow_unknown\n\n    $json = $json->allow_unknown ([$enable])\n    \n    $enabled = $json->get_allow_unkn", 8192) = 8192
09:01:57.468240 read(7, "own\n\nIf $enable is true (or missing), then \"encode\" will *not* throw an\nexception when it encounters values it cannot represent in JSON (for\nexample, filehandles) but instead will encode a JSON \"null\" value.\nNote that blessed objects are not included here and are handled\nseparately by c<allow_nonref>.\n\nIf $enable is false (the default), then \"encode\" will throw an\nexception when it encounters anything it cannot encode as JSON.\n\nThis option does not affect \"decode\" in any way, and it is\nrecommended to leave it off unless you know your communications\npartner.\n\n=head2 allow_blessed\n\n    $json = $json->allow_blessed([$enable])\n    \n    $enabled = $json->get_allow_blessed\n\nIf C<$enable> is true (or missing), then the C<encode> method will not\nbarf when it encounters a blessed reference. Instead, the value of the\nB<convert_blessed> option will decide whether C<null> (C<convert_blessed>\ndisabled or no C<TO_JSON> method found) or a representation of the\nobject (C<convert_blessed> enabled and C<TO_JSON> method found) is being\nencoded. Has no effect on C<decode>.\n\nIf C<$enable> is false (the default), then C<encode> will throw an\nexception when it encounters a blessed object.\n\n\n=head2 convert_blessed\n\n    $json = $json->convert_blessed([$enable])\n    \n    $enabled = $json->get_convert_blessed\n\nIf C<$enable> is true (or missing), then C<encode>, upon encountering a\nblessed object, will check for the availability of the C<TO_JSON> method\non the object's class. If found, it will be called in scalar context\nand the resulting scalar will be encoded instead of the object. If no\nC<TO_JSON> method is found, the value of C<allow_blessed> will decide what\nto do.\n\nThe C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>\nreturns other blessed objects, those will be handled in the same\nway. C<TO_JSON> must take care of not causing an endless recursion cycle\n(== crash) in this case. The name of C<TO_JSON> was chosen because other\nmethods called by the Perl core (== not by the user of the object) are\nusually in upper case letters and to avoid collisions with the C<to_json>\nfunction or method.\n\nThis setting does not yet influence C<decode> in any way.\n\nIf C<$enable> is false, then the C<allow_blessed> setting will decide what\nto do when a blessed object is found.\n\n=over\n\n=item convert_blessed_universally mode\n\nIf use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>\nsubroutine is defined as the below code:\n\n   *UNIVERSAL::TO_JSON = sub {\n       my $b_obj = B::svref_2object( $_[0] );\n       return    $b_obj->isa('B::HV') ? { %{ $_[0] } }\n               : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]\n               : undef\n               ;\n   }\n\nThis will cause that C<encode> method converts simple blessed objects into\nJSON objects as non-blessed object.\n\n   JSON -convert_blessed_universally;\n   $json->allow_blessed->convert_blessed->encode( $blessed_object )\n\nThis feature is experimental and may be removed in the future.\n\n=back\n\n=head2 filter_json_object\n\n    $json = $json->filter_json_object([$coderef])\n\nWhen C<$coderef> is specified, it will be called from C<decode> each\ntime it decodes a JSON object. The only argument passed to the coderef\nis a reference to the newly-created hash. If the code references returns\na single scalar (which need not be a reference), this value\n(i.e. a copy of that scalar to avoid aliasing) is inserted into the\ndeserialised data structure. If it returns an empty list\n(NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised\nhash will be inserted. This setting can slow down decoding considerably.\n\nWhen C<$coderef> is omitted or undefined, any existing callback will\nbe removed and C<decode> will not change the deserialised hash in any\nway.\n\nExample, convert all JSON objects into the integer 5:\n\n   my $js = JSON->new->filter_json_object (sub { 5 });\n   # returns [5]\n   $js->decode ('[{}]'); # the given subroutine takes a hash reference.\n   # throw an exception because allow_nonref is not enabled\n   # so a lone 5 is not allowed.\n   $js->decode ('{\"a\":1, \"b\":2}');\n\n\n=head2 filter_json_single_key_object\n\n    $json = $json->filter_json_single_key_object($key [=> $coderef])\n\nWorks remotely similar to C<filter_json_object>, but is only called for\nJSON objects having a single key named C<$key>.\n\nThis C<$coderef> is called before the one specified via\nC<filter_json_object>, if any. It gets passed the single value in the JSON\nobject. If it returns a single value, it will be inserted into the data\nstructure. If it returns nothing (not even C<undef> but the empty list),\nthe callback from C<filter_json_object> will be called next, as if no\nsingle-key callback were specified.\n\nIf C<$coderef> is omitted or undefined, the corresponding callback will be\ndisabled. There can only ever be one callback for a given key.\n\nAs this callback gets called less often then the C<filter_json_object>\none, decoding speed will not usually suffer as much. Therefore, single-key\nobjects make excellent targets to serialise Perl objects into, especially\nas single-key JSON objects are as close to the type-tagged value concept\nas JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not\nsupport this in any way, so you need to make sure your data never looks\nlike a serialised Perl hash.\n\nTypical names for the single object key are C<__class_whatever__>, or\nC<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even\nthings like C<__class_md5sum(classname)__>, to reduce the risk of clashing\nwith real hashes.\n\nExample, decode JSON objects of the form C<< { \"__widget__\" => <id> } >>\ninto the corresponding C<< $WIDGET{<id>} >> object:\n\n   # return whatever is in $WIDGET{5}:\n   JSON\n      ->new\n      ->filter_json_single_key_object (__widget__ => sub {\n            $WIDGET{ $_[0] }\n         })\n      ->decode ('{\"__widget__\": 5')\n\n   # this can be used with a TO_JSON method in some \"widget\" class\n   # for serialisation to json:\n   sub WidgetBase::TO_JSON {\n      my ($self) = @_;\n\n      unless ($self->{id}) {\n         $self->{id} = ..get..some..id..;\n         $WIDGET{$self->{id}} = $self;\n      }\n\n      { __widget__ => $self->{id} }\n   }\n\n\n=head2 shrink\n\n    $json = $json->shrink([$enable])\n    \n    $enabled = $json->get_shrink\n\nWith JSON::XS, this flag resizes strings generated by either\nC<encode> or C<decode> to their minimum size possible. This can save\nmemory when your JSON texts are either very very long or you have many\nshort strings. It will also try to downgrade any strings to octet-form\nif possible: perl stores strings internally either in an encoding called\nUTF-X or in octet-form. The latter cannot store everything but uses less\nspace in general (and some buggy Perl or C code might even rely on that\ninternal representation being used).\n\nWith JSON::PP, it is noop about resizing strings but tries\nC<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.\n\nSee to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.\n\n=head2 max_depth\n\n    $json = $json->max_depth([$maximum_nesting_depth])\n    \n    $max_depth = $json->get_max_depth\n\nSets the maximum nesting level (default C<512>) accepted while encoding\nor decoding. If a higher nesting level is detected in JSON text or a Perl\ndata structure, then the encoder and decoder will stop and croak at that\npoint.\n\nNesting level is defined by number of hash- or arrayrefs that the encoder\nneeds to traverse to reach a given point or the number of C<{> or C<[>\ncharacters without their matching closing parenthesis crossed to reach a\ngiven character in a string.\n\nIf no argument is given, the highest possible setting will be used, which\nis rarely useful.\n\nNote that nesting is implemented by recursion in C. The default value has\nbeen chosen to be as large as typical operating systems allow without\ncrashing. (JSON::XS)\n\nWith JSON::PP as the backend, when a large value (100 or more) was set and\nit de/encodes a deep nested object/text, it may raise a warning\n'Deep recursion on subroutin' at the perl runtime phase.\n\nSee L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.\n\n=head2 max_size\n\n    $json = $json->max_size([$maximum_string_size])\n   ", 8192) = 8192
09:01:57.468668 read(7, " \n    $max_size = $json->get_max_size\n\nSet the maximum length a JSON text may have (in bytes) where decoding is\nbeing attempted. The default is C<0>, meaning no limit. When C<decode>\nis called on a string that is longer then this many bytes, it will not\nattempt to decode the string but throw an exception. This setting has no\neffect on C<encode> (yet).\n\nIf no argument is given, the limit check will be deactivated (same as when\nC<0> is specified).\n\nSee L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.\n\n=head2 encode\n\n    $json_text = $json->encode($perl_scalar)\n\nConverts the given Perl data structure (a simple scalar or a reference\nto a hash or array) to its JSON representation. Simple scalars will be\nconverted into JSON string or number sequences, while references to arrays\nbecome JSON arrays and references to hashes become JSON objects. Undefined\nPerl values (e.g. C<undef>) become JSON C<null> values.\nReferences to the integers C<0> and C<1> are converted into C<true> and C<false>.\n\n=head2 decode\n\n    $perl_scalar = $json->decode($json_text)\n\nThe opposite of C<encode>: expects a JSON text and tries to parse it,\nreturning the resulting simple scalar or reference. Croaks on error.\n\nJSON numbers and strings become simple Perl scalars. JSON arrays become\nPerl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes\nC<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and\nC<null> becomes C<undef>.\n\n=head2 decode_prefix\n\n    ($perl_scalar, $characters) = $json->decode_prefix($json_text)\n\nThis works like the C<decode> method, but instead of raising an exception\nwhen there is trailing garbage after the first JSON object, it will\nsilently stop parsing there and return the number of characters consumed\nso far.\n\n   JSON->new->decode_prefix (\"[1] the tail\")\n   => ([], 3)\n\nSee to L<JSON::XS/OBJECT-ORIENTED INTERFACE>\n\n=head2 property\n\n    $boolean = $json->property($property_name)\n\nReturns a boolean value about above some properties.\n\nThe available properties are C<ascii>, C<latin1>, C<utf8>,\nC<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,\nC<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,\nC<shrink>, C<max_depth> and C<max_size>.\n\n   $boolean = $json->property('utf8');\n    => 0\n   $json->utf8;\n   $boolean = $json->property('utf8');\n    => 1\n\nSets the property with a given boolean value.\n\n    $json = $json->property($property_name => $boolean);\n\nWith no argumnt, it returns all the above properties as a hash reference.\n\n    $flag_hashref = $json->property();\n\n=head1 INCREMENTAL PARSING\n\nMost of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.\n\nIn some cases, there is the need for incremental parsing of JSON texts.\nThis module does allow you to parse a JSON stream incrementally.\nIt does so by accumulating text until it has a full JSON object, which\nit then can decode. This process is similar to using C<decode_prefix>\nto see if a full JSON object is available, but is much more efficient\n(and can be implemented with a minimum of method calls).\n\nThe backend module will only attempt to parse the JSON text once it is sure it\nhas enough text to get a decisive result, using a very simple but\ntruly incremental parser. This means that it sometimes won't stop as\nearly as the full parser, for example, it doesn't detect parenthese\nmismatches. The only thing it guarantees is that it starts decoding as\nsoon as a syntactically valid JSON text has been seen. This means you need\nto set resource limits (e.g. C<max_size>) to ensure the parser will stop\nparsing in the presence if syntax errors.\n\nThe following methods implement this incremental parser.\n\n=head2 incr_parse\n\n    $json->incr_parse( [$string] ) # void context\n    \n    $obj_or_undef = $json->incr_parse( [$string] ) # scalar context\n    \n    @obj_or_empty = $json->incr_parse( [$string] ) # list context\n\nThis is the central parsing function. It can both append new text and\nextract objects from the stream accumulated so far (both of these\nfunctions are optional).\n\nIf C<$string> is given, then this string is appended to the already\nexisting JSON fragment stored in the C<$json> object.\n\nAfter that, if the function is called in void context, it will simply\nreturn without doing anything further. This can be used to add more text\nin as many chunks as you want.\n\nIf the method is called in scalar context, then it will try to extract\nexactly I<one> JSON object. If that is successful, it will return this\nobject, otherwise it will return C<undef>. If there is a parse error,\nthis method will croak just as C<decode> would do (one can then use\nC<incr_skip> to skip the errornous part). This is the most common way of\nusing the method.\n\nAnd finally, in list context, it will try to extract as many objects\nfrom the stream as it can find and return them, or the empty list\notherwise. For this to work, there must be no separators between the JSON\nobjects or arrays, instead they must be concatenated back-to-back. If\nan error occurs, an exception will be raised as in the scalar context\ncase. Note that in this case, any previously-parsed JSON texts will be\nlost.\n\nExample: Parse some JSON arrays/objects in a given string and return them.\n\n    my @objs = JSON->new->incr_parse (\"[5][7][1,2]\");\n\n=head2 incr_text\n\n    $lvalue_string = $json->incr_text\n\nThis method returns the currently stored JSON fragment as an lvalue, that\nis, you can manipulate it. This I<only> works when a preceding call to\nC<incr_parse> in I<scalar context> successfully returned an object. Under\nall other circumstances you must not call this function (I mean it.\nalthough in simple tests it might actually work, it I<will> fail under\nreal world conditions). As a special exception, you can also call this\nmethod before having parsed anything.\n\nThis function is useful in two cases: a) finding the trailing text after a\nJSON object or b) parsing multiple JSON objects separated by non-JSON text\n(such as commas).\n\n    $json->incr_text =~ s/\\s*,\\s*//;\n\nIn Perl 5.005, C<lvalue> attribute is not available.\nYou must write codes like the below:\n\n    $string = $json->incr_text;\n    $string =~ s/\\s*,\\s*//;\n    $json->incr_text( $string );\n\n=head2 incr_skip\n\n    $json->incr_skip\n\nThis will reset the state of the incremental parser and will remove the\nparsed text from the input buffer. This is useful after C<incr_parse>\ndied, in which case the input buffer and incremental parser state is left\nunchanged, to skip the text parsed so far and to reset the parse state.\n\n=head2 incr_reset\n\n    $json->incr_reset\n\nThis completely resets the incremental parser, that is, after this call,\nit will be as if the parser had never parsed anything.\n\nThis is useful if you want ot repeatedly parse JSON objects and want to\nignore any trailing data, which means you have to reset the parser after\neach successful decode.\n\nSee to L<JSON::XS/INCREMENTAL PARSING> for examples.\n\n\n=head1 JSON::PP SUPPORT METHODS\n\nThe below methods are JSON::PP own methods, so when C<JSON> works\nwith JSON::PP (i.e. the created object is a JSON::PP object), available.\nSee to L<JSON::PP/JSON::PP OWN METHODS> in detail.\n\nIf you use C<JSON> with additonal C<-support_by_pp>, some methods\nare available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.\n\n   BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }\n   \n   use JSON -support_by_pp;\n   \n   my $json = new JSON;\n   $json->allow_nonref->escape_slash->encode(\"/\");\n\n   # functional interfaces too.\n   print to_json([\"/\"], {escape_slash => 1});\n   print from_json('[\"foo\"]', {utf8 => 1});\n\nIf you do not want to all functions but C<-support_by_pp>,\nuse C<-no_export>.\n\n   use JSON -support_by_pp, -no_export;\n   # functional interfaces are not exported.\n\n=head2 allow_singlequote\n\n    $json = $json->allow_singlequote([$enable])\n\nIf C<$enable> is true (or missing), then C<decode> will accept\nany JSON strings quoted by single quotations that are invalid JSON\nformat.\n\n    $json->allow_singlequote->decode({\"foo\":'bar'});\n    $json->allow_singlequote->decode({'foo':\"bar\"});\n    $json->allow_singlequote->decode({'foo':'bar'});\n\nAs same as the C<relaxed> option, this option ma", 8192) = 8192
09:01:57.469105 read(7, "y be used to parse\napplication-specific files written by humans.\n\n=head2 allow_barekey\n\n    $json = $json->allow_barekey([$enable])\n\nIf C<$enable> is true (or missing), then C<decode> will accept\nbare keys of JSON object that are invalid JSON format.\n\nAs same as the C<relaxed> option, this option may be used to parse\napplication-specific files written by humans.\n\n    $json->allow_barekey->decode('{foo:\"bar\"}');\n\n=head2 allow_bignum\n\n    $json = $json->allow_bignum([$enable])\n\nIf C<$enable> is true (or missing), then C<decode> will convert\nthe big integer Perl cannot handle as integer into a L<Math::BigInt>\nobject and convert a floating number (any) into a L<Math::BigFloat>.\n\nOn the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>\nobjects into JSON numbers with C<allow_blessed> enable.\n\n   $json->allow_nonref->allow_blessed->allow_bignum;\n   $bigfloat = $json->decode('2.000000000000000000000000001');\n   print $json->encode($bigfloat);\n   # => 2.000000000000000000000000001\n\nSee to L<MAPPING> aboout the conversion of JSON number.\n\n=head2 loose\n\n    $json = $json->loose([$enable])\n\nThe unescaped [\\x00-\\x1f\\x22\\x2f\\x5c] strings are invalid in JSON strings\nand the module doesn't allow to C<decode> to these (except for \\x2f).\nIf C<$enable> is true (or missing), then C<decode>  will accept these\nunescaped strings.\n\n    $json->loose->decode(qq|[\"abc\n                                   def\"]|);\n\nSee to L<JSON::PP/JSON::PP OWN METHODS>.\n\n=head2 escape_slash\n\n    $json = $json->escape_slash([$enable])\n\nAccording to JSON Grammar, I<slash> (U+002F) is escaped. But by default\nJSON backend modules encode strings without escaping slash.\n\nIf C<$enable> is true (or missing), then C<encode> will escape slashes.\n\n=head2 indent_length\n\n    $json = $json->indent_length($length)\n\nWith JSON::XS, The indent space length is 3 and cannot be changed.\nWith JSON::PP, it sets the indent space length with the given $length.\nThe default is 3. The acceptable range is 0 to 15.\n\n=head2 sort_by\n\n    $json = $json->sort_by($function_name)\n    $json = $json->sort_by($subroutine_ref)\n\nIf $function_name or $subroutine_ref are set, its sort routine are used.\n\n   $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);\n   # is($js, q|{\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5,\"f\":6,\"g\":7,\"h\":8,\"i\":9}|);\n\n   $js = $pc->sort_by('own_sort')->encode($obj);\n   # is($js, q|{\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5,\"f\":6,\"g\":7,\"h\":8,\"i\":9}|);\n\n   sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }\n\nAs the sorting routine runs in the JSON::PP scope, the given\nsubroutine name and the special variables C<$a>, C<$b> will begin\nwith 'JSON::PP::'.\n\nIf $integer is set, then the effect is same as C<canonical> on.\n\nSee to L<JSON::PP/JSON::PP OWN METHODS>.\n\n=head1 MAPPING\n\nThis section is copied from JSON::XS and modified to C<JSON>.\nJSON::XS and JSON::PP mapping mechanisms are almost equivalent.\n\nSee to L<JSON::XS/MAPPING>.\n\n=head2 JSON -> PERL\n\n=over 4\n\n=item object\n\nA JSON object becomes a reference to a hash in Perl. No ordering of object\nkeys is preserved (JSON does not preserver object key ordering itself).\n\n=item array\n\nA JSON array becomes a reference to an array in Perl.\n\n=item string\n\nA JSON string becomes a string scalar in Perl - Unicode codepoints in JSON\nare represented by the same codepoints in the Perl string, so no manual\ndecoding is necessary.\n\n=item number\n\nA JSON number becomes either an integer, numeric (floating point) or\nstring scalar in perl, depending on its range and any fractional parts. On\nthe Perl level, there is no difference between those as Perl handles all\nthe conversion details, but an integer may take slightly less memory and\nmight represent more values exactly than floating point numbers.\n\nIf the number consists of digits only, C<JSON> will try to represent\nit as an integer value. If that fails, it will try to represent it as\na numeric (floating point) value if that is possible without loss of\nprecision. Otherwise it will preserve the number as a string value (in\nwhich case you lose roundtripping ability, as the JSON number will be\nre-encoded toa JSON string).\n\nNumbers containing a fractional or exponential part will always be\nrepresented as numeric (floating point) values, possibly at a loss of\nprecision (in which case you might lose perfect roundtripping ability, but\nthe JSON number will still be re-encoded as a JSON number).\n\nNote that precision is not accuracy - binary floating point values cannot\nrepresent most decimal fractions exactly, and when converting from and to\nfloating point, C<JSON> only guarantees precision up to but not including\nthe leats significant bit.\n\nIf the backend is JSON::PP and C<allow_bignum> is enable, the big integers \nand the numeric can be optionally converted into L<Math::BigInt> and\nL<Math::BigFloat> objects.\n\n=item true, false\n\nThese JSON atoms become C<JSON::true> and C<JSON::false>,\nrespectively. They are overloaded to act almost exactly like the numbers\nC<1> and C<0>. You can check wether a scalar is a JSON boolean by using\nthe C<JSON::is_bool> function.\n\nIf C<JSON::true> and C<JSON::false> are used as strings or compared as strings,\nthey represent as C<true> and C<false> respectively.\n\n   print JSON::true . \"\\n\";\n    => true\n   print JSON::true + 1;\n    => 1\n\n   ok(JSON::true eq 'true');\n   ok(JSON::true eq  '1');\n   ok(JSON::true == 1);\n\nC<JSON> will install these missing overloading features to the backend modules.\n\n\n=item null\n\nA JSON null atom becomes C<undef> in Perl.\n\nC<JSON::null> returns C<unddef>.\n\n=back\n\n\n=head2 PERL -> JSON\n\nThe mapping from Perl to JSON is slightly more difficult, as Perl is a\ntruly typeless language, so we can only guess which JSON type is meant by\na Perl value.\n\n=over 4\n\n=item hash references\n\nPerl hash references become JSON objects. As there is no inherent ordering\nin hash keys (or JSON objects), they will usually be encoded in a\npseudo-random order that can change between runs of the same program but\nstays generally the same within a single run of a program. C<JSON>\noptionally sort the hash keys (determined by the I<canonical> flag), so\nthe same datastructure will serialise to the same JSON text (given same\nsettings and version of JSON::XS), but this incurs a runtime overhead\nand is only rarely useful, e.g. when you want to compare some JSON text\nagainst another for equality.\n\nIn future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.\n\n\n=item array references\n\nPerl array references become JSON arrays.\n\n=item other references\n\nOther unblessed references are generally not allowed and will cause an\nexception to be thrown, except for references to the integers C<0> and\nC<1>, which get turned into C<false> and C<true> atoms in JSON. You can\nalso use C<JSON::false> and C<JSON::true> to improve readability.\n\n   to_json [\\0,JSON::true]      # yields [false,true]\n\n=item JSON::true, JSON::false, JSON::null\n\nThese special values become JSON true and JSON false values,\nrespectively. You can also use C<\\1> and C<\\0> directly if you want.\n\nJSON::null returns C<undef>.\n\n=item blessed objects\n\nBlessed objects are not directly representable in JSON. See the\nC<allow_blessed> and C<convert_blessed> methods on various options on\nhow to deal with this: basically, you can choose between throwing an\nexception, encoding the reference as if it weren't blessed, or provide\nyour own serialiser method.\n\nWith C<convert_blessed_universally> mode,  C<encode> converts blessed\nhash references or blessed array references (contains other blessed references)\ninto JSON members and arrays.\n\n   use JSON -convert_blessed_universally;\n   JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );\n\nSee to L<convert_blessed>.\n\n=item simple scalars\n\nSimple Perl scalars (any scalar that is not a reference) are the most\ndifficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as\nJSON C<null> values, scalars that have last been used in a string context\nbefore encoding as JSON strings, and anything else as number value:\n\n   # dump as number\n   encode_json [2]                      # yields [2]\n   encode_json [-3.0e17]                # yields [-3e+17]\n   m", 8192) = 8192
09:01:57.469495 brk(0x1fa3000)          = 0x1fa3000
09:01:57.469590 read(7, "y $value = 5; encode_json [$value]  # yields [5]\n\n   # used as string, so dump as string\n   print $value;\n   encode_json [$value]                 # yields [\"5\"]\n\n   # undef becomes null\n   encode_json [undef]                  # yields [null]\n\nYou can force the type to be a string by stringifying it:\n\n   my $x = 3.1; # some variable containing a number\n   \"$x\";        # stringified\n   $x .= \"\";    # another, more awkward way to stringify\n   print $x;    # perl does it for you, too, quite often\n\nYou can force the type to be a number by numifying it:\n\n   my $x = \"3\"; # some variable containing a string\n   $x += 0;     # numify it, ensuring it will be dumped as a number\n   $x *= 1;     # same thing, the choise is yours.\n\nYou can not currently force the type in other, less obscure, ways.\n\nNote that numerical precision has the same meaning as under Perl (so\nbinary to decimal conversion follows the same rules as in Perl, which\ncan differ to other languages). Also, your perl interpreter might expose\nextensions to the floating point numbers of your platform, such as\ninfinities or NaN's - these cannot be represented in JSON, and it is an\nerror to pass those in.\n\n=item Big Number\n\nIf the backend is JSON::PP and C<allow_bignum> is enable, \nC<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>\nobjects into JSON numbers.\n\n\n=back\n\n=head1 JSON and ECMAscript\n\nSee to L<JSON::XS/JSON and ECMAscript>.\n\n=head1 JSON and YAML\n\nJSON is not a subset of YAML.\nSee to L<JSON::XS/JSON and YAML>.\n\n\n=head1 BACKEND MODULE DECISION\n\nWhen you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will\nC<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.\n\nThe C<JSON> constructor method returns an object inherited from the backend module,\nand JSON::XS object is a blessed scaler reference while JSON::PP is a blessed hash\nreference.\n\nSo, your program should not depend on the backend module, especially\nreturned objects should not be modified.\n\n my $json = JSON->new; # XS or PP?\n $json->{stash} = 'this is xs object'; # this code may raise an error!\n\nTo check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.\n\n  JSON->backend; # 'JSON::XS' or 'JSON::PP'\n  \n  JSON->backend->is_pp: # 0 or 1\n  \n  JSON->backend->is_xs: # 1 or 0\n  \n  $json->is_xs; # 1 or 0\n  \n  $json->is_pp; # 0 or 1\n\n\nIf you set an enviornment variable C<PERL_JSON_BACKEND>, The calling action will be changed.\n\n=over\n\n=item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'\n\nAlways use JSON::PP\n\n=item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'\n\n(The default) Use compiled JSON::XS if it is properly compiled & installed,\notherwise use JSON::PP.\n\n=item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'\n\nAlways use compiled JSON::XS, die if it isn't properly compiled & installed.\n\n=item PERL_JSON_BACKEND = 'JSON::backportPP'\n\nAlways use JSON::backportPP.\nJSON::backportPP is JSON::PP back port module.\nC<JSON> includs JSON::backportPP instead of JSON::PP.\n\n=back\n\nThese ideas come from L<DBI::PurePerl> mechanism.\n\nexample:\n\n BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }\n use JSON; # always uses JSON::PP\n\nIn future, it may be able to specify another module.\n\n=head1 USE PP FEATURES EVEN THOUGH XS BACKEND\n\nMany methods are available with either JSON::XS or JSON::PP and\nwhen the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unspported)\nmethod is called, it will C<warn> and be noop.\n\nBut If you C<use> C<JSON> passing the optional string C<-support_by_pp>,\nit makes a part of those unupported methods available.\nThis feature is achieved by using JSON::PP in C<de/encode>.\n\n   BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS\n   use JSON -support_by_pp;\n   my $json = new JSON;\n   $json->allow_nonref->escape_slash->encode(\"/\");\n\nAt this time, the returned object is a C<JSON::Backend::XS::Supportable>\nobject (re-blessed XS object), and  by checking JSON::XS unsupported flags\nin de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,\nC<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.\n\nWhen any unsupported methods are not enable, C<XS de/encode> will be\nused as is. The switch is achieved by changing the symbolic tables.\n\nC<-support_by_pp> is effective only when the backend module is JSON::XS\nand it makes the de/encoding speed down a bit.\n\nSee to L<JSON::PP SUPPORT METHODS>.\n\n=head1 INCOMPATIBLE CHANGES TO OLD VERSION\n\nThere are big incompatibility between new version (2.00) and old (1.xx).\nIf you use old C<JSON> 1.xx in your code, please check it.\n\nSee to L<Transition ways from 1.xx to 2.xx.>\n\n=over\n\n=item jsonToObj and objToJson are obsoleted.\n\nNon Perl-style name C<jsonToObj> and C<objToJson> are obsoleted\n(but not yet deleted from the source).\nIf you use these functions in your code, please replace them\nwith C<from_json> and C<to_json>.\n\n\n=item Global variables are no longer available.\n\nC<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...\n- are not available any longer.\nInstead, various features can be used through object methods.\n\n\n=item Package JSON::Converter and JSON::Parser are deleted.\n\nNow C<JSON> bundles with JSON::PP which can handle JSON more properly than them.\n\n=item Package JSON::NotString is deleted.\n\nThere was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>\nand numbers. It was deleted and replaced by C<JSON::Boolean>.\n\nC<JSON::Boolean> represents C<true> and C<false>.\n\nC<JSON::Boolean> does not represent C<null>.\n\nC<JSON::null> returns C<undef>.\n\nC<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation\nto L<JSON::Boolean>.\n\n=item function JSON::Number is obsoleted.\n\nC<JSON::Number> is now needless because JSON::XS and JSON::PP have\nround-trip integrity.\n\n=item JSONRPC modules are deleted.\n\nPerl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>\nand C<Apache::JSONRPC > are deleted in this distribution.\nInstead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.\n\n=back\n\n=head2 Transition ways from 1.xx to 2.xx.\n\nYou should set C<suport_by_pp> mode firstly, because\nit is always successful for the below codes even with JSON::XS.\n\n    use JSON -support_by_pp;\n\n=over\n\n=item Exported jsonToObj (simple)\n\n  from_json($json_text);\n\n=item Exported objToJson (simple)\n\n  to_json($perl_scalar);\n\n=item Exported jsonToObj (advanced)\n\n  $flags = {allow_barekey => 1, allow_singlequote => 1};\n  from_json($json_text, $flags);\n\nequivalent to:\n\n  $JSON::BareKey = 1;\n  $JSON::QuotApos = 1;\n  jsonToObj($json_text);\n\n=item Exported objToJson (advanced)\n\n  $flags = {allow_blessed => 1, allow_barekey => 1};\n  to_json($perl_scalar, $flags);\n\nequivalent to:\n\n  $JSON::BareKey = 1;\n  objToJson($perl_scalar);\n\n=item jsonToObj as object method\n\n  $json->decode($json_text);\n\n=item objToJson as object method\n\n  $json->encode($perl_scalar);\n\n=item new method with parameters\n\nThe C<new> method in 2.x takes any parameters no longer.\nYou can set parameters instead;\n\n   $json = JSON->new->pretty;\n\n=item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter\n\nIf C<indent> is enable, that means C<$JSON::Pretty> flag set. And\nC<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.\nIn conclusion:\n\n   $json->indent->space_before->space_after;\n\nEquivalent to:\n\n  $json->pretty;\n\nTo change indent length, use C<indent_length>.\n\n(Only with JSON::PP, if C<-support_by_pp> is not used.)\n\n  $json->pretty->indent_length(2)->encode($perl_scalar);\n\n=item $JSON::BareKey\n\n(Only with JSON::PP, if C<-support_by_pp> is not used.)\n\n  $json->allow_barekey->decode($json_text)\n\n=item $JSON::ConvBlessed\n\nuse C<-convert_blessed_universally>. See to L<convert_blessed>.\n\n=item $JSON::QuotApos\n\n(Only with JSON::PP, if C<-support_by_pp> is not used.)\n\n  $json->allow_singlequote->decode($json_text)\n\n=item $JSON::SingleQuote\n\nDisable. C<JSON> does not make such a invalid JSON string any longer.\n\n=item $JSON::KeySort\n\n  $json->canonical->encode($perl_scalar)\n\nThis is the ascii sort.\n\nIf you want to use with your own sort routine, check the C<sort_by> method.\n\n(Only with JSON::PP,", 8192) = 8192
09:01:57.470060 read(7, " even if C<-support_by_pp> is used currently.)\n\n  $json->sort_by($sort_routine_ref)->encode($perl_scalar)\n \n  $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)\n\nCan't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.\n\n=item $JSON::SkipInvalid\n\n  $json->allow_unknown\n\n=item $JSON::AUTOCONVERT\n\nNeedless. C<JSON> backend modules have the round-trip integrity.\n\n=item $JSON::UTF8\n\nNeedless because C<JSON> (JSON::XS/JSON::PP) sets\nthe UTF8 flag on properly.\n\n    # With UTF8-flagged strings\n\n    $json->allow_nonref;\n    $str = chr(1000); # UTF8-flagged\n\n    $json_text  = $json->utf8(0)->encode($str);\n    utf8::is_utf8($json_text);\n    # true\n    $json_text  = $json->utf8(1)->encode($str);\n    utf8::is_utf8($json_text);\n    # false\n\n    $str = '\"' . chr(1000) . '\"'; # UTF8-flagged\n\n    $perl_scalar  = $json->utf8(0)->decode($str);\n    utf8::is_utf8($perl_scalar);\n    # true\n    $perl_scalar  = $json->utf8(1)->decode($str);\n    # died because of 'Wide character in subroutine'\n\nSee to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.\n\n=item $JSON::UnMapping\n\nDisable. See to L<MAPPING>.\n\n=item $JSON::SelfConvert\n\nThis option was deleted.\nInstead of it, if a givien blessed object has the C<TO_JSON> method,\nC<TO_JSON> will be executed with C<convert_blessed>.\n\n  $json->convert_blessed->encode($bleesed_hashref_or_arrayref)\n  # if need, call allow_blessed\n\nNote that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.\n\n=back\n\n=head1 TODO\n\n=over\n\n=item example programs\n\n=back\n\n=head1 THREADS\n\nNo test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.\n\n\n=head1 BUGS\n\nPlease report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.\n\n\n=head1 SEE ALSO\n\nMost of the document is copied and modified from JSON::XS doc.\n\nL<JSON::XS>, L<JSON::PP>\n\nC<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)\n\n=head1 AUTHOR\n\nMakamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>\n\nJSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>\n\nThe relese of this new version owes to the courtesy of Marc Lehmann.\n\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright 2005-2011 by Makamaka Hannyaharamitu\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself. \n\n=cut\n\n", 8192) = 2275
09:01:57.470229 read(7, "", 8192)       = 0
09:01:57.470283 brk(0x1fc5000)          = 0x1fc5000
09:01:57.470474 close(7)                = 0
09:01:57.470679 brk(0x1ff0000)          = 0x1ff0000
09:01:57.471344 stat("modules/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471396 stat("modules/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471445 stat("modules/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471492 stat("modules/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471540 stat("/etc/perl/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471589 stat("/etc/perl/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471638 stat("/usr/local/lib/perl/5.14.2/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471688 stat("/usr/local/lib/perl/5.14.2/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471737 stat("/usr/local/share/perl/5.14.2/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471787 stat("/usr/local/share/perl/5.14.2/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471840 stat("/usr/lib/perl5/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471891 stat("/usr/lib/perl5/Date/Parse.pm", 0x7ffe1233bbe0) = -1 ENOENT (No such file or directory)
09:01:57.471940 stat("/usr/share/perl5/Date/Parse.pmc", 0x7ffe1233bc90) = -1 ENOENT (No such file or directory)
09:01:57.471989 stat("/usr/share/perl5/Date/Parse.pm", {st_mode=S_IFREG|0644, st_size=8947, ...}) = 0
09:01:57.472047 open("/usr/share/perl5/Date/Parse.pm", O_RDONLY) = 7
09:01:57.472100 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b970) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.472147 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.472203 read(7, "# Copyright (c) 1995-2009 Graham Barr. This program is free\n# software; you can redistribute it and/or modify it under the same terms\n# as Perl itself.\n\npackage Date::Parse;\n\nrequire 5.000;\nuse strict;\nuse vars qw($VERSION @ISA @EXPORT);\nuse Time::Local;\nuse Carp;\nuse Time::Zone;\nuse Exporter;\n\n@ISA = qw(Exporter);\n@EXPORT = qw(&strtotime &str2time &strptime);\n\n$VERSION = \"2.30\";\n\nmy %month = (\n\tjanuary\t\t=> 0,\n\tfebruary\t=> 1,\n\tmarch\t\t=> 2,\n\tapril\t\t=> 3,\n\tmay\t\t=> 4,\n\tjune\t\t=> 5,\n\tjuly\t\t=> 6,\n\taugust\t\t=> 7,\n\tseptember\t=> 8,\n\tsept\t\t=> 8,\n\toctober\t\t=> 9,\n\tnovember\t=> 10,\n\tdecember\t=> 11,\n\t);\n\nmy %day = (\n\tsunday\t\t=> 0,\n\tmonday\t\t=> 1,\n\ttuesday\t\t=> 2,\n\ttues\t\t=> 2,\n\twednesday\t=> 3,\n\twednes\t\t=> 3,\n\tthursday\t=> 4,\n\tthur\t\t=> 4,\n\tthurs\t\t=> 4,\n\tfriday\t\t=> 5,\n\tsaturday\t=> 6,\n\t);\n\nmy @suf = (qw(th st nd rd th th th th th th)) x 3;\n@suf[11,12,13] = qw(th th th);\n\n#Abbreviations\n\nmap { $month{substr($_,0,3)} = $month{$_} } keys %month;\nmap { $day{substr($_,0,3)}   = $day{$_} }   keys %day;\n\nmy $strptime = <<'ESQ';\n my %month = map { lc $_ } %$mon_ref;\n my $daypat = join(\"|\", map { lc $_ } reverse sort keys %$day_ref);\n my $monpat = join(\"|\", reverse sort keys %month);\n my $sufpat = join(\"|\", reverse sort map { lc $_ } @$suf_ref);\n\n my %ampm = (\n\t'a' => 0,  # AM\n\t'p' => 12, # PM\n\t);\n\n my($AM, $PM) = (0,12);\n\nsub {\n\n  my $dtstr = lc shift;\n  my $merid = 24;\n\n  my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);\n\n  $zone = tz_offset(shift) if @_;\n\n  1 while $dtstr =~ s#\\([^\\(\\)]*\\)# #o;\n\n  $dtstr =~ s#(\\A|\\n|\\Z)# #sog;\n\n  # ignore day names\n  $dtstr =~ s#([\\d\\w\\s])[\\.\\,]\\s#$1 #sog;\n  $dtstr =~ s/,/ /g;\n  $dtstr =~ s#($daypat)\\s*(den\\s)?\\b# #o;\n  # Time: 12:00 or 12:00:00 with optional am/pm\n\n  return unless $dtstr =~ /\\S/;\n  \n  if ($dtstr =~ s/\\s(\\d{4})([-:]?)(\\d\\d?)\\2(\\d\\d?)(?:[-Tt ](\\d\\d?)(?:([-:]?)(\\d\\d?)(?:\\6(\\d\\d?)(?:[.,](\\d+))?)?)?)?(?=\\D)/ /) {\n    ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);\n  }\n\n  unless (defined $hh) {\n    if ($dtstr =~ s#[:\\s](\\d\\d?):(\\d\\d?)(:(\\d\\d?)(?:\\.\\d+)?)?(z)?\\s*(?:([ap])\\.?m?\\.?)?\\s# #o) {\n      ($hh,$mm,$ss) = ($1,$2,$4);\n      $zone = 0 if $5;\n      $merid = $ampm{$6} if $6;\n    }\n\n    # Time: 12 am\n    \n    elsif ($dtstr =~ s#\\s(\\d\\d?)\\s*([ap])\\.?m?\\.?\\s# #o) {\n      ($hh,$mm,$ss) = ($1,0,0);\n      $merid = $ampm{$2};\n    }\n  }\n    \n  if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\\.?m?\\.?\\s# #o) {\n    $merid = $ampm{$1};\n  }\n\n\n  unless (defined $year) {\n    # Date: 12-June-96 (using - . or /)\n    \n    if ($dtstr =~ s#\\s(\\d\\d?)([\\-\\./])($monpat)(\\2(\\d\\d+))?\\s# #o) {\n      ($month,$day) = ($month{$3},$1);\n      $year = $5 if $5;\n    }\n    \n    # Date: 12-12-96 (using '-', '.' or '/' )\n    \n    elsif ($dtstr =~ s#\\s(\\d+)([\\-\\./])(\\d\\d?)(\\2(\\d+))?\\s# #o) {\n      ($month,$day) = ($1 - 1,$3);\n\n      if ($5) {\n\t$year = $5;\n\t# Possible match for 1995-01-24 (short mainframe date format);\n\t($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;\n\treturn if length($year) > 2 and $year < 1901;\n      }\n    }\n    elsif ($dtstr =~ s#\\s(\\d+)\\s*($sufpat)?\\s*($monpat)# #o) {\n      ($month,$day) = ($month{$3},$1);\n    }\n    elsif ($dtstr =~ s#($monpat)\\s*(\\d+)\\s*($sufpat)?\\s# #o) {\n      ($month,$day) = ($month{$1},$2);\n    }\n    elsif ($dtstr =~ s#($monpat)([\\/-])(\\d+)[\\/-]# #o) {\n      ($month,$day) = ($month{$1},$3);\n    }\n\n    # Date: 961212\n\n    elsif ($dtstr =~ s#\\s(\\d\\d)(\\d\\d)(\\d\\d)\\s# #o) {\n      ($year,$month,$day) = ($1,$2-1,$3);\n    }\n\n    $year = $1 if !defined($year) and $dtstr =~ s#\\s(\\d{2}(\\d{2})?)[\\s\\.,]# #o;\n\n  }\n\n  # Zone\n\n  $dst = 1 if $dtstr =~ s#\\bdst\\b##o;\n\n  if ($dtstr =~ s#\\s\"?([a-z]{3,4})(dst|\\d+[a-z]*|_[a-z]+)?\"?\\s# #o) {\n    $dst = 1 if $2 and $2 eq 'dst';\n    $zone = tz_offset($1);\n    return unless defined $zone;\n  }\n  elsif ($dtstr =~ s#\\s([a-z]{3,4})?([\\-\\+]?)-?(\\d\\d?):?(\\d\\d)?(00)?\\s# #o) {\n    my $m = defined($4) ? \"$2$4\" : 0;\n    my $h = \"$2$3\";\n    $zone = defined($1) ? tz_offset($1) : 0;\n    return unless defined $zone;\n    $zone += 60 * ($m + (60 * $h));\n  }\n\n  if ($dtstr =~ /\\S/) {\n    # now for some dumb dates\n    if ($dtstr =~ s/^\\s*(ut?|z)\\s*$//) {\n      $zone = 0;\n    }\n    elsif ($dtstr =~ s#\\s([a-z]{3,4})?([\\-\\+]?)-?(\\d\\d?)(\\d\\d)?(00)?\\s# #o) {\n      my $m = defined($4) ? \"$2$4\" : 0;\n      my $h = \"$2$3\";\n      $zone = defined($1) ? tz_offset($1) : 0;\n      return unless defined $zone;\n      $zone += 60 * ($m + (60 * $h));\n    }\n\n    return if $dtstr =~ /\\S/o;\n  }\n\n  if (defined $hh) {\n    if ($hh == 12) {\n      $hh = 0 if $merid == $AM;\n    }\n    elsif ($merid == $PM) {\n      $hh += 12;\n    }\n  }\n\n  $year -= 1900 if defined $year && $year > 1900;\n\n  $zone += 3600 if defined $zone && $dst;\n  $ss += \"0.$frac\" if $frac;\n\n  return ($ss,$mm,$hh,$day,$month,$year,$zone);\n}\nESQ\n\nuse vars qw($day_ref $mon_ref $suf_ref $obj);\n\nsub gen_parser\n{\n local($day_ref,$mon_ref,$suf_ref,$obj) = @_;\n\n if($obj)\n  {\n   my $obj_strptime = $strptime;\n   substr($obj_strptime,index($strptime,\"sub\")+6,0) = <<'ESQ';\n shift; # package\nESQ\n   my $sub = eval \"$obj_strptime\" or die $@;\n   return $sub;\n  }\n\n eval \"$strptime\" or die $@;\n\n}\n\n*strptime = gen_parser(\\%day,\\%month,\\@suf);\n\nsub str2time\n{\n my @t = strptime(@_);\n\n return undef\n\tunless @t;\n\n my($ss,$mm,$hh,$day,$month,$year,$zone) = @t;\n my @lt  = localtime(time);\n\n $hh    ||= 0;\n $mm    ||= 0;\n $ss    ||= 0;\n\n my $frac = $ss - int($ss);\n $ss = int $ss;\n\n $month = $lt[4]\n\tunless(defined $month);\n\n $day  = $lt[3]\n\tunless(defined $day);\n\n $year = ($month > $lt[4]) ? ($lt[5] - 1) : $lt[5]\n\tunless(defined $year);\n\n return undef\n\tunless($month <= 11 && $day >= 1 && $day <= 31\n\t\t&& $hh <= 23 && $mm <= 59 && $ss <= 59);\n\n my $result;\n\n if (defined $zone) {\n   $result = eval {\n     local $SIG{__DIE__} = sub {}; # Ick!\n     timegm($ss,$mm,$hh,$day,$month,$year);\n   };\n   return undef\n     if !defined $result\n        or $result == -1\n           && join(\"\",$ss,$mm,$hh,$day,$month,$year)\n     \t        ne \"595923311169\";\n   $result -= $zone;\n }\n else {\n   $result = eval {\n     local $SIG{__DIE__} = sub {}; # Ick!\n     timelocal($ss,$mm,$hh,$day,$month,$year);\n   };\n   return undef\n     if !defined $result\n        or $result == -1\n           && join(\"\",$ss,$mm,$hh,$day,$month,$year)\n     \t        ne join(\"\",(localtime(-1))[0..5]);\n }\n\n return $result + $frac;\n}\n\n1;\n\n__END__\n\n\n=head1 NAME\n\nDate::Parse - Parse date strings into time values\n\n=head1 SYNOPSIS\n\n\tuse Date::Parse;\n\t\n\t$time = str2time($date);\n\t\n\t($ss,$mm,$hh,$day,$month,$year,$zone) = strptime($date);\n\n=head1 DESCRIPTION\n\nC<Date::Parse> provides two routines for parsing date strings into time values.\n\n=over 4\n\n=item str2time(DATE [, ZONE])\n\nC<str2time> parses C<DATE> and returns a unix time value, or undef upon failure.\nC<ZONE>, if given, specifies the timezone to assume when parsing if the\ndate string does not specify a timezone.\n\n=item strptime(DATE [, ZONE])\n\nC<strptime> takes the same arguments as str2time but returns an array of\nvalues C<($ss,$mm,$hh,$day,$month,$year,$zone)>. Elements are only defined\nif they could be extracted from the date string. The C<$zone> element is\nthe timezone offset in seconds from GMT. An empty array is returned upon\nfailure.\n\n=back\n\n=head1 MULTI-LANGUAGE SUPPORT\n\nDate::Parse is capable of parsing dates in several languages, these include\nEnglish, French, German and Italian.\n\n\t$lang = Date::Language->new('German');\n\t$lang->str2time(\"25 Jun 1996 21:09:55 +0100\");\n\n=head1 EXAMPLE DATES\n\nBelow is a sample list of dates that are known to be parsable with Date::Parse\n\n 1995:01:24T09:08:17.1823213           ISO-8601\n 1995-01-24T09:08:17.1823213\n Wed, 16 Jun 94 07:29:35 CST           Comma and day name are optional \n Thu, 13 Oct 94 10:13:13 -0700\n Wed, 9 Nov 1994 09:50:32 -0500 (EST)  Text in ()'s will be ignored.\n 21 dec 17:05                          Will be parsed in the current time zone\n 21-dec 17:05\n 21/dec 17:05\n 21/dec/93 17:05\n 1999 10:02:18 \"GMT\"\n 16 Nov 94 22:28:20 PST \n\n=head1 LIMITATION\n\nDate::Parse uses L<Time::Local> internally, so is limited to only parsing dates\nwhich result in valid values for Time::Local::timelocal. This generally means dates\nbetween 1901-12-17 00:00:00 GMT and 2038-01-16 23:59:59 GMT\n\n=head1 BUGS\n\nWhen both the month and the date are", 8192) = 8192
09:01:57.472717 stat("modules/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.472769 stat("modules/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.472826 stat("modules/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.472874 stat("modules/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.472922 stat("/etc/perl/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.472972 stat("/etc/perl/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.473020 stat("/usr/local/lib/perl/5.14.2/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.473070 stat("/usr/local/lib/perl/5.14.2/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.473120 stat("/usr/local/share/perl/5.14.2/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.473170 stat("/usr/local/share/perl/5.14.2/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.473220 stat("/usr/lib/perl5/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.473268 stat("/usr/lib/perl5/Time/Zone.pm", 0x7ffe1233b5b0) = -1 ENOENT (No such file or directory)
09:01:57.473317 stat("/usr/share/perl5/Time/Zone.pmc", 0x7ffe1233b660) = -1 ENOENT (No such file or directory)
09:01:57.473367 stat("/usr/share/perl5/Time/Zone.pm", {st_mode=S_IFREG|0644, st_size=8346, ...}) = 0
09:01:57.473425 open("/usr/share/perl5/Time/Zone.pm", O_RDONLY) = 8
09:01:57.473477 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b340) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.473523 lseek(8, 0, SEEK_CUR)   = 0
09:01:57.473576 read(8, "\npackage Time::Zone;\n\n=head1 NAME\n\nTime::Zone -- miscellaneous timezone manipulations routines\n\n=head1 SYNOPSIS\n\n\tuse Time::Zone;\n\tprint tz2zone();\n\tprint tz2zone($ENV{'TZ'});\n\tprint tz2zone($ENV{'TZ'}, time());\n\tprint tz2zone($ENV{'TZ'}, undef, $isdst);\n\t$offset = tz_local_offset();\n\t$offset = tz_offset($TZ);\n\n=head1 DESCRIPTION\n\nThis is a collection of miscellaneous timezone manipulation routines.\n\nC<tz2zone()> parses the TZ environment variable and returns a timezone\nstring suitable for inclusion in L<date(1)>-like output.  It opionally takes\na timezone string, a time, and a is-dst flag.\n\nC<tz_local_offset()> determins the offset from GMT time in seconds.  It\nonly does the calculation once.\n\nC<tz_offset()> determines the offset from GMT in seconds of a specified\ntimezone.  \n\nC<tz_name()> determines the name of the timezone based on its offset\n\n=head1 AUTHORS\n\nGraham Barr <gbarr@pobox.com>\nDavid Muir Sharnoff <muir@idiom.com>\nPaul Foley <paul@ascent.com>\n\n=cut\n\nrequire 5.002;\n\nrequire Exporter;\nuse Carp;\nuse strict;\nuse vars qw(@ISA @EXPORT $VERSION @tz_local);\n\n@ISA = qw(Exporter);\n@EXPORT = qw(tz2zone tz_local_offset tz_offset tz_name);\n$VERSION = \"2.24\";\n\n# Parts stolen from code by Paul Foley <paul@ascent.com>\n\nsub tz2zone (;$$$)\n{\n\tmy($TZ, $time, $isdst) = @_;\n\n\tuse vars qw(%tzn_cache);\n\n\t$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : ''\n\t    unless $TZ;\n\n\t# Hack to deal with 'PST8PDT' format of TZ\n\t# Note that this can't deal with all the esoteric forms, but it\n\t# does recognize the most common: [:]STDoff[DST[off][,rule]]\n\n\tif (! defined $isdst) {\n\t\tmy $j;\n\t\t$time = time() unless $time;\n\t\t($j, $j, $j, $j, $j, $j, $j, $j, $isdst) = localtime($time);\n\t}\n\n\tif (defined $tzn_cache{$TZ}->[$isdst]) {\n\t\treturn $tzn_cache{$TZ}->[$isdst];\n\t}\n      \n\tif ($TZ =~ /^\n\t\t    ( [^:\\d+\\-,] {3,} )\n\t\t    ( [+-] ?\n\t\t      \\d {1,2}\n\t\t      ( : \\d {1,2} ) {0,2} \n\t\t    )\n\t\t    ( [^\\d+\\-,] {3,} )?\n\t\t    /x\n\t    ) {\n\t\tmy $dsttz = defined($4) ? $4 : $1;\n\t\t$TZ = $isdst ? $dsttz : $1;\n\t\t$tzn_cache{$TZ} = [ $1, $dsttz ];\n\t} else {\n\t\t$tzn_cache{$TZ} = [ $TZ, $TZ ];\n\t}\n\treturn $TZ;\n}\n\nsub tz_local_offset (;$)\n{\n\tmy ($time) = @_;\n\n\t$time = time() unless $time;\n\tmy (@l) = localtime($time);\n\tmy $isdst = $l[8];\n\n\tif (defined($tz_local[$isdst])) {\n\t\treturn $tz_local[$isdst];\n\t}\n\n\t$tz_local[$isdst] = &calc_off($time);\n\n\treturn $tz_local[$isdst];\n}\n\nsub calc_off\n{\n\tmy ($time) = @_;\n\n\tmy (@l) = localtime($time);\n\tmy (@g) = gmtime($time);\n\n\tmy $off;\n\n\t$off =     $l[0] - $g[0]\n\t\t+ ($l[1] - $g[1]) * 60\n\t\t+ ($l[2] - $g[2]) * 3600;\n\n\t# subscript 7 is yday.\n\n\tif ($l[7] == $g[7]) {\n\t\t# done\n\t} elsif ($l[7] == $g[7] + 1) {\n\t\t$off += 86400;\n\t} elsif ($l[7] == $g[7] - 1) {\n\t\t$off -= 86400;\n\t} elsif ($l[7] < $g[7]) {\n\t\t# crossed over a year boundry!\n\t\t# localtime is beginning of year, gmt is end\n\t\t# therefore local is ahead\n\t\t$off += 86400;\n\t} else {\n\t\t$off -= 86400;\n\t}\n\n\treturn $off;\n}\n\n# constants\n\nCONFIG: {\n\tuse vars qw(%dstZone %zoneOff %dstZoneOff %Zone);\n\n\tmy @dstZone = (\n\t#   \"ndt\"  =>   -2*3600-1800,\t # Newfoundland Daylight   \n\t    \"brst\" =>   -2*3600,         # Brazil Summer Time (East Daylight)\n\t    \"adt\"  =>   -3*3600,  \t # Atlantic Daylight   \n\t    \"edt\"  =>   -4*3600,  \t # Eastern Daylight\n\t    \"cdt\"  =>   -5*3600,  \t # Central Daylight\n\t    \"mdt\"  =>   -6*3600,  \t # Mountain Daylight\n\t    \"pdt\"  =>   -7*3600,  \t # Pacific Daylight\n\t    \"akdt\" =>   -8*3600,         # Alaska Daylight\n\t    \"ydt\"  =>   -8*3600,  \t # Yukon Daylight\n\t    \"hdt\"  =>   -9*3600,  \t # Hawaii Daylight\n\t    \"bst\"  =>   +1*3600,  \t # British Summer   \n\t    \"mest\" =>   +2*3600,  \t # Middle European Summer   \n\t    \"metdst\" => +2*3600, \t # Middle European DST\n\t    \"sst\"  =>   +2*3600,  \t # Swedish Summer\n\t    \"fst\"  =>   +2*3600,  \t # French Summer\n            \"cest\" =>   +2*3600,         # Central European Daylight\n            \"eest\" =>   +3*3600,         # Eastern European Summer\n            \"msd\"  =>   +4*3600,         # Moscow Daylight\n\t    \"wadt\" =>   +8*3600,  \t # West Australian Daylight\n\t    \"kdt\"  =>  +10*3600,\t # Korean Daylight\n\t#   \"cadt\" =>  +10*3600+1800,\t # Central Australian Daylight\n\t    \"aedt\" =>  +11*3600,  \t # Eastern Australian Daylight\n\t    \"eadt\" =>  +11*3600,  \t # Eastern Australian Daylight\n\t    \"nzd\"  =>  +13*3600,  \t # New Zealand Daylight   \n\t    \"nzdt\" =>  +13*3600,  \t # New Zealand Daylight   \n\t);\n\n\tmy @Zone = (\n\t    \"gmt\"\t=>   0,  \t # Greenwich Mean\n\t    \"ut\"        =>   0,  \t # Universal (Coordinated)\n\t    \"utc\"       =>   0,\n\t    \"wet\"       =>   0,  \t # Western European\n\t    \"wat\"       =>  -1*3600,\t # West Africa\n\t    \"at\"        =>  -2*3600,\t # Azores\n\t    \"fnt\"\t=>  -2*3600,\t # Brazil Time (Extreme East - Fernando Noronha)\n\t    \"brt\"\t=>  -3*3600,\t # Brazil Time (East Standard - Brasilia)\n\t# For completeness.  BST is also British Summer, and GST is also Guam Standard.\n\t#   \"bst\"       =>  -3*3600,\t # Brazil Standard\n\t#   \"gst\"       =>  -3*3600,\t # Greenland Standard\n\t#   \"nft\"       =>  -3*3600-1800,# Newfoundland\n\t#   \"nst\"       =>  -3*3600-1800,# Newfoundland Standard\n\t    \"mnt\"\t=>  -4*3600,\t # Brazil Time (West Standard - Manaus)\n\t    \"ewt\"       =>  -4*3600,\t # U.S. Eastern War Time\n\t    \"ast\"       =>  -4*3600,\t # Atlantic Standard\n\t    \"est\"       =>  -5*3600,\t # Eastern Standard\n\t    \"act\"\t=>  -5*3600,\t # Brazil Time (Extreme West - Acre)\n\t    \"cst\"       =>  -6*3600,\t # Central Standard\n\t    \"mst\"       =>  -7*3600,\t # Mountain Standard\n\t    \"pst\"       =>  -8*3600,\t # Pacific Standard\n\t    \"akst\"      =>  -9*3600,     # Alaska Standard\n\t    \"yst\"\t=>  -9*3600,\t # Yukon Standard\n\t    \"hst\"\t=> -10*3600,\t # Hawaii Standard\n\t    \"cat\"\t=> -10*3600,\t # Central Alaska\n\t    \"ahst\"\t=> -10*3600,\t # Alaska-Hawaii Standard\n\t    \"nt\"\t=> -11*3600,\t # Nome\n\t    \"idlw\"\t=> -12*3600,\t # International Date Line West\n\t    \"cet\"\t=>  +1*3600, \t # Central European\n\t    \"mez\"\t=>  +1*3600, \t # Central European (German)\n\t    \"ect\"\t=>  +1*3600, \t # Central European (French)\n\t    \"met\"\t=>  +1*3600, \t # Middle European\n\t    \"mewt\"\t=>  +1*3600, \t # Middle European Winter\n\t    \"swt\"\t=>  +1*3600, \t # Swedish Winter\n\t    \"set\"\t=>  +1*3600, \t # Seychelles\n\t    \"fwt\"\t=>  +1*3600, \t # French Winter\n\t    \"eet\"\t=>  +2*3600, \t # Eastern Europe, USSR Zone 1\n\t    \"ukr\"\t=>  +2*3600, \t # Ukraine\n\t    \"bt\"\t=>  +3*3600, \t # Baghdad, USSR Zone 2\n            \"msk\"       =>  +3*3600,     # Moscow\n\t#   \"it\"\t=>  +3*3600+1800,# Iran\n\t    \"zp4\"\t=>  +4*3600, \t # USSR Zone 3\n\t    \"zp5\"\t=>  +5*3600, \t # USSR Zone 4\n\t#   \"ist\"\t=>  +5*3600+1800,# Indian Standard\n\t    \"zp6\"\t=>  +6*3600, \t # USSR Zone 5\n\t# For completeness.  NST is also Newfoundland Stanard, and SST is also Swedish Summer.\n\t#   \"nst\"\t=>  +6*3600+1800,# North Sumatra\n\t#   \"sst\"\t=>  +7*3600, \t # South Sumatra, USSR Zone 6\n\t#   \"jt\"\t=>  +7*3600+1800,# Java (3pm in Cronusland!)\n\t    \"wst\"\t=>  +8*3600, \t # West Australian Standard\n\t    \"hkt\"\t=>  +8*3600, \t # Hong Kong\n\t    \"cct\"\t=>  +8*3600, \t # China Coast, USSR Zone 7\n\t    \"jst\"\t=>  +9*3600,\t # Japan Standard, USSR Zone 8\n\t    \"kst\"\t=>  +9*3600,\t # Korean Standard\n\t#   \"cast\"\t=>  +9*3600+1800,# Central Australian Standard\n\t    \"aest\"\t=> +10*3600,\t # Eastern Australian Standard\n\t    \"east\"\t=> +10*3600,\t # Eastern Australian Standard\n\t    \"gst\"\t=> +10*3600,\t # Guam Standard, USSR Zone 9\n\t    \"nzt\"\t=> +12*3600,\t # New Zealand\n\t    \"nzst\"\t=> +12*3600,\t # New Zealand Standard\n\t    \"idle\"\t=> +12*3600,\t # International Date Line East\n\t);\n\n\t%Zone = @Zone;\n\t%dstZone = @dstZone;\n\t%zoneOff = reverse(@Zone);\n\t%dstZoneOff = reverse(@dstZone);\n\n}\n\nsub tz_offset (;$$)\n{\n\tmy ($zone, $time) = @_;\n\n\treturn &tz_local_offset($time) unless($zone);\n\n\t$time = time() unless $time;\n\tmy(@l) = localtime($time);\n\tmy $dst = $l[8];\n\n\t$zone = lc $zone;\n\n\tif($zone =~ /^(([\\-\\+])\\d\\d?)(\\d\\d)$/) {\n\t\tmy $v = $2 . $3;\n\t\treturn $1 * 3600 + $v * 60;\n\t} elsif (exists $dstZone{$zone} && ($dst || !exists $Zone{$zone})) {\n\t\treturn $dstZone{$zone};\n\t} elsif(exists $Zone{$zone}) {\n\t\treturn $Zone{$zone};\n\t}\n\tundef;\n}\n\nsub tz_name (;$$)\n{\n\tmy ($off, $dst) = @_;\n\n\t$off = tz_offset()\n\t\tunless(defined $off);\n\n\t$dst = (localtime(time))[8]\n\t\tunless(defined $dst);\n\n\tif (exists $dstZoneOff{$off} && ($dst || !exists $zoneOff{$off})", 8192) = 8192
09:01:57.474543 read(8, ") {\n\t\treturn $dstZoneOff{$off};\n\t} elsif (exists $zoneOff{$off}) {\n\t\treturn $zoneOff{$off};\n\t}\n\tsprintf(\"%+05d\", int($off / 60) * 100 + $off % 60);\n}\n\n1;\n", 8192) = 154
09:01:57.474644 read(8, "", 8192)       = 0
09:01:57.474691 close(8)                = 0
09:01:57.475174 lseek(7, 6275, SEEK_SET) = 6275
09:01:57.475220 lseek(7, 0, SEEK_CUR)   = 6275
09:01:57.475264 close(7)                = 0
09:01:57.476619 stat("modules/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.476673 stat("modules/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.476723 stat("modules/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.476771 stat("modules/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.476820 stat("/etc/perl/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.476869 stat("/etc/perl/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.476918 stat("/usr/local/lib/perl/5.14.2/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.476968 stat("/usr/local/lib/perl/5.14.2/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.477018 stat("/usr/local/share/perl/5.14.2/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.477069 stat("/usr/local/share/perl/5.14.2/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.477119 stat("/usr/lib/perl5/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.477175 stat("/usr/lib/perl5/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.477225 stat("/usr/share/perl5/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.477276 stat("/usr/share/perl5/Tie/Hash/NamedCapture.pm", 0x7ffe1233b3d0) = -1 ENOENT (No such file or directory)
09:01:57.477325 stat("/usr/lib/perl/5.14/Tie/Hash/NamedCapture.pmc", 0x7ffe1233b480) = -1 ENOENT (No such file or directory)
09:01:57.477378 stat("/usr/lib/perl/5.14/Tie/Hash/NamedCapture.pm", {st_mode=S_IFREG|0644, st_size=1542, ...}) = 0
09:01:57.477438 open("/usr/lib/perl/5.14/Tie/Hash/NamedCapture.pm", O_RDONLY) = 7
09:01:57.477491 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b160) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.477536 lseek(7, 0, SEEK_CUR)   = 0
09:01:57.477594 read(7, "use strict;\npackage Tie::Hash::NamedCapture;\n\nour $VERSION = \"0.08\";\n\nrequire XSLoader;\nXSLoader::load(); # This returns true, which makes require happy.\n\n__END__\n\n=head1 NAME\n\nTie::Hash::NamedCapture - Named regexp capture buffers\n\n=head1 SYNOPSIS\n\n    tie my %hash, \"Tie::Hash::NamedCapture\";\n    # %hash now behaves like %+\n\n    tie my %hash, \"Tie::Hash::NamedCapture\", all => 1;\n    # %hash now access buffers from regexp in $qr like %-\n\n=head1 DESCRIPTION\n\nThis module is used to implement the special hashes C<%+> and C<%->, but it\ncan be used to tie other variables as you choose.\n\nWhen the C<all> parameter is provided, then the tied hash elements will be\narray refs listing the contents of each capture buffer whose name is the\nsame as the associated hash key. If none of these buffers were involved in\nthe match, the contents of that array ref will be as many C<undef> values\nas there are capture buffers with that name. In other words, the tied hash\nwill behave as C<%->.\n\nWhen the C<all> parameter is omitted or false, then the tied hash elements\nwill be the contents of the leftmost defined buffer with the name of the\nassociated hash key. In other words, the tied hash will behave as\nC<%+>.\n\nThe keys of C<%->-like hashes correspond to all buffer names found in the\nregular expression; the keys of C<%+>-like hashes list only the names of\nbuffers that have captured (and that are thus associated to defined values).\n\n=head1 SEE ALSO\n\nL<perlreapi>, L<re>, L<perlmodlib/Pragmatic Modules>, L<perlvar/\"%+\">,\nL<perlvar/\"%-\">.\n\n=cut\n", 8192) = 1542
09:01:57.477754 lseek(7, 163, SEEK_SET) = 163
09:01:57.477800 lseek(7, 0, SEEK_CUR)   = 163
09:01:57.477844 close(7)                = 0
09:01:57.477931 stat("/usr/lib/perl/5.14/auto/Tie/Hash/NamedCapture/NamedCapture.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.477990 stat("/usr/lib/perl/5.14/auto/Tie/Hash/NamedCapture/NamedCapture.so", {st_mode=S_IFREG|0644, st_size=14472, ...}) = 0
09:01:57.478069 stat("/usr/lib/perl/5.14/auto/Tie/Hash/NamedCapture/NamedCapture.bs", 0x65f138) = -1 ENOENT (No such file or directory)
09:01:57.478138 open("/usr/lib/perl/5.14/auto/Tie/Hash/NamedCapture/NamedCapture.so", O_RDONLY) = 7
09:01:57.478193 read(7, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\200\17\0\0\0\0\0\0@\0\0\0\0\0\0\0\3101\0\0\0\0\0\0\0\0\0\0@\0008\0\7\0@\0\33\0\32\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\36\0\0\0\0\0\0,\36\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\270-\0\0\0\0\0\0\270- \0\0\0\0\0\270- \0\0\0\0\0\20\3\0\0\0\0\0\0\30\3\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\320-\0\0\0\0\0\0\320- \0\0\0\0\0\320- \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0\310\1\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0X\34\0\0\0\0\0\0X\34\0\0\0\0\0\0X\34\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\270-\0\0\0\0\0\0\270- \0\0\0\0\0\270- \0\0\0\0\0H\2\0\0\0\0\0\0H\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\213\271\267}\272\252\226\253\344\350\352>\267\223\215 \313\367G\2\0\0\0\0%\0\0\0(\0\0\0\0\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\25\0\0\0\0\0\0\0\r\0\0\0\21\0\0\0\0\0\0\0\0\0\0\0\30\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\24\0\0\0\7\0\0\0\36\0\0\0%\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$\0\0\0&\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\6\0\0\0\34\0\0\0\32\0\0\0\0\0\0\0\n\0\0\0!\0\0\0#\0\0\0\22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\16\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\2\0\0\0 \0\0\0\0\0\0\0\27\0\0\0\31\0\0\0\17\0\0\0\0\0\0\0\20\0\0\0\3\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\37\0\0\0\0\0\0\0\"\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\3\0\0\0\36\0\0\0\1\0\0\0\6\0\0\0", 832) = 832
09:01:57.478334 fstat(7, {st_mode=S_IFREG|0644, st_size=14472, ...}) = 0
09:01:57.478392 mmap(NULL, 2109648, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 7, 0) = 0x7f74311e8000
09:01:57.478442 mprotect(0x7f74311ea000, 2097152, PROT_NONE) = 0
09:01:57.478493 mmap(0x7f74313ea000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 7, 0x2000) = 0x7f74313ea000
09:01:57.478550 close(7)                = 0
09:01:57.478607 mprotect(0x7f74313ea000, 4096, PROT_READ) = 0
09:01:57.479000 read(6, "];\n  my $args = $request->[1];\n  my @params;\n\n#printf STDERR \"PARSE_YOUTUBE_API\\n\";\n  push @params, $args->{session};\n  my $res = $response->[0];\n\n  if (! $res->is_success) {\nprintf STDERR \"PARSE_YOUTUBE_API: res != success: $res->status_line\\n\";\nprintf STDERR \"PARSE_YOUTUBE_API: X-PCCH-Errmsg: %s\\n\", $res->header('X-PCCH-Errmsg');\n    my $error =  \"Failed to retrieve URL - \";\n    if (defined($res->header('X-PCCH-Errmsg')) and $res->header('X-PCCH-Errmsg') =~ /Connection to .* failed: [^\\s]+ error (?<errornum>\\?\\?|[0-9]]+): (?<errorstr>.*)$/) {\n      $error .= $+{'errornum'} . \": \" . $+{'errorstr'};\n    } else {\n      $error .=  $res->status_line;\n    }\n    push @params, 'irc_miggybot_url_error', $args, $error;\n  } else {\n#printf STDERR \"PARSE_YOUTUBE_API success!\\n\";\n    my $json = decode_json($res->content);\n    if (! $json) {\n#printf STDERR \"PARSE_YOUTUBE_API no JSON\\n\";\n      push @params, 'irc_miggybot_url_error', $args, \"Failed to parse JSON response\";\n    } else {\n#printf STDERR \"PARSE_YOUTUBE_API got JSON\\n\";\n      if (defined($json->{'items'}) and defined($json->{'items'}[0]->{'id'})) {\n#printf STDERR \"PARSE_YOUTUBE_API got items and it contains id\\n\";\n        my $v = $json->{'items'}[0];\n# 21:02:28<EDBot> [YouTube] Title: The Good, The Bad and The Bucky: Highlights from the Buckyball Run | Uploader: Esvandiary | Uploaded: 2015-05-15 00:47:44 UTC | Duration: 00:07:13 | Views: 1,591 | Comments: 7 | Likes: 39 | Dislikes: 1\n        my $blurb = \"[ YouTube ] Title: \" . $v->{'snippet'}{'title'};\n        $blurb .= \" | Uploader: \" . $v->{'snippet'}{'channelTitle'};\n        my $pub_timet = str2time($v->{'snippet'}{'publishedAt'});\n        if (defined($pub_timet)) {\n          $blurb .= \" | Uploaded: \" . strftime(\"%Y-%m-%d %H:%M:%S UTC\", gmtime($pub_timet));\n        }\n        if (defined($v->{'contentDetails'}{'duration'})) {\n          $blurb .= youtube_parse_duration($v->{'contentDetails'}{'duration'});\n        }\n        if (defined($v->{'statistics'}{'viewCount'})) {\n          $blurb .= \" | Views: \" . prettyprint($v->{'statistics'}{'viewCount'});\n        }\n        if (defined($v->{'statistics'}{'commentCount'})) {\n          $blurb .= \" | Comments: \" . prettyprint($v->{'statistics'}{'commentCount'});\n        }\n        if (defined($v->{'statistics'}{'likeCount'})) {\n          $blurb .= \" | Likes: \" . prettyprint($v->{'statistics'}{'likeCount'});\n        }\n        if (defined($v->{'statistics'}{'dislikeCount'})) {\n          $blurb .= \" | Dislikes: \" . prettyprint($v->{'statistics'}{'dislikeCount'});\n        }\n#printf STDERR \"PARSE_YOUTUBE_API pushing blurb to params\\n\";\n        push @params, 'irc_miggybot_url_success', $args, $blurb;\n      } else {\n#printf STDERR \"PARSE_YOUTUBE_API no items?\\n\";\n        push @params, 'irc_miggybot_url_error', $args, \"No items? Content '\" . $res->content . \"'\";\n      }\n    }\n  }\n\n  $kernel->post(@params);\n  undef;\n}\n\n## Fallback parser in case we don't have a YouTube API key, or it's just\n## not a URL for a specific video\n# 21:02:28<EDBot> [YouTube] Title: The Good, The Bad and The Bucky: Highlights from the Buckyball Run | Uploader: Esvandiary | Uploaded: 2015-05-15 00:47:44 UTC | Duration: 00:07:13 | Views: 1,591 | Comments: 7 | Likes: 39 | Dislikes: 1\nsub parse_youtube_com {\n  my ($res, $args) = @_;\n\n  my $blurb = \"\";\n  if ($res->header('Content-Type') =~ /^text\\/(ht|x)ml/) {\n    my $tree = HTML::TreeBuilder->new;\n    $tree->parse($res->decoded_content);\n    $tree->eof();\n    my $title = $tree->look_down('_tag', 'title');\n    if (! $title) {\n      return $blurb;\n    }\n    $blurb = \"[ YouTube ] Title: \" . $title->as_text;\n\n    my $yt_user_info = $tree->look_down('_tag' => 'div', 'class' => 'yt-user-info');\n    if ($yt_user_info) {\n      my $a = $yt_user_info->look_down('_tag' => 'a');\n      if ($a) {\n        $blurb .= \" | Uploader: \" . $a->as_text;\n      }\n    }\n\n    my $datePublished = $tree->look_down('_tag' => 'meta', 'itemprop' => 'datePublished');\n    if ($datePublished) {\n      $blurb .= \" | Uploaded: \" . $datePublished->attr('content');\n    }\n\n    my $duration = $tree->look_down('_tag' => 'meta', 'itemprop' => 'duration');\n    $blurb .= youtube_parse_duration($duration->attr('content'));\n\n    my $interactionCount = $tree->look_down('_tag' => 'meta', 'itemprop' => 'interactionCount');\n    if ($interactionCount) {\n      $blurb .= \" | Views: \" . prettyprint($interactionCount->attr('content'));\n    }\n\n    if ($title) {\n      return $blurb;\n    } else {\n      return undef;\n    }\n  # } elsif (image) {\n  } else {\n    $args->{'quiet'} = 1;\n    return \"That was not an HTML page\";\n  }\n  return undef;\n}\n\nsub youtube_parse_duration {\n  my $d = shift;\n\n  # PT2H7M20S\n  my ($hstring, $hour, $min, $sec) = $d =~ /^PT(([0-9]+)H)?([0-9]+)M([0-9]+)S$/;\n#printf STDERR \"youtube_parse_duration: Duration '%s' %s %s %s %s\\n\", $d, $hstring, $hour, $min, $sec;\n  if (!defined($min)) {\nprintf STDERR \"Can't find minute in Duration '%s' %s, %s, %s, %s\\n\", $d, $hstring, $hour, $min, $sec;\n    return \"\";\n  }\n  if ($min >= 60) {\n    $hour = int($min / 60);\n    $min -= $hour * 60;\n  } elsif (!defined($hour)) {\n    $hour = 0;\n  }\n  return sprintf \" | Duration: %02d:%02d:%02d\", $hour, $min, $sec;\n}\n###########################################################################\n\n###########################################################################\n# IMGUR URL Parsing\n###########################################################################\nsub get_imgur_image {\n  my ($kernel, $self, $args) = @_;\n\n  my (undef, undef, $image_id) = $args->{'url'} =~ /^http(s)?:\\/\\/(i\\.)?imgur\\.com\\/([^\\.]+)(\\..+)?$/;\n#printf STDERR \"GET_IMGUR_IMAGE: image_id = %s\\n\", $image_id;\n  if ($imgur_clientid and $image_id) {\nprintf STDERR \"GET_IMGUR_IMAGE, using API for '%s' (%s)\\n\", $args->{'url'}, $image_id;\n    my $req = HTTP::Request->new('GET', \"https://api.imgur.com/3/image/\" . $image_id, ['Authorization' => 'Client-ID ' . $imgur_clientid, 'Connection' => 'close']);\n#printf STDERR \"GET_IMGUR_IMAGE: req is:\\n%s\\n\", $req->as_string();\n    $kernel->post( $self->{http_alias}, 'request', 'parse_imgur_image', $req, $args );\n  } else {\nprintf STDERR \"GET_IMGUR_IMAGE, NOT just using scraping for '%s', no output\\n\", $args->{'url'};\n  }\n}\n\nsub parse_imgur_image {\n  my ($kernel, $self, $request, $response) = @_[KERNEL, OBJECT, ARG0, ARG1];\n  my $args = $request->[1];\n  my @params;\n\n#printf STDERR \"PARSE_IMGUR_IMAGE\\n\";\n  push @params, $args->{session};\n  my $res = $response->[0];\n\n  if (! $res->is_success) {\nprintf STDERR \"PARSE_IMGUR_IMAGE: res != success: $res->status_line\\n\";\nprintf STDERR \"PARSE_IMGUR_IMAGE: X-PCCH-Errmsg: %s\\n\", $res->header('X-PCCH-Errmsg');\n    my $error =  \"Failed to retrieve URL - \";\n    if (defined($res->header('X-PCCH-Errmsg')) and $res->header('X-PCCH-Errmsg') =~ /Connection to .* failed: [^\\s]+ error (?<errornum>\\?\\?|[0-9]]+): (?<errorstr>.*)$/) {\n      $error .= $+{'errornum'} . \": \" . $+{'errorstr'};\n    } else {\n      $error .=  $res->status_line;\n    }\n    push @params, 'irc_miggybot_url_error', $args, $error;\n  } else {\n#printf STDERR \"PARSE_IMGUR_IMAGE: Content: '%s'\\n\", $res->content;\n    my $json = decode_json($res->content);\n    if (!defined($json)) {\n#printf STDERR \"PARSE_IMGUR_IMAGE: No JSON?\\n\";\n      push @params, 'irc_miggybot_url_error', $args, \"Failed to parse JSON response\";\n    } else {\n#printf STDERR \"PARSE_IMGUR_IMAGE: Got JSON?\\n\";\n      if (!defined($json->{'success'}) or $json->{'success'} ne 'true') {\n#printf STDERR \"PARSE_IMGUR_IMAGE: No success, or it's not true?\\n\";\n        push @params, 'irc_miggybot_url_error', $args, \"JSON failed: \" . $json->{'data'}{'error'};\n      } elsif (defined($json->{'data'})) {\n#printf STDERR \"PARSE_IMGUR_IMAGE: success == true\\n\";\n        my $d = $json->{'data'};\n        my $blurb = \"[ Imgur Image ] - \";\n        if (defined($d->{'title'})) {\n          $blurb .= \"Title: \" . $d->{'title'};\n        } else {\n          $blurb .= \"<no title>\";\n        }\n        if (defined($d->{'nsfw'}) and $d->{'nsfw'} eq 'true') {\n          $blurb .= \" | *NSFW* \";\n        }\n        if (defined($d->{'animated'}) and $d->{'animated'} eq 'true') {\n          $blurb .= \" | *ANIMATED* \";\n        }\n        i", 8192) = 8192
09:01:57.479640 brk(0x2011000)          = 0x2011000
09:01:57.480157 read(6, "f (defined($d->{'size'})) {\n          $blurb .= \" | Size: \" . prettyprint($d->{'size'});\n        }\n        $blurb .= \" | Published: \" . strftime(\"%Y-%m-%d %H:%M:%S UTC\", gmtime($d->{'datetime'}));\n        $blurb .= \" | Views: \" . $d->{'views'};\n        if (defined($d->{'section'})) {\n          $blurb .= \" | Section: \" . $d->{'section'};\n        }\n#printf STDERR \"PARSE_IMGUR_IMAGE: pushing blurb\\n\";\n        push @params, 'irc_miggybot_url_success', $args, $blurb;\n      }\n    }\n  }\n\n#printf STDERR \"PARSE_IMGUR_IMAGE: \\@params = %s\\n\", Dumper(\\@params);\n  $kernel->post(@params);\n  undef;\n}\n\n## Albums\nsub get_imgur_album {\n  my ($kernel, $self, $args) = @_;\n\n  my (undef, $album_id) = $args->{'url'} =~ /^http(s)?:\\/\\/imgur\\.com\\/a\\/([^\\.\\/]+)$/;\nprintf STDERR \"GET_IMGUR_ALBUM: album_id = %s\\n\", $album_id;\n  if ($imgur_clientid and $album_id) {\nprintf STDERR \"GET_IMGUR_ALBUM, using API for '%s' (%s)\\n\", $args->{'url'}, $album_id;\n    my $req = HTTP::Request->new('GET', \"https://api.imgur.com/3/album/\" . $album_id, ['Authorization' => 'Client-ID ' . $imgur_clientid, 'Connection' => 'close']);\n#printf STDERR \"GET_IMGUR_ALBUM: req is:\\n%s\\n\", $req->as_string();\n    $kernel->post( $self->{http_alias}, 'request', 'parse_imgur_album', $req, $args );\n  } else {\nprintf STDERR \"GET_IMGUR_ALBUM, NOT just using scraping for '%s', no output\\n\", $args->{'url'};\n  }\n}\n\nsub parse_imgur_album {\n  my ($kernel, $self, $request, $response) = @_[KERNEL, OBJECT, ARG0, ARG1];\n  my $args = $request->[1];\n  my @params;\n\nprintf STDERR \"PARSE_IMGUR_ALBUM\\n\";\n  push @params, $args->{session};\n  my $res = $response->[0];\n\n  if (! $res->is_success) {\nprintf STDERR \"PARSE_IMGUR_ALBUM: res != success: $res->status_line\\n\";\nprintf STDERR \"PARSE_IMGUR_ALBUM: X-PCCH-Errmsg: %s\\n\", $res->header('X-PCCH-Errmsg');\n    my $error =  \"Failed to retrieve URL - \";\n    if (defined($res->header('X-PCCH-Errmsg')) and $res->header('X-PCCH-Errmsg') =~ /Connection to .* failed: [^\\s]+ error (?<errornum>\\?\\?|[0-9]]+): (?<errorstr>.*)$/) {\n      $error .= $+{'errornum'} . \": \" . $+{'errorstr'};\n    } else {\n      $error .=  $res->status_line;\n    }\n    push @params, 'irc_miggybot_url_error', $args, $error;\n  } else {\nprintf STDERR \"PARSE_IMGUR_ALBUM: Content: '%s'\\n\", $res->content;\n    my $json = decode_json($res->content);\n    if (!defined($json)) {\n#printf STDERR \"PARSE_IMGUR_ALBUM: No JSON?\\n\";\n      push @params, 'irc_miggybot_url_error', $args, \"Failed to parse JSON response\";\n    } else {\n#printf STDERR \"PARSE_IMGUR_ALBUM: Got JSON?\\n\";\n      if (!defined($json->{'success'}) or $json->{'success'} ne 'true') {\n#printf STDERR \"PARSE_IMGUR_ALBUM: No success, or it's not true?\\n\";\n        push @params, 'irc_miggybot_url_error', $args, \"JSON failed: \" . $json->{'data'}{'error'};\n      } elsif (defined($json->{'data'})) {\n#printf STDERR \"PARSE_IMGUR_ALBUM: success == true\\n\";\n        my $d = $json->{'data'};\n        my $blurb = \"[ Imgur Album ] - \";\n        if (defined($d->{'title'})) {\n          $blurb .= \"Title: \" . $d->{'title'};\n        } else {\n          $blurb .= \"<no title>\";\n        }\n        if (defined($d->{'account_url'}) and $d->{'account_url'} ne 'null') {\n          $blurb .= \" | User: \" . $d->{'account_url'};\n        }\n        if (defined($d->{'nsfw'}) and $d->{'nsfw'} eq 'true') {\n          $blurb .= \" | *NSFW* \";\n        }\n        if (defined($d->{'images_count'})) {\n          $blurb .= \" | # Images: \" . prettyprint($d->{'images_count'});\n        }\n        $blurb .= \" | Published: \" . strftime(\"%Y-%m-%d %H:%M:%S UTC\", gmtime($d->{'datetime'}));\n        $blurb .= \" | Views: \" . $d->{'views'};\n        if (defined($d->{'section'})) {\n          $blurb .= \" | Section: \" . $d->{'section'};\n        }\n#printf STDERR \"PARSE_IMGUR_ALBUM: pushing blurb\\n\";\n        push @params, 'irc_miggybot_url_success', $args, $blurb;\n      }\n    }\n  }\n\n#printf STDERR \"PARSE_IMGUR_ALBUM: \\@params = %s\\n\", Dumper(\\@params);\n  $kernel->post(@params);\n  undef;\n}\n###########################################################################\n\n###########################################################################\n# https://community.elitedangerous.com/galnet/uid/...\n###########################################################################\nsub parse_community_elitedangeros_com_galnet_uid {\n  my ($res, $args) = @_;\n\n#printf STDERR \"_PARSE_COMMUNITY_ELITEDANGEROS_COM_GALNET_UID\\n\";\n  my $blurb = \"\";\n  if ($res->header('Content-Type') =~ /^text\\/(ht|x)ml/) {\n#printf STDERR \"_PARSE_COMMUNITY_ELITEDANGEROS_COM_GALNET_UID\\n\\tGot HTML or XML reply\\n\";\n#printf STDERR $res->content, \"\\n\";\n    my $tree = HTML::TreeBuilder->new;\n    $tree->parse($res->decoded_content);\n    $tree->eof();\n    my $title = $tree->look_down('_tag' => 'h3', 'class' => qr/.*galnetNewsArticleTitle.*/);\n    if (! $title) {\nprintf STDERR \"_PARSE_COMMUNITY_ELITEDANGEROS_COM_GALNET_UID\\n\\tNo galnetNewsArticleTitle\\n\";\n      return undef;\n    }\n\n    my $galnet_title = $title->look_down('_tag' => 'a');\n    if ($galnet_title) {\n#printf STDERR \"_PARSE_COMMUNITY_ELITEDANGEROS_COM_GALNET_UID\\n\\tFound galnet title text\\n\";\n      return sprintf(\"[ %s ] - Elite Dangerous GalNet (community.elitedangerous.com/galnet)\", $galnet_title->as_text) ;\n    }\n\n  # } elsif (image) {\n  } else {\n    $args->{'quiet'} = 1;\n    return \"That was not an HTML page\";\n  }\n  return undef;\n}\n###########################################################################\n\n###########################################################################\n# Misc helper subs\n###########################################################################\nsub prettyprint {\n  my $number = sprintf \"%.0f\", shift @_;\n  # Add one comma each time through the do-nothing loop\n  1 while $number =~ s/^(-?\\d+)(\\d\\d\\d)/$1,$2/;\n  # Put the dollar sign in the right place\n  #$number =~ s/^(-?)/$1\\$/;\n  $number;\n}\n\nsub mylog {\n  printf STDERR \"%s - %s\\n\", strftime(\"%Y-%m-%d %H:%M:%S UTC\", gmtime()), join(\"\", @_);\n}\n###########################################################################\n\n1;\n", 8192) = 6033
09:01:57.480868 brk(0x2032000)          = 0x2032000
09:01:57.481053 read(6, "", 8192)       = 0
09:01:57.481103 close(6)                = 0
09:01:57.481504 read(3, "", 8192)       = 0
09:01:57.481554 close(3)                = 0
09:01:57.482191 open("bot-config.txt", O_RDONLY) = 3
09:01:57.482252 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.482300 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.482345 fstat(3, {st_mode=S_IFREG|0600, st_size=463, ...}) = 0
09:01:57.482397 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.482449 read(3, "nickname: Jameson\nircname: Commander Jameson - *the* original commander\nchannel: #elite-dangerous\nircserver: hako.miggy.org\nircport: 4242\nconsole_password: qg8269287fla\nconsole_port: 3337\nrss_url: http://www.miggy.org/games/elite-dangerous/devtracker/ed-dev-posts.rss\n#qauth: Some Q Auth\n#qpass: Some Q Password\nyoutube_api_key:  AIzaSyBXbDN_F8cx4wwzIv6V1rZD8cxKxhlcFvs\nimgur_clientid: 8d3435a35f4818b\nimgur_clientsecret: 734464eaa88371b137edabd4300823a41feb9162\n", 8192) = 463
09:01:57.482568 read(3, "", 8192)       = 0
09:01:57.482616 close(3)                = 0
09:01:57.483802 socket(PF_FILE, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3
09:01:57.483868 connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
09:01:57.483935 close(3)                = 0
09:01:57.483984 socket(PF_FILE, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3
09:01:57.484030 connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
09:01:57.484086 close(3)                = 0
09:01:57.484144 open("/etc/ld.so.cache", O_RDONLY) = 3
09:01:57.484197 fstat(3, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.484249 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7436f01000
09:01:57.484295 close(3)                = 0
09:01:57.484343 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.484402 open("/lib/x86_64-linux-gnu/libnss_compat.so.2", O_RDONLY) = 3
09:01:57.484458 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\22\0\0\0\0\0\0@\0\0\0\0\0\0\0\340s\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\0\\\0\0\0\0\0\0\0\\\0\0\0\0\0\0\0\\\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\214g\0\0\0\0\0\0\214g\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\310m\0\0\0\0\0\0\310m \0\0\0\0\0\310m \0\0\0\0\0\370\4\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\360m\0\0\0\0\0\0\360m \0\0\0\0\0\360m \0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\34\\\0\0\0\0\0\0\34\\\0\0\0\0\0\0\34\\\0\0\0\0\0\0\304\1\0\0\0\0\0\0\304\1\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\310m\0\0\0\0\0\0\310m \0\0\0\0\0\310m \0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\251F\320\354\261]\251\30\n?\301\264\275\374\334e\31kAR\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\32\0\0\0$\0\0\0\2\0\0\0\7\0\0\0Q\0\1\2\20\t\220\r\20\4\23\200\1H\272\201$\0\0\0%\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0(\0\0\0)\0\0\0\0\0\0\0+\0\0\0\0\0\0\0\0\0\0\0-\0\0\0.\0\0\0/\0\0\0\0\0\0\0\0\0\0\0000\0\0\0\0\0\0\0001\0\0\0002\0\0\0\0\0\0\0003\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\267\356\37>\3465\10\301\3468\303M%\313\271\330\274\361O\206\266y\332\201__\352+\267\321h~\23a\242\222\6", 832) = 832
09:01:57.484591 fstat(3, {st_mode=S_IFREG|0644, st_size=31584, ...}) = 0
09:01:57.484648 mmap(NULL, 2127048, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7430fe0000
09:01:57.484698 mprotect(0x7f7430fe7000, 2093056, PROT_NONE) = 0
09:01:57.484748 mmap(0x7f74311e6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f74311e6000
09:01:57.484813 close(3)                = 0
09:01:57.484865 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.484914 open("/lib/x86_64-linux-gnu/libnsl.so.1", O_RDONLY) = 3
09:01:57.484967 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0\0`T\1\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\340\32\1\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4C\1\0\0\0\0\0\4C\1\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\230M\1\0\0\0\0\0\230M!\0\0\0\0\0\230M!\0\0\0\0\0\260\5\0\0\0\0\0\0008-\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\300M\1\0\0\0\0\0\300M!\0\0\0\0\0\300M!\0\0\0\0\0\300\1\0\0\0\0\0\0\300\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0\374\32\1\0\0\0\0\0\234\5\0\0\0\0\0\0\234\5\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\230M\1\0\0\0\0\0\230M!\0\0\0\0\0\230M!\0\0\0\0\0h\2\0\0\0\0\0\0h\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\320\205\237\306\f\222U\265Y\2363\211A>h\261\323\204\326\n\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0\370\0\0\0p\0\0\0\20\0\0\0\n\0\0\0\1\0015\232 '@\0@\0\0\2\f!\1\10\0:\0\0\241\nX\0H\0\16,\0\5\200\6`\260\23 @\224\21\20@\344r\224D\350\206@1\250\202@\260z\1=\10\331\0\0\20\26\200\0044B\201*\0209\203K\200\20 \"\221\3\0D\200\302*d`E\10\0\4\4\t\4PDB\200\20\300\22!\4`@\0\32 \0\0\0\10\4\2\200\220\200\0\344#\0\212$\2\206\210\0\0`\300\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0p\0\0\0q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0t\0\0\0u\0\0\0v\0\0\0", 832) = 832
09:01:57.485100 fstat(3, {st_mode=S_IFREG|0644, st_size=89056, ...}) = 0
09:01:57.485154 mmap(NULL, 2194128, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7430dc8000
09:01:57.485203 mprotect(0x7f7430ddd000, 2093056, PROT_NONE) = 0
09:01:57.485253 mmap(0x7f7430fdc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x7f7430fdc000
09:01:57.485308 mmap(0x7f7430fde000, 6864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7430fde000
09:01:57.485361 close(3)                = 0
09:01:57.485427 mprotect(0x7f7430fdc000, 4096, PROT_READ) = 0
09:01:57.485481 mprotect(0x7f74311e6000, 4096, PROT_READ) = 0
09:01:57.485531 munmap(0x7f7436f01000, 98904) = 0
09:01:57.485597 open("/etc/ld.so.cache", O_RDONLY) = 3
09:01:57.485653 fstat(3, {st_mode=S_IFREG|0644, st_size=98904, ...}) = 0
09:01:57.485708 mmap(NULL, 98904, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7436f01000
09:01:57.485754 close(3)                = 0
09:01:57.485800 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
09:01:57.485854 open("/lib/x86_64-linux-gnu/libnss_nis.so.2", O_RDONLY) = 3
09:01:57.485906 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0p \0\0\0\0\0\0@\0\0\0\0\0\0\0\250\242\0\0\0\0\0\0\0\0\0\0@\0008\0\t\0@\0\36\0\35\0\6\0\0\0\5\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\370\1\0\0\0\0\0\0\370\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\260\205\0\0\0\0\0\0\260\205\0\0\0\0\0\0\260\205\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\227\0\0\0\0\0\0\200\227\0\0\0\0\0\0\0\0 \0\0\0\0\0\1\0\0\0\6\0\0\0\270\235\0\0\0\0\0\0\270\235 \0\0\0\0\0\270\235 \0\0\0\0\0\320\3\0\0\0\0\0\0 \7\0\0\0\0\0\0\0\0 \0\0\0\0\0\2\0\0\0\6\0\0\0\340\235\0\0\0\0\0\0\340\235 \0\0\0\0\0\340\235 \0\0\0\0\0\340\1\0\0\0\0\0\0\340\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0008\2\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0P\345td\4\0\0\0\314\205\0\0\0\0\0\0\314\205\0\0\0\0\0\0\314\205\0\0\0\0\0\0L\2\0\0\0\0\0\0L\2\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0R\345td\4\0\0\0\270\235\0\0\0\0\0\0\270\235 \0\0\0\0\0\270\235 \0\0\0\0\0H\2\0\0\0\0\0\0H\2\0\0\0\0\0\0\1\0\0\0\0\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\232\333D\210\363\263\26<\360\234v=\362^e\177\206;\266K\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\32\0\0\0\0\0\0\0g\0\0\0001\0\0\0\10\0\0\0\t\0\0\0\0\0\4X\" \22\0\0\0Bg\3\0\1\4\t\03448P\30\6\243\331\220\212$ \1\10\0\342@\310\224E\20\211\244\0\0\4\20\10@\0@!\0\0\4\0\0\0\200\0\v\0y\343\0D\202\0\0\0\0001\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0009\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 832) = 832
09:01:57.486068 fstat(3, {st_mode=S_IFREG|0644, st_size=43560, ...}) = 0
09:01:57.486131 mmap(NULL, 2139352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7430bbd000
09:01:57.486182 mprotect(0x7f7430bc7000, 2093056, PROT_NONE) = 0
09:01:57.486233 mmap(0x7f7430dc6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x9000) = 0x7f7430dc6000
09:01:57.486292 close(3)                = 0
09:01:57.486354 mprotect(0x7f7430dc6000, 4096, PROT_READ) = 0
09:01:57.486407 munmap(0x7f7436f01000, 98904) = 0
09:01:57.486467 open("/etc/passwd", O_RDONLY|O_CLOEXEC) = 3
09:01:57.486523 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.486570 fstat(3, {st_mode=S_IFREG|0644, st_size=5517, ...}) = 0
09:01:57.486623 mmap(NULL, 5517, PROT_READ, MAP_SHARED, 3, 0) = 0x7f7436f2e000
09:01:57.486670 lseek(3, 5517, SEEK_SET) = 5517
09:01:57.486733 munmap(0x7f7436f2e000, 5517) = 0
09:01:57.486779 close(3)                = 0
09:01:57.486836 open("/etc/passwd", O_RDONLY|O_CLOEXEC) = 3
09:01:57.486888 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.486934 fstat(3, {st_mode=S_IFREG|0644, st_size=5517, ...}) = 0
09:01:57.486986 mmap(NULL, 5517, PROT_READ, MAP_SHARED, 3, 0) = 0x7f7436f2e000
09:01:57.487033 lseek(3, 5517, SEEK_SET) = 5517
09:01:57.487087 munmap(0x7f7436f2e000, 5517) = 0
09:01:57.487133 close(3)                = 0
09:01:57.487194 open("/etc/shadow", O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
09:01:57.487459 brk(0x2053000)          = 0x2053000
09:01:57.488064 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.488130 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.488207 write(2, "2016-01-26 09:01:57 UTC - _child:  'create' 'POE::Session=ARRAY(0x2032ea0)' 'POE::Component::Client::Keepalive=ARRAY(0x20332c0)'\n", 129) = 129
09:01:57.488600 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.488666 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.488730 write(2, "2016-01-26 09:01:57 UTC - _child:  'create' 'POE::Session=ARRAY(0x2032b70)'\n", 76) = 76
09:01:57.489006 select(8, [4], [], [], {0, 0}) = 0 (Timeout)
09:01:57.489421 select(8, [4], [], [], {0, 0}) = 0 (Timeout)
09:01:57.489507 write(2, "_GET_URL: URL 'https://community.elitedangerous.com/galnet/uid/56a60d089657ba197a730a88'\n", 89) = 89
09:01:57.489737 select(8, [4], [], [], {0, 0}) = 0 (Timeout)
09:01:57.489916 stat("modules/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.489970 stat("modules/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490020 stat("modules/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490087 stat("modules/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490138 stat("/etc/perl/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490188 stat("/etc/perl/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490239 stat("/usr/local/lib/perl/5.14.2/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490291 stat("/usr/local/lib/perl/5.14.2/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490348 stat("/usr/local/share/perl/5.14.2/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490401 stat("/usr/local/share/perl/5.14.2/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490452 stat("/usr/lib/perl5/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490501 stat("/usr/lib/perl5/URI/https.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.490551 stat("/usr/share/perl5/URI/https.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.490604 stat("/usr/share/perl5/URI/https.pm", {st_mode=S_IFREG|0644, st_size=107, ...}) = 0
09:01:57.490664 open("/usr/share/perl5/URI/https.pm", O_RDONLY) = 3
09:01:57.490718 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.490766 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.490826 read(3, "package URI::https;\nrequire URI::http;\n@ISA=qw(URI::http);\n\nsub default_port { 443 }\n\nsub secure { 1 }\n\n1;\n", 8192) = 107
09:01:57.490921 read(3, "", 8192)       = 0
09:01:57.490969 close(3)                = 0
09:01:57.491024 stat("modules/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491074 stat("modules/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491124 stat("modules/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491173 stat("modules/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491222 stat("/etc/perl/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491271 stat("/etc/perl/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491321 stat("/usr/local/lib/perl/5.14.2/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491372 stat("/usr/local/lib/perl/5.14.2/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491422 stat("/usr/local/share/perl/5.14.2/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491473 stat("/usr/local/share/perl/5.14.2/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491523 stat("/usr/lib/perl5/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491572 stat("/usr/lib/perl5/URI/http.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.491622 stat("/usr/share/perl5/URI/http.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.491673 stat("/usr/share/perl5/URI/http.pm", {st_mode=S_IFREG|0644, st_size=405, ...}) = 0
09:01:57.491733 open("/usr/share/perl5/URI/http.pm", O_RDONLY) = 3
09:01:57.491786 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.491835 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.491896 read(3, "package URI::http;\n\nrequire URI::_server;\n@ISA=qw(URI::_server);\n\nuse strict;\n\nsub default_port { 80 }\n\nsub canonical\n{\n    my $self = shift;\n    my $other = $self->SUPER::canonical;\n\n    my $slash_path = defined($other->authority) &&\n        !length($other->path) && !defined($other->query);\n\n    if ($slash_path) {\n\t$other = $other->clone if $other == $self;\n\t$other->path(\"/\");\n    }\n    $other;\n}\n\n1;\n", 8192) = 405
09:01:57.492043 read(3, "", 8192)       = 0
09:01:57.492091 close(3)                = 0
09:01:57.492146 stat("modules/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492195 stat("modules/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492245 stat("modules/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492293 stat("modules/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492342 stat("/etc/perl/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492391 stat("/etc/perl/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492448 stat("/usr/local/lib/perl/5.14.2/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492500 stat("/usr/local/lib/perl/5.14.2/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492550 stat("/usr/local/share/perl/5.14.2/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492601 stat("/usr/local/share/perl/5.14.2/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492651 stat("/usr/lib/perl5/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492700 stat("/usr/lib/perl5/URI/_server.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.492750 stat("/usr/share/perl5/URI/_server.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.492801 stat("/usr/share/perl5/URI/_server.pm", {st_mode=S_IFREG|0644, st_size=3702, ...}) = 0
09:01:57.492859 open("/usr/share/perl5/URI/_server.pm", O_RDONLY) = 3
09:01:57.492911 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.492958 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.493016 read(3, "package URI::_server;\nrequire URI::_generic;\n@ISA=qw(URI::_generic);\n\nuse strict;\nuse URI::Escape qw(uri_unescape);\n\nsub _uric_escape {\n    my($class, $str) = @_;\n    if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\\#]*)(.*)$,os) {\n\tmy($scheme, $host, $rest) = ($1, $2, $3);\n\tmy $ui = $host =~ s/(.*@)// ? $1 : \"\";\n\tmy $port = $host =~ s/(:\\d+)\\z// ? $1 : \"\";\n\tif (_host_escape($host)) {\n\t    $str = \"$scheme//$ui$host$port$rest\";\n\t}\n    }\n    return $class->SUPER::_uric_escape($str);\n}\n\nsub _host_escape {\n    return unless $_[0] =~ /[^URI::uric]/;\n    eval {\n\trequire URI::_idna;\n\t$_[0] = URI::_idna::encode($_[0]);\n    };\n    return 0 if $@;\n    return 1;\n}\n\nsub as_iri {\n    my $self = shift;\n    my $str = $self->SUPER::as_iri;\n    if ($str =~ /\\bxn--/) {\n\tif ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\\#]*)(.*)$,os) {\n\t    my($scheme, $host, $rest) = ($1, $2, $3);\n\t    my $ui = $host =~ s/(.*@)// ? $1 : \"\";\n\t    my $port = $host =~ s/(:\\d+)\\z// ? $1 : \"\";\n\t    require URI::_idna;\n\t    $host = URI::_idna::decode($host);\n\t    $str = \"$scheme//$ui$host$port$rest\";\n\t}\n    }\n    return $str;\n}\n\nsub userinfo\n{\n    my $self = shift;\n    my $old = $self->authority;\n\n    if (@_) {\n\tmy $new = $old;\n\t$new = \"\" unless defined $new;\n\t$new =~ s/.*@//;  # remove old stuff\n\tmy $ui = shift;\n\tif (defined $ui) {\n\t    $ui =~ s/@/%40/g;   # protect @\n\t    $new = \"$ui\\@$new\";\n\t}\n\t$self->authority($new);\n    }\n    return undef if !defined($old) || $old !~ /(.*)@/;\n    return $1;\n}\n\nsub host\n{\n    my $self = shift;\n    my $old = $self->authority;\n    if (@_) {\n\tmy $tmp = $old;\n\t$tmp = \"\" unless defined $tmp;\n\tmy $ui = ($tmp =~ /(.*@)/) ? $1 : \"\";\n\tmy $port = ($tmp =~ /(:\\d+)$/) ? $1 : \"\";\n\tmy $new = shift;\n\t$new = \"\" unless defined $new;\n\tif (length $new) {\n\t    $new =~ s/[@]/%40/g;   # protect @\n\t    if ($new =~ /^[^:]*:\\d*\\z/ || $new =~ /]:\\d*\\z/) {\n\t\t$new =~ s/(:\\d*)\\z// || die \"Assert\";\n\t\t$port = $1;\n\t    }\n\t    $new = \"[$new]\" if $new =~ /:/ && $new !~ /^\\[/; # IPv6 address\n\t    _host_escape($new);\n\t}\n\t$self->authority(\"$ui$new$port\");\n    }\n    return undef unless defined $old;\n    $old =~ s/.*@//;\n    $old =~ s/:\\d+$//;          # remove the port\n    $old =~ s{^\\[(.*)\\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)\n    return uri_unescape($old);\n}\n\nsub ihost\n{\n    my $self = shift;\n    my $old = $self->host(@_);\n    if ($old =~ /(^|\\.)xn--/) {\n\trequire URI::_idna;\n\t$old = URI::_idna::decode($old);\n    }\n    return $old;\n}\n\nsub _port\n{\n    my $self = shift;\n    my $old = $self->authority;\n    if (@_) {\n\tmy $new = $old;\n\t$new =~ s/:\\d*$//;\n\tmy $port = shift;\n\t$new .= \":$port\" if defined $port;\n\t$self->authority($new);\n    }\n    return $1 if defined($old) && $old =~ /:(\\d*)$/;\n    return;\n}\n\nsub port\n{\n    my $self = shift;\n    my $port = $self->_port(@_);\n    $port = $self->default_port if !defined($port) || $port eq \"\";\n    $port;\n}\n\nsub host_port\n{\n    my $self = shift;\n    my $old = $self->authority;\n    $self->host(shift) if @_;\n    return undef unless defined $old;\n    $old =~ s/.*@//;        # zap userinfo\n    $old =~ s/:$//;         # empty port should be treated the same a no port\n    $old .= \":\" . $self->port unless $old =~ /:\\d+$/;\n    $old;\n}\n\n\nsub default_port { undef }\n\nsub canonical\n{\n    my $self = shift;\n    my $other = $self->SUPER::canonical;\n    my $host = $other->host || \"\";\n    my $port = $other->_port;\n    my $uc_host = $host =~ /[A-Z]/;\n    my $def_port = defined($port) && ($port eq \"\" ||\n                                      $port == $self->default_port);\n    if ($uc_host || $def_port) {\n\t$other = $other->clone if $other == $self;\n\t$other->host(lc $host) if $uc_host;\n\t$other->port(undef)    if $def_port;\n    }\n    $other;\n}\n\n1;\n", 8192) = 3702
09:01:57.493476 brk(0x2074000)          = 0x2074000
09:01:57.493972 read(3, "", 8192)       = 0
09:01:57.494021 close(3)                = 0
09:01:57.494093 stat("modules/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494144 stat("modules/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494194 stat("modules/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494242 stat("modules/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494291 stat("/etc/perl/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494340 stat("/etc/perl/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494389 stat("/usr/local/lib/perl/5.14.2/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494439 stat("/usr/local/lib/perl/5.14.2/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494489 stat("/usr/local/share/perl/5.14.2/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494539 stat("/usr/local/share/perl/5.14.2/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494589 stat("/usr/lib/perl5/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494639 stat("/usr/lib/perl5/URI/_generic.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.494688 stat("/usr/share/perl5/URI/_generic.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.494739 stat("/usr/share/perl5/URI/_generic.pm", {st_mode=S_IFREG|0644, st_size=5762, ...}) = 0
09:01:57.494798 open("/usr/share/perl5/URI/_generic.pm", O_RDONLY) = 3
09:01:57.494851 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.494897 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.494956 read(3, "package URI::_generic;\nrequire URI;\nrequire URI::_query;\n@ISA=qw(URI URI::_query);\n\nuse strict;\nuse URI::Escape qw(uri_unescape);\nuse Carp ();\n\nmy $ACHAR = $URI::uric;  $ACHAR =~ s,\\\\[/?],,g;\nmy $PCHAR = $URI::uric;  $PCHAR =~ s,\\\\[?],,g;\n\nsub _no_scheme_ok { 1 }\n\nsub authority\n{\n    my $self = shift;\n    $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\\#]*))?(.*)$,os or die;\n\n    if (@_) {\n\tmy $auth = shift;\n\t$$self = $1;\n\tmy $rest = $3;\n\tif (defined $auth) {\n\t    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;\n\t    utf8::downgrade($auth);\n\t    $$self .= \"//$auth\";\n\t}\n\t_check_path($rest, $$self);\n\t$$self .= $rest;\n    }\n    $2;\n}\n\nsub path\n{\n    my $self = shift;\n    $$self =~ m,^((?:[^:/?\\#]+:)?(?://[^/?\\#]*)?)([^?\\#]*)(.*)$,s or die;\n\n    if (@_) {\n\t$$self = $1;\n\tmy $rest = $3;\n\tmy $new_path = shift;\n\t$new_path = \"\" unless defined $new_path;\n\t$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;\n\tutf8::downgrade($new_path);\n\t_check_path($new_path, $$self);\n\t$$self .= $new_path . $rest;\n    }\n    $2;\n}\n\nsub path_query\n{\n    my $self = shift;\n    $$self =~ m,^((?:[^:/?\\#]+:)?(?://[^/?\\#]*)?)([^\\#]*)(.*)$,s or die;\n\n    if (@_) {\n\t$$self = $1;\n\tmy $rest = $3;\n\tmy $new_path = shift;\n\t$new_path = \"\" unless defined $new_path;\n\t$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;\n\tutf8::downgrade($new_path);\n\t_check_path($new_path, $$self);\n\t$$self .= $new_path . $rest;\n    }\n    $2;\n}\n\nsub _check_path\n{\n    my($path, $pre) = @_;\n    my $prefix;\n    if ($pre =~ m,/,) {  # authority present\n\t$prefix = \"/\" if length($path) && $path !~ m,^[/?\\#],;\n    }\n    else {\n\tif ($path =~ m,^//,) {\n\t    Carp::carp(\"Path starting with double slash is confusing\")\n\t\tif $^W;\n\t}\n\telsif (!length($pre) && $path =~ m,^[^:/?\\#]+:,) {\n\t    Carp::carp(\"Path might look like scheme, './' prepended\")\n\t\tif $^W;\n\t    $prefix = \"./\";\n\t}\n    }\n    substr($_[0], 0, 0) = $prefix if defined $prefix;\n}\n\nsub path_segments\n{\n    my $self = shift;\n    my $path = $self->path;\n    if (@_) {\n\tmy @arg = @_;  # make a copy\n\tfor (@arg) {\n\t    if (ref($_)) {\n\t\tmy @seg = @$_;\n\t\t$seg[0] =~ s/%/%25/g;\n\t\tfor (@seg) { s/;/%3B/g; }\n\t\t$_ = join(\";\", @seg);\n\t    }\n\t    else {\n\t\t s/%/%25/g; s/;/%3B/g;\n\t    }\n\t    s,/,%2F,g;\n\t}\n\t$self->path(join(\"/\", @arg));\n    }\n    return $path unless wantarray;\n    map {/;/ ? $self->_split_segment($_)\n             : uri_unescape($_) }\n        split('/', $path, -1);\n}\n\n\nsub _split_segment\n{\n    my $self = shift;\n    require URI::_segment;\n    URI::_segment->new(@_);\n}\n\n\nsub abs\n{\n    my $self = shift;\n    my $base = shift || Carp::croak(\"Missing base argument\");\n\n    if (my $scheme = $self->scheme) {\n\treturn $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;\n\t$base = URI->new($base) unless ref $base;\n\treturn $self unless $scheme eq $base->scheme;\n    }\n\n    $base = URI->new($base) unless ref $base;\n    my $abs = $self->clone;\n    $abs->scheme($base->scheme);\n    return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;\n    $abs->authority($base->authority);\n\n    my $path = $self->path;\n    return $abs if $path =~ m,^/,;\n\n    if (!length($path)) {\n\tmy $abs = $base->clone;\n\tmy $query = $self->query;\n\t$abs->query($query) if defined $query;\n\t$abs->fragment($self->fragment);\n\treturn $abs;\n    }\n\n    my $p = $base->path;\n    $p =~ s,[^/]+$,,;\n    $p .= $path;\n    my @p = split('/', $p, -1);\n    shift(@p) if @p && !length($p[0]);\n    my $i = 1;\n    while ($i < @p) {\n\t#print \"$i \", join(\"/\", @p), \" ($p[$i])\\n\";\n\tif ($p[$i-1] eq \".\") {\n\t    splice(@p, $i-1, 1);\n\t    $i-- if $i > 1;\n\t}\n\telsif ($p[$i] eq \"..\" && $p[$i-1] ne \"..\") {\n\t    splice(@p, $i-1, 2);\n\t    if ($i > 1) {\n\t\t$i--;\n\t\tpush(@p, \"\") if $i == @p;\n\t    }\n\t}\n\telse {\n\t    $i++;\n\t}\n    }\n    $p[-1] = \"\" if @p && $p[-1] eq \".\";  # trailing \"/.\"\n    if ($URI::ABS_REMOTE_LEADING_DOTS) {\n        shift @p while @p && $p[0] =~ /^\\.\\.?$/;\n    }\n    $abs->path(\"/\" . join(\"/\", @p));\n    $abs;\n}\n\n# The opposite of $url->abs.  Return a URI which is as relative as possible\nsub rel {\n    my $self = shift;\n    my $base = shift || Carp::croak(\"Missing base argument\");\n    my $rel = $self->clone;\n    $base = URI->new($base) unless ref $base;\n\n    #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};\n    my $scheme = $rel->scheme;\n    my $auth   = $rel->canonical->authority;\n    my $path   = $rel->path;\n\n    if (!defined($scheme) && !defined($auth)) {\n\t# it is already relative\n\treturn $rel;\n    }\n\n    #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};\n    my $bscheme = $base->scheme;\n    my $bauth   = $base->canonical->authority;\n    my $bpath   = $base->path;\n\n    for ($bscheme, $bauth, $auth) {\n\t$_ = '' unless defined\n    }\n\n    unless ($scheme eq $bscheme && $auth eq $bauth) {\n\t# different location, can't make it relative\n\treturn $rel;\n    }\n\n    for ($path, $bpath) {  $_ = \"/$_\" unless m,^/,; }\n\n    # Make it relative by eliminating scheme and authority\n    $rel->scheme(undef);\n    $rel->authority(undef);\n\n    # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.\n    # First we calculate common initial path components length ($li).\n    my $li = 1;\n    while (1) {\n\tmy $i = index($path, '/', $li);\n\tlast if $i < 0 ||\n                $i != index($bpath, '/', $li) ||\n\t        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);\n\t$li=$i+1;\n    }\n    # then we nuke it from both paths\n    substr($path, 0,$li) = '';\n    substr($bpath,0,$li) = '';\n\n    if ($path eq $bpath &&\n        defined($rel->fragment) &&\n        !defined($rel->query)) {\n        $rel->path(\"\");\n    }\n    else {\n        # Add one \"../\" for each path component left in the base path\n        $path = ('../' x $bpath =~ tr|/|/|) . $path;\n\t$path = \"./\" if $path eq \"\";\n        $rel->path($path);\n    }\n\n    $rel;\n}\n\n1;\n", 8192) = 5762
09:01:57.495643 brk(0x2095000)          = 0x2095000
09:01:57.496208 read(3, "", 8192)       = 0
09:01:57.496257 close(3)                = 0
09:01:57.496313 stat("modules/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496363 stat("modules/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496412 stat("modules/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496460 stat("modules/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496509 stat("/etc/perl/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496558 stat("/etc/perl/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496607 stat("/usr/local/lib/perl/5.14.2/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496657 stat("/usr/local/lib/perl/5.14.2/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496707 stat("/usr/local/share/perl/5.14.2/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496757 stat("/usr/local/share/perl/5.14.2/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496808 stat("/usr/lib/perl5/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496857 stat("/usr/lib/perl5/URI/_query.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.496906 stat("/usr/share/perl5/URI/_query.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.496959 stat("/usr/share/perl5/URI/_query.pm", {st_mode=S_IFREG|0644, st_size=2451, ...}) = 0
09:01:57.497016 open("/usr/share/perl5/URI/_query.pm", O_RDONLY) = 3
09:01:57.497069 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.497114 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.497173 read(3, "package URI::_query;\n\nuse strict;\nuse URI ();\nuse URI::Escape qw(uri_unescape);\n\nsub query\n{\n    my $self = shift;\n    $$self =~ m,^([^?\\#]*)(?:\\?([^\\#]*))?(.*)$,s or die;\n\n    if (@_) {\n\tmy $q = shift;\n\t$$self = $1;\n\tif (defined $q) {\n\t    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;\n\t    utf8::downgrade($q);\n\t    $$self .= \"?$q\";\n\t}\n\t$$self .= $3;\n    }\n    $2;\n}\n\n# Handle ...?foo=bar&bar=foo type of query\nsub query_form {\n    my $self = shift;\n    my $old = $self->query;\n    if (@_) {\n        # Try to set query string\n        my $delim;\n        my $r = $_[0];\n        if (ref($r) eq \"ARRAY\") {\n            $delim = $_[1];\n            @_ = @$r;\n        }\n        elsif (ref($r) eq \"HASH\") {\n            $delim = $_[1];\n            @_ = %$r;\n        }\n        $delim = pop if @_ % 2;\n\n        my @query;\n        while (my($key,$vals) = splice(@_, 0, 2)) {\n            $key = '' unless defined $key;\n\t    $key =~ s/([;\\/?:@&=+,\\$\\[\\]%])/ URI::Escape::escape_char($1)/eg;\n\t    $key =~ s/ /+/g;\n\t    $vals = [ref($vals) eq \"ARRAY\" ? @$vals : $vals];\n            for my $val (@$vals) {\n                $val = '' unless defined $val;\n\t\t$val =~ s/([;\\/?:@&=+,\\$\\[\\]%])/ URI::Escape::escape_char($1)/eg;\n                $val =~ s/ /+/g;\n                push(@query, \"$key=$val\");\n            }\n        }\n        if (@query) {\n            unless ($delim) {\n                $delim = $1 if $old && $old =~ /([&;])/;\n                $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || \"&\";\n            }\n            $self->query(join($delim, @query));\n        }\n        else {\n            $self->query(undef);\n        }\n    }\n    return if !defined($old) || !length($old) || !defined(wantarray);\n    return unless $old =~ /=/; # not a form\n    map { s/\\+/ /g; uri_unescape($_) }\n         map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);\n}\n\n# Handle ...?dog+bones type of query\nsub query_keywords\n{\n    my $self = shift;\n    my $old = $self->query;\n    if (@_) {\n        # Try to set query string\n\tmy @copy = @_;\n\t@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq \"ARRAY\";\n\tfor (@copy) { s/([;\\/?:@&=+,\\$\\[\\]%])/ URI::Escape::escape_char($1)/eg; }\n\t$self->query(@copy ? join('+', @copy) : undef);\n    }\n    return if !defined($old) || !defined(wantarray);\n    return if $old =~ /=/;  # not keywords, but a form\n    map { uri_unescape($_) } split(/\\+/, $old, -1);\n}\n\n# Some URI::URL compatibility stuff\n*equery = \\&query;\n\n1;\n", 8192) = 2451
09:01:57.497696 brk(0x20b6000)          = 0x20b6000
09:01:57.497822 read(3, "", 8192)       = 0
09:01:57.497870 close(3)                = 0
09:01:57.497992 stat("modules/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498054 stat("modules/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498109 stat("modules/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498158 stat("modules/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498208 stat("/etc/perl/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498256 stat("/etc/perl/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498307 stat("/usr/local/lib/perl/5.14.2/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498359 stat("/usr/local/lib/perl/5.14.2/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498411 stat("/usr/local/share/perl/5.14.2/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498461 stat("/usr/local/share/perl/5.14.2/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498512 stat("/usr/lib/perl5/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498561 stat("/usr/lib/perl5/URI/_idna.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:01:57.498610 stat("/usr/share/perl5/URI/_idna.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:01:57.498661 stat("/usr/share/perl5/URI/_idna.pm", {st_mode=S_IFREG|0644, st_size=2038, ...}) = 0
09:01:57.498719 open("/usr/share/perl5/URI/_idna.pm", O_RDONLY) = 3
09:01:57.498773 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.498819 lseek(3, 0, SEEK_CUR)   = 0
09:01:57.498882 read(3, "package URI::_idna;\n\n# This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)\n# based on Python-2.6.4/Lib/encodings/idna.py\n\nuse strict;\nuse URI::_punycode qw(encode_punycode decode_punycode);\nuse Carp qw(croak);\n\nBEGIN {\n  *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003\n    ? sub () { 1 }\n    : sub () { 0 }\n  ;\n}\n\nmy $ASCII = qr/^[\\x00-\\x7F]*\\z/;\n\nsub encode {\n    my $idomain = shift;\n    my @labels = split(/\\./, $idomain, -1);\n    my @last_empty;\n    push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq \"\";\n    for (@labels) {\n\t$_ = ToASCII($_);\n    }\n\n    return eval 'join(\".\", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;\n    return join(\".\", @labels, @last_empty);\n}\n\nsub decode {\n    my $domain = shift;\n    return join(\".\", map ToUnicode($_), split(/\\./, $domain, -1))\n}\n\nsub nameprep { # XXX real implementation missing\n    my $label = shift;\n    $label = lc($label);\n    return $label;\n}\n\nsub check_size {\n    my $label = shift;\n    croak \"Label empty\" if $label eq \"\";\n    croak \"Label too long\" if length($label) > 63;\n    return $label;\n}\n\nsub ToASCII {\n    my $label = shift;\n    return check_size($label) if $label =~ $ASCII;\n\n    # Step 2: nameprep\n    $label = nameprep($label);\n    # Step 3: UseSTD3ASCIIRules is false\n    # Step 4: try ASCII again\n    return check_size($label) if $label =~ $ASCII;\n\n    # Step 5: Check ACE prefix\n    if ($label =~ /^xn--/) {\n        croak \"Label starts with ACE prefix\";\n    }\n\n    # Step 6: Encode with PUNYCODE\n    $label = encode_punycode($label);\n\n    # Step 7: Prepend ACE prefix\n    $label = \"xn--$label\";\n\n    # Step 8: Check size\n    return check_size($label);\n}\n\nsub ToUnicode {\n    my $label = shift;\n    $label = nameprep($label) unless $label =~ $ASCII;\n    return $label unless $label =~ /^xn--/;\n    my $result = decode_punycode(substr($label, 4));\n    my $label2 = ToASCII($result);\n    if (lc($label) ne $label2) {\n\tcroak \"IDNA does not round-trip: '\\L$label\\E' vs '$label2'\";\n    }\n    return $result;\n}\n\n1;\n", 8192) = 2038
09:01:57.499056 stat("modules/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499108 stat("modules/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499157 stat("modules/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499206 stat("modules/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499255 stat("/etc/perl/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499304 stat("/etc/perl/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499354 stat("/usr/local/lib/perl/5.14.2/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499405 stat("/usr/local/lib/perl/5.14.2/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499456 stat("/usr/local/share/perl/5.14.2/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499506 stat("/usr/local/share/perl/5.14.2/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499557 stat("/usr/lib/perl5/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499606 stat("/usr/lib/perl5/URI/_punycode.pm", 0x7ffe1233c180) = -1 ENOENT (No such file or directory)
09:01:57.499656 stat("/usr/share/perl5/URI/_punycode.pmc", 0x7ffe1233c230) = -1 ENOENT (No such file or directory)
09:01:57.499707 stat("/usr/share/perl5/URI/_punycode.pm", {st_mode=S_IFREG|0644, st_size=4630, ...}) = 0
09:01:57.499767 open("/usr/share/perl5/URI/_punycode.pm", O_RDONLY) = 6
09:01:57.499820 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bf10) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.499870 lseek(6, 0, SEEK_CUR)   = 0
09:01:57.499929 read(6, "package URI::_punycode;\n\nuse strict;\nour $VERSION = \"0.04\";\n\nrequire Exporter;\nour @ISA    = qw(Exporter);\nour @EXPORT = qw(encode_punycode decode_punycode);\n\nuse integer;\n\nour $DEBUG = 0;\n\nuse constant BASE => 36;\nuse constant TMIN => 1;\nuse constant TMAX => 26;\nuse constant SKEW => 38;\nuse constant DAMP => 700;\nuse constant INITIAL_BIAS => 72;\nuse constant INITIAL_N => 128;\n\nmy $Delimiter = chr 0x2D;\nmy $BasicRE   = qr/[\\x00-\\x7f]/;\n\nsub _croak { require Carp; Carp::croak(@_); }\n\nsub digit_value {\n    my $code = shift;\n    return ord($code) - ord(\"A\") if $code =~ /[A-Z]/;\n    return ord($code) - ord(\"a\") if $code =~ /[a-z]/;\n    return ord($code) - ord(\"0\") + 26 if $code =~ /[0-9]/;\n    return;\n}\n\nsub code_point {\n    my $digit = shift;\n    return $digit + ord('a') if 0 <= $digit && $digit <= 25;\n    return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;\n    die 'NOT COME HERE';\n}\n\nsub adapt {\n    my($delta, $numpoints, $firsttime) = @_;\n    $delta = $firsttime ? $delta / DAMP : $delta / 2;\n    $delta += $delta / $numpoints;\n    my $k = 0;\n    while ($delta > ((BASE - TMIN) * TMAX) / 2) {\n\t$delta /= BASE - TMIN;\n\t$k += BASE;\n    }\n    return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));\n}\n\nsub decode_punycode {\n    my $code = shift;\n\n    my $n      = INITIAL_N;\n    my $i      = 0;\n    my $bias   = INITIAL_BIAS;\n    my @output;\n\n    if ($code =~ s/(.*)$Delimiter//o) {\n\tpush @output, map ord, split //, $1;\n\treturn _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;\n    }\n\n    while ($code) {\n\tmy $oldi = $i;\n\tmy $w    = 1;\n    LOOP:\n\tfor (my $k = BASE; 1; $k += BASE) {\n\t    my $cp = substr($code, 0, 1, '');\n\t    my $digit = digit_value($cp);\n\t    defined $digit or return _croak(\"invalid punycode input\");\n\t    $i += $digit * $w;\n\t    my $t = ($k <= $bias) ? TMIN\n\t\t: ($k >= $bias + TMAX) ? TMAX : $k - $bias;\n\t    last LOOP if $digit < $t;\n\t    $w *= (BASE - $t);\n\t}\n\t$bias = adapt($i - $oldi, @output + 1, $oldi == 0);\n\twarn \"bias becomes $bias\" if $DEBUG;\n\t$n += $i / (@output + 1);\n\t$i = $i % (@output + 1);\n\tsplice(@output, $i, 0, $n);\n\twarn join \" \", map sprintf('%04x', $_), @output if $DEBUG;\n\t$i++;\n    }\n    return join '', map chr, @output;\n}\n\nsub encode_punycode {\n    my $input = shift;\n    my @input = split //, $input;\n\n    my $n     = INITIAL_N;\n    my $delta = 0;\n    my $bias  = INITIAL_BIAS;\n\n    my @output;\n    my @basic = grep /$BasicRE/, @input;\n    my $h = my $b = @basic;\n    push @output, @basic;\n    push @output, $Delimiter if $b && $h < @input;\n    warn \"basic codepoints: (@output)\" if $DEBUG;\n\n    while ($h < @input) {\n\tmy $m = min(grep { $_ >= $n } map ord, @input);\n\twarn sprintf \"next code point to insert is %04x\", $m if $DEBUG;\n\t$delta += ($m - $n) * ($h + 1);\n\t$n = $m;\n\tfor my $i (@input) {\n\t    my $c = ord($i);\n\t    $delta++ if $c < $n;\n\t    if ($c == $n) {\n\t\tmy $q = $delta;\n\t    LOOP:\n\t\tfor (my $k = BASE; 1; $k += BASE) {\n\t\t    my $t = ($k <= $bias) ? TMIN :\n\t\t\t($k >= $bias + TMAX) ? TMAX : $k - $bias;\n\t\t    last LOOP if $q < $t;\n\t\t    my $cp = code_point($t + (($q - $t) % (BASE - $t)));\n\t\t    push @output, chr($cp);\n\t\t    $q = ($q - $t) / (BASE - $t);\n\t\t}\n\t\tpush @output, chr(code_point($q));\n\t\t$bias = adapt($delta, $h + 1, $h == $b);\n\t\twarn \"bias becomes $bias\" if $DEBUG;\n\t\t$delta = 0;\n\t\t$h++;\n\t    }\n\t}\n\t$delta++;\n\t$n++;\n    }\n    return join '', @output;\n}\n\nsub min {\n    my $min = shift;\n    for (@_) { $min = $_ if $_ <= $min }\n    return $min;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nURI::_punycode - encodes Unicode string in Punycode\n\n=head1 SYNOPSIS\n\n  use URI::_punycode;\n  $punycode = encode_punycode($unicode);\n  $unicode  = decode_punycode($punycode);\n\n=head1 DESCRIPTION\n\nURI::_punycode is a module to encode / decode Unicode strings into\nPunycode, an efficient encoding of Unicode for use with IDNA.\n\nThis module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode\nstrings.\n\n=head1 FUNCTIONS\n\nThis module exports following functions by default.\n\n=over 4\n\n=item encode_punycode\n\n  $punycode = encode_punycode($unicode);\n\ntakes Unicode string (UTF8-flagged variable) and returns Punycode\nencoding for it.\n\n=item decode_punycode\n\n  $unicode = decode_punycode($punycode)\n\ntakes Punycode encoding and returns original Unicode string.\n\n=back\n\nThese functions throw exceptions on failure. You can catch 'em via\nC<eval>.\n\n=head1 AUTHOR\n\nTatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of\nIDNA::Punycode v0.02 which was the basis for this module.\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=head1 SEE ALSO\n\nL<IDNA::Punycode>, RFC 3492\n\n=cut\n", 8192) = 4630
09:01:57.500919 lseek(6, 3467, SEEK_SET) = 3467
09:01:57.500968 lseek(6, 0, SEEK_CUR)   = 3467
09:01:57.501014 close(6)                = 0
09:01:57.501387 read(3, "", 8192)       = 0
09:01:57.501437 close(3)                = 0
09:01:57.501610 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.501676 stat("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3661, ...}) = 0
09:01:57.501741 write(2, "2016-01-26 09:01:57 UTC - _GET_GENERIC: 'https://community.elitedangerous.com/galnet/uid/56a60d089657ba197a730a88'\n", 115) = 115
09:01:57.501934 select(8, [4], [], [], {0, 0}) = 0 (Timeout)
09:01:57.502571 pipe([3, 6])            = 0
09:01:57.502633 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.502682 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.502729 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.502794 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.502843 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.502888 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.502964 pipe([7, 8])            = 0
09:01:57.503017 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503064 lseek(7, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.503111 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503157 lseek(8, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.503203 fcntl(7, F_SETFD, FD_CLOEXEC) = 0
09:01:57.503248 fcntl(8, F_SETFD, FD_CLOEXEC) = 0
09:01:57.503312 pipe([9, 10])           = 0
09:01:57.503363 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503409 lseek(9, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.503456 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503502 lseek(10, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.503548 fcntl(9, F_SETFD, FD_CLOEXEC) = 0
09:01:57.503592 fcntl(10, F_SETFD, FD_CLOEXEC) = 0
09:01:57.503657 pipe([11, 12])          = 0
09:01:57.503708 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503755 lseek(11, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.503801 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.503851 lseek(12, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.503897 fcntl(11, F_SETFD, FD_CLOEXEC) = 0
09:01:57.503941 fcntl(12, F_SETFD, FD_CLOEXEC) = 0
09:01:57.504010 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.504081 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5503
09:01:57.504828 close(11)               = 0
09:01:57.504884 close(8)                = 0
09:01:57.504933 close(10)               = 0
09:01:57.505115 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.505206 close(6)                = 0
09:01:57.505285 brk(0x20d8000)          = 0x20d8000
09:01:57.505339 read(3, "go\n", 8192)   = 3
09:01:57.512206 close(3)                = 0
09:01:57.512426 fcntl(12, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.512474 fcntl(12, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.512643 fcntl(7, F_GETFL)       = 0 (flags O_RDONLY)
09:01:57.512689 fcntl(7, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.512794 fcntl(9, F_GETFL)       = 0 (flags O_RDONLY)
09:01:57.512849 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.513093 pipe([3, 6])            = 0
09:01:57.513152 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.513195 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.513228 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.513275 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.513328 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.513361 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.513524 pipe([8, 10])           = 0
09:01:57.513560 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.513604 lseek(8, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.513655 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.513694 lseek(10, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.513727 fcntl(8, F_SETFD, FD_CLOEXEC) = 0
09:01:57.513763 fcntl(10, F_SETFD, FD_CLOEXEC) = 0
09:01:57.513834 pipe([11, 13])          = 0
09:01:57.513964 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.514006 lseek(11, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.514067 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.514113 lseek(13, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.514157 fcntl(11, F_SETFD, FD_CLOEXEC) = 0
09:01:57.514193 fcntl(13, F_SETFD, FD_CLOEXEC) = 0
09:01:57.514266 pipe([14, 15])          = 0
09:01:57.514387 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.514429 lseek(14, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.514475 ioctl(15, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.514508 lseek(15, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.514542 fcntl(14, F_SETFD, FD_CLOEXEC) = 0
09:01:57.514575 fcntl(15, F_SETFD, FD_CLOEXEC) = 0
09:01:57.514692 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.514756 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5504
09:01:57.515141 close(14)               = 0
09:01:57.515297 close(10)               = 0
09:01:57.515369 close(13)               = 0
09:01:57.515494 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.515600 close(6)                = 0
09:01:57.515668 read(3, "go\n", 8192)   = 3
09:01:57.521641 close(3)                = 0
09:01:57.521830 fcntl(15, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.521876 fcntl(15, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.522091 fcntl(8, F_GETFL)       = 0 (flags O_RDONLY)
09:01:57.522129 fcntl(8, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.522212 fcntl(11, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.522261 fcntl(11, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.522470 pipe([3, 6])            = 0
09:01:57.523151 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.523698 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.523741 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.523775 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.523809 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.523855 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.523930 pipe([10, 13])          = 0
09:01:57.523976 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.524106 lseek(10, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.524155 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.524227 lseek(13, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.524262 fcntl(10, F_SETFD, FD_CLOEXEC) = 0
09:01:57.524311 fcntl(13, F_SETFD, FD_CLOEXEC) = 0
09:01:57.524700 pipe([14, 16])          = 0
09:01:57.524742 ioctl(14, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.524776 lseek(14, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.524977 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.525016 lseek(16, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.525055 fcntl(14, F_SETFD, FD_CLOEXEC) = 0
09:01:57.525098 fcntl(16, F_SETFD, FD_CLOEXEC) = 0
09:01:57.525175 pipe([17, 18])          = 0
09:01:57.525235 ioctl(17, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.525282 lseek(17, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.525422 ioctl(18, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.525470 lseek(18, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.525512 fcntl(17, F_SETFD, FD_CLOEXEC) = 0
09:01:57.525550 fcntl(18, F_SETFD, FD_CLOEXEC) = 0
09:01:57.525612 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.525687 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5505
09:01:57.526140 close(17)               = 0
09:01:57.526191 close(13)               = 0
09:01:57.526330 close(16)               = 0
09:01:57.526477 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.526713 close(6)                = 0
09:01:57.527541 read(3, "go\n", 8192)   = 3
09:01:57.534560 close(3)                = 0
09:01:57.534864 fcntl(18, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.535661 fcntl(18, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.536132 fcntl(10, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.536277 fcntl(10, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.536781 fcntl(14, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.537191 fcntl(14, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.537451 pipe([3, 6])            = 0
09:01:57.537563 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.537597 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.537632 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.537703 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.540370 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.544258 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.544351 pipe([13, 16])          = 0
09:01:57.544417 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.544454 lseek(13, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.544517 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.544619 lseek(16, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.544789 fcntl(13, F_SETFD, FD_CLOEXEC) = 0
09:01:57.545269 fcntl(16, F_SETFD, FD_CLOEXEC) = 0
09:01:57.576766 pipe([17, 19])          = 0
09:01:57.576858 ioctl(17, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.576928 lseek(17, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.576989 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.577062 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.577103 fcntl(17, F_SETFD, FD_CLOEXEC) = 0
09:01:57.577163 fcntl(19, F_SETFD, FD_CLOEXEC) = 0
09:01:57.577240 pipe([20, 21])          = 0
09:01:57.577284 ioctl(20, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.577317 lseek(20, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.577357 ioctl(21, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.577416 lseek(21, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.577909 fcntl(20, F_SETFD, FD_CLOEXEC) = 0
09:01:57.578229 fcntl(21, F_SETFD, FD_CLOEXEC) = 0
09:01:57.578295 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.578393 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5506
09:01:57.578969 close(20)               = 0
09:01:57.579021 close(16)               = 0
09:01:57.579053 close(19)               = 0
09:01:57.579251 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.579368 close(6)                = 0
09:01:57.579563 read(3, "go\n", 8192)   = 3
09:01:57.587488 close(3)                = 0
09:01:57.587705 fcntl(21, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.587892 fcntl(21, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.588043 fcntl(13, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.588089 fcntl(13, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.588193 fcntl(17, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.588329 fcntl(17, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.588590 pipe([3, 6])            = 0
09:01:57.589004 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.589037 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.589072 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.589135 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.589169 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.589204 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.589316 pipe([16, 19])          = 0
09:01:57.589579 ioctl(16, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.589746 lseek(16, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.589811 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.589848 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.589883 fcntl(16, F_SETFD, FD_CLOEXEC) = 0
09:01:57.589918 fcntl(19, F_SETFD, FD_CLOEXEC) = 0
09:01:57.590086 pipe([20, 22])          = 0
09:01:57.590133 ioctl(20, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.590170 lseek(20, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.590204 ioctl(22, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.590237 lseek(22, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.590621 fcntl(20, F_SETFD, FD_CLOEXEC) = 0
09:01:57.590657 fcntl(22, F_SETFD, FD_CLOEXEC) = 0
09:01:57.590721 pipe([23, 24])          = 0
09:01:57.590773 ioctl(23, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.591234 lseek(23, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.591356 ioctl(24, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.591397 lseek(24, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.591432 fcntl(23, F_SETFD, FD_CLOEXEC) = 0
09:01:57.591556 fcntl(24, F_SETFD, FD_CLOEXEC) = 0
09:01:57.591624 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.592067 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5507
09:01:57.593089 close(23)               = 0
09:01:57.595407 close(19)               = 0
09:01:57.595453 close(22)               = 0
09:01:57.595905 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.596151 close(6)                = 0
09:01:57.596380 read(3, "go\n", 8192)   = 3
09:01:57.602095 close(3)                = 0
09:01:57.603028 fcntl(24, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.603477 fcntl(24, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.654404 fcntl(16, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.654450 fcntl(16, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.654573 fcntl(20, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.654620 fcntl(20, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.654917 pipe([3, 6])            = 0
09:01:57.654975 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655027 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.655073 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655114 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.655153 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655183 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655434 pipe([19, 22])          = 0
09:01:57.655463 ioctl(19, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655484 lseek(19, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.655512 ioctl(22, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655533 lseek(22, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.655552 fcntl(19, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655570 fcntl(22, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655614 pipe([23, 25])          = 0
09:01:57.655642 ioctl(23, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655675 lseek(23, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.655717 ioctl(25, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.655745 lseek(25, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.655788 fcntl(23, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655835 fcntl(25, F_SETFD, FD_CLOEXEC) = 0
09:01:57.655912 pipe([26, 27])          = 0
09:01:57.655965 ioctl(26, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.656007 lseek(26, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.656051 ioctl(27, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.656094 lseek(27, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.656137 fcntl(26, F_SETFD, FD_CLOEXEC) = 0
09:01:57.656178 fcntl(27, F_SETFD, FD_CLOEXEC) = 0
09:01:57.656256 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.656324 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5508
09:01:57.657042 close(26)               = 0
09:01:57.657102 close(22)               = 0
09:01:57.657147 close(25)               = 0
09:01:57.657341 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.657417 close(6)                = 0
09:01:57.657822 read(3, "go\n", 8192)   = 3
09:01:57.663953 close(3)                = 0
09:01:57.664375 fcntl(27, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.664408 fcntl(27, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.664591 fcntl(19, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.664631 fcntl(19, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.664726 fcntl(23, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.664754 fcntl(23, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.664967 pipe([3, 6])            = 0
09:01:57.665106 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.665176 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.665409 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.665506 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.665726 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.665793 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.665874 pipe([22, 25])          = 0
09:01:57.665922 ioctl(22, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.665960 lseek(22, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.666004 ioctl(25, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.666061 lseek(25, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.666101 fcntl(22, F_SETFD, FD_CLOEXEC) = 0
09:01:57.666233 fcntl(25, F_SETFD, FD_CLOEXEC) = 0
09:01:57.666310 pipe([26, 28])          = 0
09:01:57.666356 ioctl(26, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.666397 lseek(26, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.666426 ioctl(28, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.666465 lseek(28, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.666507 fcntl(26, F_SETFD, FD_CLOEXEC) = 0
09:01:57.666541 fcntl(28, F_SETFD, FD_CLOEXEC) = 0
09:01:57.666606 pipe([29, 30])          = 0
09:01:57.666739 ioctl(29, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.666823 lseek(29, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.667238 ioctl(30, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.667282 lseek(30, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.667324 fcntl(29, F_SETFD, FD_CLOEXEC) = 0
09:01:57.667365 fcntl(30, F_SETFD, FD_CLOEXEC) = 0
09:01:57.667625 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.667704 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5509
09:01:57.668564 close(29)               = 0
09:01:57.668643 close(25)               = 0
09:01:57.669377 close(28)               = 0
09:01:57.669963 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.670050 close(6)                = 0
09:01:57.670283 read(3, "go\n", 8192)   = 3
09:01:57.678502 close(3)                = 0
09:01:57.678985 fcntl(30, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.679119 fcntl(30, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.680599 fcntl(22, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.680764 fcntl(22, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.681463 fcntl(26, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.681820 fcntl(26, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.683241 pipe([3, 6])            = 0
09:01:57.727293 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.727377 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.727805 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.727834 lseek(6, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.727857 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.727875 fcntl(6, F_SETFD, FD_CLOEXEC) = 0
09:01:57.727961 pipe([25, 28])          = 0
09:01:57.728009 ioctl(25, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.728048 lseek(25, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.728077 ioctl(28, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.728097 lseek(28, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.728116 fcntl(25, F_SETFD, FD_CLOEXEC) = 0
09:01:57.728149 fcntl(28, F_SETFD, FD_CLOEXEC) = 0
09:01:57.728330 pipe([29, 31])          = 0
09:01:57.728408 ioctl(29, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.728453 lseek(29, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.728498 ioctl(31, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.728926 lseek(31, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.728970 fcntl(29, F_SETFD, FD_CLOEXEC) = 0
09:01:57.729009 fcntl(31, F_SETFD, FD_CLOEXEC) = 0
09:01:57.729079 pipe([32, 33])          = 0
09:01:57.729120 ioctl(32, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.729441 lseek(32, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.729471 ioctl(33, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.729492 lseek(33, 0, SEEK_CUR)  = -1 ESPIPE (Illegal seek)
09:01:57.729511 fcntl(32, F_SETFD, FD_CLOEXEC) = 0
09:01:57.729529 fcntl(33, F_SETFD, FD_CLOEXEC) = 0
09:01:57.729574 rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0
09:01:57.729616 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7436f1b9d0) = 5510
09:01:57.730392 close(32)               = 0
09:01:57.730426 close(28)               = 0
09:01:57.730448 close(31)               = 0
09:01:57.730666 rt_sigprocmask(SIG_SETMASK, [], ~[KILL STOP RTMIN RT_1], 8) = 0
09:01:57.730751 close(6)                = 0
09:01:57.731926 read(3, "go\n", 8192)   = 3
09:01:57.738381 close(3)                = 0
09:01:57.738641 fcntl(33, F_GETFL)      = 0x1 (flags O_WRONLY)
09:01:57.738731 fcntl(33, F_SETFL, O_WRONLY|O_NONBLOCK) = 0
09:01:57.738906 fcntl(25, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.738953 fcntl(25, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.739059 fcntl(29, F_GETFL)      = 0 (flags O_RDONLY)
09:01:57.739095 fcntl(29, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
09:01:57.739265 brk(0x20f9000)          = 0x20f9000
09:01:57.739634 select(40, [4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [33], [], {0, 0}) = 1 (out [33], left {0, 0})
09:01:57.739881 write(33, "64\0\5\t\2\0\0\0\4\10\201\n\34community.elitedangerous.com\n\003443\4\3\0\0\0\1\10\206\0\0\0\10protocol", 67) = 67
09:01:57.740018 wait4(-1, 0x7ffe1233c9ac, WNOHANG, NULL) = 0
09:01:57.740259 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:01:57.740514 rt_sigaction(SIGCHLD, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:01:57.740622 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:01:57.740837 select(40, [4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {179, 761658}) = 1 (in [25], left {179, 553719})
09:01:57.949068 read(25, "189\0\5\t\2\0\0\0\3\10\201\n\0\4\2\0\0\0\2\4\3\0\0\0\5\10\206\0\0\0\10protocol\5\0\0\0\tcanonname\n\20\2\0\1\2734\36\210,\0\0\0\0\0\0\0\0\0\0\0\4addr\10\201\0\0\0\10socktype\10\202\0\0\0\6family\4\3\0\0\0\5\10\206\0\0\0\10protocol\5\0\0\0\tcanonname\n\20\2\0\1\2734\36\313~\0\0\0\0\0\0\0\0\0\0\0\4addr\10\201\0\0\0\10socktype\10\202\0\0\0\6family", 65536) = 193
09:01:57.949893 select(40, [4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {0, 0}) = 0 (Timeout)
09:01:57.950106 select(40, [4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {0, 0}) = 0 (Timeout)
09:01:57.950268 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
09:01:57.950303 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.950356 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.950398 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c720) = -1 ENOTTY (Inappropriate ioctl for device)
09:01:57.950436 lseek(3, 0, SEEK_CUR)   = -1 ESPIPE (Illegal seek)
09:01:57.950473 fcntl(3, F_SETFD, FD_CLOEXEC) = 0
09:01:57.950543 fcntl(3, F_GETFL)       = 0x2 (flags O_RDWR)
09:01:57.950582 fcntl(3, F_SETFL, O_RDWR|O_NONBLOCK) = 0
09:01:57.950664 connect(3, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("52.30.136.44")}, 16) = -1 EINPROGRESS (Operation now in progress)
09:01:57.950914 fcntl(3, F_GETFL)       = 0x802 (flags O_RDWR|O_NONBLOCK)
09:01:57.951108 select(40, [4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 998474}) = 1 (out [3], left {14, 985131})
09:01:57.964719 getsockopt(3, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
09:01:57.964783 getpeername(3, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("52.30.136.44")}, [16]) = 0
09:01:57.964903 fcntl(3, F_GETFL)       = 0x802 (flags O_RDWR|O_NONBLOCK)
09:01:57.965163 open("/dev/urandom", O_RDONLY|O_NOCTTY|O_NONBLOCK) = 6
09:01:57.965221 fstat(6, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0
09:01:57.965268 poll([{fd=6, events=POLLIN}], 1, 10) = 1 ([{fd=6, revents=POLLIN}])
09:01:57.965311 read(6, "\211\242\356\357\3610\20\342\210\230\361\37\343m\312\267\323J\330g><\235V\264\267\226\230M^\265\31", 32) = 32
09:01:57.965361 close(6)                = 0
09:01:57.965413 getuid()                = 1000
09:01:57.965597 brk(0x211c000)          = 0x211c000
09:01:57.965694 write(3, "\26\3\1\1#\1\0\1\37\3\3V\2476\5\315\357C\275\205\27`\342\3\276p7\234T\265\211A\215\335F\356\345r\6\272d\311\217\0\0\210\3000\300,\300(\300$\300\24\300\n\0\243\0\237\0k\0j\0009\0008\0\210\0\207\3002\300.\300*\300&\300\17\300\5\0\235\0=\0005\0\204\300\22\300\10\0\26\0\23\300\r\300\3\0\n\300/\300+\300'\300#\300\23\300\t\0\242\0\236\0g\0@\0003\0002\0\232\0\231\0E\0D\3001\300-\300)\300%\300\16\300\4\0\234\0<\0/\0\226\0A\300\21\300\7\300\f\300\2\0\5\0\4\0\25\0\22\0\t\0\377\2\1\0\0m\0\v\0\4\3\0\1\2\0\n\0004\0002\0\16\0\r\0\31\0\v\0\f\0\30\0\t\0\n\0\26\0\27\0\10\0\6\0\7\0\24\0\25\0\4\0\5\0\22\0\23\0\1\0\2\0\3\0\17\0\20\0\21\0#\0\0\0\r\0 \0\36\6\1\6\2\6\3\5\1\5\2\5\3\4\1\4\2\4\3\3\1\3\2\3\3\2\1\2\2\2\3\0\17\0\1\1", 296) = 296
09:01:57.965853 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.966671 getpeername(3, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("52.30.136.44")}, [16]) = 0
09:01:57.967146 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 982436}) = 1 (out [3], left {14, 982432})
09:01:57.967313 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.967501 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.967595 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 981983}) = 1 (out [3], left {14, 981979})
09:01:57.967726 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.967790 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.967885 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 981695}) = 1 (out [3], left {14, 981691})
09:01:57.968011 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968074 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968155 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 981423}) = 1 (out [3], left {14, 981419})
09:01:57.968275 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968337 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968416 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 981162}) = 1 (out [3], left {14, 981158})
09:01:57.968534 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968595 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968673 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 980904}) = 1 (out [3], left {14, 980900})
09:01:57.968792 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968853 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.968930 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 980647}) = 1 (out [3], left {14, 980643})
09:01:57.969048 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969108 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969204 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 980373}) = 1 (out [3], left {14, 980369})
09:01:57.969324 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969386 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969464 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 980113}) = 1 (out [3], left {14, 980109})
09:01:57.969581 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969642 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969732 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 979846}) = 1 (out [3], left {14, 979842})
09:01:57.969850 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969910 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.969988 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 979589}) = 1 (out [3], left {14, 979585})
09:01:57.970120 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970159 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970208 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 979365}) = 1 (out [3], left {14, 979362})
09:01:57.970281 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970339 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970417 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 979160}) = 1 (out [3], left {14, 979156})
09:01:57.970533 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970594 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970671 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 978906}) = 1 (out [3], left {14, 978902})
09:01:57.970797 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970859 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.970936 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 978641}) = 1 (out [3], left {14, 978637})
09:01:57.971052 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971113 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971191 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 978386}) = 1 (out [3], left {14, 978382})
09:01:57.971307 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971368 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971445 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 978132}) = 1 (out [3], left {14, 978128})
09:01:57.971561 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971622 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971699 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 977878}) = 1 (out [3], left {14, 977874})
09:01:57.971815 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971894 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.971974 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 977603}) = 1 (out [3], left {14, 977599})
09:01:57.972091 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972151 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972229 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 977348}) = 1 (out [3], left {14, 977344})
09:01:57.972345 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972406 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972483 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 977094}) = 1 (out [3], left {14, 977090})
09:01:57.972598 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972659 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972736 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 976841}) = 1 (out [3], left {14, 976837})
09:01:57.972852 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972912 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.972990 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 976587}) = 1 (out [3], left {14, 976583})
09:01:57.973105 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973184 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973264 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 976313}) = 1 (out [3], left {14, 976309})
09:01:57.973381 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973442 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973519 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 976058}) = 1 (out [3], left {14, 976054})
09:01:57.973636 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973727 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973803 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 975775}) = 1 (out [3], left {14, 975771})
09:01:57.973915 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.973973 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974082 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 975505}) = 1 (out [3], left {14, 975502})
09:01:57.974158 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974203 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974252 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 975321}) = 1 (out [3], left {14, 975318})
09:01:57.974349 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974407 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974481 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 975095}) = 1 (out [3], left {14, 975092})
09:01:57.974602 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974658 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974743 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 974834}) = 1 (out [3], left {14, 974830})
09:01:57.974855 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974913 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.974987 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 974589}) = 1 (out [3], left {14, 974585})
09:01:57.975099 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975159 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975233 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 974343}) = 1 (out [3], left {14, 974339})
09:01:57.975346 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975405 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975478 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 974098}) = 1 (out [3], left {14, 974094})
09:01:57.975589 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975647 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975722 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 973855}) = 1 (out [3], left {14, 973851})
09:01:57.975836 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975907 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.975983 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 973594}) = 1 (out [3], left {14, 973590})
09:01:57.976096 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976154 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976229 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 973348}) = 1 (out [3], left {14, 973344})
09:01:57.976340 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976398 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976472 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 973104}) = 1 (out [3], left {14, 973100})
09:01:57.976584 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976642 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976717 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 972860}) = 1 (out [3], left {14, 972856})
09:01:57.976828 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976886 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.976960 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 972616}) = 1 (out [3], left {14, 972612})
09:01:57.977072 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977137 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977222 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 972355}) = 1 (out [3], left {14, 972351})
09:01:57.977335 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977393 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977477 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 972100}) = 1 (out [3], left {14, 972096})
09:01:57.977589 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977655 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977733 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 971844}) = 1 (out [3], left {14, 971840})
09:01:57.977845 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977903 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.977977 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 971599}) = 1 (out [3], left {14, 971595})
09:01:57.978108 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978148 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978197 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 971375}) = 1 (out [3], left {14, 971372})
09:01:57.978270 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978325 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978399 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 971177}) = 1 (out [3], left {14, 971173})
09:01:57.978542 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978602 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978676 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 970901}) = 1 (out [3], left {14, 970897})
09:01:57.978788 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978847 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.978920 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 970656}) = 1 (out [3], left {14, 970652})
09:01:57.979031 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979089 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979163 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 970413}) = 1 (out [3], left {14, 970409})
09:01:57.979274 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979333 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979407 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 970170}) = 1 (out [3], left {14, 970166})
09:01:57.979518 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979576 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979650 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 969927}) = 1 (out [3], left {14, 969923})
09:01:57.979761 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979820 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.979914 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 969663}) = 1 (out [3], left {14, 969659})
09:01:57.980028 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980087 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980160 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 969416}) = 1 (out [3], left {14, 969412})
09:01:57.980272 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980330 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980404 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 969172}) = 1 (out [3], left {14, 969168})
09:01:57.980515 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980574 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980647 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 968930}) = 1 (out [3], left {14, 968924})
09:01:57.980794 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980855 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.980930 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 968647}) = 1 (out [3], left {14, 968643})
09:01:57.981042 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981100 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981191 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 968387}) = 1 (out [3], left {14, 968383})
09:01:57.981306 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981364 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981439 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 968137}) = 1 (out [3], left {14, 968133})
09:01:57.981551 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981609 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981692 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 967885}) = 1 (out [3], left {14, 967881})
09:01:57.981830 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.981924 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982023 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 967555}) = 1 (out [3], left {14, 967552})
09:01:57.982188 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982236 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982294 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 967280}) = 1 (out [3], left {14, 967276})
09:01:57.982445 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982510 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982594 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 966984}) = 1 (out [3], left {14, 966980})
09:01:57.982720 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982784 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.982867 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 966711}) = 1 (out [3], left {14, 966707})
09:01:57.982990 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983053 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983135 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 966443}) = 1 (out [3], left {14, 966439})
09:01:57.983257 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983321 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983402 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 966175}) = 1 (out [3], left {14, 966171})
09:01:57.983525 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983589 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983670 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 965909}) = 1 (out [3], left {14, 965905})
09:01:57.983792 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983875 read(3, 0x20f3130, 7)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.983961 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 965612}) = 2 (in [3], out [3], left {14, 965609})
09:01:57.984054 read(3, "\26\3\3\0B\2\0", 7) = 7
09:01:57.984116 read(3, "\0>\3\3\231\f\36\263\5\326\310\215\231x3s<\213\273o9\37\223\261\v\260^\310fG\352O8*\316\21\0\3000\0\0\26\377\1\0\1\0\0\v\0\4\3\0\1\2\0#\0\0\0\17\0\1\1", 64) = 64
09:01:57.984169 read(3, "\26\3\3\t\352", 5) = 5
09:01:57.984212 read(3, "\v\0\t\346\0\t\343\0\5p0\202\5l0\202\4T\240\3\2\1\2\2\22\21!\372\215\303\242\324\317\234/\210\263\37\212j\300\227E0\r\6\t*\206H\206\367\r\1\1\v\5\0000f1\v0\t\6\3U\4\6\23\2BE1\0310\27\6\3U\4\n\23\20GlobalSign nv-sa1<0:\6\3U\4\3\0233GlobalSign Organization Validation CA - SHA256 - G20\36\27\r140721142519Z\27\r170721142519Z0\201\2131\v0\t\6\3U\4\6\23\2GB1\0270\25\6\3U\4\10\f\16Cambridgeshire1\0220\20\6\3U\4\7\f\tCambridge1\v0\t\6\3U\4\v\f\2IT1#0!\6\3U\4\n\f\32Frontier Developments Plc.1\0350\33\6\3U\4\3\f\24*.elitedangerous.com0\202\1\"0\r\6\t*\206H\206\367\r\1\1\1\5\0\3\202\1\17\0000\202\1\n\2\202\1\1\0\323\1V\250K?EP\311h\226\351\265\214}\317\344\234$\223\310\246\346\334\217\30716\306=\331Y\200\373)\201\350\301vP\332\303j\233\306\304\10$(\262\2064\353\324N\331`C\302\310\251\354\5\203G*\202\17\335)#\327\335o\321\352(H\262]C\205&yn\374\353GK\334>\246\0\273\312\10\213,\344\377\200\334\242\343J\217\253\34\240\302g\227\\w\214$Q(IEk\243\367B\r\r\363\230\220\231/Z\243\252\223M-\323G7\330<\33\373\360\224]&Z\277-\340\327\0350\240\225\347H\337\23T\257\264\221\361`\355\241\333L\333\367\32\16S\261\206\324\33/\301|\34\1\350\314\341\216FE\317K3\201H\307\34a\365\20\226\340\370O\17T\204ve\213$\230\373\360\364\240\\\220\231\3118W\325\230O\203\35;\300\301\356\202k;g\247\5\276[\225\214\267\377)\3373\300\17\224\220\245\17P\315g\2\3\1\0\1\243\202\1\3540\202\1\3500\16\6\3U\35\17\1\1\377\4\4\3\2\5\2400I\6\3U\35 \4B0@0>\6\6g\201\f\1\2\0020402\6\10+\6\1\5\5\7\2\1\26&https://www.globalsign.com/repository/03\6\3U\35\21\4,0*\202\24*.elitedangerous.com\202\22elitedangerous.com0\t\6\3U\35\23\4\0020\0000\35\6\3U\35%\4\0260\24\6\10+\6\1\5\5\7\3\1\6\10+\6\1\5\5\7\3\0020I\6\3U\35\37\4B0@0>\240<\240:\2068http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl0\201\240\6\10+\6\1\5\5\7\1\1\4\201\2230\201\2200M\6\10+\6\1\5\5\0070\2\206Ahttp://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt0?\6\10+\6\1\5\5\0070\1\2063http://ocsp2.globalsign.com/gsorganizationvalsha2g20\35\6\3U\35\16\4\26\4\0241p\347~ \23\336\273x\22{\335?\372\220\241v\300\327\0210\37\6\3U\35#\4\0300\26\200\24\226\336a\361\275\34\26)S\34\300\314};\203\0@\346\32|0\r\6\t*\206H\206\367\r\1\1\v\5\0\3\202\1\1\0\35]\213\275\33fm\354_\247_`\254\316\346w+\347\337\360\24\325j\333\235\220\310]@\226@\301Q\271\267[J\273(\376\32\22Plu\200\231\330\323V=0\10RP\341\272\206)\264\230\337\355\2 \375\202\366\310t\254\365\227\6G\22\260xM\374Q\372\207e\225\354,\201M\236,j\311\313;W\324;\220\364\374\310\2\234\345\275\314\214\177\253\27\300RD\361\326\200\337\3?y\t\362\211\31)\"\340w\37\262\216|\305\262\330\233a\23\203\37v\240\367x\17\202\245\n\371w\353\244\36#\0330\261\322@S\231\311\227#\265*\214~R<\27\300J\36\211\t\n\353\255B}d\346\223N\227+<\254\343b\267\21~<\301\266@\346\217$+\225[3Ue\315\240B\310N\35\370\330\235\21)\333\312\311\233\201\10\10\3727\23\312y\251+\207\270\3\215\20\370\277\222\37\343\33\257&+\306'\253hR\371\354\224\321\0\4m0\202\4i0\202\3Q\240\3\2\1\2\2\v\4\0\0\0\0\1DN\360BG0\r\6\t*\206H\206\367\r\1\1\v\5\0000W1\v0\t\6\3U\4\6\23\2BE1\0310\27\6\3U\4\n\23\20GlobalSign nv-sa1\0200\16\6\3U\4\v\23\7Root CA1\0330\31\6\3U\4\3\23\22GlobalSign Root CA0\36\27\r140220100000Z\27\r240220100000Z0f1\v0\t\6\3U\4\6\23\2BE1\0310\27\6\3U\4\n\23\20GlobalSign nv-sa1<0:\6\3U\4\3\0233GlobalSign Organization Validation CA - SHA256 - G20\202\1\"0\r\6\t*\206H\206\367\r\1\1\1\5\0\3\202\1\17\0000\202\1\n\2\202\1\1\0\307\16l?#\223\177\314p\245\235 \303\16S?~\300N\302\230I\312G\325#\357\0034\205t\310\243\2.F\\\v}\311\210\235O\213\360\370\234l\214U5\333\277\362\263\352\373\343V\347JF\331\23\"\3126\325\233\301\250\343\226C\223\362\f\274\346\371\346\350\231\310cHx\177W6i\32\31\35Z\321\324}\302\234\324\177\341\200\22\256z\352\210\352W\330\312\n\n:\22I\242b\31z\r$\3677\353\264s\222{\5#\233\22\265\316\353)\337\244\24\2\271\1\245\324\246\234Cd\210\336\370~\376\343\365\36\345\376\334\243\250\344f1\331L%\351\30\271\211Y\t\256\351\235\34m7\17J\0365 (\342\257\324!\213\1\304E\255n+c\253\222ka\nM \355s\272|\316\376\26\265\333\237\200\360\326\213l\331\10yJOxe\332\222\274\2765\371\263\304\371'\200N\377\226R\346\2 \341\7s\351]+\275\262\361\2\3\1\0\1\243\202\1%0\202\1!0\16\6\3U\35\17\1\1\377\4\4\3\2\1\0060\22\6\3U\35\23\1\1\377\4\0100\6\1\1\377\2\1\0000\35\6\3U\35\16\4\26\4\24\226\336a\361\275\34\26)S\34\300\314};\203\0@\346\32|0G\6\3U\35 \4@0>0<\6\4U\35 \0000402\6\10+\6\1\5\5\7\2\1\26&https://www.globalsign.com/repository/03\6\3U\35\37\4,0*0(\240&\240$\206\"http://crl.globalsign.net/root.crl0=\6\10+\6\1\5\5\7\1\1\00410/0-\6\10+\6\1\5\5\0070\1\206!http://ocsp.globalsign.com/rootr10\37\6\3U\35#\4\0300\26\200\24`{f\32E\r\227\312\211P/}\4\3154\250\377\374\375K0\r\6\t*\206H\206\367\r\1\1\v\5\0\3\202\1\1\0F*\356^\275\256\1`71\21\206qt\266FI\310\20\26\376/b#\27\253\37\207\370\202\355\312\337\16,\337du\216\345\30r\247\214:\213\311\254\245wP\367\357\236\244\340\240\217\24W\243*_\354~m\20\346\272\215\260\10\207v\16L\262\331Q\273\21\2\362\\\335\34\275\363U\226\17\324\6\300\374\342#\212$p\323\273\360y\32\247ap\203\212\257\6\305 \330\241c\320l\256O2\327\256|\30Eu\5)w\337B@dd\206\276*v\t1o\35$\364\231\320\205\376\362!\10\371\306\366\361\320Y\355\326V<\10(\3g\272\360\371\361\220\26G\256g\346\274\200H\351Bv4\227Ui$\16\203\326\240-\264\365\363y\212I(t\32A\241\302\323$\21050`\224\27\264\341\4\"1=;/\27\6\262\270\235\206+Zi\357\203\365K\304\252\264*\370|\241\261\205\224\214\364\f\207\f\364\254@\370YI\230", 2538) = 2538
09:01:57.985002 read(3, "\26\3\3\1M", 5) = 5
09:01:57.985052 read(3, "\f\0\1I\3\0\27A\4\0\21H\234\245A\207\376k\22w\323=\26RMX\272\214\213b\312\3\324\363z\301\220\250\10\317\312\333\2400\203\f\306\355\rg\2\202\350\\\366\3015.\303y\334Ex1hWnz%s\210'\312\6\1\1\0\317\310\233\342K\247\34\222\225\317\224\200\344D\213\300CDy\362\357\24'\2137%@\202\310\6\307\266@\2708_\f\220cs\303\351\200=\216\10\325A\301k\336\265\30\7\202P#P\r\357\335\33s\3\311\342&\233\352\244\36\2135j \201\302D\344L\250I\322\231}9\305*o\v\25\235\1'\25\277\370,\216\227\272\312.\221\215\343\354jq'%\325z(\2165\36\315\32t\26\220O\217m]\341|J\203Et\6\6\261\227\310\27\230\377\243\357\242v\331\236\223g\275\363\256\254P\324\345`\17#\345gE\212\31!t\267&\24\3523\362\347\347\367\274\247L\374\320D\370\1\206\363TY\320p\246Q8C\24CwU\353vzccV\207\3\275\257\372\34&i\364\35\\\250qH\361@\234\223-\301\254\373{\30\266\241\302\32Y\2078\346\361\3114\1\224\253\336\6`xf\3222\0202(\20\312\314>VF", 333) = 333
09:01:57.985419 read(3, "\26\3\3\0\4", 5) = 5
09:01:57.985463 read(3, "\16\0\0\0", 4) = 4
09:01:57.986172 write(3, "\26\3\3\0F\20\0\0BA\4\374 \313\321!W\33\257\366\202\371\\\265K5jK\276\222\207\376\272K\36N\351R\337N\"\304\220\200\221&\263\332\326\254\253\346o\250\204\313f\276\352@Wu\310R\10\20OH\212\245O\311B\33\260\24\3\3\0\1\1\26\3\3\0(\246\245\260Lk\247\307\365\306h)\2M\232u:E\364\222\377\244\224\330?\361V\336\317\270\211\375\306\20\371)F\3730\260\332", 126) = 126
09:01:57.986244 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986297 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986413 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986454 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986538 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 963041}) = 1 (out [3], left {14, 963037})
09:01:57.986671 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986737 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.986820 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 962758}) = 1 (out [3], left {14, 962754})
09:01:57.986947 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987013 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987095 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 962482}) = 1 (out [3], left {14, 962478})
09:01:57.987220 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987285 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987368 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 962210}) = 1 (out [3], left {14, 962206})
09:01:57.987504 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987571 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987654 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 961924}) = 1 (out [3], left {14, 961920})
09:01:57.987779 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987855 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.987948 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 961630}) = 1 (out [3], left {14, 961626})
09:01:57.988075 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988140 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988221 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 961357}) = 1 (out [3], left {14, 961353})
09:01:57.988345 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988410 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988492 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 961086}) = 1 (out [3], left {14, 961082})
09:01:57.988615 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988679 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988761 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 960817}) = 1 (out [3], left {14, 960813})
09:01:57.988884 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.988949 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989031 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 960547}) = 1 (out [3], left {14, 960543})
09:01:57.989154 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989219 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989301 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 960277}) = 1 (out [3], left {14, 960273})
09:01:57.989424 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989489 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989571 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 960007}) = 1 (out [3], left {14, 960003})
09:01:57.989706 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989747 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989799 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 959774}) = 1 (out [3], left {14, 959771})
09:01:57.989876 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.989951 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990049 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 959545}) = 1 (out [3], left {14, 959542})
09:01:57.990143 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990182 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990231 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 959342}) = 1 (out [3], left {14, 959340})
09:01:57.990317 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990383 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990464 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 959114}) = 1 (out [3], left {14, 959110})
09:01:57.990587 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990651 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990732 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 958846}) = 1 (out [3], left {14, 958842})
09:01:57.990854 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.990933 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991016 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 958562}) = 1 (out [3], left {14, 958558})
09:01:57.991138 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991203 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991284 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 958294}) = 1 (out [3], left {14, 958290})
09:01:57.991406 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991470 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991552 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 958026}) = 1 (out [3], left {14, 958022})
09:01:57.991673 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991738 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.991819 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 957759}) = 1 (out [3], left {14, 957754})
09:01:57.991965 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992031 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992112 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 957465}) = 1 (out [3], left {14, 957461})
09:01:57.992235 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992299 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992381 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 957197}) = 1 (out [3], left {14, 957193})
09:01:57.992503 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992567 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992648 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 956930}) = 1 (out [3], left {14, 956926})
09:01:57.992771 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992835 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.992917 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 956661}) = 1 (out [3], left {14, 956657})
09:01:57.993038 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993103 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993184 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 956394}) = 1 (out [3], left {14, 956390})
09:01:57.993306 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993371 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993452 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 956126}) = 1 (out [3], left {14, 956122})
09:01:57.993573 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993638 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993733 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 955845}) = 1 (out [3], left {14, 955841})
09:01:57.993856 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.993920 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994002 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 955576}) = 1 (out [3], left {14, 955572})
09:01:57.994125 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994164 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994212 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 955361}) = 1 (out [3], left {14, 955359})
09:01:57.994285 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994337 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994429 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 955150}) = 1 (out [3], left {14, 955146})
09:01:57.994552 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994617 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994698 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 954880}) = 1 (out [3], left {14, 954876})
09:01:57.994820 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994885 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.994965 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 954613}) = 1 (out [3], left {14, 954609})
09:01:57.995087 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995152 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995233 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 954345}) = 1 (out [3], left {14, 954341})
09:01:57.995355 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995419 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995501 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 954077}) = 1 (out [3], left {14, 954073})
09:01:57.995623 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995687 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995768 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 953809}) = 1 (out [3], left {14, 953805})
09:01:57.995905 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.995972 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996054 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 953524}) = 1 (out [3], left {14, 953520})
09:01:57.996178 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996242 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996324 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 953254}) = 1 (out [3], left {14, 953250})
09:01:57.996446 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996511 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996592 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 952986}) = 1 (out [3], left {14, 952982})
09:01:57.996714 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996778 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.996859 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 952719}) = 1 (out [3], left {14, 952715})
09:01:57.996981 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997045 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997126 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 952452}) = 1 (out [3], left {14, 952448})
09:01:57.997247 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997312 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997393 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 952185}) = 1 (out [3], left {14, 952181})
09:01:57.997515 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997580 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997672 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 951907}) = 1 (out [3], left {14, 951904})
09:01:57.997776 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997822 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.997880 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 951694}) = 1 (out [3], left {14, 951691})
09:01:57.997974 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998020 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998099 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 951474}) = 1 (out [3], left {14, 951471})
09:01:57.998172 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998211 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998259 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 951313}) = 1 (out [3], left {14, 951310})
09:01:57.998350 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998396 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998454 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 951120}) = 1 (out [3], left {14, 951116})
09:01:57.998572 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998612 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998662 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 950911}) = 1 (out [3], left {14, 950908})
09:01:57.998749 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998795 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998853 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 950721}) = 1 (out [3], left {14, 950718})
09:01:57.998939 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.998986 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999043 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 950531}) = 1 (out [3], left {14, 950528})
09:01:57.999130 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999176 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999234 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 950340}) = 1 (out [3], left {14, 950337})
09:01:57.999320 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999366 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999424 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 950150}) = 1 (out [3], left {14, 950147})
09:01:57.999510 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999556 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999614 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 949960}) = 1 (out [3], left {14, 949957})
09:01:57.999700 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999746 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999804 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 949770}) = 1 (out [3], left {14, 949766})
09:01:57.999905 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:57.999951 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000009 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 949565}) = 1 (out [3], left {14, 949562})
09:01:58.000096 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000142 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000200 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 949374}) = 1 (out [3], left {14, 949371})
09:01:58.000287 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000333 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000390 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 949184}) = 1 (out [3], left {14, 949181})
09:01:58.000485 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000531 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000589 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 948985}) = 1 (out [3], left {14, 948982})
09:01:58.000676 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000722 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000779 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 948795}) = 1 (out [3], left {14, 948792})
09:01:58.000866 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000911 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.000969 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 948605}) = 1 (out [3], left {14, 948602})
09:01:58.001056 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.001102 read(3, 0x20f3133, 5)   = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.001160 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [3], [], {14, 948414}) = 1 (out [3], left {14, 948411})
09:01:58.001259 read(3, "\26\3\3\0\272", 5) = 5
09:01:58.001294 read(3, "\4\0\0\266\0\0\1,\0\260\341\340\36y\246b\231\343\223!NQ\327\"\303\200\323\330\316q\272DB|\201\324\225\204FO\263\243d\331L\273T\340\220\222b9\355|\334\270H_\16\216\27\252(n\377]v\4tg\342\227\346^\20\362h\255\205\343\256\220\243\263\225\305\246\247\332\340a6\10\237*\205.\221S*\31:\200\200\272\235\211\333\337\334\266\22y\36M\336Qk\220%\213\345\325\326\325)\26\311o\361\302dh2\222\215\317\241\253\251\207eM\210J\326\262\33\306\231Ya%$\26bY\366\201*\334\356\5{QV\324\257b,\263\332\4\234\10\31\26p\275\347,\203%[\214\250", 186) = 186
09:01:58.001361 read(3, "\24\3\3\0\1", 5) = 5
09:01:58.001390 read(3, "\1", 1)        = 1
09:01:58.001444 read(3, "\26\3\3\0(", 5) = 5
09:01:58.001474 read(3, "I\331+\236!&\370\245\220}\314\364c\342=\231\r\26\366\234yB\34R\\k\261\5\341\202\230t\251=\tT3\7\t\331", 40) = 40
09:01:58.001558 write(3, "\27\3\3\0\353\246\245\260Lk\247\307\366\23@\213\37\337#\3\227*#\"\362Wu\226\10\347\246\343\35\30\311\314p\276\260\346\257\10\337\342\340&H\365\211\27\2\207\314\300rl\247a\273\215\352l\332\303\253\211\272\216\212\20\314\2104\4d\311\24\305\332\2=x\352\7\333\241r\275z\355u\10\251\201\4\r\246& =8\243)\231c\224\310qA\336\310>\223\321\1\203\324\4\357l1\317a\n3X\337\200q0bBi\306\177\366\26\216\350\31R+O\241\r!\312\\\335\321H\301\212\235\326\310\236\32T\275\4\355\32?W)`~\4WR\n\306\300\365\24@\265\225\376\345\0\303b\10$k\221\26\335\17\267\341\335\t\267S\321\35T\\FR\10\331\374\233Db\217w\321\f\347\\-.\222\31\320\266~\325\342z\330y\236\"Q\340\3005?\330\22\335\3017\336", 240) = 240
09:01:58.001753 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 947822}) = 1 (in [3], left {14, 926097})
09:01:58.023601 read(3, "\27\3\3@\30", 5) = 5
09:01:58.023641 read(3, "I\331+\236!&\370\246\363\316\341/\314\265\233+\21\276\267\352\205,=\224\355\302\242\316t\4\1\331\0314\1\353\2\232\36\334\375\\\213U\253\332\310\210\6\v\322@7\363\255m\245\335\376\347\363\277\371\323\nCi6\225\245)\207\277\234\271\200RB\342\f?,\4s\225\357i\230\373\272\321\364\35\232\374]vL%\307\275s@.\315\303\256\354\377;NEl\347~c\315=\342#!7\253\271h\237f\300uT5u\306D\235\36\246\\\34\3437C\274ri%\20\17m+\234\202\21\367\200\4>\261\360\333\364\233\232\316c\2662\314il\346\343\342\365~-\234W\361\311\322\336u\242Z\217\301tB\365L(\353z^\243S>\6\276\372\204\370\247\341\302\26'J_(\274\23\333,\200\335>Y\234e\303>\32\272\16\33 \270\0267W\177j*\307\275\25\203TD\241P\305\242D\325\36\267\26\270\310\355\351+\24\330\2443\214\314\0051\r\0W%\t\25M\276\307Ss\255:\364\237d\345H\34\10`\313u\0171\262/g\261J\22\250\3141\304Pv\367\242\22a\352\373\355_'\215\240\30H\261\242_\355\215Y6\374/Rwl\264_f\346T\32\327\221\235\0024\232\231\255X\371\355\223\26\221\\\313\211I4U\343t\377\347\n\323\376y\347\237\352\255\302E\4\243\2\315\214\211~\353\235\375\321\"\23\204\212w\344\366\364XR\33\335#\27\356\367o\370\0^\265\250\337\305J?\277)p\300\211\317\314\23\365\304\2643\273\303\277qV\265\7\375\346\342$\365\275\21\n}\214\366\351\336R\267\364n\231{\370\223\261\206#!\5\227[\273\226w;\0213\263\323\256+\211\0011\341F'\324\23\306=\203|\267;\33\320R\260\271\341|rO\375'\217\374\241\316\375^sR\246\37\203\214\366\203[G\225|\222\0051\nC\274\306\225\351\276\267\r\177\325\301\204M\223\274\276\250\25\320\36\237\322\23\343~\261\24I{\4^\253\22\255A\342\235\202\275\371\230 '\323<\273\301b=\361\276\303\311\345\264\2416\5v\346T\335\256K\324\346e\273\224?\244\377\34\337*:\366\211\232\344\377\216z\207\25l\202\370\315j\346\232)|V\206\25\275\234-\332-\367*y\207X\377-\337\202=\252\301\346\364#\244\355\334\20o\1h\315\327D[\322rB\275zq\301\306\365%c`\33-\217\267\360\361#\250y\265\346\337\20\2724\26s\275\f~~K@\2473\264\23\2153\37\1x\3418\304-\326\342\365\27\200\277\236k;`\230\215N\336y\262\265\17$\324\247a\363\32\31\273\223\363s\230\261Ggw>0\220\336\2\310o\254a+\222\376\267H\354\240\336\276\216\220\22\251:\31[8(,x\211/i[l\10\343\207\233\336O7\250\343l\355\364\31\241;SJR]\273<\317\316>e\330\305s\330\304>\221v\223\230\311O\271X\212\376\341\32\313\374r\360Ms\241O\314F\300\321\241ofA\0\213\300g\36\224@E@)|+5\3210\330\363d\207\366\26\245\344CU/K\351uCY\373\325\222\223\303OD\365\327\221\345\326\"\223n\354B\340\232\2444q\5\333\222\236\357\317\22\373\320\177\5\332\301G>\230\232\317\21\311\242}\6\276\0050\177\250\21\5\322'\17\235}i\n\231.n\334&\351\316b\302PR\312\22!?q\274H*\307\277*\31\234\0107\25\251\310\3037B\323\31$<\272\247U\243\334\250a\22\306\314{\251\274\213\331\222\vX\353\246}\34)\242\222-m\262\304\224\346H:\214\357\375\270\340\252\322`\272\327NZ\33\341\236\3569\325\317_\21\230\334xz\371\220\207\346\321\217u\v\22\5n\271\243\327\27\267\320+6,\3700I\300<\220\271!\344\325i\204\0077`\t\234\221\226J-\23Xz\32[\326\240\270\3029\223m\372\r\275&3\235\372L\307\35@h\10\352\271\277\312V\305)S\\\233\177\321\320\272\301{\v\5\6\271\271\366\244\213\207\270\216\225\250\272E\351\274\234V\246\237\240\266\324I>TO\256\375\365\254\6\254S\274%h#\26\303\342\253\340\275\36\201`\364\333\364\10\342[\310h\320\326\0|\20\211\325\1x\275\375L\247\237<\6\2719;*\223B\23i\227\0066GlW\236\265\361\34\333\343zkl\2~\352xg\362\354\312\303\257\233\277\351[>\367\342\"\n{\256ZH\225ra/K\231\23\21\17'\357\tPI\236 \3(jT\361z\204F\267@gv\271\34\244\344\6\232\273lQ\344\212\201\374\311\211t\374\0cS\242!\235t\331[\211\32\255\356N\33r2\250\356\37C\236\2067\22\220\367\246}\364\261\351\307\261\234\202G\223\373'\\\322\325D<7#\325PK\354\3729\341\357(\354\213\366 wB\237m\233g\364\206\243C\225+\216\221\366\32\316\17\264\244\211_4o[\245*\2642<N\31\240\213\257n\305-\376\344\370\227\3\224)8$P\356\310\17\321\0021\270\306\303\354\357D[\223\370\255\371\236\260\275\315\244\33\305\rd\347^\23q\313\276\277\233\335\216\20\356\246\233\0z\361\333\306\31\272fDR/\243\337cK\32\32z\255\272\0\304\202\31 \271\324\340\263\303\325\313I\322_g\350\322\323\307\206\215\243S\245%\177l\vY\314\233\"\311\216\370\221\350\243U\334\335\10\263\16\331\360.\306F\301\207\360b\\<\300[\1\355T\244\240\264\244\227\1\306\211\326\255.r\332p{9&i2\25\305\n\321\272\302Q[5\210\245n\35l\366\332\200\326\316!5\21\247k7H5W\347\37\270V\234\356\26FO\357%\1\231\326\213\2671p\213[[\231\27\246\337\313]\3354\267\312\247\26\321\356]{\234\376\202\275\215\246A\3&\f\306\212*\241\263\316\253\316\34\320i\250%\31\3332\315\7\344\22U\206\340lv5\342q[\333![\365\225\\q\3360\204R]\314\275{\310\261V \24\4\37B\233\337at\301v?\346\364\27\207\262\262\355\217\331\303<%\261\323\221\262T\265\276\351\354OV~\331\332AA\334\2019\207\375\200s\371\240\311\266t\212j\324v\237UN\256\3159tUn\360\\\343'8\35\351^\233\4\320W\351\4\235\261l\330\310\300\263\253\227g7\257\212\372\306\3539\316\333\303\320\30\213c4\2550T\r\263\270\264\27\301\314\365\21\1\374\303a\373\313t\226\21\302\361~\212\36Oe_G\223\f\36\376\341\224\10\2a\212\341l\317\235;\"\24\"\tKt4\372\211B5|o\370#9\21\222!\331\27x\317\207\306\246s\343\2`\205h}\256\17\"\17\361\246r//\r\204\356\376\237t+\3013\7\2I\3204\255q\331k\262\360\3bxB0\366>\177.\207>.\204\nm\37I\273\t\2032?w\333/\tH\210\354\36(\357\36\207\325@\7\330\253\v\n\350&\213 \t\27\350\362\272\264\215D:>\331\255\245\366=\315)\235m-\347V\343/\327\237u\357\340\220\333\207\341\3678\24\237\255\320.D\t\321\250\266&\21\262\301<\2562\352\313O\242j!\300\217,9e\325\252\r\24\373\244\310\240\177\367\271~Q:\267#3Q\205\376QQ\364\".\17}\366\307\257ro\336EI\227?9:T&\336a\36\233\365\366\266\306\363wy[\267\275\306v\213\272\4;:b&I\16v\276eK\277m\3\335\220\r\327\250i\1770!Ld\310\343\215\205\332\33\220\3477\\\t\203\342\5\273\304\345\324\347 \334\205\275^\226\272T+\311\277`J\253\243C\315L\253\7k\366\376U\254\36\30\223\263\207\273\24\341|q\201\353\360\32\6~C\371\315\177\314\365?\342N\307\235\23\223\36&\f\32:-\2574\360\265\177[\226\202\353z\361\306kl\3376\230\205\231\336F\2749r7\312\224H\2142\205\367\272u\230\362]\224\261_\306\355\6i\n\3246J\242\tHm~\322M\225\vS\3235\257/11GQ\265\10\247\233U\256\327`\r\263\"\316n\374aI\34f\244>?g\344\216\322\32\352\10j\263\267\177J\324v<\2517N\221\342\17\233\345\254_\211\340\216\351\357DSC\243\2031t\377\220g}\354\2707\6*\266\250\340\2166d_T\10\375\35\270~\16f\273\377\357/\303\365\355\214\337\36\33-\232\314\213\337\"\f\342\372\343\312-a\21\264\6am\250\235\255\222\307\236yx\225E3\272*0e\204a!o\343\345\226\17f\205\206\16\334Y>\26\3334\353\276\311\7\256\356\217\301\25Y\370U\362%\n\211\250\250A\302\214\213v\272\374\334\357\332\352\266\360\t\vX8\264w\357\4\346\306\33y\225\6e\346W{\rz\261JYB\266\263\204\372\2457\30\271\252S\374s\300S\373\16\35d\32>\353tX\324\303\255l4\306\354o\235\23;o\313\305\f\333u\v\207_\2432\16\270@\224\234jb\37\244C\357)\345*\301\240rI\226A\226 ~\4\271\276\202(P\210\2\234\236\262\254\213\31T\34\253;\243\216\267\277\25\1\6\6a[`V\271!\33q\247\26\307\272#\235\311\372o\225\346n\30\332\f#U*N6\365bbD\334K\305\324\361\22\317\177\3\31>(\331\363\346\213\37\354\361p\227\244x\347\223\331CS\205\177>q\257S\315\210\27\0\231\4\263,\263\243\261\232xh\2376\373\306\202\233\263\t\35.q\7_\207Io<\376 \276Hf)\215\263'`%U\206\217\340\321\247\3634\2\226\27|PD\206\204\226\336\347\222\"bh\335\310<\313\351~4\34V\4\225+A\375\353\314\351/i\26\313[\304\375H\332]\371=\27\316\351\17\6\2010\254\27$\277UW\320\4\207!KS\344W\346\343WG\240b\272\231\17\367$!\242\322$\2568\243hM\240\272\17\316\204\355\347\177\377u\374\351,m\273n\f7\252\245\311iC\203:P6cs\243\356W\242\301\31\344\337\222\254d\247\23\272\\\\\253\376\323\206\225ST\352\314\36\36\363\223\317\326\357Z(\3362\274\314\227_K1k\230\f*\323\373\256c\206\327\v\204\272\311\377\275\234\355od\366\276\231\3643\302\5\3439~<\23\17NW\222w\277\322I?\330\321\16\244\315a\216YH\324\242\305\27\214Uz\372\33\22ff{f\253\273o\237\224G\363A\264\215%a0*\177\\D\252(}g\324\225\217\250\2413\246\36\0163@\314=\255sf4^\34\31\367\327q\344V\325\325(\6\27\224\275\217V\355\341\177\365\213\332\257\205\236<Wh\26\177\354\325<\317\377\2073\251Oaj>FqYqX\353\374\350Jy\366Y\177\30/\201\5\231?\rC\1\376(n#C_\331\202\222\33W\365\272\316\10\17I\342\264\22\7\tE\247\226\220Hp\321n\372\315\301\200\3\21_\v(\327a\347\245\243'\225U\16\344\204\357.G\260\6\323\311\246\316o\27\227N\211\371%\242\202tB\305\226\231\312Xr\333\245;}!\206\211\242c_\340c[\316\226\262i\212\23\336V6\205\7e\3>W\367[\252\377\202A.h{\363\36d&|\266N\21\215\340WnV\231\215\275_S+e\342\2\311\250\355\30*8\21\307\272\372]\0107\243\234v\251'{B\376\320/:0\21qp\364\2176>\202\4-\2671w?\210\20IO\3119\211s#n\220\276\210\37\355\317b\206\r\321\344\217\272\333G\253E\216\374\227\31\304b\370\356\6\0/li,\235\37\371[\346L@\353\202\230^\335\265'ri\243\r\2544\352\216\31\365\230Y\210z+\307\262\372\222\304\340\265\30\2444'\246\327J\372\363\0?K:5\217\346\216{Tr\322\342U\310\323\331\313j\257gWJ\347\246S\n\263n:\310jRy\341\360%2d\350S\0\307\205\253\30NA^\31&eO\206j\1\207\306/\347\311\272\203\240\2152J\217\217\252\343\320>e\273\346g\370\227b\214!\0264hua\\\f\222h`\370\212R\24$\177<\205\236\322\302!\"&\300\345|\20\334\311\256U*G:QGq\265C\337\273\250Y\336H\272\341\200\274#.\271S\7\32\300\331)1\23e\24\200\331\344r|p\10\251x\20\352\374\23`\16\302\3713\10\261\345@\311\"\262&\23\275,S\23\350\361\352B6<`2\3F\333\277hn\211\311s\0\342Ue\201\355\217+a\177;\313'\\3A\362icWr\311\247\207\373`o\236\255\214\270\366\216\3\34\272\233\226<\367\243\5p\3076|x\354V\30\326\216\301\5T\334\31\276\242N\25\30O\313\361\23369\2214\266\20\7}8:\312\304\376\354\274\334\0E\303*\332\6\330_\30H5P\201N\354>\366\"Gr\350\376\25{8\247#[\205\345g8u\0043\300\347\376\305C\223\312\370oD\362p\272\300\27\371\223G&\360A\363\257\214\234\"\242> \312\246\377\204\233\227T\220\5\346\246r7\304\334\222Tb\20\247\331\262\206\3402\366\333L\3568\35\211\10\215~a\213F\255\275\345\36}4n\363\241D\332~\212`|\25\216\6\303]\371\t\334\347\334\303~dk!7\342\277\331\235|\223\221B\370W\316\367\371\367v\376\304\323\315r\31\336R5hP8;<-\252@e\211\221\244j\7I*8i\341~\304\363\207,\213d\216\375\367`>\215\357\353\7.g\30zx\321\332\376v4\240F\227<\30]\203\335\27|C\345\341\237\200\347\343e\305\0\320\306\270\35<rn\3551\271\223\n\213Z%e\10\256w\3566\2560f\371\260\240\265\314\252P\351d\0270u\334p\340\376\342,\34\230c \255\301\33jm\343\252_h\20`Y\16\"\22\322\215\"\200\1\201\240~4\333\v\253\260\2054U\313J\22\234\313\320\332\353\0\325\17\3\27y\30\2!\333\253H\345s[\244\362\235\320t\324\376\243\324w;V\217\"\234\0256\346\370\227A/\241\300\266mp\340\213\251\272\5\227\241\310\0322&?\302\325'O\360\35\307\366\220\253\306\341\335\356\316\231\344\365\333\24&\222+7\222)Sb\210\327H\1\30\331Z\341qO\377S\270Y\226,AQ\367\205\236A\274.q\351P\326\363\262(\\]\356P\251e\371\v\223\323\373\213[\215\223k\342\35\226\255V\330\361Z\213\211\2729\236\210\306\331\2203Wb\235\262\222\261\0u<\2313\3445\367\247[\203\336g\342\256b\226 `\347#\305A7#\300U\1777\177\227\374\262g\3\306A\337\331\264\205\267L\1\333S\332T\27\250\35Do\222\22\vg\323\324\33x \0240\217\230 \246+I\317P\263\34\24\265\v\306\10:\207\336\236p2W\364_\34\351#\2\235D\361\223\336S~\10\376\305\21h\17\207\211\360xW\f\213\27\n\0105\31\313\1\233{z\316\267u\223\331G\275\315a\20\211\377\364\203~\364\35\200V\36.\365\261)\236\353\244(\241\360\240J\261\341\225\310\22! \310\257DM\2203\247\f\201\306z\336\221yF\333;\10\2\256\205S\337\247\263\2049\350\301u\245{39.\250Cr@\3221\230$\264\273u\207\\w\337\316\247\37\331\262y\200\207\246(\"\367wl\21\350Q%qv\3771\0\326a>\254\244h\207\324\10\2:1y\371\302\337\320\261h\210>\254LZkO\276?\36\241\366\3561\240cD\305\317\256vB\317p\254L\336\371}\f\2114nx\305\247\210~\347\225\377\251H\3\2012J\240(g+#\367\352\374\215c\340\322\n,\304\314J6\f=\342\325\264`q\374kPE\306?\207\34\rJi)\32X=^B\332\222 H\321\376KU\354k\36\rs\237\250\na\255\330\r\23\256\216\311\0163\25\230\27A\0329\207\361J\231\7=\242\213\225\304\222-\217\347\224%l\323\310,e\270\255\325p\275b\205\247d\10!u%;\2305\204\231j\3532Q4\265\204X\35\352\372!h \307\304\36\fV'\323QO\252 \20\266\335\211|\236\216J\273L\255Oa*M\374\273\360\222\212Fq4\r\357\243\374v\333_Fv\211J\357\325[\30\t\200\370\254\256wY\223\356\321\306c\320\v\262\205jo\\{\220\363\340\214m\200\3446\"\216\337]O]\23\275)\26+\v=P\377\257\233\326\3\256\273X\362\n.\221\257\300V\7\251\r\"mC\33\315\252\2\233S;s\227\252\336\226\300\36\340\313 \352\324\310g\216\4\241\356\336@)\234s\24U\323\253\25\376\257\20E\211\253 S$\271R\302[@\333\"\0\323\17\302\207\310\323\226\34\353\340v\26?\327lU'\36\273\26A\374\223\271R\341\333\\M\221R\311\323\245\177O\37\217\27\323,kY-\3\324\311\21\300O7\374\t\332\370\203\222(\374\236\250\311T\253x\357E\331\3\306\371\247\323j\2665\234\340u\221\0\10\245\3\225\307\216\247\262+\3054#\377\324\245\267\251,]\272l\364Em\262\320<@\336\22\26\177w\367\223\352V\235\32\2714\355\350\213\243\n\362\350a\33\354\216i0\v\37\"\260\253\366\204\26\201\3< \366p_\305\250a\257\212\337\340R\24\226\372E\270H*a\234{\344\227\364\n4\227\303$x\277g\10y\213\317\326\352\343\347\327\220\322I*g\233\354Pd\372n\316\311p\237\332\20\316\0\375\f8^\331\\\211\362{\222\273l\204L\316mx\246\254\206ol>&\36\332g\302\205\305\224d\337w\203{@\37kh\321\24\343\361\261\204|\343\301\207\331<\336\227\27.8\25\252%-|\354\315Kg]9uoT\345\335\2170\302\215\364%wRo\233*\201\1\205U=\tJ&/\27\256\317\330\216\3123%i\332]O\360=@\374\26\267\354\263r\vx\236\25\356\274\327\271XM\336\10Y,\210T\205t\331\212I2\207\375(\330\35\354x\3131.\361\323g\327KC\r\320-\24\201\36\371-U\22>x\317K\371\274\247\272V\177E\344Jo$\351Sv\33\352A\260\f4\235\367>\241l\312T\333f\356/fW\302C\233\304\354P\277v\3 (\335\341\230\3339\3570@\20\341\344\3545{\375\347\225U\234{\246\2010\275\237\367\224\202X\304\334\227\367z/\372d\4\375.q\246Pc}]\360\330r\366\33\26\333:,/\273\304\334@7\323~Uu\245\201#H3\277\316\272\303\211\270\34\325\305l\370\202\362\315\204\221\235\5\22\333\260x\362R\266@t\356&\225\213\v\312y\362\245\22\212\314C\254f\3\24\225\241@\355f\273C\3027\352\307\355\34\327DC\221z#\316\250\341\30\327+oQaHN\7\241\32$e6\24\367B\36\262lM\351\253=\334v\366\2635V\27\231\242\251\213\352S\221){\273\345\3;\210\213!|x,\372\220\24\3257\345\325hQ\276L\311\222\330\352\236\35\326\346\365\1L\226\214\217/\37i\220\17\357\33\232\322\332PK\7\3\350\r\356\204F\313\252\30\t\202]}BRYoE\256\205\300iV\352\2\362\205\347M?\315\254\344\267\277\24\324\200\f\264@x\31\272\203\375\313:\222\360\330?\250\360X\333\276Uf'.\236\340\265t4\205\242\351S\203\262\320\260\362\v\252\355@\350J\352!\311\25\262n\203\17\24C-\231\222\312\221\325\202:\337kN\351\212\232\1\355\274\312\360\21p\201G\357\20\355R\365g\314\335\255\306\255[\261\233\230e\247\344\310p\27\337B\315\37U\32\10^\276\221\367\"'UaC}\326\325c5l\372\262\322\361FJ\1q#\361\276h\33\7g\302\2*t\254\254\31T\230\347\257\247\364\365\1}x\216\364\232W\344\22\345(\344<$<\261\204q1\334x\365c\222\261\25\16r\220\257\3556R7\30\346~\22\n\350\274\360w\346\6\316US\273\312\336\236B\344\2671\244\266]\311K\332\325/\362\220m$\323&\6\3677\322\225D\273Dg\350\321\7\267\215\347\277\214b\206I\245\6\315\2\v}\33\315\275\303\334\361l\321\336\217`\362\3\263@\332@]\352]\t5\366\331FD\0C\247\320\351'\322\310\375?\260\246\315\372\25\242WCv%\34r$\"\327\4\7\37\326S\233^\305{T\3~+\r\257b\205`\326}\323f\310\233\n\6\234\320%u~\342\202W'Y\16\r\204\223\264XE\31\r7%\375\36\37\265\376*\222a?^D\2579\26\246{\245\10\263\226:\346\370\257\5\353\v\210\334\354\23\34F\300\227T:\6\276\206_i\374\354\306\35P]#kV\363+\201\216d\343\203/\243\334\207\7\241\v\17\17\320xM|\334\v\272W\271s$\251\327\365U\371\211\200\17\354c\225\361h\245\227\2002\275K:\6O4\256\\\260\205\224\334\263\241P\17g\207\207\367j\362\374\37\257\16!\227\347\\\274\362\315\363\"0\323\362v\242\371\372\367n\372;J\16\4\216\272\341\21A\251\350Eo\262\337\245h?\271\366r(bg\307\" C\361)\227?\346\330)\225b\314\317\343u|i\t_\2779\\\27d\254\3364\313\327\177g\227~\235\343J\233d\27\37\273)\30;\26X\2\177\n\201\253p\345&^\206\360\1\277\340\5\342\311\203\243\202\233\263\22\20\344\276p\254\271\325*\244A@\213G\255:S\t\374\361d\311\236%\375H\311V\345\3549)\212s\2341K\224\356E,\215\363\v\\\10\315YX&\210\313\30\276\200S\335\3\263\264\362\362\n\213\214\27:\316\206\t^i-\373n\212L*\2551aK\t,TLs9%\332\325e\313E\266\205\253\364f\22\3208!\252\352\302\233E\251\2066\317\306\16w\366:\333j*\310\303?\321\337\265\2500n\v_\20\\_n\313\356u\346\5.\344\\3\16\323)\337\215\25\2\371>\370\271\36)\250\343\34\17\346\320t\4z<rf\35\2\211\324\7V\371\361\234\200\347\351\266\3646\363\232\244\376\310\371\240\343\213zYG\337\356\345\33\20\302\376q\27\343\330\321i\352\275K}\356\343\265W\303\370/\220C\362S\277U\260\233O\6\204(\5\330\370-BSPl\354\334\346\356\3778G\365xo+\346\6\213\0\274\364\306=a\342\333\373\6\265\262CD\225'\37\224Hi&\7\310\315v\254\347\277^]~\231\265\327\270tg\243i*\316\344\344\325\263\33_Z\2474\256\364\2465@\217\33:\365\f\261S\240\f\321\245rS\227\276k\334\322f\326$0\307\21{\217I:{\254\350E~\355\364\250\357\246z\310\330\325\367U\247G-\367\343=s\5!\262\223\375\331\6\35vP/8{\v\2323\327o\332\210\236\325\20\\\330\232\206\334\247\330\365\234\313\324\2128_Y\5\rcCo(\240\225\0242\343\252I\36\216\313y\356\362\246\334>[W\332\322\254\352\350>\00611\7l\336y\211\330\205\301\342\210\263\240;F\235 \204\370SP\364\2\226\243\324'\242N\251n\n\\\24:\276L\312J\232\360?\200\25\274\211\221\366\350\250N\314)\226\304\272?\32\230\265\245\"\341\222TQ\245\200\17-\372\260o2\276\0=O\3272R\237D\222\317\\\"\\\330H\245\374\340%-\361\275\177\257\224.\367\6\325\301\354}E\262G\236_>\313\363\247\332s2\243\215\264\253\244\21A\221;X!G\6m\376o\223\265!\301\\\321\4(\355Zz2Yw\376\346\373\232\262T)\213\332\35\311\366\304{uZ[\244\321M\336\31\226\315K\24\360\222-G\252\354\220!\350\201\366_P\v\341P3\32\23\31e\326\0?\340\313\337\240up\325-\204\336\21\17Wb\257\352t\223*\331\37@v\211\350b\33ae\246&\n\365j\r\221\3518!\32\227OWKW[\4J\341\310SZ}\3642\265\257/\234\1\201\345\240-\243\260g\233\35\201k\372\311M\341\237\311\17K\25\372L>l\372\210\337 \234GB\361Po\372Q\nNPw\244\365\300y\344\34\340o\302\245\203\2052\347\262_9\200 8q\6v\262m\221\312\221l.F\306\213\366$\370\333\35.\20\326\313\241\0RJ5\253\24\0D\351\372i\33\24\237\222\226\212\211\332Z\217Q\316\2\274\353\331(\261\0032\21\351O\234\23\333\25\374\270\260\310X\6\326\315V]\311\"\23jW\30Q\314\325\t\361\361\5J\350\210\177\370\31099\v.Z\337f\377\27\305\252\265\2211\16\303\345\303\335\331\7.\313\271gg\357\343\r\36\270\317\351J\306\370\27\227\227\250\6\270 ;a\350L\34\30\333a>\242\262d\0004\2\362\26C)\7\35\307z\37\240\205W\254\210a\322(\244\21\363\361!&\16gx\321]9\347\304I\254i\273\212\310\353\32\242\240&\341C[m\203\301\204\31aZ\233\350\307\35*\310\365\30!w\vP\226I*\26\350vl\321X\325\256f%\20f\356\27\350x?\35\2461\326\16\307\3555C\363|\304\25\201\211\335O\26f\310\205\315dX\217\341\357\\\315\255p\336\277\331P\205_k\227/\2543.E;\5\201\316>.\3776\206\316\354j\31N\3069\37+\235\316\334\347\17\255\350\246\312To\345\220\264\263\261\247y.\0\202b^\222|\254\n\226\21\311\346]\24\16\31B\241\352(\212C\311mR\"\246\320\2036\273\272\321l\256\304\24\243]y\251\2474y\21,E%\254:\10?\247\253\314$\267\314\205P\tGc\201#mB\360\353\270G\255\226;\2\305\231\376\327\327\351\367\324n?~U\301t\f!\327\252\323\367~\36\312\25\n\350\311\347\305\6s\252\2\361lG\255{;,`\274\21\321\211\351'-\364\344\311E'\337!\304\354|b\377K,\307\6=\275J^\177@\0302wT\31^\334\232\226\252S2\213z\236u\263\352\23w\31\222?\216\10\256G\363n\342\354\253d\315\251)\254\4\261\375\33\210A\32\301\24\340#Sd\2332\213\214\206\364\375\25y\355xn&C\263}\323u\204[f\240[\316\r\241X\254\22\245\265\350vD\206[\321\31\360CA\302>\275\353\3124\214\270\272r\376'\205\346\257\233fJ\370U\246\2438\213\30v)5\327\213H\240l\273\247\27\326\331\255\276\202N\370\23\333\273\261\275\37^9\215M\333zN\326\17,j \214\306\316\33R\225\324\2640oi\356k@mEG\243\347\241\364\31\1\260D\223\230\25e\226\363'\262TW\230p\3064\333\4\275\262\203W\224E\361\233\236x\17f%\260J\222\312\\+F\33<p}H\253\3145\10TC\n\255\3363A)K;6\321q\252\263$\n\321\220\250\355\252\10\375r\274\r\206\212\202h2\247p\342\361\307<\355\262Qb\342ClD\251\235[\7\340\344\331\376\32\262\344\262o1\253\313\2054G:BW\33\340\tu\370\31\373y\214D\3259\365G\31\215\23\34\3147\26{\324\tjl\364\22kL\33\236\360\205t\t\250qr\36]\24\0350\22X\7\10Q\345\217\267\333\225j\233\354\374U\230\352l\343\2470\1^\210Q\371\vR\337\336R9\276\212\213\203\216\"&\373\243[0\304\210\253\17\325\353=\332\376Bf\36\306\264\213\31\334\30.\276\2273\342\312\34K\277lW\313\351)\33\3643B\201\206G2E\310\3W0|3!\27\267\305\33\37\301QHy\364=6\247\225\240{|\262\31\323\244uT\250\2521\2260\254D\26\220\3303\301\2\3\210\260\374iV^.\323\17\272\200e\241\241~\307\234l*\317\302\362\21!-=\n$\32\342\306\3249\340\322T\\\243>HdJx\16y\344\t\255\336*+x\0\34lZ)\25\361!\273\330l\f\240\373h\217?M6\377\255\212\2265\25\312\27\361\223^\241>\340\r\252s\225\202\370\\\357g\272\210\v\177Z3\201L\36A\211X\264\305\30Cha\2763rS\322\34\33m\177\267N\25\347J\246\350\r4$\315\330~\6l\2055\340:\7\374\263\267\10\314\23\320~\247\207\221t\255\265\356s\222 F\254\316aAG\226\254E\231\211FC>\277P]6\36\324\231\361}\212\256\16\311\270P\320\335\231\352\317\211\3656\37{\254w\260\20\242\357pe \fEM\311\365\325\375}h\345\216K\nI{h\252C\354Y\32\214\247\214s\324\320\33\27e?g\221\242\34vZC\336\346\26\343E\376\343>\fi\324I@\267h\301{\222\236\252\2618O\351\304B.\204\371\357L\202\301\t\372\245\6M\206~\347\321s\271\240U\255\246!V\220\247\331\250\337\333\231\305\347xA\344\243U{\374V\370\276\332\t\10\211\4\21\272T\242\236P\261A\212\257T\216\23\f\253\24&\223Yf\365Qe\225>@X\2232\311\214\236\324[s\223\246\7\367JH\337\20\303\26\271,\306\203\2\234Ki\301\fC\31\344wp2$\333\24\364t\3r\317\"Bh\366#\373\0\20\30^\25\343\241\215`\252\202y\363\272ccy\236O\364\353\21\275\0\306G_=!\261\371m\21ge\254\36g\350/\301\4a4\250\325\21.\2oq\301\33\4N9\207/e\217\203\223\2326\246cp\236\311j\2502\354\270]\f!\356\3\206kWy\3546\3\31\355V$\304z\352\354\274\365n*\343k?\30\263\321\32\207\330=\374\203\6V\t\271\2776\4\246>\311$6\24\244\371\303{\344\316\346\374\204|>,\2\314\205,y\370,\337\261=\263\254`\350\223\3#!Jv\37\fh9U\221\375\224\nA~t\215\21\374\270\377_\210+@\341\245\363\262\240\332\7Z^)r\270\203\0z\362]\330\224\255Z2\f\34\354<\220\307t\23\24}\330q\353>6\7\266\27\37\351\211\245\240\331\234^\362B\316?\3632%\362bM\236z\226+\315c\300\200lxM\234Ei\377'\241\370\231\335\10\322_V\2458\374\243\274\214\276T\227\276^F\272A-+\231\"SH\271.M{\367_\217\1ga\271V\2276\233}\226D\5\234b\275\207\300J\267\343\211,\236\333N\316\304\331\10p\200\r:\276\362 M4\263\336L\2717E\2\211\203\10\303\20Bc\355|F\253\30\270\211rv\276\216\254\270s\276]\326\236F\314fCv\203\344\336\330R\254n\231\3230\"4Aa\272\333z\375N\32\363;\2P\343+\321b\351\200>\310\336\2337\25\256HQ\237"..., 16408) = 13027
09:01:58.024611 read(3, "\261d\344Q\"\250\237\31B\254)\221\327#U\310i\252|\207w\2439;\345{\v\334d\372\346\263j\340\244\22\364w\332\2134#\36\0\326\273\212@\251\243\355\362\245\35USw\305KIh\303\fc\320\340\366+\355\246%\245\305\1 \25\311F:`\320r/|\215\21y\256\335\220WHL\313)\264\273*\247\321#\255\3016u\37\314\203\3227\205\257\226hw?q\301\5\t\353Z\325\247\371R\231\314u\221\257S\324tyE\344\267\2q\215\t\32\324}o\256\257\242\341\v\303\205c\3\370\373Q\7\323\0002\244<z{vZ\361\205\272\255\352\240\2\363\306a\223Q|\234\204(6\373|\367jJ\327^\22\266\200L\326+\33\311{\254\325\307\233rv\272KA\277\350m0\275\356\344\235\213T\246\352\177y\336\3365\342\266\206\2666F\213u\314(\v\362iiG\3\265qq\f\177\24\345\26U\237c\30\312g\334\230\363:\265\371\3260`l\305G\241\0\306\301CTw\236\232\333[\300\246{r\35\257\236m\336>|\350\203!m=\n\233\333i\371\304v\251q\\9\343\230-\t\275\317\213b;i\305\353\251q\220g\233\30\203\277rT7q\2406h\327<\36\3[\364\322F\231Q\366,\232\321K'\365\261\376\275\316\336QUF\374\302d\v9\215\270\331\371\"\17\335\204\264\35\255\250CEI\210\200\332\365x\261\33d9o\215\343\367\346\305\3X\371\3\1\325\234i\207\245t\322\250c\323\27\35\tc\371\237\3^\2169-\314\\\211\37\230\356\212\237Q\351\217\327\210\37\265&\302\262\310\353\233G\2171\340\376\21\"\5\363/ \263\251\vz\226g\252NJ\2046\300,l\250\254\360\362h\366y\21\357\2322\361\0\304\322\212\370J\300\243)\210.)\264T}\r&\260\223\264R\375\313\303H\247\346\202\232\246=\204R\30T\363\346*MOR\362~\364\342\344%\36\215\223-\353\314\t\375 \224\202\345\10\262\236\261\320\364\371Lo\3213\no@\340\220\306\2623 \207\210\262\35\353\221\17F@\336\313\317CObB\6\0\211\273\264\235Q\370\242\243\f\26\360\301\200V\320[\325\211\336J\251\244\265\357L\20+\212u/\323O(\201\274\351\32\344\243\371Ua\202Jj\312d\216\240\370\243\275\375\26Gy5\352\22\224y1\313\261\302\263\37\271\217\t\275\34\n\f3(\312\262N\235\201\327\226\330\224\216\300\340\226\316'\215\317\227\230\331\202a\203D\356\2564\252\207\354dJ\214\210\275\v\301U$J\177\t\343\354\303C\16\204\365\245\243\21\315mZ\317g\r.\346$\335P\260\373C\3073\261\357\6\354\341\263\245O\362/\0\255\237\213 \252\263`(\375C\337\214\32\241v\276\257\27\240\7\355\7\361V{\352F\255\37&\313\364q\3764f\31j\10+\251\224\304\213\247bp\v]\273\332\362B\271\323\314\352\234\362\27\254\365[\357$B\333[\372\220\362\0\242\350i\206\261>\330\274\370\232\354&\242\273\322C\306RV\2475z\234'\235\333\253\346\254M\236\346\323\20H\32\32\224kqL`C\375\346~\r\322\37\270\255\33\"{\230\374!\250\10]\240\246\373A\323S\214\231\337\343\236r%\377\375\341k\7.|\311\244\304\306\232\2\267\252\211%!\340\313\20\37<`d\265\355\202\341\3343\0U\16K/d#\f\356\24\367I\0\3339/jj4\377\274\223\200\322&\354\361\36;(Lkl\364\3217\303\274h\207E\315\246\262\3544A\324s\212\225t\3\246n\276\2635\331\217}\30\241P\334\205N_\335\2\214\265\265\324\230@x0\247\1\302|m \354T\31<\220\234Z\\@\0166\374\17Z\266\314\t\267\212h,+\345\353\311\253\237\377\177~\252\271%\333\225E=\347tC\316R3\322\230\6\3\371o\266\317\240W\356-\276\236\6.<L\321:\303$\373L`\34\3467vGp\250 \324Q7\375sh\210u\307k}i\273L\350\22Xc\227T\362\333D\242{+\354\207\217\312-\207\255V\204\r\24C\336\226>\307=\225\372aU:8\337tgG\337\270\376b\317\t\341\261\215[w\200Z\271U\\&\337\370\222\207\370\324\271\34\201@\327\272\374c\215\345\2364\2467\10Q-t0\330\337\303\357\ra\210\260\253\4\v]\353Y\275\333O\315\217a`x\244\\\314\312\370\321,y\260\36h9\327)W\0379N\r\247\217v\361\362\335;\203\265\21\30p\32\22r\20\330\216\6\35_\356GeI4t@\5\324sr{h\331\313\36\36\221\365@P\363\275\257\264mo\355\25\224>\350\20\262\v\301#\233\352\364?\3721\232\fH\327m\231d\303O\"E\3256r}\7\2458\264\237\3f\202\22d\37\\\365L=\215\360h\227\274\300\6U\177D8\264A\316+\2466C\177\31\22-r!\300n\365\336\317\366\t$\347\27`\376#\"\305\276%\235\307[\25\346\31\260\274RM\27\323\7\307\306\362\357\351XU\331\316l\10\17\347!\f\246[;@N\217C\216\214\350\307\37\0222\242\\\340_\"jI\7d`\177\352\324\220\212\253\16\345h\225\245l?\325\5\ro\312\325\262B2\344\340\325\372\324yeGJ\204v\374\2722\325y/\334\213\374\272A\324\327\31\275\10qy\tzB\262\222k\302\255", 3381) = 1448
09:01:58.024795 read(3, 0x20f69c3, 1933) = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.024872 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 924703}) = 1 (in [3], left {14, 912439})
09:01:58.037277 read(3, "bM9-9\251/\361\354\215!\370`\351\304i\320\220w\35\235\226\323\26\35\370\200\367uje\246\v\203S\nd\370\256\352\301;8\200\332nf\374\241[\215\237KwR\177a\212\211\364.w\376+Y\261U\243(\251W\331\31^\206H\2\300\207\0\v6\305\277\333@\0\376\210\363E\30\240\252\234\2269\325\210\261Z\345_\346\341\357\337\246|\225\272\271H\216\264'\304\202P'\252\323%\262\177.\356\300\3\203\264\305\272;\rQ&\v\324\260\0359\256\351\216\276\214\273\270FY\316\331\354\1\321\"Q\265\250m\374\250\257,\247\34\364 \255\353\310q7\237j\300r\2\232[\337\255\3015l]\tG\252?-,\337I|\211\301\357\230\327=p|^\255\244~\320\16e\211\22U\246lL\370H\275\21\237\305\206\345\311\337\234\235\225+\n\32Z\361R\30\343fu(\25t\266\223\35\326/\25\307\260\330-\243\333\22\320\25\203O\245|\234\222\2772sH\272b\0160\357\\S\245^g\360\277\317\363T\343\370Q^\346\33\313\7\277_d\362\33\210\342 k\3\244#.Y\315\4\23\372\326\346\325\367\201\372Dbc\27\313\273G7\377h\232\257yZe>\265h=dy\223\265\355\371m\21C7-:*\254\223[\260\255\21\10U\301-\211-%\\\372\232\rC\350+\362\216\v5o\253R}^\25\254|\366\357\312\312\31?~r\302\234o\2548T\207\356\240T\324>\177,\0\t\277\342\306A\344\320\367\320R\212%\315\374V\231\330\256o\324\25\266\227^\4\n\r\337\n\217\375/\374`\220P\344\333\3014:\26Gy\265\37\35\37\356FJ\231*+\26x\327\274(b\232\346^0\307R\33Hck.\307O\321L\245\303N\305\267\246\356\324\305<\214h\265\361\205\tg\236\274\372\274\321\234\f\253\203I\375L\4\23#\207\31f\323I\340 ^-%K\324#\301\310UT\244\252+$\32|\302\331\257-'-+\373\344\253\10#:c.\270y\336\211\202\20VJ;\231K\371\7\32B]\222@\341\226\224\1-c\302[\6\267\322\377\213\363\201I5r\344 \314\25\360\375\223n\236E\254\357V\"\220\232\34\301\253\\\213[\316\\\375\r\212\26\177\22\37z\353\355\346K\220\312J!\224[\235\357*\345\301;\362\207A\22\276n\n\356Ku9\307\346\257\333O\266K\36\2721S$\230\367\v\3037\303\332\203X!7.\27\211\274|\254\243u\5\357\16\32\273[QK\204\334w\205n'K\6y#?\256\254\276\271\373\243\35\t9)~\203\346\37\362\210|\316\342\267\373\245\220\3\225\330'TG\311\367\277\247<[Q\3602c\323\230*\266&\274\334Z\363b\277\326o\3041\305g=c\275\345Poq\210\216\264\342|\3749Jm\3\226\200\261\3\200\36\20\231\275\240\355\324\200\n\325\334\7C\365sW\331\5\356\5\356\244X\227\2311\255\272\250\0236\256O\314\212W\320!D\336\346?\"!m\300\356\202\30e\247\250uqd\355\34\2068\226\236#\24d\371\2348\205\177\361\253L\243vuYS6\331\210Sz\330N\304\242\352\320\276\213\233P\24\333[\f\\}\371=\230|\367\333\34n,$\22\232D\3452 \177U\377\326\366X\25\315\302\201\214{\315\6\221%E\315\341\244r\206\1\374\313\32\260\237\341\271a\"\307\373\263@\340n\6\337\22\314E\302c\351\3132\243S\t\265\17C\356\235\372\251\245\243i\347(\323H\370rW\221\266-Tw;1\25\247\315\264&\220\205\32\3431\3449\237H\221\320&\257\310\276\225\244&\273V\320\274\342+\206\221\266\202I\330\251\325\23\346\343\27/\232\255'\234\361\vqj\f\337q\325Jj\376\2412\26\"\0Rca\25p\362\343n\327\f\335h2\222K\321s\216s`\"G\336\240{\37:H4\256\215\f\r<\203\r\315\2333d\22\327\363\263b\221\375*\241!x\16\214po\233\337p\20a\257\224n\212\t\317\2\351\261\335\24+0\260\372\201\25O\326<\225\20.\256>\356\252\243n\226Q\364\17y\274k,F\314\325\315U/c\250\352\373\20\273'\261-\204\307o&5\216|\3342hM'\245\351\3023\312\226S\210\2068C\330\33A\367;\347\221\221\254,\16\0>\212\316\211\301\271\32\2162Z\320 Y\325$mN\2178\274w\231\337\0102\3250\235f\302^~\207\200z\214\303\352)~\n\251\307\211v\370@\205\301\352\310\205v\37\2410\214J\347L\242\305\316D\363KDim\261\260\202\264&\33\n\326$K^\306O'\221\311P\246Y\314\372\366Q\333\201hB\323RZ\277}\251[\276\f\362\252q]\236z4\6D\237\344\214\230J\360'\f\23\\y\206\212\201\204\374\375\264N\244>\366K\266\310\213\347<\3162\216Tm\33-!\23!\262\352\6\f\223\20x\236\340\353z\325>\4\\?\233\227\316\361\341K\273\230G\354\247\332\270*\177\35\311\302e\324\370\337W\326sIn>\363t\6+\310Y\211\244\316\250,C\3070\243\332MK\304\255\21\4X\225\320\240d9\224}n\n\346\200\n\376L\230\346\n5\206\364\213\326\t\345\232\2258\246\245Z\331oAA\235\337\243\224\317\t\\\0\303\n\331M&\217-I\252\266wD\324T\"\333n$\300);\303C\4Q\334\27\372f\251\23*2\316\177ag\204\2337\230y2\337\22\211\34\336\306[I\330\227\340Z\f\265{\375\252|\5\17y \356^Db\327A\202\352zq\373\272\"\32\203\356\253\217\2132\364Rj\367\207\372U\0374\16\232\350-\2061\224\363\204->\5\333x\251\22W\2\254H\264H\302Dk\17\2318\224N\307\253Y\310\0002\315\243Q\31M\350J\241\273,\365\260\0\232\372\235\223`\331\302\240\7\315p\330\343\235\276\r\0\217\7g4f\364\24[9\211o\376\340h\34\317\0\263\202\345\337\253\254\332\263\5J\330\233M\354\314-\n\262y\373H\216O\200\0\274?\343'\315\322_.r\215\31\371\234\35\n{7%\202N\302\245\356\33'RL\3\221^gN}\347\332\204\35j\252\226\21R-}5\252\326\223yi\216Z\321\373~+<\373\323z\221\n6\243\263*\0&\377D\333\221I\v\376\205\320e\226\366\246\327j\26\200E\353\275\300Kl5\n/\357\3152\375\360B>y\3\260\221b<6\327\324\343c\320W\22\37&2\203N\200\3527\200\33f\243:R\365\231\337\255_'$z\216.\301d\303\252\206\257\300\242\231\31\231_O\211\256\216\276\1\27G\344\373\371\\an|\265j\261lD\232\370w\222\205<fs\304N_z\315\306\201,'\204MZ\313Y\216\316\3727\16U\320\37\356\237\253\20bsKo\361\344\"\376df\342\3631$\225]\3427|d\361\354r\363W\277\201.\345B\31\16\302S\363\2026iq\357:\3703'k\312\3028g\"dh\ts\f\247/\200\2748K\204\225\\f&\354}l\362\224+\0005\334\274\201V9jK(\313\303\236\7\200_\366\266\264\275~\345\17\331[", 1933) = 1933
09:01:58.039373 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 910208}) = 1 (in [3], left {14, 910204})
09:01:58.039547 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 910031}) = 1 (in [3], left {14, 910027})
09:01:58.039904 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 909675}) = 1 (in [3], left {14, 909671})
09:01:58.040064 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 909514}) = 1 (in [3], left {14, 909510})
09:01:58.040184 read(3, "\27\3\3@\30", 5) = 5
09:01:58.040229 read(3, "I\331+\236!&\370\247\255-=\372U\206\210\266I\2531\301+\216\377\231\353\1s\367\24\237\312@C|n\372^m,\325\232M[\202wy\365@\2D\321\36\336\270Z\3327\233\2007C\304\23\3407d'\333\364,\3\r\264O\366\276\177\376\256\372\t\230\345<\24U6\10\304Hg\6\2327O\311\216\262\r\356\0T\344\257p\255 \300\302N\5\240\300\206B?\322\3744I\27\6,.\207L\271\177\24\204}\253@\265\3\370W\375\nm\235/\2041V\320\245W_Q\213\364\fqJ\325\323x\231\312.\350\234ft\364\321\252q\6\330\251\26|\260\211\361\205\300\36z2\272\203\215\211\314\200\245z\362\245\267\35)\2323\3238\251Uoa]\260\320<#\337\251\376\315\361\5\37\367a\315)6\364\356\356\214nG\374\310\6\263=\234Ad\r\213\332\323\7\300j\373c\247\205*\233.#u\27ZF\372\7\303\35\21\27\340d0]\257KW;OW/T\373\223\240 \366\364=\320k\273?\271g\360\214\242\231\323\30[\36\1]\350\375\351\274\376\23D3D\331\233\247$Q\217\335\316\245\254\"QX\361\271\314Y\221\330\363\357\247\322\227<0\5Q+\315w\f\247\241n\341(v\232~\242,z<\31\362\204N\201.\367\230@\267-\305\250\v\"\236\334\214\220\225~\5\3634\360\215O\227\221\304\350\353~F\17)\315\303G\375\351)\240\241d\317\316\207\350\2451|W\303K\264%B-y:\240e\320\253\242\352\340\326\350\255\304\374\23\265K\274'\r\267\327>X\1\367\265\222\305Pt\351O\4\327\322G\321\21\342\222S\275\326\243\237\6\340\211W\353\331\272<\323\1z\331Y~\244?_o|]\373\3r*R\v\317(\271\350\266H\245E\330\210\304Qx\255S\260\256\335\377\262=R\246\10\221\355\267\352W\203?\262\213P\367c\273\241\323s\337|ZU\236H\33M\235\304>\226\35260\36ob\1779\253\253\r\207\202\352\275\2473\233\313\357\263\257F\310\305\250\247\35\3Rf.\30Y\205\363Q\240\314\316\260\267\345I\1\321\\R\341\352XDV\260\340t\317\345Q\227\2B\307t\357\2317X0\20\265\301\311\222\323\365\360N\252\20\260\200E\265s&U\32\350\316\312t\v\267\v\363\224\356\361!\202[\272\t,R/\273,\33R?\257\254\346Raw\245\266\24(\260\255\274\234x\21\20\214\3737P\244\332\4j\204:\240\253k\304\217\245\233\311\\\231\17\3148\334\262\304\34\224\303R\23\215\211\32\267\255\304\322U\360\346/p\177\203P\234\207\323Z\231&G\216\337\351i^<b\267\364\210N\316\242\276\312\257\207uJ\364\357\353\310\32\216!\342\311\35%\355\213\3343\267\335:\206\356\331\206v\375\22k h\307\n.@\37\264\346\243\367\307n\302`\177t\204\224\255p\"\336\235\266\247A\327]we\353\234\26Wp\206\300\37W>\201\351\214\7d\3f\256\206\34\304\267A\210Rq\331\234\246\336\274t\254\37\3336\377\325+\333m\272f~t\17 \355o\0\377\355\260\212\260\32349\361\245\350\221\226\205s\316R\277\235\331n\256!MnS\226\333\212\3700\300\252\256<j\3757\3112\325\213\315F%\204\5}\357\221\252\205\364Q\254G\7\257\250\377h\277w\342\r\3\264\33{\375C\317\366?\252\361Tu#y\344\7=\355\26FL\346\355\237*\271\246\366\"\222\rt\316\235\332;\354\236(\213\340\361\254\36\2\225\243\334)\17\16\3223,\357\266`\307\333\343\303p\25Z\340\"o~.\255\253\274\302n\302\365\220z\265*\232\247\206W\5{\300-\343\274\266\177\305\253Z\321\30\225_\354\274\225Iik}\276#\226Th\320\\\210\305K\311\25\36\263\266\4\6g\23e\f!\3D\305A\324|\341>E\27\205\f\303_?\310\341a~\202RcQ\222\373\271R!\17\204\253\3\315\2757\246\321\210'\36\252>\373\23\3\2RxsU\3\20\304h\240\242\27\341x\336u\202\261B\276\367p\265t\333} \215\220o\323\22\t\255\350\204\350$!5Eq\265\314\262\337\267\373\312BY\270\277`\271\322*\313\314ts+'\231\f\222\226\7\236\342y\33\31\321\360\302\327\226\370\364\275\211:\372\340\362\376\240olx1A\224W`\274f\252}\326\7\2000\334\351n6\320\n\7\255\307\344\313\251\353\374[\0\16\35\222\344\302z\3124U\23\370\254\25\360H\256\r\266\210R|Q\4\200\275\354Ff{\271\214\0241\374'\200\32C\20)EVK\333{\0010\250\251K\300\232\f\22o\202\305\303\351\340\306\300\326\2108\321\25Q\31\2264/\3475z_\306\346\221@:\342\220\366\230\350\366\370t\234#\225\273\324l\272Aw\240\304\242\325?\240\200.k(\t\v\v\314\n\302(\364\204\356\315\251:\230\351z\371N{ \345\232\"\217\306Q\n <C\36\6\243\301i\2\n\274G\207\210\363)\2707\177\235&\231\\A\r\216D\240\241_\322W\231\321qN\21)<\212\3711Z$4\265N\216)\343IKnx6\22j\vF\16[\340A\315\224*'\245\263\236\217\200!\37c$\22tm\227Rx\244$\216\250%\247\10\315_\r;\236[\35*I\242(\275u\216\343\2\240C\211\27\273FH\371\367lR\33\377T\345\264\300\326\227|\3223\177\243\261M\2\253\346x.\265\303\251\370,\346\265\246\373L\225\264\217M\270L\367\250I\204\271\324\306i\31Mj\323h9\210\23We!\316\340M?3\254\27\211%n\3323\366y\376\342\256Y\376\310B\312\363\22\356)\351\320Dw\26462\305\331#jm\352\204\364\245S\333\260\v;8\23\211nt\247A\220\301\200\227\246\351\350\343G\322N`]\201\3562\257u\332\201s\371\2103\376\331\256o\220\250\237\2322o\210\26\265\223A\323\n6y\7\202\361q\343\223W\212\"\273H*\342\2533U\211\217:\344Y\311\224\6\264\2264\6\252\4\32\340\326\7\2238\262p\262\325\233po=\210\"\331\264\265\4\233\320\366\361\340\325\302\t\24\10\30=\226\224\31\r\306Mc\272c\t\25\211@S\277p\276L?\234.\377N\210\333\31\2\213\227s\362\35\303\216VF\263\317\371\220\257\254\30\276\3531dM\316d5/\246f#yO\252!\233\374\r\212j\300\\\357z2\203\244G\311Aj\244\325\237\331=6\271\337\236\4u\353/\274\314iV\342\317\322\202l\216*0p\206\311z\255]_x\37CW|\341\351\375\361u\343\344b\317O\233i\253\357\331\212\236\377\7\212\235\327\365\34\377\1\276\v\375\243K\305\364\302YF\0\te|j\20Z\201\201u\216&\10\6Y\r\20\353\34\3\345\312\255\34l\204\207\2\355\276\332\317\253\200\332b\200\360\230\336+\366\1\253\251\310\237\253$\363\352\307\310t\252\242OWF\214\270P\31\7\30_|\261=[\204\310\365C\30X\5\307@}1\3017CE\372\220,&#\17\f\343\326p\7$\32\302\336xT\36\2544L\315\270P\323L\35\30:R\355\34K\f\320e\304\240\"I\304\252#{\262\10\200\351\272\2\360\3L8m\326:$\22P\354U\356qu\204\21?5\\\202-\367q\5\4Pb\210 T\347\302\365N\362\370\266\204\365p\277\33\16 \233'\350\261\306\211\367\237\221\306\315\213\245\360\254A\\ YL(f\204<F\244(U+\30\27\237\34G_\366\3609\204\31\375\204v\274-<\2=\253\262\3603\353W\213\307g\357~\362\225sm\f\20>e%+\266\275\232\3401\\\2P\343\10\370\357(\201\302\5\236\341_[\302B\224\321\261A\357y\r\345#\357\341\322\16\301\356\316\315\363d\202\301~\360dDH3*;\271\223\235\255\246E\305>\342(\246\5\252\264\320\365QD\313\333\203Re6\205\316Y\224\26\204\222\237\300e*?\10R\343\251;J\363\234\203\300\233|\222\273\27\241`G\372\307\303\225RTms\350}\364\253\"#3%\f(\372\377g\263\311j\265Z\362\371\213i\1+Qo\261\316\17\312\342\35\v\322\362\200\26\362\325@\232\36\361\245\230\373\\\20\364\360\2055\206\260\324\246<\337\275l\265O\33\353\v\330U%\360\266\367\336\372\26mfw\325\262\254\224-\10\357\325\355\323\244\365\360\3g\24\20\201\277\366\341q\"\330\n\340\366\271|\377\364k\366\1\217\2167\355\314\225\1\n3Z\3l\263Ya\236\273e'#\344(g\323\311U\251s\273=}|\355:x2\255\7T\355\223\330\36\242\251\366\0065A7\243\r\303.\217\10%L~\177\374?W)\273\242dc\0211\207\323\337\342\212 `\1\2579\350\320\243;\376\6\232\227\363\266\245e\256\33CV]8\377T<e\234\33O\233\f\"i\206r\2\200\265\207\333-\357\371\302\3636\250T0|\321O\377\317hkxy\322\34u/U\342\364\1\347\233*\204a\222\224\263\375B\27KT6\0320\16\220\272\214\334H\2569\371\262W\31P\302\347\10\241\336\354,t\n\323\224\255\205\2226\373\370\ne:\335b\6\rnZ\0039\300\323\375\315(\375\2219\325b\272\360#\4\275C^\317tF\372\262hJ\342\273\236_\320=\236\35\262\261\247\257\n\325\3D\317\276\323\351)(\302\370J\24\304\323\366\242B+\317\316\363\256\4\215\247k7b\7\f22\207\365\323\222\275\0356hy\257\223\302\266\360\200mw\212\231\221\211E\214\253\330J\231&\334\344/\33\366\226&\302\273V\364\333f\21\227\22\0.5\373-]\273`k\333\371'\20\343\245\205a\220\241Q\260\v\331\256\vP\367\361\254\31%\225\373\31~r\311M7\v)(\300z\3711\276\177\271\306\314\n\240\267\346\2268\236&?\30\22\240]\254WA\236L\27\302GT\21i|dj\341!H\321\277\0\323o\306\320\366H\266\372\317\252\373\33\23\371\344t\213\25\302*2\242\236\301Vb\343v\236\30\267U'Mz\275}\364nIl\7\357\0376P\f\f*\336\fO\221\342U\233{\vR\314dR\373\223Q\202\231K=\337h\321\326%\v@\225\335\340V\235\363\34\362\265\274\233J3y\16#+}\217\311\331\203\335\257/\210\224\206V\2068\211\0310\353_\2166\37\245T\2177'>p\33\343\332m\342( \233\23z4g\224\372\204\3011\251w\236\350\352\203\353\300We\214\244\322\3629W\322\7\344\266\303:\34\2301\331#\322\330\177\255 \364\273D\34\361Q\5\252\304x\365\367\f\245>\363\340\246\313\255O\270\332vf\355-\207\300\304\311W\327\2\21530bV=Po\305\277\354~\241\3065\231\226A\355\0^\313\2515=Q\336RPse\n\210\273\3014\7\207\346\346%\332>\34\35208W4V\263\276\343R\342\220\265\236>]\212\17N4\255\260\nO-\373\243\30\226\2677\356\273[6\1\251\"\365\337\251\256\20eDpv\"\305\351\r\204,\247\20\22\33\372\10\230,\204\337\35\365\334\311\21\224Ml\376bx\366\361\212\17\371\223k\343\2\v\n\351\341^\r\177\214\305Mg]\237.\3768z\35\376\371\217\22\376\375\267\207\341\7 \223b\216\31\214\3767\320de\313\247\3327\377\314\227/\314\247<\350+s\0017\223\345\306\353\3224\372\335#2\217hd\336M\30\306}\217\nr\250\335\372\"\264m\313=\344\206\33\226\275~\207\177\23\357\216\361\211W\236\6\276?B$\226z\305\357\1F\372\246\230\271B\24\315\r\326\344|\325\334m\224\256\264\333\232\3216%\f\205\373\363\330\226\301\200\254\373\\\215\373\271\6z~,\244$\246\245\254<P\361Cu 9S\254\246\26`dg\372Q\374\252\245YG1:\253\nM\260a\212\354M1H\25g<\0004\36Q\17$\17^rC\3`\36\306\206\373yQK*N\274\204\10~\337\242F\245\206\3736B\342\33|3\356\265,\326f!\267\314\236\333Q\331nB'|\304'\336\254\337\321\10+\275\215\245a\322\374\327\3719\355\243\301P`%$\375\314L\16\262m\323\335?j\261\350\2419\264\367Z\f\346\26-\252\267\325\305\377B8\222\17\204W;\371J\320\315\231\331\351\360\30\nF\250\243t\"y\245c\275\244\272\242\214\371-\304w\362\353\357u\322\323\325\357\306Jc\4\326\\\343.\254\32\0D\325\273U\207L\237\214\334\r\330\26\251\356\2e\314y$!\254\27\206\"{\262\\\320\35Uiy\364\351\346O\244\364\21+\353\177\371\30\24~W\271\332}F\225rf|\2676\24Yb\325!\35\27\353\372\255t\211\223z\232K\274 x\3404\211\256\223\266\6\352\20D\223\"\225\373o\271\300\373\217\301\260A\212q\355\357\226\264\200\20_\272\273\376\341[\267\307rCi\325\17\225Q\t\231\242a)\273\241L\321\216\27426\230\177\6\305>\203Y\n\321\336xJ\30\6q}P\3n\213-m\36\33\374\23\203'\204_\200\5SU\nF\325\3357K(\272\26\252\251/\266iT:@\33\355\312:\276\311\351\363\371\367A\324\217\2054\225\305\267\217d\237Z\37`=\17\26)U\222\376\366\251\206\374\203R\17-\266\202\2470\225\4\256\177!.1\363~\306\335\215\351\263\377x`d\231\331H\25\265~]\302`\340I3\252\"hy\22\272c\3117\337\362\303Hx\21\363n\271\277\373\1\25;%Z\361\334\335c\355\244\5!\331\220\342\371\17\356\261\223.\324\360=i,\275Qw]\220n\372P\215G\305\333\355\347-\373\337\3\354\23\204\334\315\230\321\271\232s;\340L\210\376\236\255R\231\f)\312S\212\341_\255\3225\21\7u\300m\252\211Y\244\367\305\211\263\206\7\356\363\311\3\2440?\214c\336M\f~\374\254\256\276\360\7\267\355_y\364\267\240)\343\3547\27\335s\223\307\2\355\267\332\376\16\317p\371K\275i\346\333\236\214\21\206\372\303\214\264>\3753\23\226\f\340\t\241\212SS\202\270%\363K\20b\n\264\321(\5*\20S\211\357Rx+kD\220|Q\177\344|\346[\244 @D\305\324\341@[8\t@\303Pu\261I\234 l\365 5\205\341X\1\36^\306o\370\360\34}_\25Z^\312!C\10\224?\230P\217\322\34\31\f\31\272\325.9]\247\330\317\275\227\360\323\245\223\243\207AH#\315u1\2542\3612\201\244\0022\3401\205q\206\273~s\274\204\v7\375\374\214\300\211\320\254\3320\tT\333\343\277\324w\326\231F\242t!\204f\1e\263;\333\262\211\200X\253\200\366f\rW\7~m\n\223Q-#\360\265z\324k\37?\16<\252\336f\376\311Pb\5\305\323\356\370\320\215\206<\325\364\214\377@\325\304\300\220-\334%\v\6\360/\7\360\302\267n\f\273T_\376\244\373f\3374h\\\322\v\337i1:\201\271\306\303Dh\5\f\304\257m\2460\307\257\350`\0\302~\365\210\20\265\322Fi\245v\345\342)\316\30o\237\315t\270F\223TM}\240\322\274>\333m\357\235\360K\202!\221\272\344\355\27\335`G\353\fw\277Y\347\266\361c\203\206\260\242x\20\7\313\251\266\250\26u\253`z\331\202\27\261\340\fz\26k\365wE\22j[\35(\237\323\243\t[\0\23\241\333\211\240\250\365\326Ra\371eatj\307z\332\37\331Z \322b\2129\257W\317\344\234=<I(L,qG\323f!X\272f\356\333\t\376\250\367B\242\177\23X&\275\310\371e\242\337\215v5e\216\243\6\16\242KN\344\373\213q\237\307\215nn\21\252\235:_\n\364\254=\220\361\261m\224g^<\224#w\375\365\301\2613\247~\312$\253\220\374\354q$\270\2502\321\342\357\3365p%\254\231\352B\377\317q=b\300#e\335T5\26Wgl0\252\321\17\20a\231S\227\27\344\261\16\300\6z9a\2b\34\361\357\16p\250\24\343\247^O\21J\276jt\1\10#\206Q\251t\335X\246\225\307\331\207M0\205\260\207]5\265\353\314\341`\273Q\260\310\232\4\253\222O\357#\4\343yr\211\355\200\204\257d\247\225\36\316v\353\213\223\211\363\321TD{\324\320\334\333\344\325k\204x\332q\36\30\337\263\357\265n\310\324V>\323n\317\264:\347\336\370\230x*\1\355\23\256\204T\207\207Q,b\3060\215N\361H\10\31P\275\347V\320\334A\217\210od\362\322\2563\216\31<\211\7l7\251)\354\365\336\376\204\204\307t\340!&z\225\342\350K\217\344\232\352\312O\237\324.\3706\364l\206L#\272VI/\224Rn\r\266\250\357\371`\243\t\322\3219\303\245\10\254\342A\370\313\26:h\271\302\37\200\347<\353\207S]\354?\r\251\226\313\364\315\244*o-\251\206\217\366.\216\365ms\24\1\230\240\226D\307\307\314\305\330\32\371z\\\nM\214z\331\265\343\337Q(X>\216\246\321G\375<a\26\301y0\223c\2430\311\375\347\263\253\313h4&\244\202p\265\344gQ\200Z\324!\213QS\322\275\27\340Oi\332\321W\254\256+\371\3617\7\16\314\237\327\325yX\26\247O{\346\341Q\357&\331\210\343 \227\365\313\372\310_$K;\35\312\273\346\r\10\325\204\35\257\22\334\2(\341\323\"\373t\34@\355w\300\321\20F\270\215\240K]M\204\331\24\307L\323@8\226*\266\224\32\222\276\f\365_$te\203\202tdg\32i\32\31\215\307\332*\251\217\7\323\247bg\226]\0\202d\6\210\3108=\363\0\17\357/o\221\fR_\347\227\241:zV,4\257iQqL\33\242\363Wx/\r\t\305\272\23\312\273\33\304\310\374F\245\204\6\4\201\23\v,\345\377y\215G\372\342DUvJG\317V\t\234\32\274\201jE\3\201\2\201\313\206\334\324\206o\347\235\230\2g\272%\335\215\364\355\306\7\332~\25JjT\v\367\207\5\305\315\276Bi\222Z\355\27$Q\253\2\230\373\230\373\226\0003\355\250+c\213\272\0355\247rl\343=\2419\230g\335\37\r\263\333-\234\330\313\272\271\th\252\335\272;\21\2666%\337\3618\3449\246\3\312\314N\214T\354I`\312\203\233{\262\226\372\5\1T\253F\4\24\0\327\233\376\374]/\3\fi\33,\303\257\230\240;\204\270\3164\237\200o\220Q\247\237 \235A\360\3146\32\332\364\337\214\357.\341\346\261\31\25\340kp\370Ve\236\366\333\10\300\204n\350\3\234?#?\261M\340-\235\205v\224\222\23\320 \255FO\230\330\324\3043ii\316OUv\236\205\\\r&C\5\343\30\363T7\341\20\247Z\2216\221?\t\245}\377\303\361\30287!\33P=\275\327>Lr\261\236U\320\250@\336\237Q0\242\363\2}\351\264t\266\357;c\310\320\262\6\2r\210\37\345\354\\9ck\0211\20\2*7\357.\362p\242\232\357d\251\213s\2345]^-\371\253MUgA\f\37\362\354\16^\26\7<\222\327l\0243\271=i\350\233 \373\221EV\223U\303\26\352 )\261d\2171~\5\350`\275\271\316\222W\326\0265\366\306\207\331\345\245\"\214\31(\332(\314C\316M\216M},\373\373\313\272\217\366\367\223\367v\351iP\2235\0205\225\24R\261\345-\357;\344\234\243\277Y\2115w\345M\204\217\363\7\321\t\272>3\t\3219\241`>\216K\234\27%\353\342H\36\224\26\320\213\221{\243Td\326\241\vJ\0373\207WR!\374D\202\f\240\356t\376\2\313W\3517tP\305\6\322w@WI+\246\32\333\1\326\212\377\2426\305\200\304cy*\200\372j\375\232\310p\201'\fw\34\232\252\353\254F\7\226\223\255d\30J\34J\215\304>\253\3751$JsZO\254\320\300[\25>B\203\234\260U\307h\f\321\233\337X\225u\375,\271\335D\302\345\335\246\244\255\36\327/\217\31~5\10\261\361\211. \240\304\204(C\nM\301\0069\363&\246\310\301\36\267\265\3461\303\267\212\234\207\4\257\341\202\25\373d>4\\\3646$\20d\365z\317-\304\241<\177?\256\316\314\277\204\260\360\361\363\236nn-\23\344\3777\376\330\263Q\245\307\322\tB\5\325E\210\17\251\201\205U\366\320YJ=\265J\376'\312\227\237\341\223\242%\346\213\211\211}\f\307\340Go9v\255TcV\2602'\223Z\310\0173\211\323\217WZghG2\277\331\10}\2072l?\262O\355\243\307{u\377?\33\310\243S\377~\326\32FP\211n1#\n(\34%\17\235\374\243!c\250\217\205cIG\242S\273\301p\3\217\322\365\371R\365A\26\335Kg2q!vS\36\237\361\363\277d_\351\33\35\216v\226\35\36)\322\250\325\v/\302\25\344\35\302\25570M\fK`\22X\327\20^\216m\351\216\335WT\205TD\334\231\351\f\256 \200\f\227\276\263\310\236\204\360\321\247\354\367\31z\224\245\275\217\200\201C(\31\342f\360\203w\322<\322'\251\0\267\202z8/H&\217R\300\210\253\37\26\364\t\363KY\336L}I@\344\225t\2/G,\37\231\37D\311\263\336\376\244\323\237\236\255\225\240\3k\353gV\357\347N\372JS\22\311\376Z\326\262y\271\350:\377\246'\322\313\313\303\211\7\253@\316\334\305\232\254M-(\212\201JsNah\23+\267\32\252\224\5\222\304:eb*\352\177\371\n\17\250\334t3\33\276>\251/ns\210=x\2047\236\217\23\372\2240\232\372dh\32\1\232(o\300\315\337\274 \313\377\374\365*\304\277\205'\264\252\251\nm\262\363@y\271\254\0\262\275t\225\32\220\2513\250>%\273\3011\247\v\366\16\\\f\222'\241\226\32\226e\6\371A\320\264\306.>\v\275\276\r\25\26m\300\7\2342\2770|\322q\16\242\264|\300`#t\272\345XS\334{\345w\364:,'w\355\215L\324.}\330z\240L\353\177\364$\321\330\305\355Eg.\5=\317\315\222\303\211\272\257M%\371_\303pB\34l\1gz\345a\337\361s\246\222\242\307G\212\3\257\336\5.\364i\205-\300~\373J\207F\234\271\343\207\245\260\332FQ. YW\3\264o\314\33c\232Y?{ef*\274\323\336\215 \23\327\f#jS\17N\267\263Z\n\316\233\3\275s\217\203?f\325\10\254\r6(\3728\345SJj\264\375$3\244$\6\21\3466\3=*?,]\1778\f\326\313>?\360 m\377\270\7\223xY-X\252@}\26\201\225\374\30!/(\200\fC\267}\203\377\253\314I\321\36\10Ia3\4\365>#\323\t\303XI\35_',\26\233\226\243\262j\0076$\322\377\342\2703|{lM_\230\320\332\244kx\366\262P\243cb\214\205\327pO_A\1779&\242m^\277\345\360\257 \216\266#+\"\1772*\344\345U\177\4\26\327\221R\274\350\211c+\372\331\343\271\3104H@\267w OWV\r5\205\365l1d\266A\376e\320\253\233v\22g\32\26\225\315W\257\\\271\214'i\351\261\306\236-W\316Y4s\273\244\263(_\34\32\355\27\271?\344\32\225\211~O8-Ku&\24667*^\325\342\354\264S0R\323\353+4\204\212\324\264\223W\304ho\266\373\364\27,\327\317\341\27P\3762s\354\274\212\6\7\320\217\235\370x^\254Qio;]\316_K\236~\312\261\317\347\260\n\370A\347\274\320T\333\217>\f\211\376L\220\255?(JY\312\356\321\37;\24\333\200\224\353.\373\253\256\373W!\223\373m\344\0379\2516\332\17\25\325v\330\34\242\30j$\351\207mz\321\204Wz\17\377\320\206\272kD{\312\360\310\246\315Q\7\300\334\347L\233\212\275\265L\237\367\261\335\36\351\332\f\351i\371\312\346^\216}\205u\25nn\240A\0\2\235u\344\237\354$\261\371\366\342\257*\337\363\201\350\347\277\216u\214\277\270\242\332\01614\316 \342\fv\346n\21Z\nO|&\2\200ABe^\224\272\204}\213\272J\377,\340\361\353\304\34\300\30\230\372\26v\276\253V _N\234\300rA\301&\301f\6i\250\2703\312\366I\364m\374X$\311\177\32W\202n\33786\205\357ajx\266\325\372b\275\310(\361\234\3715h\263\236\354I\340\220F\366\5\254\0206\256\354\277\376\201\371\240\224=\314Ir\300\362\357\3075u\320\342\314QK\223p\312\303\30r]\4\02646\2638\225\235\227\263 \266\317\314\234\1\22\2605\212\33\225\370\2065\257\222\361y\260\275\22\306\262\4\345\346ry\204r`y\204\254\211\10\341\20 1D\361\256\355w\5\247\0368C\5\362\352\16\256\247<*\262\275x*m\270o\237\327\277K\334\352\270\361\240\21n\323\3329\200\"\250O\33_K\232\343\26\370w\216\234\277\10\35'EB\351\4\v\220n\304\265\322\225\356\357\f\300\t.\274{!\2\7\301\3726<\236]\226O\327<\356\330\364e\265\346\225\35\241\362\327>l)\227\326\31Wn\200\313\300c\22#\254upF\365\3I\226\211*!\206\244\270E\336\20\177\3311\r\230\237\332\236T\235\201o-r\377rkW\10k\243\336\222\343dF\207Y\247\0060\355\303\315\234Z\31\232\352\237\340\342\226\4\300e|\33x\343,\322\335\f\17\234\356\376\203\332}\331\267\22!\264\227\261\3038\267\232\23`\240\25\245l\354A\264\342X\375+*\374c\364\356\274r\344+\361\30\376\365X\267\325\303\217\22<uw\277\371\20\227X$1\356\345\266\352\334\276\n@\373,)\262\235\233}B\357\212Y>\366#\366\207\263u\215Y:\265yxv\325#\276\222H\177\232\340\3574:\354\215\205x\330\246\237R\37\365\326\3151\202@\325\230'\215#!\324\22\227u*\2d/\350,\227S\211\\\372x\276h\306x\254$\304\37\362-\201\"\336\307\33\21\216\22\376\224\317e\22e\352\1=\213o`{\352\302\242\242\t\24\16\331~\237\270@\2708\207\203\303\177!g:\200#\"C\205bP\204X\34t@\203\353\215\30\363Ku\374\352d\246\305V;\363\237\370\272D^D\23\327e\273\206\325\311]\260\214\352\207\231\300_G|\332y\347\3357\222\260n\\l_\241\374c\32$\377*\7u\374\265\214\352\20\f\5\6\261@\210:ja\364&A|]\365\230\0\200\245g\326\34\325D\264\366\327c\n\2544\232\317\32\234ln;5\26\203\253E\377\323\357'\3358\v\256\212=\32SI\340\376\34P\205\273\216r\311\21h\260$\374N\230\r+b3\354\270\320\32\217E\36\2)\300\31\7@)\376<\374\207\22\362+\rO\226*\27\0354\f\307y\2148\343[L\346\363[j\257\235\26\3360p\211c\371\321\222\221bX+_&\22\231\315\311W\346>-\363\22\365\234\221\311K\310\354\fW\3401\342h\215\361d\202$\254>\352\363XC\231\263G\35\277&?\325M.}Z\301dXa\270w]\361\376g\30\322\264\216\327tbk\357\327\274g\5\251\213_\331\203U\334\2410\261\252\210\234(\227\330))O[\200\246$;A'g\364\360\247,r1\254\24\276w\277\273\364\377\n\224\327w\267\316y^\353M\4R:\5\372\25\351\351\324irX\330\317\365\36\311\333\16\223\340G\243\331~\206{\f\224e\266\213+\254<\330L\236\226\376\245\264\332\374\335\1\373$\200!\231\313\201\235\206</\254\353\364\t\273\275CfR\350[\1}@;\332:\231\274\324\362GML\215\312#SY\315\323IU\302>\33\253w|/\366O'!\2003\235\325OIqy\254\0\347\241.]\2760\211\345\325\311\3k\265\202,\234\333y\360\f\201'\3602!y\203\265\3471I@0\241\3470\2\263\v\217\320\322\233\233\200\277\202a\16\242\266\"\236\177\234\372\t\211\250\363\16\245%\211s\0273\246\267\200\353{\315\202\20\r\361\10bs9\316\372\356\372m \252\247\243O\17\317\330\226\36l*\16\341'\366Bi\324\"d#\0309\364f\2309\r\277\223\311\223\310\234I\267]4\3322\330\377-\334\242\300\3676z\274\v]\334\265:\353\272?xd\306{L\22\n_\254\20\272\220\317\214'h\242;\22\253\246`0m\366)(\300^\371`e_\35\262\225\34\367\341\2723\f}o\3276P\24\270\210\35\200\316g\312/>&\370a\\0\207%\337\323\244\343\201\246!\210\vi\321(9z\n\31\333m\367\23\354)\355\343s\355V.\316\200\372\0235\341\230\347E>m{\306\237s\235\224:\323\315\227\340\345\302\206\363\31\22$\224`q\r]\223\34\246\223\1\273\244\277&B\320\2344x\303\2744\271\367\316\212\220+K\261\230\31d\225\34\364G\16\230\204\221\31742\t\216\303\214:w\355\342\377\325\277\377 ?.~(\2411\213\267\274\21\0 %\320\311\21\\i&T\355\345>\311w\236\354\211\241\256\245`L\373\237Z\342\201=\273\233_\34\244;\357\22\333\230Up\277\2733K\2/r\206\316\5\224\n\20\231\335U}e\255\207.\357r\n\367Q\206p\2\201$JC\276\21\251\345Wy\306[*E\323\25R\307\351w\372j\261!v\210P\230f\5\333\220\266\373\367\367\"\1R\215f\31\10\23c/\305F7]\300\0\243\313EC\267\261\0304\326R\300\342\344C\350\242\350%\267\333z\316\372\36`\256\2173\7\253\232\347\225\0358Kn+\224\224{\311\223?7\"+J\230\2733\246\216yt\312A\353\30J\321\222\234\377\243\231\22?zfAO\316:\344!S#\255\v\23\3LF\266%|\240\304\236\352\207M,\n\320\214\255\215\363\242 \332f\313\353\0\322\204C\254s\303\244\244,\300y.}\247e\234\251/\346C\23\206\217H\326\373\374\0241\323*\221\350\365\222h\345\226\25\304\345dn\205\2413Qr\215v\212\7\326\6\30Z\273+\10\334\333AZ\7i\201{\233\232\362\376\226\274\340e9\215Y\324\305\226\333\275\211\257\274\177\211\253\301\371\24\301\274s\243\366\10vN\7\257\216\307\264\262?\20\346\333\200'j\361ON'\276\312\373\274ht\345\203\265z\353\242\230\36\205(\0372#\36(\275\177qN!\34)"..., 16408) = 13990
09:01:58.042106 read(3, 0x20f67de, 2418) = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.042183 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 907393}) = 1 (in [3], left {14, 898735})
09:01:58.050979 read(3, "\247\332l\215\23\207X\262;^\n\302d\361\223G>\206\337\0378\336\365U\202\266\35\0\357\233\212\3204\36\203F\345\3262)gz9\331\302A\304\244\241'fu\25\376\317]\275\234pb\315?\32x\317\fx\331\326\25@\352\3638\341t\21\1`[R\317\253\276\250\211\214\352\25\262\241sU \337\276\366\274\23\354\265\2535\366\266\237\224]\364\23\212\333\351\262'\346\316\344\235{S\230Vs\223\261:s\320\343~N\321\261\305\373\302\247\26 \224\177\22\16 \233\260X\330\236\237\34\31\347\210\20\33\226\375\335\6\274\265\307b\215+\26\0\332\33\246\212`\267\5\312\2671B\211\205\263\177v\372\204\375/\267\277f\303\256UB_\231\353\205\227*\312y\257\276%\255\265no\322\377\0326a\200\254\312\210\2745O\30<\214\243{\255\225\35\320\207\5\321k$\36(\341\244T'Y]\332\341\242\254\203\335\353o\236\243\352-^\255iM$z3\30\261\265 \0241-\316\256^\343\324i\30]-:g4\352\210/\246\367G\334\3120\1\314mI:\27we\341\252((Tn\265\2@\20\20\312\245\311\367C\354Z(&\234\322\376,#n\355\257I\33\362\22\203\267\312{.\300\352\233\227\304\322\273R/\340b\233`\314D\364\7\215.\\j\353\206#\303x\10!\206l\0215:\332\337\35\24 \\\242\371\215x\206\24A!iK\211y\306\275\304\223\351\214\252\365\301(\260\236xR\217C\rF\n\325\277]\216'S]\216\17\255N\257\321b\374\317\32\\5Q\34\267\204\206\330\30&\252W\354K7]>8\225\365)m\203\2.\337\241\16aP\267\337xx\2672\261\202\267\201[\375\205\373\277i\262\360v^\233~l\250N\372\244\1\214W:\25\202\4v~\324\326p\25HP\323\214A\333\303\270\331\332\271\236R\27\312\r\362\257\3355\375\324J\314]E\236\353\1\25\231\320\320l\213Z\3\200\5\312\234\365\340\341\253\326\250!\374\315N\210Q}\245%G\23\203\260\305(8\2316\277I\34\16[\36\311\207V\322\25n\v\273\212\243\340\2035*Q\3071o\371py\32\373\31\213\202\234f\276\215\356RkEv\233\304\364x\203\274\0yH\242\23\315\300\344\17j\323A\333\271U\237E\340\376\210\277n\235\273\214\31\232/\303W|\202]&,\361`%$\220\337\232\251\275\325\27\324\20\223\26\221\336\\\207\324{\3273\341!\304\317nu\304\300\36\16\302\\<\327\372\327q\33\6\t*hv0\323\\\3629\nH\262\33\355F\fH\343\337\364\326\317\340\323X\320,M]\254\242\313\352$\272\305\372\261\3\277s\4\22Z\224\244`\240x\242!|\0\310n\6\v?\370i(yd7(\225\\\307l\7\326.\222\327\367{]@p\20I\21\210wV9dz`}\37RH\233\272\5\200\360\340\337\33cm\352\0359\f^\211\226\265G\24d\324\363\261\230\242\225\365U\3A\220\337\271PCD\270\1K\310\0\2730XJ\204;x\237\333\20\275\207_\313\350\20\222\204\323\tm\10\23\2758\332\26\354\375\376]\1@(\237\306\20{\354{\177\345\254XBXV2\203\352\257-R\336\337\365\340\322\243\303\322\374\320\t=\262P\272\244\350\374\311\33\206t\205\30,\372HyGF\303\25\24\21S\274;\351\320\221\244\1\345T\362h\177C{^\17\345\21717\343$\37\340\f\361\274\351\233\v\22r@=.\223\200\271^#\263?P\2102\35\322M\262\\\240\32\317\3\243VB\f\356\375\365D\341\357\360\372\250\353@,\7B\207)\223\266\"\2\313k\322\217]A*\6\20\305\34\247\234U\337K5\351\260-\313\16\360.\362Pn\246\374wZ4\3\244\26\203\254\206F\334\246\337\342\363\240\217\234&\232\200\245J\7`\265L\1\362w\277\223 !\216\371U1\27\321\4\r@z\224\22\304\20\212\262\211\306\20F/\7\317\313\347\305\337\216\337\267#\274\251\235sJ\34\10\370\24\311\334I\24\333\211\376A\230\226\241I\374\352~\252T\261\371\363\r\220^\302\355&\222\256\204s\330\\ou7\25\341f\250z|\350\226\342\345-~\25\232`^\304\332+\340\323Cf{\226%\304\03076\343w\344s\212\301X'F\272cxd\260k\4\3204\205_\215\36:/\245\216\216~\25\353\27_=N\352\22\230{\246\36,Q\327w\345\326\314\200u\223:,\365*\337\376\262\231\324\341\204]\340\212\30\265Z;\351\310\0\231\272vi\334+\237>8\352\371\365\300w%\32\223+b\343\263F\345,mVB0X*\231L0\260\361\310\202\373\177\32DH\323\316f\354\252\267<fG\2560\31\37\270R\364\310\263\3O%\331;n\271\205*n\263\347L%\310\267\30\223\213K\314\300\254\206C\f-qW6\323\f\0258\32447\255\32\367S\275\365\207\344P#J(\330-IF[\16\33o\211\311wI@K\365S\212\362\0177\3Y\370\312\263;cH\306\2\256\221T\215\24\245\316R\375g\n=\216\327\276\307?\211\212E\257\16\212\36\341\32\6\220\0\265\330\340\36\241v<'\320>+D\320\321\222f7'\342\322\333\16V\265\331\370\0304\366\357!\275\22\346\353\350\255\305\335\201iW=\322[\n*\274\256d:\247@\301\330M\206", 2418) = 1448
09:01:58.051288 read(3, "\316\16\357%\211PK\376\337{\255x\356`\255W\3110\350\242\322\273\343\264\244\331\307\230\"\300\30\213\223\366\"\22\266:\255AT\245\364\371\26781B\224\262m;\20\371\362\313Z\2\257\322\214ldl\5!*\212\210\332\271}\266\330\3750$}h\355\3\251e\20\r\262\246\256\235\215+y8\2079\305\245\r\353j$Jgt\24\302E\316%b\207\250\331\334[\323\10\331`\2\305\256(\241\261\306\6\246(\240\30\27u\0\26\36qe\23\206\341/k\24\t-\304\223\262o\361\226XO\371\312t\n\323\323\216\351\f\213a\261\255\224=\205\246\3175\206o\350\352v\r\343T^\213`;\313\271P\201k\375\372_\"\213\356\257\371`E\215\nl\276\210\21\254\225 }-n\357\261\341\277$\277\352\373\3102$\261\2107\224,\242\t\312J\303\374\251\330*G\330\310d\262%1\177\330F<\262O}\35+Ac\372\346h\350\3\252\261cQB\314\226\31\333\216\322\256\371Qf\367n\312\315X\256\267z\225\344>y\204\20\356Aje\r\311Z{g\253w\314!W\271wx\313\2528\346\260fj\251\234\256\361aF\234t_k\336s\4<\335\356/\330=\223/\350Q\235\6\7y\276\316\"S\34G{%\243UMI\215j\264'\253c\245\275\325\352\\\322!k?\345R\315\373K\320H5q\312\227m_\255v\301xH\315xo\254x\276\314\235mY$\311\240\267?\205z\263\377\254As\211\34\225\f\357\350\314\31p\307:\207#\233B\263\244\0\365v\f\223\32\377\375\207\t\2710y\351\226s\37\366\220 ~]\332\347EAp,\236\354BdW\274\316\35{ ^\336\345x\216k\327\307\10\2670\247\377.\343\273Q\303\20#\257{\214\345\261\6\357x.\230\350\232\250\324\353bt\t\247\342~\244\235\347\236\255Q )\373\215.\202\251p\333f\336\377\261\24\vt\1$A\345;G\241Z\305H\330\340&\311\253\314\250\251\365\221p\244\212\32`R\250\312\363\0nc\311$\274\32\322\233\322B7\351\227\272A\336\325\217d\334\254\336^\21\32\3\244^\374B>W\2\332\27\213\234\266`b\27\25\3575\322\311~\346\205-\24\351?\347l\306\317\217\305dbC\200\240\277\304\2o\366\254ij\320\233\250Z[\24DD\257j37C \354\10\1\350\t\327\260i\315\262\274\371\373\221\213\275K\361\n\266sZo\353\336\342\371\276\201\247;\250\341\fZ\306F\344\315l\3212\322\274U\377\10\323\376>\323\355Q\f\374\217\341m\377\r\367\262\253k\30&C\303\321\33~\225\207\204l\"\230\353\354\313\342\204\240yhAW\233ET\302b\217\274\343u` \355\240m\265;\321\267\225N\255X\214\334H\261a\272v\216$\253\312K/9\272O\357\325\226\274\240\230\325\263h\36Hk\311]0\226\367\267}\276>\233\257\324\366\211/X\307\20\20_\256y\266\"\313~\373\1776\300S\360Z\317^\242e\333\260>v\377\310\27&>.\204K\226\202\304\234-30\246\244\201m\327\300\202\372\10\20\"\271\341\215zZ\343\242\335\275\36\353\316\252\0179:E`\254\377\320EKUt\213\332D\270c\270]\305\355\220X\3408l*\226\337\352\214\341\314\255j\311\245\373E\32\246;+\200\221\252\37@b?\363\2575\342\352=y\0V\236b\231EEj\371I\2107\337(NqAX\322\366M\350\325\n\237\220(\252\377`\3257\253\204\246\332>\310\7\2531\3\0\300\2\274\316L\10\36\243{\20?\237", 970) = 970
09:01:58.052097 brk(0x213e000)          = 0x213e000
09:01:58.052247 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 897331}) = 1 (in [3], left {14, 897327})
09:01:58.052397 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 897180}) = 1 (in [3], left {14, 897177})
09:01:58.052691 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 896887}) = 1 (in [3], left {14, 896883})
09:01:58.052836 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 896741}) = 1 (in [3], left {14, 896738})
09:01:58.052946 read(3, "\27\3\3@\30", 5) = 5
09:01:58.053001 read(3, "I\331+\236!&\370\250\202i>@\274\3405\371\240\303\22\207\\\315\270\320\f`\n\230ne\343\350|\247/\211\340\377\220\355G\347.wA\t\310\324\317\341\257\f\376\2U\327F\242Mpiu\324\256\3\272u,N0\275(\25!{|\300\217dm\240\26\234?$g\256|[\332\265?C\347?\375X\352\250\252\356\\q!\200\334=\10\357\373Lu\273\317V\376\32\300\347/\234\311\3010a\327u\22\27\0\352\225\261CP\322k,\33\215^2w\237\31\337\316\2554FE6\27\224q\357\3067\274\376\316\271\10 \336\302\244\4\205\314>\252+\22\342\33w\361w7\252\266\333\346\306\264\362\20\5\210\237H1\342\317\"fNU\330\254\263\23\361_p\273-\2s{\5=\303\26Bq\233\370\227\324\351\323\242\241u\362\301\257_\354\4\376\27\345\34\236\312\37'x\230\3677=\230u_X'\342\230\177L\210\360\346\32\326\325\4;\4\224\3140\344\26\206\v6\251\31\257\260\324{L\22\3042\354\304\315\307\0\36\30\377\2069\215\30Xa\251:\3545Z%M\227\303\n\346oY$f\310\237\377\256\3\344\331S\371im\265\335\277!R\347\262qP;a;\304\335\325}0\26!\27[D\225\350\272\326>+p\365\21\300\336\4\221f\361\6\201\217\230*\225xv\337\177d;#4\325\303\265\273\245a'TU\210r\234\206\200\10\233\32\326\261N\203K7R=-_R\305c\362$6R\252\31\362\230\300\331\261\311\264\270\341\316\6\21\275\230&ftr\314\233\26!%\326\350\37\37w\35\246{\306\266\324\233\311\367H\275K\225\376l\257\334X\7\213v\346\275y\274T\364}\3252\17\n\245;\267\261\202\2038-\333Q[\364\222\321\217\223\314\316=\224\237L\3236\375\306\275\3267\233\253\271\0209\273\231\370\340Z\320\343\314\360\261\253O\t\2376\r\260\332\325\333\336\305p\r$\370\374)~\3032\230\267Z\235\17\21j\2069\302\34\327\4\250wk7\204\334i\243rA'\371\237b\321\5\34-\35\4\223\322\3\254=z\36\212\207\332\343\2\2571\\\"\217E\177\242Uwy\332L<\215\223\5\272\201\330^\236\257#E~\223J\217\255\"3\314\276\206i\273\1j\"al\373\327\262\25BJ\17\267i\255\300`Q\213\4\37\354i\\a\310\322&(\365\203\30\30!\2546@\362\257\334g\327\305#\0209\4\255M\240\343\26\247\366#\235\37>\200}\1\332\270\271\21\246g*P\236~\177\234\324\245}<se~\242G\204A\301\321\334/\221?\3168p\345\26\206\302\250\25\tB\335x \266QM*\373\235\377\327U\305\325e\331/+\322\310\350\5\311n1\225@\260\34\250\211\324\1\251\201\252A\22\302\v\361\237\270c_\350\232\1/\351\2512N\373j\314\377\td\330\3301\301#\217\270*\307\237\230\353\230\333\340\370\370\323(v\332\231kz!\0F\20\317\24\201\356\2473\3\"\306\3471k\356 \24323\365\7\313\364h\340o\\\35=s\356\341+'\352\216\306\25164)\345\32'\262\255=\214\240\314\204*\3436\356\311u\263\201\35\241X\177X\323\177L\0006X\224\372\331\243_\6>5T\250\317\226\304\215\352\254\224\7\6\355>\226\16C\307\324\231Z\23{-y'\275\340\336\360\26\307Z<o\17\374\35\253D*\317\203wP\177\2\271P\333\341e9KM\230+\5VtD\262\2421\21\274:`G\365X92[D\362}\v)\207\33\342\277\225\336\324\354^37\356 \f\232xg*\273\375\35\230HFw\5$\361\237\272{lVEl\35\357\316z\204Q\n\321\211\262\270\372q\20\360\313+eh\331\251\ro\322\223\353\240-\35\231\337k5=\217Y\332>q6\342\335\\\305{/\334'\230\223\2\204\333\3342(\313\266R\277\234\3564\256sAtS\3147\234\306Y\256\356\273Ncp\346GZ\344\271\312@\300\255\265\342B\310E\304\231#2z\v\3\30\37\217\17q\22\216V\177\335O\321\3609Dn&\205\253\23\365^/\255\370\t\256\363+\256\217&e\220\321\247\373\365\321\372\301\210\215\305\340v\315\357\276o\222\354\375\32\\\362\247\322H\253\224\317\341v\25\20\270\227\222\252\374q\0\205$P\220[Y\235$\374\30\366\277!\311go\4\245H\231\344\343\375\307\302\7\233\277\245\303\256u\314]\224\301\207wb\201jG\334\277\6T6 j\241\n\364\23\257\275=-o\310\22*\5\35\203s\311B\204\n\21\263y\35\230\n\30\316\354\304A\251\v\350\373F1:}+\3'\334\235mui\261_~K\264I\255+\352j0\210\263\306\24\374\336B\230\242\2\231\3375\235\216\342\346\312\366]'\223\236\332\341\35\345\7\3xB\t\314 \234n/\377F\34\303\214\240}\271A\37]b\353v\252\245\227\351X\307\1{W}\"d\364g\305{D*t\271\334\354e_\353\273\204\177\215\347\264D\312\211Iv\374E\3375f\261\276\233\330 \304z\354\342\"\236\2362\230X[\210\364M\334\253\200l\256\32J(=d\364\301\366\263p\315\377\202^\26\260\351\276\231\3252f\32\261G\213\334\23\274Sl\274&$\2O_\212%\207\301B|O\265\307\v|T\6\360\211\3359\267\34\22M\36\313\250Cm\5\202\361\3008\250\364\37/\2013\315\317\255\356'X\7\231l\364.\201\n\344\324\177\225\214\255\316\307L\307\20\335\6\364H\206\27\22\2408\256\233\343+\235\375\0\242G\2659\2109\254\177;'\261s\33d\343\310aW\346\314\214\270C\344\roI$\250r\316\276\225\312c\32E\370\352\212\236\341\315\260d\316l\210\376\rmM_\377\213)\342A\266_\4h0E\344\34\216\7\254\373J\331i#\2645\224\212gb@1\352\342\221\305!L\376\25\1\364W\v\215\201XB[\5\300q\3511\342s\375K\362\200S3\3CH'T\26u1\31;-\376\26\373^\307]\216\262k\270\3108\323 Z7\177\3\25H\264\325\275\316\t@\241\272\212A\2\205\236\252\17\340\"\247@\317\355b\275\225\23*\351\24\334\226\236s9\313\271\222\207\24\341\356a\232\24\364\304q\20\322+wn\325.\355O\353\210\346u\366\352s4\25\240\23\222=D\257\274B\6w\277\271\273d,B\226\326\333\7\22\207\366$\257\34!\222\331\36\376\25HcG\220K\36M\263\300\250=g\216\3\4X\217\364<\234\31Z\335Z%\31\31\37\2151\360;h\304v|\r9\246\344\2676\242S\250\204\36\35\375\226\rv\4\216\27ye?\322eM\v\343}\233\223@O.\233k~\325\337\371\261H\25\320\266\334C3F\330\204\242QK\270<<\256KL\271\343\202\16c\272 \225\277\v0s\342h\320\325\241\343e\361&\7.[3J>\374s\357X\345\340n\355i&\240C\30^\272\353\36*\201D\337\266*\21\243#\202_\270/c\271\340\376U\256Z\27nt\vL\2753VF\227\310\254AC\201\265|\25\210\345\345\251\326\rQ1O\325p%\n\266\264\200\255:\376AMd\20\212x\201\\\362Z\27&!t\\\221\25\330\371\2}\325k\345r_#\227\207z*\0339C.\235\207\3555u\303\245\343|\331\252`\356~>\1\307\264O=\374\36449\336\16\303\361\36\354\6o\265K\336\31\332\210\37@V \344\370\333\225T\252[z\7\324^\30+\322\n\337\373t\201\225\325\316\255\273\265\37\323\34\224I\273\364\221\323\207\243\265E\26\310\20\226\301\302\247\360\24_s\257\247\211_\214\177g\327\307+:B\35\20\4\376a\260+\327o\367I:\0323\244\270=\211\351W \320)\214\35\341t2\211k\302\220f'+\326\214\244\23\324\201\252\376\204\204\302&\231r}\300\361\256\300\375\3124p\36In\23 \275\r\332\253\f\242\333\n=8\336k~t2i\0\367b\21\377\214'\30\350~\353\2234\310\2\266\r0\313Wu\21D\337\260f\343=vg\257]\277Q\24\226QV9bV8[Z7e\247\3756\235\320\367>\0m)yf\10\35500l\311\225\"\377RO\6#\32z\253\352\"\t\235G#n\376\vE\25\342R\1775\27\5M\17\333\347\360\257\351\311\274\0301F\254\351\0\224\261$\306]=\314\345\241\337\314\36\253qn'\323F9\220\271\226gQ;\344T\310\242\5\16KD\363\364\2066\360\225@\330==\200\365\213m\250,2\327\257E\177\362\6UN\353&K\272\352g\237\f\214L\362\25\\I\226\251\264NA\202#w\365\200\341k'\320\330\315GL\203\211DAuG+\333\321R\304\251\323P\263\232\204\363\234.\230\36x\332\204BK\226\271Q\335\300\302\273|g:\v\242\237\212\235\266\355^\351I\201qXY\271\367\2262\330\356D\2554a\217B\r\33\276\25\27\22!\255\1\245\356\311}\266G\303k\303Q;Wc\3058\324(\336\334\311U&V\23\343n\7&\375\\\3237\263)J\247\307\307K\243\22\331\306\t\1\326\344\234B\3)\205\215dh\246\262\270l$6\373<w[\1\332\256(\327\22\275\356\374\361\30lc\31H(,\"O8\222\341d$\357\231\253r,\253\261\207\213F\315 \r\371/\316*T\215@\316\226\332\226\17|@\200k\16\342\0,3\362\\1\265\252\t m,(\335'\205\203\251\345\246\324\234@p\360\t\263\16\350\360,\325\351$3\2579\274\303\204_\225\344+H\16av\231\36\205\322\36\342\1$J\257\353\31\0168\20\33\333\7Ht\277\304\216\277\375\301\241wV\370\3400\241\327\246\256\316l\27D\204\251\300\\T\373Z5 \252x\367 M\237+\217e\256X\304\206\264\256ZPj\16\276\231\337\32\177\233\274\367\334\233\7w<</Ws \37j\266\304]!\215,gQ\\\331\300\23\22\231\344\226\377\244\253\354\221+I\266\231\343\2413S\310\t\207VO\234\216M\5\235\351'\200\21\34\277\234\3Q\315\236\363\33\327\267\267\332sR30\336E\277\37\364\243\r\233'\332\344\\\35$\376\3074\0232:YJ\t\3205\4\225\2b\360\233\242ceq%6;\301\267\34q\275\33\323\252\271\"\370\326R\206s\272\0175\34\273b\321\257<\0^\274\\t\352}\33\313\245Hk\265\\\250\327{q\234\331\372b\02738\235\243B\233\260\260\272\246\353U\267\331\327\222\243\276u\322{\305\360p+\225\"M\371v\310Qib\31\317\30\304v\211\3511\35\371\331\377W\357\351\317\234C\211\31o\325\304>\3550S\323\376\257\316\27\352\7z\364\256\351\3770!Q\227\273\252K\262\320\2\236\222\5]Q9d\27\236\255?\235\22Z\00238\341\266\342\0\231CC\243\241\336\2512a\337Y\363?\376\330?\347\317\323\256`\351!\32+\25\20\242PL\214\312\24\336\217t\37\305\322F\335\301\350\324\25T\354\210C=`\327\240=!\211\21\314\20\1\301\250\344u\263=\264\331\37+\365\276\374i\30tc\211c'\344\263\344Y\210sJ`\247n\354\246\375\205nY\302t\245\347\276\235\34`\367\341\215\212\322 D \r\242\370\334\256\227\341\"\304\3530\233q\350\\\362\10\t\"\255_^V\341(P\316{\210\35\20|w\rm\352Bm\314\341\305\213\301\37\222\377\3672\277Gq\236- \7\323\343LY0\247\34Wv\242\273V]@\205\330\0\243`\250G\266|\336\244\300\204\307R\364\254\333R\263\206\242\272\27\255>fsI*4y\326\302\326\220\343]\365W\356\260\322\207\336\346Gt~\355c\32\373\3\35\202$\24\22s\343gu\2HO%\352`U;\321\304,)\2372GC;\202\347W%g\311vso\321\333\353\4\30'\215\16\360\235\372!\250\216\260<\225\321\235O\276Z\4D\34\372\16\210\304\r\321Oj\313\2556\364\221X\235\342\37>l\303\203\4\205\17\273A\255\16\272\17Bm&UYi\327\203\256\314\323\312\0260\325\276\201=\263\233\316\2647\301p\336@\213q\237F\312\317\355\352{].@\313<\313\365\234\312\372\240\16\233\264\245\351\31\373\21\302\24\f\36]\347k \303j'\343\345\353m\25\261\f\252M\305\3W\252\30t\371\31\342)\310f\370\31?\310\350\230\f\210\2524\245\235\300_\4^\314.\20\302\272E\34\376\367\325\273#\207\16\312\20K\214K\335pj\274,o$`\207\f\362\363\224\"|\353\211\264\311\277\247\322K\347i\16\\\273\316\2774\301I\357\355\265\267\303\6\214\35H\225k\34\307\22\364\305G\211\310\254\360J?b&T\273\367\337Tz\17.\235\206\376M\312\336+\6\20\21Q\301\302\323e\6\336\303\305\325\225\332\207\312Cx'`\25\5\302\215I*\214\240\255\35B$\310\365!\v\332,\35\225\333e\335\376t;\335\333s\30h\37t\33\334E\5nO\204b\211{\321\247)\254\337\305\3039o\4\363\361/BB\177\213\35\203[\342\344\242uP\300`q\216\244\3\217\207\364\272\227\244\4dte\34d\31\263\265K\201m\343\235\237\312\264F\345`\250K\275s\265\213\233\372\333\222\3650\3729\357`\354N\356z\345~X\203\32\1\347\214\225\274x\241\1\260\337\5\37\370\345\310\231\336D\n\353>\366\2f\314\nG\34\4Hc\10\275A\335DX\240\36\216ycr\237\307\367\264\33\333W\242\354\n\17\37\367\351\37\257{'\347<,V\327K\32L\333\3-N\377\312\304Z\222\206ai\234}/2\343\371\245\325o\314Y\320g\21\367@\234\350\274\"|\377\231\226\216\342\267@~\2137\3p6\326\"\327\275\302\t~\262r\3\242K\272P0\5N\331,\364\315\v\340V\27J\227D\373j\320\241&\344U\342\6\345\35\233X\20k\371[h\241\377\200\327\6L]\v\270Jv\371\211\242\210\310+-h\273\377YAuFg\316\351\350\24x8>\223\375\270\233{S\240\262\235\253\20\313\3559\311k\242\3301T\242r\225\350\211\v\355\225U\354,\271\32\275\21\211\233z\207\221\330A\200\33\242\205\316/#o\3739\271\206\222\243Og\330\213\327`;\352\272\34\301\275\235\272g\204)\340\344\"s\370h\344B\233\233Y\236\3\303\310\372\205\261Z\32=\375D!\222\240BD\315\325\300\24\205i\301\30\31nmQ3\302\0066\372\3352\223\21\220\373\274f\223E\215\233;%^\2265z_\313t(e]\n\364\206\215\25s\222I\17V\334\224)\212\317&Ts\334\324A(ov\364\3532o_\7\360\263\253\242\313\307,\241\376n\225?7\371\223K\300\364\253\31I\265\26W\311\7\314\224\364L\262\212Ww\370x\330\261o{\17\31p\214K\3365\300\267\26z\225\307\22-\261\223\330\225\16\350\233#\334\206\303v\307\25F\24\321\326\241\255\344%\362\33\336KC\3\247\267+\255\306\r\212S\361\26C\207\243s \272\371\264^\230SmE\243\233\243O\227\367&w\323\32wl\205>\376W\337\362D+\271\272\0[\273=\205\227\232L\266\2553\33d\266\35\35\226\267<\366\337\3\25\244\201!\371\\p\257\6\232%\10S\366fXM{\256\327J\374O,\23\375\340\312\212m\322\335\222\337\26\32\256\340\262Ju\324^r\322\22\22\30\367\255\353\323\325\5\344\35\273z\335\200\374\264\217\325C\274Y5\365\332Q\253L\326\263\253\370\345\314\3356\252U\362s\222\241\tn\353\357\354\7\177\1B\250\274yV\322{]\"\310q$=\233\202N\213\3251\364\v\254\255\250\373a\217L\233\217lwj\3&\304\357\322H\4\367\373\270v\335\203,\360c\371\302\365\330\\\207\250>\316\275j\376M\361C\320\252y\334\246\325-\221k\326\246\333\266\305\"=\200\240\302\363\177\232:]\321f\342\0\7\261\323@v\234,\310\nK:Y\313\34|\221u\301Z\3764|K\3\352\22F\224\300\214\321\317\23\304-Z=\347\3\347\332\312\357\216\203lQ5\257\t\373vv\272\253\234\206\322\234p\7Ps\364Y,\250e\263\2\324\202a\36\275|&\203*\310S\273\256\2740q$\337\361\267\266\315\272b\206\356Gy\342\3|F\4wY\351\v\240y\244\310~\201\363\343D\27\257\345\270\305Z\320*\350\34(\226z\1\20u)v[\210\221\276\343\35\327m|\344\210\337\254\217\2264\321h>\312\177\310\320\16\323\257\315\21\31^\36s7\371\216\315\221\275\366G\270\201taw\230P\346\341\276z\327\37\3\3<&\372\300\353$k\226\f\200\235]9\334K\251~\t\331f}\275\372\302s\243\277\235\367T\355_WbZs\16\207/r\370\225\346\211\360\241.\342\324Q\25BY\350\262t[\3628\335j\334\257\364\271\277\3\16\212\315(\263\306\364Y\2123\345j|\200\341\226\307\264\0ip\353\252\353\257\23y\r\371\341\21?\347\0013\324\221~\3431\363\26Z\376\372\33\25\211$\362\350,\250<\240\r\347\307HL\327\354\354\241<_\3\234\246\213$\345\253&\263\246e!v\236\202x\236\267\325\334I\20N\320\361\0\274\313q\350eo7\240=pi\334\336\240&\340\256k\202\327\346\266\37\352\231\264b\256\20\373\27\322\221\370\224gq\16\314\362\273\231\231\4\342\201\331\342!~\262A\311)\264l8\275\215\235:Tm\304\212gi\314\212\33t\265\241\210\361f\374\371\f\336\200\352\243\304\3678*(\260\v\252\177\371\326\302\310\310\375w\337\337\230\217a\5/\f\211\26\257\247\254B\30L\37\16'\232\222\\d>\257&\342X\345Y\354\273\316\0353\350\304\26\0218\315\33]\253\231\337\20\264\354I\270\342\35o\366\37\37\236\364^\353\303w\211\351\24\"\227[\255w34\177>\271\320\345\217v\360\\<\206\363\350\200\254\33ve#|\232\365\204\322\341\f\362*\23\f+\3033\326\274\3263kS\374\360\21\354\222O\312\264\t{>\275\\\35\355A\254\304\255\17\0\267\n\342v\365\17\243\217yq+\276\341Nrc?<r\0243\314\\O~\360W\235\256[\272\370\30\304S\306\31\237TB\35J\214\367Q\325E9\231\21\332\277\324\312\310\26D-\223\331\327\267\2728\320D?\231d\200C\4@\311\246\373K\333\313\325H\232|J\374\275]\222\273\31i\271\t'U\377\233\350jz\210\353v\370\307U\365\316\203\216\17\310v|;M\304\310\22\215F?\343A)M\322\200+\235\3761\36H\241\333\211}C\327\rd\324LC9\22US\200\345\331\270Rf\16\251\35#_\377\20\4\235\266*Q\356?\343X\5\21\247\210\353\10\24\2301t\27\254I\342zH\373\351\240\6\311\232>9\255\250n'\327d\2\311\270\2.($\r7\10r?m\363YhM\262\305\306\325o\361\276\200\"\374\36^'\316b\267\265\323\251\27\24\243%*Q\213\223R\251\274\251\6\321\210\245\372\316\261=\340\366\v\204\277\245\367\202\265\30\313\6\0\365f\231\177\354\305\331 W\n\22\366\31\27q\212s\3\365tGW\262+Bn@@@\\\177Y-\352\302\0028\277\332~\27\\qP\23\232lz\240\223C\201\3704\21\3347\233\300TR).];\324\260\320\302\3705\322\31k\375$\6M\202\203\1779s(\311\200of\277#\302M\301u\361\377\330\373\2325\315}\341\204\326\350Q\"\373\273\243\377X\36\2644#\204BM,\337\20\304B\246a\303\224f\303\254\177\260I\250c\216\251\240\23\235\252\5T?\354\201\31\216s\36\204'QF\323\0241\354\205\367\205\34\365\2117!\361J\305\257\314\324\25[\263{\352\357K3d\6\370-\230<\232\257}V\37\377\333\244\222C\375\265\355\320\321M3:(dDv\366n\334O\17\347\323\326Scj\205l\360Lx\306\317a\32\322\327F\0068\3\277M\353\262iU\337\225\347\360\256\227&\257;\244{\373B\343\316\24\316\303aWP\0342\353{qJ\"Xa\33\262\214(\355\243\221\257\264\4y\366\2512\370=D?\v\230\324\262\326\267\342\10\336\36\377\362\273\262_\241\201<\267\22t\353`\270\364Z\336\30\211\232\24\27\203\256\26\225i\327\221-\367\275E\326\311\246\363*\16}\366\6q\244\215Tfn\205\365\267\26\200Ag\374\326\376\31\357`{\377\330\264\234'1*Ay\326\34\277\234\350\240\357\22Hd0\227*\234*\30\333wh!~NH\1\256z\32\343I6V\232\256\315B\4$0\225\222\3\347Zr\244\273\324\202\267K\307\36\204wA\303\370\214\302\24:\277\304\237\264\300\177j\235\372\356\2711\302\303?9\30\353\234\20(\337\225\261\374\373\3\266K.K}\242\275'\220\4\257\360\237\300\217\242\344P_W\362\342\240\210\24\177/;7\333\256\300\324\311\2\221v\3115\353\202\f\302\367\305t\177Xw\30676\2632\4j\200k'q\370\16\313\4#6\7n$\16\302\177f+\313\233@A\372\3\3\236\235\307\226j9\"X\300\371\246\202\21\337\347\376o\16\f\301\r\336B\267\200\375\337\335\262\367'\371\307.\30G\253\300\360n\6\230\322\26\"TV\331\nC\273A\23\34{n\332\274\273\36\361W\374I\22ET\217\353;\26({\337\0342\263\263\252\3069\332\351\267\220_\245\320P\335\242\24`]V\34\253\231\23\360\335z\250\1\227\337\5\263\1W\361\303\250]K\201\234#aT\31\263\2553?v\311B0\331\227^\3749P\22\242\352\316E\372b\374\305\306\261\242\360\310\335\221i\25Lp\334\336\16\224\206\230\355\313D\333u]\366$\337\306\212\253\365.UW\262\324?\225;\203\246\351\236\5\315\337\373#e7\212\251\27_3Y\3740\0Kf\35\n\217\311\376g=\226\16P\t\342\250[\221t\251\2241\36<l,\310K\317\267\221\271\371\33Y@\254\272}\251f<'R\324\342\23\244\346\242\333\302\247m\201\24\204\223!\36\240\373R\\\377(\276\245\t\336u_r1\267\303\2150'\36\275\216\246\\z\217\335A|\31\312s>iAA\375\207;\37\5\211\177C\353\337\20f\234\202.\255t\325S\206\3545k\342K\327(\364\223X\371\0165\334G\337v\225H\325\307W\333\323\201s\366l\261\246o\34\3620\344\5?\30\243\301\343\271\337\275\27\307\367\263E\325A\234\224\332\355\31\303\251\366P\362\324\270\212\303c\213*\376[\25*\301\330^\0050\203\360\264D\346\261\370\317I\202\370\\\274gm\207e5\3113\224\230\241\1\30690\324yF*b\262\355uk~\253\24\226^i\252t\356\306\22\362\254Q5\307\240\222\3441\331b\371#|8\3153\305-\25\321\370\212\206\371\207l>2\3366\n\21\254\306\347\322{\237\316\265/\20Vk\332\261\272[\336J\222\2624\312\246\244\37\27L:fo\264\310\224\253C\32\17\323K\21P\355\200\275\33\24\226\246\16\251d\372\217\236\34]\217b0-W\335\203rr\222\30B\350\217\255\212\313+\326\31\262\236\214 q\200&s\245\222\316D\n\340\311\357\264\373\264V\204\34\256\205c\r0\22\262\25o\202A\271\276\355\261\33\21!(t\0215g-{\365\373W^w\26\354\375D\210\274\202\332\370H|\355\341N\254C\237\261p\267\211\304;-04\361DR\346\302\0053/`\306\276\355\213\305\1\210\277,\23R\335v\0\31\233|\207\240\376\371rL\366C\20\31\205\31\31\r\252\0Ti\20\310\316\0311\203\345\34\2'K\240V;\177\251\324F\376v\377\257\301\233\331\246Wa\373\206@Z\201\10\346\345D\352~\16$\7LN\347\237I\3243\277U\25\330_\34152\217x\330\221q\t(\324u\255\314\20\3179\316\206\t\305\r8\260\330I\240\20\23\\\266\264\362\206\245\245\332\351\\\357L\26bE\322cQ\275\347\362\353\271^\3\16\201\264\222-\256\320pO\254#\352\335\4\322HB\340F\nG\245\360\364#\221,\350\234r,\r\373\33\207\16\324\313c|\273O\370\316\7\370\235dE\no\17\375\v\206B\317\227\314zv\314><\356\344+\244\266\nr\366\313\302>6\350\325\312V\212\rO[\215^\245h\213\370\\C!{\256q\3205\244b\365\5yt\177\312\230\315\264\0201\31\177\313\224\213\223\273\325Ya|\272\211\322\311\205\236\3301>\207\256F\304\225y\372\277\25\1\320d\275\377V\334\321\32\360\327\300\377\265]\333\21\345\355\300\262\364\366\206\250<\314\255c= B \353e<\1t\203\273\223\215\nJp\300\200ug\364\23\222<J\245j\17\334\24\277mCv\221\377\367\304\26\231\27\375\345\371\261\34\362\341\272\214\341 B+\243\331Q\2245\243\35Y\307R\266\241\22\27\250\213\6\233\211\34\251A^\317_\215\7\17:\257\211\274\3w\243\225\22\301\260x\304\223\262\205\177w\223\332\16o\240B\3s\325\201\253\263\310\265\304}\314n\35\352\363\210\333\360U\324D\0211K\363u[G\0\341\322\"\331\302\320\275\326\342\225^*2\247\254OF\237j0\20M\202y \206G\30m\272T\22O\332\262\376U\246\342\233V3\231;\201\35\257\333W\30\f\327\347\310\310\334~\362\3577\210W\266\n\346\16\352_\256\377\245\rd\307\27m\300(VQY\333\346\263\0\376\324>\345\367q[\353\361\306\240a\333P:\262\232$\23#\2754\324\32H\203r\1\276c\3766F?\10\365-F\312\243\270<%\304\350O\266\205f\3638\364\7\"\314\25\313\213\274\227`\26\363\1\34\257\"N\263z\202\355\7SO\255\277\225\315\277$\221\34\257G\324<\205\201y\320\205`\350\0\312\201\353\372\7e(\34\363\343zR\265tiz=\3563u~DIr\234\236-\366\273\330\272s\343<w\325\233|hn\215\2\306j=\320.(\34698\317\231p;\373fa\202\236q4\21J\23S\3W\243\267\37@Dn\342t\203f\345\362P\217oO\260]\270\320=T\276\343\351\244k\r\214\26\242\201+\202\371\210eH\344^\3368Pw\321&8a\n<4v\226Q4\351\361f:\306\215\250\363[J\3221\224j\312L\264\335\314|h\212\306\266\0035\203\6M\204=^\352\36\251q|\241\322\321\0074x\350a\317\213y\r\22\16\242\327\357\216Y\352\263\373\257\10^t\246\257\234\0041_\331\250\345\275\372\36\254\374\326KB@\235\211\270c\210!\350\356\304j|Xu\234}\377g\213\345\325bE\254\307\3L\375\251sy[\314\36\212\26\212\201\203\26\212tH\3\201\177z\6~0w\202\31\245\317\256\320\211\316\336\21\335e\276e\250\337\344\371\266\310\21\212\0\225\23\26\v\7(\277\300\307\212]\367\10\252p7\30\\J\1q\275\360\313\376`\222\315\224z|{\27\371\310W\346\rR\224\324\330\362E\n\5\26\365Z\30\311\272\341\326\336[,J\307\345\356\223\231N\2\266\0\36\7\262\227\353?\25\23\301\3379t\3504\342!\264\322\272\357^|\267\1E\371\4\316m\325\336Ws\340\351\355\322\260G\346Km|@'\212\3615\240\330\337\266x\272\22s\336\206\375\206\347\262S\332\341?f\r\3601\343}\335=\255}dN\326\305R\257\262\367\246Z\363y\356~\17i\17\332X.YF \366\2462\307s\333O\307&?\342\3\276\235\345E[IDG\244ef\37\241\364\252\"\257\337\2\2%&\1\353\374\355\350x\6$\276\310\341u\233<1I\204\333\f)\22\362\226T\347<M\337\n\346>\356\26\35\22\353[\363\350\313|\t\355\34\276\311\305\0\0H\t\343\31d6\6\206\345Cx\333\257\363-U\243\3712\260\337\265\243R_u\37\260\30\276\341&\315\254\217-Bg\314[\357\221Z\27\345[=A\3632\251vm\200\332\320ow\315\377\260\210\v+\327\311?\234\33\213`o{\250'\326!|[%4\216\"\23\353\341B\242\35\332\224\220\316\t]\276\316\325\"s1\273'&Z[\362\2\330\311\7\tJ\262\236\24\345\306\262\365h&\366\1&#\304o\266K$\222J\0\237Ux\367\n\220\212\310\35\f\314mm\352e\24\317\247q\364\266r\266\3508\225\220\327?\1\211s\223= \3042\240wy\324\33\33t#rx>\r48@\206s\212}\270\247\340\222\334^\n\236\212\344\331s\324C@\6\3148\222W\333\261\363\307\262^\357vd\356\270\273'lo\312/\360\357\241*5\301\235\276\366\204\221\243lz\277\26\266Z\r\307\232\n\263\322\324\215k\316\223a\372L\264f\351\213\27\2509~\244y\223\373\0070\v\267\3335\227\254\27u\221l]\2040,\21B\262J\340\334\261D,\326\277\241w\347\262\334j\0\337S\237\223\0079\252\3505\355+>\314f\357m\326$\236[\233,\324K%7\241d6x\0\224\307\310\313\33_\340\374\3\270\370\314V\242\263\2541\342\255&P\3726\261\331\256\r=\304\245\tA6\265av\345\247S\314\337\31\227\226\204\300KC\213\3617'\363u\17\n\324\1\355Q\"\363>s\256\210\266y\312q?\221T{\347\375\232\223\231\367\f\23\177zY\346@\373\377=\235\373Qt\251\205&\210;\215^`\3n$!\21\363\367\242'\0\331~sb\262\375w\3014\306\360%\354\312\335\"\303\242B\327\n\31w\305c=rU\f\241tJ\361\240o\334\21\27\307\250\30\246!\311\325\"\231\255OMY}\0 z\345_\214\243\207\203~\225J\33;v\367\276x)a\24\271\23\205V\366\256U\225h\234\337\236\324\362F\236\212F\213\223t\20\215\357=`FY\301p\24\224\324\310\315/D\1.\353B\237j\273\3433\t\2\330\214\374RnI^\252\312\27\332{\351\17n\25\16\311\177\272\231\363\250vv \307\322|\236,\"\301x\337\216D\221\224\25Q\324\332\251\213\33f\260(j\241\214`p\17}v\\XJ\6W\210\\S\242\255e%|$\235\206\30\2201t;F\263\257\r\217m\34\237\233\370\376\370>\240\17!\35E\203\357fD\r\256\27\373\253\366.\7Y\277,Z\204\203\10\2605M\276\316\365\341`4\333i\335\215&\v0w\211\362\266\210(\312\t\250\374\346\243\375\32\\g"..., 16408) = 16408
09:01:58.055210 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 894370}) = 1 (in [3], left {14, 894366})
09:01:58.055528 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 894050}) = 1 (in [3], left {14, 894046})
09:01:58.055676 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 893902}) = 1 (in [3], left {14, 893898})
09:01:58.055971 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 893608}) = 1 (in [3], left {14, 893604})
09:01:58.056098 read(3, "\27\3\0031Z", 5) = 5
09:01:58.056140 read(3, "I\331+\236!&\370\251\37}\371\267\f\270\250\24Zd\34\346\7\223U\2465\210\235\354\253@Y\3\224\206\10\322\177\370\4n{<^\24f\221i\307\372h\3236\301E\300$\275U\374C\321o\371sXM\266$\236j\20\0\205\236\354a\275\31F\30W(\35\202\34\263!\1o\222=\205\333\351\266\0\213\2\234\310\353\245\225\372\227!ZZo]\21r\205\316;\335m?\306u\177\364\267\316\254q\21\260f\200\373\234 I \235\7\354=\262mw\3662\305\267\177\5\325\305\330\0201uKWB\322\2276z\22\200\273*S\310\326\272&\326'h\226\220\r\252\326Yv\4i\317W\2014L\377\371#6\377U\356l\347M\36\263(\17&\275v\347\24\r|\322\272\377Z\331\271\232\363\312\213=N\303}w\34\220C\345<\231\32\311\356\211\276(L\323Db\10Z\335\321\30\177(\2326\371\r\331\357\347Y(j'\245\240f\177\354=\224\26l{\342S\16\v\226r\334\177y#\316\365\375C\236cp\313[\200\35Y\353\325\264\201\315{7\276s\246ogD\252yPe\373\276\221\31_a\203\214\201Zxo\373j>\205E\274K\5\214\7nT`\254\t6D\377R.\0006k\255MB\n\207\354\241\273\16\362D\374\27\267\364O\303Q\274\214\0\202\253=\306.\7m\345-\te\234\325\212{\355_\3733\322\262\0w\204T8\306?\302\225\1\363\334\220'\273\241L\300\360?\271\361\225`\4\"\321I\363\242\35H\3752w/&\22\361\223y\226\t\255[M/\340\360\303\256\34\"\302\35\351\10]p0F\252\313\312W\357\373^\334\365\237yM\33\277\313m\331+Tq\302\21 G\331!\327\215xYob\16\211{\334\236\300\317\270\344\220m\345\225\361\241\227AY\345p\244<Hq$E\200\223GV\341S\314ITD+\30\217G\246\373\376P\t~\23\34\274\355t\351\n\255\3244\254vb\343\331\307qWZ\3715p\320\216{q\377?M,\344\324\250\23\321\302\254<\34VX\277\7\233\t&l\211\241\243@\24W\257v\274\t\363r \242\220\232\371\27\0\272p\n\v\375\3105\240\303G\273\232\377B\235\254\220\vg\366(\206\226G\220\207\346g\212bt\373_\321[G?\304\302\3623\305\251\3\372\355\301\237\206\317\"\nI\230_\331\30\362\214\271<\324\7\35\372*\252\247\375\233\16q\262(\4w\243\35k\240\3266\0172\263\274\270I\24)\324b\276\250\363\rj\277\354\234Oe\230HO$(\273.\f:\303\270%\313\214\267\312\375\307\32\363\3754\t\234\326\230\335\245o\313\324=\25T\241g\\\374\21\n\375\224\227\211\21\315\334P\331\366qp\342\253\346\211\247*\271\235.<\213\345\327/\326%\311e\352\211;*\317\330\212Q\370\227\21\303\356d\272\314j\375\311r\245?\372\214\20S\fS\177\376\335!\232\302(\246\321cH\360m\26\275\354x `\3051p\310\350\231l\336Zj\340vw\334\16\316\221\364\337\t<i\t`<N\f\27k\302\r\30>J\35\271\331u\23\232\7\240\347K\3316\303^Yz\211\304\242\343\335\261\274O\344\264\260\3145Z\355\206\266\342\321\220\2\241gz\260C\306\2573O\220Xiv\361\354\221\224\277\201\274\271\237\364\366hfEK\5\253O\326\304H:pFo#\211\325\277\17\177\252%\311Z7u\201\363[>\t\272\256]:\224\255\0\310\10I\310\322-Q;\260[\235\314\32\357d\372\274\203\364 B\325\4\343\22\236\34MG\17\345\323d\336\330\tKC\220\37\21mLj\226\6\234b\\yL1\3021'\234\327\20\316\7\254\225YS \255\366G\316v\3$\213\3\17W3\24%\203\3\203\356\7\3\370+\276\265\314\210\256\r\357\340U\372f\205\302B\342\236\322\35\247\230\230\250\232\265X\237\1\7]\251\217\254\221\20\264Sk\273\364\200lL\315\207\0350\10S)\3\206\3464\342\233u\213\32oIV\223-\231\34\201\27*\214\305\204&pt \2755\324\3249(d\247v\25\32\16\202\270\325R\221\t\27\357\6\3042\371G\276\244\211\00302\37\367l\21GJ\216\26It\374\255\0022W\16\270<\37\321\r\377\361O\252R\324\350_V\0 |1\353Y\361\353\356\340\242\230\206\351\313\227>\224\30\233\373\235\231\231\264\213\270\"\375\310\rC'm\242\177\241-D\220-j\230Z:\4\255\335Wg%E\273\225P\372=\267&\26\25\3546-/\327Z\313n\243Fd\270:\6\257a\347\276\312\325\250\237\253q\344&9R\351AS\211\220\246BYx\352\22)\351+\245\204b1Zc\242`\247\257*_V\332\301\271\335\350XF\f\0221\241\223\353\235\4\7\331;\177\334\220\275\324q\201\312\262\343*\3525Bc\205\332,\376\257D\247\326M\230\334\t\tc\234l@\261\217\2745I\215\274\262Y\312'\217k\30(\274\204\343z\352.\365\342\0\221$\242\n\342+\vf\315\245\200\4\377SWciyR\354O\272^\250;+\3641\312\7\204\210\373r-\17\226 \3ens0\342\31\3537\243\336\22\311x0\202X\r\233\273L\264\360\316\312\345\333\2758\214H\226\363\1\37\233\4\207\253O/\256\231\r\313\345\314\23d\3\304\34\304\3\352\343\362p\212\32\341v\346\371\377\374;\20Xr\341\30fZ\323W\363y\4\270\r\200[ 6E\314\201R\342\235\322\2\264\207\252!\361P\37\277\306l\217m~fp6\311\224\337\32\v7\275\376\213\237\260\37\243\312\3449\34\36\316\253\312T\330~\255N7\302\253BK\23?\374\324w\275\336\24\310\372\243\344\215$\241\215)\320\313\255\322h\337\n5`\342\366\303\310\347(\23ss\326\236\242i\204W\35\242B\336\341\26\20\226\244l\335F \355\201N\220\332\274w;\333\254u\361\243\362\20\250\205L\210\332\0\313Q5|\215\fK9\254\222}\200_\302\300\3561\221\220&v\23\177\211\237\310G<\341\0\317\\\333\332\363\335\340\345\263~\302D\34578Z\0E\301WW\220,\21187;\1J\236\322\221\354\377\377<~\"\354\t\236\333p\350:+u\201\233\215\24\253\374T\354\353\7or\212ivYOc\225\24\366\204,\37668\233\255G\367\21\322\7@\316%\206:\372\253d}\365+\213:\224?\0217\241@\1774\6O\222\20\377\314\306{\336\10\2e\331\376\21$ch\305\251\322\207?m\347\271\337\340!O\n!0\6\313\30]\26\223f0\25\325\304I\35\24\366o\271\335\304c \3075U\315a\0065\247\230\363\"X\275\26\33\363\371J\253\250~\355b?\351+V\32\366MT\237 \222\240\3755\232\233\201\245\210\225Bc7bn\344\356\344v\263\310q\3104&u\345?\2334\6\316S\275\302\v\336\26\362F\245\214\374\222\234\200z\2612n\304\313;\350,\32\270\314hB\371`>|I3+\350i\313=\226FS\201\252Q\35\343U\v\345y\332\22\363\212\266\374F\6\335\366h\333\336)#h22&\202\f!\237Uy\31*\273\276\260P\f\356n\240\n\226D\357\326$\320\357d6\305b\25tf\3262\377\261\26\205\220\222\233\267\350\274*@\347\4\\\312\0\313\317DU\267o\202\260O\5\341w|\267\346\16YA_\242\333\255B\251z\353\241\302x\270\344\262\277\302\300\261\373\f\36\343\332\267~-\256M\302\366\"\277\233%\210\323\237N\310nc\201\253\220\262\243S\20\320\243\310Vstr\220\276|'K6 \215\6\302\217\224B#\242\310\5\210B\32]\302h\10\254\241\323\377An\363\322\255\320Q\260\325\373X\363mC\251\324\350\23193<72\35s\265\270\371Kxw\326\347HM\352G\23\0234\342|a!\247\370y\33\321\246\270@}JJ\244\353\f\256\257N\35~L \210\354X\351\0\276$\277_\213c\220f\215\240\220\6@\23f\361\306\332\336\314WW}B\237\32\214\370\24\303\323,\205Pm\225\0\237P\212\232r\306:\333Z$9\\\331o\272\251\332\341,\231\364\v\214\4}\341kj5\223x\2\261\354\304G\34H\21[\325\10/\\\324BB\211\270\33\367\215N\226\240\342\220\21\366r\372\350\364\20\212\242v\365P\357\n\252\326\10g\257\241[\301\2576\362\364\243\301W\216\2fi\354F\336\31Z\342\26\2053\246\375\1\204~k;\367?\325\327\261s\211\230\371j'\235\10\27^\26,G\343\362|\351\334\361\366\241@\311a\30\240\245\35\335f\5\305\215b \321\"\332n\323x\264\277\267F\365\361\330hr\21~\321\332\276\r\211f\217\16\v\327\220\370*\352\10\3578\26g\3\r\241\27v\235\30\"6\343\320\332\257\362\245h\363\10g\16\244_?J\23a\t$\3xt\204\26N\r\252=\26\250\17I\355K\222\203\23\271{\206+*1B\251H\360\1775\307v>\23\231>\331\227j\344\324\352\250\227Ijm\0227-\30X\377zh\254X0\ng\277IB\360\202\345\3513uQ\274\177\241.\311l\307\204;\367\320L!\277\202Ap\314S\212|\323\3462Mj\236\354\252\4`\25\353\345\2279Q\224\340$\310\6\266`\336zHL\270\26\"L\2732\362\313rZ\204\240\25\2\362nD\275\234{H\317\325^B\304y\262\352}~\201\267\355\243\1.\240r\367\fhDS\221TN\20\333\353\376#\274\321d\211o\"\227\344\326\t\34E`\22\275N\335T\247\230\313,\30,\215\342\360t\26\317n>\212d\226\207\5\314\233\370\37Kf&+J\364\361\233\331Q\347/zY\336l\261\3339E\267)\257(\363\332-`\203:kI\256\200\t\226\35\376L\3250\36\f\214\215\320I\30\321(\375O\27z\376\323\347\224&\200mBOc\322\r\376\347\20\251\1pF\372\261\30\351\31\214\273E\321\256\357\r\24\253\2074=\302\307& -\317=\353o\261?\227\330\366n\320\203\320\214\304\336\302\371\"\326\2358i\364\5\340\260hm\347\25\31\247\214\0\202\31vZ\3044\23\4\f\243\215\374)c\236\362O=\33#s\321Q\347mUvj\347YXt\337c\17JjK\301\31\5\4;r\365\370s\34\236h`\243?\304\16\5y\22\271v\3723C\3725\363\203\31\307\256\223\340\375,D\27fD`\16%:\377'|\364\341+\271N\345\20\242gF\30(2\263Z\361\345\27\20\376O\364\230\314b\224\3569.\364\325\201\346\220\306\17\177\361u\220=\253(\345\3174.ZY\360~\242\222\6\353\306\257B7\341}P\325\342\334\2075!x\246\320)\365S\341\1\327\25\255\234xx\366\275\5xB2\r\266\200\367GIl\247\200qS&\314\314b\361\356\321d\34[c\217\0\305\345x\367\344\221\27\272?\231\205\vs\370\311\337\234\365\330vG\232\327\206\312\17\10\262\343Lc\fI\17\256\377\221\352%N \324\360\201l\222{\265.]\341\257-\212E\3036i\266\343H\266F\226\270j\300\314\337*\314\35\30\361\2718\1776\216\231\374\355]\3\3078/M\27\317}\361\0p\364\320\1\vq\216V0pCr:Q\314\371xu\230\222\2316\254\315\261\244\27Pz\3168b\374>\2330\301B\334\340\31@\315\357\376r\213\365\0317\244 \322\310b\204mT\\\312\204YP\222\234*\31\332tC\272\215\261\327]\2533\26 -\337\306\265\206\333\324\231\247q< c.C\321\\\35\t>\214|8\0\f\320bL.\352\235\335\217\236\266)\335<\340\370\346j\26\264\33\243b\304H\17\4\354 \337\243\30\374\322\341d\366UVf\376\ff\\\\F\35~61\35Rq\234T\332g7w-c&\317\356DE\243'\216\24723[\303\363T\234\344p\311:\5\226tYh\37p\261\360\360\357\264H\0\264\334\325#\274\372\321\275!\260\234\234>\350\222z\307\271\206\362.\32\"\300_\3568\247D\216J\323\324d\0314\262\324\255\350x\35\3l\304\262f\232\360\30\301A\370\230\272\363V\264U4\240\347\31\330O2\257wU\2\10s\273&_\362Zm7PB\20\265\31W\6\320\305\262\0022.\307\373\333\243\261\270\352q\372\232*\370\34\304=\2315j7\362W\262\222\360\4\233\345H\341\264f\332\271\32Q\302\273\207\253NlZ\6!\223\227H\362t\260.\351N\20\4\24\234\360ep\32\276\307\344s\17:\216\360\33\350p\240n\337m\244\31\4V7[S\254\370~\2747\321f\356\252\211\300v\344\263G5\320\26289NYK[\332\7W\332\322\205\312\343(\22o\247\245\354K\177\21\264U\304\275\2738\272\362\307(\342\271\241iL\31\321\224\251\177\332XH\4\3\374Z\270\\w8\250\274^\265\301%x\321\343\313\373\21\200e\325 xL9\226\214\354\242aL\337(\22\376\255@\337rW\336BxDB\332\316\253\254\340v\217h\233\225\266\0015\250\310\255fu\374\37@\210\\\245\212t\347\356\t\0\267\311\2627\237/\2136\273\226n\331\23\343\n4\353\372\36\267q\10\273\246\227\17u\250\300\310^\n3 x\213\321\4\326\270sV>0\246\200\212\211D\"'\340\230o\223H\27\r\346g\250\332j}{&\252\262\1\245\375\334.\210\211K\244v\363@b\4\216,\n\205M\274e\310\0\331YY\360D\0340\340\346\245\n\216\fm-\323\206!\257U&\214w\305\366X,,\305\261\0z\361\1\36\322*\331\273\0227\1\326\375\213e\20}``\343\25\360\5]\264\0\226\0274\232]{\2324\35\275O\205\17\316\250%\334\315;;\365\340\345i\214Z\357\n\17\300\205\3\304\205\2\320\362F\301\250\7\270\220P\3469\265\242\326{\337\37m\357\206\277\34\243\230\377\240\26\252\206\263\31(Ur\355\354\30\10\357mM\275J\250@5`\34<\307\243\35\331\31\215\7\333vrR{wS#\177\360\301\301\357\24\313\334\331\203\16\376\10/B\265YU\205\263\272\222\200^7\235G\16\206?\26\311\244\266&]\364oLd\1\274\374\273\2501vK\23\375%\0h\242Z\305\272D\22%\277t\0000\277Q\371\251\250\7\305\203\2y\230\347b\274L\4\233\23\244wDJ]-\332\321\225\311]\320\321O\212%l*c\322\221\241\302\333F\2128\351\21\25BNP6\31\235\251\30v\31+A l k\216}\177\257\316w5\356\341\203\302\333^t\373)\212\236\22\350&' \3603YA0\0058\4\300\272\2378\351\350Hn.VbA@-\37\242Nk\360(op\221\254\335\v\237\313\264\355\340&c\237\213d!\10Y\370\26S>$\324\366\255\273\203\26d\206g\333\21\177\216\210\350,\3069C\364\304\246\215$\"\246v\247\234\6V@\215\226\261\345\32\0363\34\300=\354O\4\226i\214\260\221J\215\322v\345Y\215@b\32\31\346\206\375\270G\347Y\307'Z\305\20Y+X\241\273W\233=i\254\342\367T\225\337\27:*f\276\203\240F\272\361L\2\323@@(\326\236\242E\251\254z\356\265\344\204ri}\n\247\213\1x\351]\327\232\36<{90\203d\4\26\222\202\34\335d\300\315E\232\260j\202\333\t\250r_t\277b\1\21\233\273B\f\236`x\323\3540.|\307\277\314\2003)\354\366f\344<\276F851'\257\n\317)\231\362\354V\22\21\306\24\254\266\243\202y\315\275\330Dz\234\345\2146\366\270\274K\303\360\r3:\376\306\235\270K,B\247t\373:\327\0K{d\3178\272?\324\20\323\373\241)pE\342i\1!p\243\242\230Py\211\212\t\341~\276\1\345\2\342\335HYxz\271\253^\263\204\34\341\252_n\231`0\0345\311\206\231\321.\0~\212\214\344\275\364\343\211V\33i\244xZX\22\362]\362\37\207\211(\200\227;\230\372\311\276ZV\300\25\1?\303\177\332\337\266\223\232\3103\327O", 12634) = 4332
09:01:58.057017 read(3, 0x20f4224, 8302) = -1 EAGAIN (Resource temporarily unavailable)
09:01:58.057106 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 892471}) = 1 (in [3], left {14, 884821})
09:01:58.064892 read(3, "t\212\371\334\306\f\313\266\323\307\255\336\32\6\r`\370N\343\335\377Y>\366\361\250\261'\300\3227\244\247~\211\357\r\0176\250:s\2431H\1\377\21Ma\233\222\273~\300\202\266\25\221|#\240\265\356Y\247\177\206}G\272\232D\201|\323\34/D\334\3\267\211f\366\177\25\355L\r\35\376P>,\364\342t\335\220\376\341\206\\\203\204\211I\200.\350\231\1\331\316\245\340\322\204\345\312\205\360\250\366\22p\31\217P\371\354\252\21\t\212\306\16\376\217\254G\364\0:\252\366x\307\215:\326l\35\342v|\367]\362\177W\250M\312}\204\23N\342\17\26\36n\n\371\311VU\33)\351\16\372\354\322\262\257\330H/\303\373\37\0_\320\250?^G\177\202\34\217\333\24\322;sp\220\312\1\272h\0\257\26\303<\204\207\370\250\310a\310\310\254pWN \322\220X\210J\307W\320\37Bf%\201\275\237v\335\366\232\205\307\f\16_\225\301Z\365\277\367\323s\226\305\2105\200\314\350qLXs\27\332\372l\263\304.0\352x\344\36\300\241h_\231Q<o\355#\3379\32\256*h8\307\226\241\222\201\310\243\301@a\374o\333\272\3707*U\263\\\346\306\357\335\221j\314:\3123\342\35\226`k!\3639?g\32\330\324\341V\325\354\177\30<\21\"\217\223\267/\243\217\212\345\0279\371\366\311'V\260\230k\3\332b\21j\243\224\34\211\311\367\213\251^e\351\234P%\7\24\35a\322\376Z\316\340@\313\213\237\355\263\214[\"\301\366\324\271\314#\232,\313\321W\317\226I\231\353K\260\f\320\271Q\340\331\345Q\322(\202E\323A\205\362A&\252FZ<\243\21\7\36\351\353\236\34\264\205Q\312\252d~\r\333D\374\356\n@nc\256\246\252\247\364K\211\356\257ft\352\34\3672g\271A\210\177hH\261\377\3718\201\310\350'\233\332\357\245A\302\345g\362\246\213\353\3475K\25Ap\215\236\366\347\32T\0\312]\211\253\341\246\346?:G\316\272\373TRq\243]\357\31\353,\261\240%c\340\241\330~Ht\244u\251\375\275\2249o;\237uH\210\233I9\262\347s\344\260\201~o\36\344\274\246\247\35z\340\214D\6j\334k\265\34\274\3632\205\306\331c\272\372\1@x3tU\322#\37\23X\330;\217\207:xT\33\r\320\313c\360<\347\277'a\275\277\364\3329\f\334DK\243M\10u\233\303\314\350\240\301z\307\265\256Y!\254P\345\233\30We\30\262;\rwt<\30nm\204Q\322-\240\363\276\365)&tZ\226i$\0\203T!\214\325\307]j\24\257\300\247\262\266;i\340\337\302\347+g\\\326ze\263\362\244\304\275\t\372\7\7$a\17\205\313S\317\257TF\10\344\307\351\207p\322PF\204v\354\n\254\35mO\233\254\272J7\242\326\227\352\210>\341\244j>\361\346D4\317y%\36\212=\207\3503U\336\243\316\206\26\207\306\227\214Ywz\320\244\215F\20Y\211\340\364\243\365\374\343\216\366\211\2266\347\267\312a\2\316\341\3\330'\311\310\251\312\361\306FQ\31\230\t\261\257~t\264\10\225\373\217\235j\335&\324\251\315|\16\35\261s\27\21\315\3\230\22\363\346Q\272\273\213\366-\243.O\243\231\255\332\333o\254\244\231\360\314Zq\350&\343\35~\"\243\350+\vn\225\316BM^\356P\264\34\"q\373\304\360\363;\360S;Sr?\256*i\6,\305\354\274O/\253\331V\362B\352\352\305k\247\271`\240\302\235&\346\343\332N\310\17\200\262\362[G\256\245i\331\304p\236\347\256t\271\366{5\300y\370nuq\344\254\2355\243\1\305\237\275\373\27\213\241+\270\2733\v\31{\v2\f\232\2308|\35\273Eq{[$\215\327\31\274]Zy\327\r?4\10\214W0\3450G\37\230\320\260\0375\30+\317\222e\253\337SR\26\323(\236-\371\365\277E\322:\310\262\214\322Ce\367\0\260\346%\33Q\254\256\342\241=\230\27N\34\236g\240\311\260\6\357\205\315fX\257\373O\372\244ax\25\210Q}\232'vZ\247kXW?z\245\216\24g\353\264..?\347\264\1770\366\177\347B\2\3050\264ZN\304\346\17s\264:GQ\347\35\342\262\300\31\204\257\203}\2\320\222\232U\214\26\275$;\371\220\254\177\3577l\4\341k\202\33\213\261u/\214\273\211hrd]\370\260\211\212\206\6\312\241z\252y\22\322\234\276\3676U3\231\222&\260\274[_\10\17<\353X\340\251jhY\16\200h\365M\237\21D\210t\312\255\201\322\30\311\235,\230h\374\275\355R>\250\270\10t\240K2WS>\3130\22ML\336\264\232\345\376.\347\330P\362\21\322W\217X\273y\2o\263\7S8\273\372\335&\332\202Q\332o\277\30\260\361\354\333-\326\375\253\253a\fk\331o\231/_&0\303FV\200\364~\211\260\237\346\20_E\254]zd\241\255\353Ki\365x\310\215\271\366U\201j-\336O\376\346\360:lmzu)\275\273\247\305\255s\205\0\312!\343\353\334\35J\10\360\360w\350\364\214\254\262\354\230\350\16\306\330\374\f\265W\321\251\17\207\327\260\205J\372\331\5\255Z\212\327\370i)\232\375\264\4\36\252\2300@\3677+{~\355\221\246'\223E4aq_\32\177\353\247[s\313v\1\322s\376H3\331}(@\21\276n\240\fu\252\374\300*\277\\\201\2358\4\373\273\326\316\200\1\241y\232f\205\0109C\24\250\234\332\346\373\367\2161BO5/\274\322\345\321&\262_\31\202\26\243H\326\236\305'z\30\354\30\255\351\233\344\f\361'3\2343Z\243\222\364\307[rF\200\304TUK\332\313\5S$\323\272\323-\370O\266\304\20\314\177mj\32\236\371\3\244\326#\340\33Y\17\335\231J\300*\326>\346E0\320\264\241\306\237\36\327N\250b\356\272\242\24\342\2\206\336\241 s\237X\237\35q\t\352\\\220\202\324-\276\277\31o\203L3\26b\204\25\321\357\305E\372G\260<\344\322S\377\337\321:$\244@\365\4\f\f\241\313g\217\244\311\r\242\250\247\366$\222s\252\321\301\355\372t@\224\305\t\250\213\231\220I\2622&\237\341\245\271\212\377\204\231\25\302\344\21\313\25\261\6\331\310\37UK\204\21\250\252\362\5\242\331\35\0~\306z|j\366v\t\271HL\16\214\377T\274\216^\353F\246_\317\16\310d\303\0\356\263\327\372\217\376\267\227&]\222\313\220\201\310TJ\31'/\200\32Y\r\303\354\336\241\237\341\244\221@\243\244\224RI\350\340\1\321\360\303\343v\225Rv(\247\313\310\vC2\32\243\367T\314\v\234\221\0\5\6`\210\214\275\332\321\252\\F\345\314\251n\331\3001~\3436'\321\356;\3334\24\7?\262\227\350\301\3722RS\\\332\254x:)\372\227\276Y_\257\277\26[T?\371<\231N\2178:\342? \352MT\225\2272\354\251-\314D\3666\362\333\270r\215p\1X~\232\327\1\204L\275\205L|\317\335\1R\3005\314\240\21a\324\1*\244\rz\352\262\0077U\367\247\2\231M\222\246\10\20S\335\326\200\n\37n\331\36\3\252\357\253\312\335\336\331D\244{\233;6 v|\375\334 \236s\200ox\253\177\255N\337'i\32\367wL\332\31#\316\250[\336p\340\253\307nVn\311,\17\237G\334w\246\267\224|\273\6 \201\216\346C~\35\327\377\224\rI\312\262r\331M7\207-\230\215C\200n\7_6\326\267\252\302~\276P\20\360\"\332:\304\326\305\3\204sT\24\236\374\242<\235\357\224\210\343\375mj\247\221\320\4\4\316\310\372/\212\334o\t\341f\0210]\347\220\262\375m\351\347u\346f\222\7\17\345\200\323N\266O\250\1\363\343\1\246\307\237;\235\23x\f_\311#i\364\204\4\226!3\215?\232t\314\233OV\247\312M\227,\316\210 \343\232(x\323\36\200vs\262w\356\3150\376#\372\201\307f\360\275\213r\3vg\342w\237A\202\263\"\304_\0239\246<3\372\263\216\0206>,_\3015\256\331\353J\333\271\244`0\330\345\264\v4\356\23K\304\372k\34\352b\331\242\303\322}\361\361\360\333\250\331\\\35\311%\26\203\312\0301\34\t@\306\215i y\243]J8\202j\267\371\231*\225\n\352\"\362\7.\355\244\35\3175\355\33SZf\335\7'\265\303Z\5\347\t\331$\2273\225J]\371\34\20V\322\274\312\0344\0004q\241G\253E\332\272\25\336\223\277v\26k\351\202\244\372\250#\276\322\345\2>c\337\213\310u\\20f\r|\331\337[ \252\t\f\371\352\326-GJ\37A\27\33S\2w&`f\255\372\353d\270\21\326h\250\327\331]\202\26\202e\312E\215\254\365\3452\23\rA\276\347>\255\345\324\16\0\310\200\266\267kMy\240\272\207\375\30\304\313\245r\377\352\305MY\315Ydd\322\365\335Y\0c\177\361R}\326\17{\241+x\206\253\flmot\300,\253&<\375e^\203\346\27\34\251\334(\360\371\344\27\2\200\27\213`3\210B\375\274\23s7r\320^\244y\324\3\221\34\3\374 \4\246\23\270r\360\312m\374\372\222\"m\255\275\267\34 \343\2473%\257\212\252\337\3020x\25\3678\350\375Lr\356\207\233\16\324\20\300\367`W\270\v\236\214\324\252|\311\361\364\312\221?\303\2\376\353\347~n\247#\22j{\267\273b[nr\207\260\365\"7\27\263k\277\6\225\2259\324\372/\2\312\177L\272\214\265A7\31\317\266Yb\313\177\243\33\311\fLe\221\377\37\273j\230@\212.\327;\n\257\203f\303\330\306\316}\354\366\234\233\3\362\233\237\\\266\206\315\21\207\f\266\320W\221\263(\237CC\35\206\375\221\365\346\256F\225\356\333\367\271\32\30s4\372\211\275-\266\205\253\341\24\25\325lR'I7I\222^\222\23\336\205\344\3\n\10UWF\23y\370\307\354\5\375\227\254\227\311\261\213\276W4Gj3W1\343\341o\3pd`V,<\215I\203\0\235\f\2155\23\304<\347p\255\337\220;\216d$\333M}\235\252T\4\276\342\364\1\34\n\34~f\366\361k\273\227i\27\266\21\256yV\352\310N\230\242\341o#v\201>\374A\340NH\233sE8E\375c\322q\271]\324\342\370\261\336I \351\215\254\260\304\331n\375*4a8\30\356Yc\217-2\372LW\34\371Z\337\266V\237\312\370s\230\237\201@\353]\3\322\372\f\2664\17\361)O_f\353w\311\31\207\372.\324\232\32\22\230\3524Q\377\34\270=\4\6;%\253\361{/Y\373\217\306fZ\271\226\t\224\336\t\177X\4\37\355\320\360\307\2672G\303\0\367&\343\346-\f\211T\3745\301I\267k\21\226u\322\361H\3663ZP\234`\1\215\7u\217\315\2628R\324\315\216\304r?\330\271\277\7hF\324\343s\5\353]zmO\200S\267\344z$v\302\366|\365s\335s\236<\302\366\204\227\300\35\355'L\240g\235\36g\356\16\357\n-\232T\24D\367\f\202\3139\251o\262\360\370\236\177\234\211\340\2144<\277\17rR\357\320\245Uj\207\215\267\275[Y\377\222\371tE\216\353\304\333\3153O\22P\302;\371\340\343u\273\305\331\21r\313>\203a\266>eI\347*^Z\347\354\4\22\254\316_\250\1DEl\305\37\320<\0332\262z\2729s\224heNTd\267B\245\241\347\247bU<\367\3024\264\4\266\3461\352\376\362\206\t,\353\244{\305\331\344\\\251\357P\1v\177O\220>\372u\227\247\264>\345\2270\352\334\336d\307\27\313\241\377L&\317\225;\340z\233\205r\345]\266\344f\261\357E8\200\351J\271\251X\0))(w\257\357\210\275\31\25\373\7^I\361\274\260\243\334\305\263\331q\264\273\231\27\353u\277\217\0341\271kf7e\370n+\21\22\\}K8\264.\215\vnh4+\363\272\210\374\335\342.2\315\346\307\342\325\271r\207S\364\375\362\321\231\"P\34\tk\254\33\23,G\4\252k\370\232\205\213\v\251\351h\325\316\264w\17I=\244T\307\330KM\5\7\342\206:\322X\32;\211\371\266V\321\200\251i\336~\361\213\f&\3),\204\260\0053\200\2056\376\17\v*\270o\237\225\250\236\30\367)A\360\321Q1\0\203\344\244+)\26\211\5\226\365y~\323\373o\350_\240\36\240k\31\4\225\"M\200\273&\346\t_\333\374\262~\220+\300<\302\1\v\254\310\353\344\34t\200\203\254XB\314&B&\270\216\37d\3677\234\210\212\266JF\325\2\246_3(Fb\211\\\306\17Z\204%\317\303\227\312\333\r\0w~\313\2\304\27:\31a\t\245\342\35\207\244j\277\3621\324b\326\321\223:C\324\346\216\33\33O\177\f\371\261\310\215$t!VE\23\335*7\235\234\261\0\360f\326|\347\241\262z\211\257,\4jw\266\331\315\332I\310\250v\262\254Y\210\331Ek\17\316\4\247\344\342\256\251\"\247\235\24\24\263\f)\32=\323\310<74j,1\31\3138\30hmc\23\317a\375/\367\301\2739\220J\214\4^\215q%\37R\352w\3502\301\3636\347\261\304\356\337e\v\340\270\365B\243\302p\214,h>\360\263'\226\241\370\3605\224\263\222Z\7]\32\266\276\357\303&L\251wG\311\2\342s\210F\3\\\17\324\301\2448\277\244K\327\326a\336\356\215}\371F\311\220\260\305M\21L\210\373K\272\246;F\317q@8Y\232\323\377\264 9i\354\37\352\326\5\37;\35\250\262B&\17Y\271d\274\34EC)X,\217\2425~\245V\366\2&sKx\344\351\7w\355\262Y\260\20\16\317\340\3422a\324\24\v5\214A\230;\321\320l\213\314m\234l\26}\17\307\331q\20\371\30\264H=\254\344\274\310\256\26\227\f\333\213\331\375\234\375qTY\302\342\350($<\274A\3\\{lQ\34\374\337C\377\213m\211\317\250,ayW%\0045\365)\3475\321G\254\361\6\374\364\201@\351\306H\37\320@\370\305\277\224\322q\267\321?\337\250\353\333P\312\376WL1\306\2151P\262\345\320)'\303O\215\350\16y\33\20pLc\251\331\303\325\244%\2608!D\233\315w\277![\360}\1\336\210\215!\3\302\320\366\275\350+\21\276S\273\237\373\277,\36\2462&\314\371\"\2573t\374e\362g\223\35\326f#=\374\\\376\177\341X\211V\371\333\362;+Y\223hoH\ta\330\36C\357\37\2345\342Ce\311Pfx\301\32%\337Us\307I\334\227\263\270<\251\234~\344\330\330\214\202\263\227\326D\23\4\16\344\366s'\212\356\324\311\247g\267\202\234(M(\202S@\267$\2751-\"P\251/\177zDv\351\36[\262\31!\233\0\16\331\352\304\223 /V\16C\231Sr\202]\217\267\0332Yq\343\270\253\35580]\377=;\222\333(\3016\352\343\245d\310\256Y\347\332y\270\266N\5\7>\212tt\243?\333\246\355\270rH\220P\303\36\341\0\301\n\302\235\320\22\323l\0048\224|\316\303 uw\2432\300&\37yC\326w\322^DA\200\243\22\323\245\203\216\270\r\312+~I(BK3\311>#\2756\312$\332;?\v\247\20R\344\375I\312*\231\215\236n\30\374r\243\306\211\366G\34$\265\375\343z\20w\220\t\346\234+/\201\274\343\nY0\315\3767\364\25j\357hs\1\377\201\nS\303}\16\302\2353\346f]\246\10\16\264\323\20[H\305\247.i\n&\24\331`\343F\2436\205\2412\230\236WR\332\307\226R\260\227=\362[\370p\35\255\317\325\200A\201Tn\213\342\24Y\300\305\331G\2710\376P\261m\2443\270\267\371@\301\36\365?\217]\255\227zM\205\376\367\2029\213c\205y\247\352\365D\354m\355\7]\271\25\247*\0018\21\23Z\325\277\26;\271\226=@\253k\270\271b\26>\r\2468\226\340U\230\24\231\335\246\17x,I\5c(\6\333\34l}\327\302\345\322\336\376\341+5\211v\242Bp\223vp\355>\217\245\276/\363\233\240T\275\200@Q\"\346Y\366[jOedM\275\370\355\277\263\2\352\23\214\177\217\360\254\314\37\220\323v\v7\251v\365H\217}\343\307\274`kc_\230\202\330\245n\327\356\r\314^vv\247\343\26X\30m0\306t\236\212\371\336\317\212\24|\354\"N{r\304\2\201H|\253\33;\375Ct\7\3110\0\222\213\215\332M\201\v\304m\3315\202/\240K\247n\220\337\v\233\366\236\216\377\244\317M\204&\216mN\200:%1\376\v\320<\272L\204\263\331R\266C.\330\220\216l\177\252\33=\37\242\212\302;\231Q`\vrd\273eX\212X$\316/bf\233\270\217\337\216\257\210!\2527)oj\n\354\336\25\251\222\376\225\0010\305\275\374\3558v\301c\21yu\6\341p\323\277\241\\\36q+P\17\34p}\22\301k\235\306\360\1\306\275\372l*a\323\216\354\7P\340j\336CB|\307\246\302\335\"\226\355=n\251EQwh\222\233\233~\7]K\6\247D\376^`\324K/\342\234T\301o\226]\3201\370\260X\374V\25\236\31kS\245\35\312\227\235\212\363\335\17Ka\360x\\\315\330@\23\v\365\217a\240\252K\204\301o\200\312\255\345\267Y\303K:O\223\211\206\221v?\205<\371\t#\0268\200\27\33O=F\335J(\354\202\240Y\320\236@\366\246J(\355\"\16U!N\322\204\366|\31\322\317!\254\322W\207\304B\1\1\253\377\25_\254\7Z\226\373\342eK\310\235\376\374\303V=M\22\243\354\340,\332\340\250\362\1\200\351\321\33r\202\5f\353\203\356\353@\237\25Z\272\244N\340x\35\360\216\30DR\215\272\270\2656\222\2b\305;~\255\246\204Jg\351\240\325\354\355O\214h\244\205\201\304\277\270\231\304\\\270\4G\363N\341\254\360\370\323\336n>\371\10\5\307+\2\323\336)|\375\241\333\207\200U\203\367J\365\236\0\37\257\206\320\r4a\27\221\362!*\357\367Vnaw\304Oo\313\224\30\346|\320\300\36m\340\212~\314\216a\347\315s:\241lCd\272W\256\365\\\1bS\22\317\3354\310$[\210\254\341\301 \6\233\276\210_)\321\246\211\177xY8\277\\\234y?\251\337\252\251r\306M\206\36;X\264|\320\270\237\270uVm\224\256\213\206\371\232\367\315\237LL\313\356\313\"\324\361\344|\22\332*1\362\214\262x\t\364\366\354\222\4;\3332\37\2645\342\205\322\210\370\300-\f]\352\25\227\212\371\242\2675\201D4\233\330\307\32\0\245}_\343\263T\207\243~\244\252\24\217\264\315\27\222E\373\232\236.\344\247\375\277\356\336\325\2674 jq\7\35\222\360\340?9\272\213C6\356\2742\307VE\1,\2776=rv\312S1\302\253:\6\35\t0pkO8\251\235\220\324\251V\24vc\271,:\362\t\25C\333\207\27]^\25\247u\3658\302\361\253X\3469\rm\17\305\351C\316Lk\265\242n\352\220\347\365\255Ov\365\3708\347\303\367<\205o\372Uu\303\36\313\255\206\265~\234Q\372rp\324\217)\245\177\17[\v9I\275\324\"\367g^\324K\342P\354L5\346a\212\t\265\26\"T\326\v\263\355ZQ\213T\251\342^\264\20m\210\343xIS\367\377\264\2200\307\344?\254\216\5\33\207\347L\252\345\314\346\347\254\6L\231\23&\270\2105\231/\307\214Q\2309\25\372X\316\31\2737\365\16?y\314\265h\5\206\344\366\313\357dL\36Q\223o\255\262WT\276\374Ifcx-\373Y\21\37\237\270e\267\210\324\264\220C\251\270$h\243\324i\35\324(M\356\rx\364\222\17\375\366\270\265+\3\204C\354G>\357\3048\315{\300Gh\322\2712\332\r\3671.sL\31\r\rc\37\321M-K,Cp\35\345\232\30M\5W\177\276\222\2\1\250\327\200A\217j*\354\4\306?2\236\221\373q\217\227\177\236\321%\344\360\361 \341m*\2758>\254B\212U2C\21S\213\263\230+$n\262\346\213~,]b\253Ix,\221\31\255c\223\360I#\f\200\367\204K\231\320\2377+\325\355\206\336\374\322?\254=\241H\235}9S:\253\304m)f\24qa\302, \223\215\32d\373:{\253]\304\346\326\352B,`\361\273\244\371F?\25\33\257#O\333ad\n\25\256%'^\306Vap\353\216\274\377\177\252\326nO\371\204$:/z\1\17\327[]\6\\\326R\177\6Q\335\366\r\317QR\10@\372\372?\373\21=\215\214%\330p\256\252v\177\316wj\263\20\0047e\234\224\333kn\234w\237\313n\206\2039h\6\304\223\365\3718\365\307\305\274\311V\31<\301\362m3\232\354\322\221\275\2302\10^GW\217s\305}\205\306\230\230\217A*\342|\364\244N(E\342c\230\304\370+\f\355\310\322\371\364\24\2111@l\362R\223\31\250Cc\231\4\274q\22123Y\251\16\231=\255$Q\367\267j\201\334\242q\211\3\0160\212\236j\2417\262\27\204\204\r\6\314\6\343p\253\23\222\20;-g\262\337\363\"j\370D\373B\256\361\21\210>\177\347\27>\t\306u\242\261[\220\6\30O\367\257t+\350\265\303\361\240\252\373Z\300\361\26V\355\0063\335\320\3562\27\365\223\371\3658\212\354B\35F\225\225\20.@\326\275!p\200naX:\317C\227\264\227\272\32\343-\27Q\362r%\217\255\230\260\361\354\275nV1:oZ\226:\276B1\344G!\241/\260\221\306\250\7y\35\fX\0031\270a\342FM\205\305\323\37\362\330\303Pw\212\255\256\351\214\342\17h\254\347\32H\366\370\207\245K\250\330>\32n\331+\356\366|\330\\\232\376\177\22\5OcP\30\212%\304\374\225\36\244\343\253\317O\325\357\3022\211\212\361Y\340c*\\R3\234H\231\244\246\267\357q\265\24\217\205\307\277%gQ\257C`!\266,\257\272a\3651>U&\232<\20A\366\305\225%x\313r\340]\2650\357\314\355E\2319};m\305\177@A\237\352\300g\206[\34\263\35ywi\352\313.\365\0327\21\341\250G\213\227[-SiG\6\311\324\33\36\223u\250G\355\352\r(\3159\217\374\340\f\17\206\360\345\320\275\"(y\234\217*eG\251\24\356\215\373\rg\356\2\340\242\375\201\203\233\35\32-\237\256\352>\v\v\23\276\0239\331\310Ih\234a\216\236\7\226O8[\267:cO\355\305|\23\17\0M\250\210\237\r5\247\n`F\0014\226\4qW\3276\234IF4Q\265\203\3437\204R\237b\256[XsC)\204\230H\367\252\373\325\341\354\312z\222k\22q\336\260u~\310\267\0219\274\n\364\204}\300=g\336\217\361\200\5\370!\32\261_S\214@\6e\300\267\3\214\233\213\322\253%r\367\327\365\334\367'\322\204\234\34\324\351\26m\205\377\337\5\34\201p-\215\371\22f\207\244k\372\f\363\\\n\343\213\212h\316\1\274C\306\353&\231\276,\274\255'S\353\3\335\32'>\344\216\243\251\3\367[\226\315\361\217\201\323~b\3364\320\0358u\324S\243\265{\37\v\226\257\316\23\4\257A\331\"\377\"\357\360\337\243\201\0318U\210BM\376\203\270\204\32A}\30\371s\215\247\360\256DK@\237\234\17s\252ei\375\362C\225\272\252\3203\266?1\352<\20\357\v\334\222\r\227\2774\4[N\326|W1\205\206\254\210\244\nB,\270\20\322&%,B\231R\304\357\262\365\217\333\220\2039Keg$\234\324g\220\237\204\273\34\301\231\355\232\366\31z\35i3\360B\251\223\34$\v)\357\377a\306\f\257\220\10\207\375\232\203\360%\376Wz\274\5(\232M\251\332\271<R\306\7\240Cr{\241\26\251Gt\231\346\233*\274\233PD\327\374\336\251X\233\7wp?\321E\251\231W\376\27tQ\316\334\202\22{1\2\31\36\310\236\247\354'`\302\2151Fu\230\237\352\343\303/R\33\217$%z\10\4\326\234\1\372\242[\333\262\2508\2735p\1\324\321\370v\216\254[\345?e\230I\227G\244gl\217\326`g\332\313\v\1\336^T\352\267G!\330\317\337xP\22151\301\3605\353\305\203\247*P\302iw\2520\372l9\266\200\333$\365i\1\350\222t\311\r\fB\342\324W\301/\220w\\\237x\214\302\221n\343\354\307\267\321\255\201q\351,\246\371(r=\231\337\226bL\260\351\244~\253\200\225\0019\250x\273\3520\37F\230}[S\204\34[\250,\250\203\262\244\303\\\227i\231\207\342\3763\375\211b\3\0\261\357\t\303\240:\333\16\211\345\310\233+\212\324w_\3\37\256r\360\326\277\352^\25\35\37\332\363\363Bm\262T'4\277\271\36#\234X\357\226\5-l\241\343\347\235VGQ`\200\351\250q\370~O\375\274\227\317\313\356\321\347\250L\21T\210\273\205\301\2469H\337\317M\234\240%\362O\202\224\315\32\347\236|\231-AL\264\2\2\352N\206\351V\334\251\245\232\314#\243\327S\4\224\263\202~\263\201\2762\254\236\202\207\0\231\263&\236\371\254/%X\0037\371\327;\241\255\31\346\3574\333\313\345jE\333\f[\323-\346\5\27X\355\274ba\325\271\213]\24\203\n\313\206\324RB\254s\256W\341\345(\234s\341\205aZ\205rb\360)\265j\352\30\325\224zCr\20X1\334\300b\366$]A!\264\336\256\372\352\247;:\216|\316V?>\262\236\236\345Uk\331\305\322EDjG\t\30\311\320\350M\371\rAE\35B(\275\271\336\233\247\327\302qu8\270(\320\222\227SB\264\356\325\t\273\t\202\246t\345\6\276$\303\217\211\237}qs\0359\6\351\313cj\206le\363\32\344`\251\"Q\372\250\336\226\252\0T\206\303\335q\236s\r\360\265\234\363\306\307\300q0Q\350\\\314M\316\16\266\263`\352\33\32\256\276\271H\306\241\223\251\265\240\373\7P\226\t`\371\253\372\315\367(\250\367\202=\273\300\272\210\243\325\2346{\271\252h}U\237\366\235\367\274d\242\353\311'\232:\212\26\n\271\260\300n\317\23\3521\371\206b\2135\10\340{\354\33\3534\"\303ca$,\246\310\24\202\5,*\372\364\331\253\251F\243\4\307bT\342%\252\v\241\22\347/\351[\210\254\250N\346\321\244\357\321=g\272\275\35\231\3201\237L\1\222\23i\237\340\313m\321\35d\350\211q\257\253?x\270m'\202\254\266\371\250%\v\7n\364Xu\240\312z\356.\34\303\370I\332p^\n\344 \t\207\233`\302\213XY\342}0\253\24\260\264@\361M\312\363\311\310{<\275\0]\372U\350\364\0%D\222\227Y\354 \211\225\215\2763\25j\316\321\224\332\375\331\215\332e\212\32\34\306\204\200\302g2\3\r\371\24\307\33\307S\266\236|N\247\321\317\24\217k\334\371F\272\266\30/\352e\37\257\314\204mblS\250\177B(\n\321\t\225A\257\336'\242a%\211\230\245N\214k\202\2773\5\vnA\207+H#\220\251A\36\202\\\"\376*\4\305l\345\350\335c\202\303\4I\331\326\32\300q\323?W\272\177\363\334\302\\\366\253\vy1\314Olt;\231\325og\177{\307@\217\371\312\364\353\20\206\341\316\363\253\316\r\32;!~\316\206mWf\310\3763E5\277\202\1F\362\223\320\335\257`F\337\321f\t\321\347\302\301\235\325\331r\320\343\331\246\363\263\0166\2630\260F\302\315\303/:u\332h\210I\204\353#KQ\332\312\\\210\37\253\334\216\235\345mFRG\262n&Y\34*!\371I\233C\25\262\372\"%2w\216J\312\212\305\255>cs\327\267e\312\274\244\321\340\330\3\204\326ZH\314\177\227\351\343\275\23\277\3DZ\310\337*OB\315\\\306g\307\31=2\373\3\203\303\340\1\262\v\247NdBab\276\257'c[\362\224}e(\7g\216\352\21\316\26\245D\266\232+\233\277n\3720\2060\375\271\216\253\260-\366\323\35\350^/\270\237\3468[\0060\261\265\225\215\20\347\31`\247\325[5j'5~\362;3W\30k\265*\200l\377H\177\257\21\3409+\363\251\215\265\330U\16\373\241\25\275\223\37\247\2760\337\315O\355 \360\322\201G\200\376\227Y\0322\323\202_\260+\214\5\364\332\336\3358\237\320Z\302\214\3478\277\217\2\376\250\220N\3160\300U\f;\333\363gpZH&\201?\16\317h\26\206pFbF\231I,\325O\352\374\336\302_IS\320\270\6W\2508daX\271\237\305H_\345\214\33\311\26565_\230a\310\204\230\376S\223:\331\276y\263\353\214\210\377H}\276\20\346\267.4\225CP\351\274\274\r\340\266>\274\23\227\24\372\375\254?/\212J\250\204\255flZ\307@\260\261V\204{\205\\+u\4\357\367\322\213\215\305^\214\37\221<\34V~\177t\260cO\302\356\337\33\33\361G\265\21Bo{\330\2211\6\25|\224}\7a\211o\373?\337\r\267K\376\2624\317\t\206rO\355>\275\320\237\376n\216\334\376\307^@F\4H\36n\221Y\16\357\354\327Y-\215\337@\33\373\324\200W\272\343\275692\6\312h\331)\304\17\246s!?\232\324\30\24E\305Ev\266\360\301\316T\266\324\323\311\354d\3\342\266\214\24\205\371\3\276\335\17\367\225p\27\2\367\3061<\10\375\335\314\357\302moP\234=\20[=\323\321\36\331\254\236\27\235\356G\177M\321\30U@\177\306\273y\375\223\324m\360\342\374pY\360\34\31\312\320\321\245\372\372\212\256\213\323I\30a\twE\357\\>;\246\242%kv\262\373\237\377\240\270\25\214\352\313\366!C\223\243.7\325_\34>\373\267\361r\354\311\302\363t\257r\17\322\311\353\322\362\265\221B\371\244\2053Z\272'?\33F\346\r\307\211\210\250m.=\2\233;.S\276\3339\274\263\315B\220\300aP\245%\340\322\220\244\36y9\343\37K\241\326\31\301\263\377HO\\\200dF\320\342\323\3249\340wa\"u\220\n\3\233\236c\273Y\322zVV2rd\276\6\375\332\323\177\312\25\243(\251\325\221V\3\rb\267\202I'R\6\267\302\214\200c7U\200V"..., 8302) = 8302
09:01:58.066813 select(40, [3 4 7 8 9 10 11 13 14 16 17 19 20 22 23 25 26 29], [], [], {14, 882768}) = 0 (Timeout)
09:02:12.962343 kill(4294961786, SIGKILL) = 0
09:02:12.963271 --- SIGCHLD (Child exited) @ 0 (0) ---
09:02:12.963319 rt_sigreturn(0)         = 0
09:02:12.963403 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.963523 rt_sigaction(SIGCHLD, NULL, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.963718 write(5, "!", 1)        = 1
09:02:12.963862 rt_sigprocmask(SIG_UNBLOCK, [CHLD], NULL, 8) = 0
09:02:12.963965 kill(4294961793, SIGKILL) = 0
09:02:12.964762 --- SIGCHLD (Child exited) @ 0 (0) ---
09:02:12.964806 rt_sigreturn(0)         = 0
09:02:12.964886 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.965002 rt_sigaction(SIGCHLD, NULL, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.965157 write(5, "!", 1)        = 1
09:02:12.965290 rt_sigprocmask(SIG_UNBLOCK, [CHLD], NULL, 8) = 0
09:02:12.965432 kill(4294961792, SIGKILL) = 0
09:02:12.965580 kill(4294961791, SIGKILL) = 0
09:02:12.965684 kill(4294961790, SIGKILL) = 0
09:02:12.967714 kill(4294961789, SIGKILL) = 0
09:02:12.968085 --- SIGCHLD (Child exited) @ 0 (0) ---
09:02:12.968113 rt_sigreturn(0)         = 0
09:02:12.968154 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.968206 rt_sigaction(SIGCHLD, NULL, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.968277 write(5, "!", 1)        = 1
09:02:12.968334 rt_sigprocmask(SIG_UNBLOCK, [CHLD], NULL, 8) = 0
09:02:12.968394 kill(4294961788, SIGKILL) = 0
09:02:12.968458 kill(4294961787, SIGKILL) = 0
09:02:12.968640 close(30)               = 0
09:02:12.968796 close(22)               = 0
09:02:12.968856 --- SIGCHLD (Child exited) @ 0 (0) ---
09:02:12.968871 rt_sigreturn(0)         = 0
09:02:12.968902 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.968942 rt_sigaction(SIGCHLD, NULL, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.968992 write(5, "!", 1)        = 1
09:02:12.969033 rt_sigprocmask(SIG_UNBLOCK, [CHLD], NULL, 8) = 0
09:02:12.969178 close(26)               = 0
09:02:12.969340 close(27)               = 0
09:02:12.969479 close(19)               = 0
09:02:12.969608 close(23)               = 0
09:02:12.969768 close(24)               = 0
09:02:12.969897 close(16)               = 0
09:02:12.970025 close(20)               = 0
09:02:12.970215 close(21)               = 0
09:02:12.970343 close(13)               = 0
09:02:12.970439 close(17)               = 0
09:02:12.970565 close(18)               = 0
09:02:12.970698 close(10)               = 0
09:02:12.970834 close(14)               = 0
09:02:12.970976 close(15)               = 0
09:02:12.971107 close(8)                = 0
09:02:12.971233 close(11)               = 0
09:02:12.971375 close(12)               = 0
09:02:12.971516 close(7)                = 0
09:02:12.971644 close(9)                = 0
09:02:12.971786 close(33)               = 0
09:02:12.971911 close(25)               = 0
09:02:12.972005 close(29)               = 0
09:02:12.972122 select(40, [3 4], [], [], {165, 83765}) = 1 (in [4], left {165, 83761})
09:02:12.972257 read(4, "!!!!", 65536)  = 4
09:02:12.972313 read(4, 0x21247c0, 65536) = -1 EAGAIN (Resource temporarily unavailable)
09:02:12.972502 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5503
09:02:12.972696 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5504
09:02:12.972865 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5505
09:02:12.973019 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5506
09:02:12.973171 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5507
09:02:12.973324 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5508
09:02:12.973477 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5509
09:02:12.973629 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGKILL}], WNOHANG, NULL) = 5510
09:02:12.973800 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.973858 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.973930 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:02:12.974047 wait4(-1, 0x7ffe1233c9ac, WNOHANG, NULL) = -1 ECHILD (No child processes)
09:02:12.974130 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
09:02:12.974169 rt_sigaction(SIGCHLD, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:12.974211 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:02:12.974271 select(40, [3 4], [], [], {0, 0}) = 0 (Timeout)
09:02:12.975011 select(40, [3 4], [], [], {165, 80858}) = 1 (in [3], left {120, 720730})
09:02:57.335803 brk(0x2163000)          = 0x2163000
09:02:57.336091 select(40, [3 4], [], [], {179, 999586}) = 1 (in [3], left {179, 999582})
09:02:57.336307 select(40, [3 4], [], [], {179, 999367}) = 1 (in [3], left {179, 999363})
09:02:57.337430 select(8, [3], NULL, [3], {0, 0}) = 1 (in [3], left {0, 0})
09:02:57.337550 read(3, "", 5)          = 0
09:02:57.338025 close(3)                = 0
09:02:57.338529 write(2, "_PARSE_URL: Recognised a ^http(s)?:\\/\\/community\\.elitedangerous\\.com\\/galnet\\/uid\\/[a-f0-9]+$ site...\n", 103) = 103
09:02:57.339370 stat("modules/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.339520 stat("modules/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.339658 stat("modules/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.339789 stat("modules/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.339927 stat("/etc/perl/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.339997 stat("/etc/perl/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.340058 stat("/usr/local/lib/perl/5.14.2/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.340124 stat("/usr/local/lib/perl/5.14.2/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.340209 stat("/usr/local/share/perl/5.14.2/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.340290 stat("/usr/local/share/perl/5.14.2/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.340369 stat("/usr/lib/perl5/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.340446 stat("/usr/lib/perl5/HTTP/Headers/Util.pm", 0x7ffe1233c7b0) = -1 ENOENT (No such file or directory)
09:02:57.340520 stat("/usr/share/perl5/HTTP/Headers/Util.pmc", 0x7ffe1233c860) = -1 ENOENT (No such file or directory)
09:02:57.340597 stat("/usr/share/perl5/HTTP/Headers/Util.pm", {st_mode=S_IFREG|0644, st_size=4888, ...}) = 0
09:02:57.340698 open("/usr/share/perl5/HTTP/Headers/Util.pm", O_RDONLY) = 3
09:02:57.340784 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233c540) = -1 ENOTTY (Inappropriate ioctl for device)
09:02:57.340854 lseek(3, 0, SEEK_CUR)   = 0
09:02:57.340986 read(3, "package HTTP::Headers::Util;\n\nuse strict;\nuse vars qw($VERSION @ISA @EXPORT_OK);\n\n$VERSION = \"6.03\";\n\nrequire Exporter;\n@ISA=qw(Exporter);\n\n@EXPORT_OK=qw(split_header_words _split_header_words join_header_words);\n\n\n\nsub split_header_words {\n    my @res = &_split_header_words;\n    for my $arr (@res) {\n\tfor (my $i = @$arr - 2; $i >= 0; $i -= 2) {\n\t    $arr->[$i] = lc($arr->[$i]);\n\t}\n    }\n    return @res;\n}\n\nsub _split_header_words\n{\n    my(@val) = @_;\n    my @res;\n    for (@val) {\n\tmy @cur;\n\twhile (length) {\n\t    if (s/^\\s*(=*[^\\s=;,]+)//) {  # 'token' or parameter 'attribute'\n\t\tpush(@cur, $1);\n\t\t# a quoted value\n\t\tif (s/^\\s*=\\s*\\\"([^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*)\\\"//) {\n\t\t    my $val = $1;\n\t\t    $val =~ s/\\\\(.)/$1/g;\n\t\t    push(@cur, $val);\n\t\t# some unquoted value\n\t\t}\n\t\telsif (s/^\\s*=\\s*([^;,\\s]*)//) {\n\t\t    my $val = $1;\n\t\t    $val =~ s/\\s+$//;\n\t\t    push(@cur, $val);\n\t\t# no value, a lone token\n\t\t}\n\t\telse {\n\t\t    push(@cur, undef);\n\t\t}\n\t    }\n\t    elsif (s/^\\s*,//) {\n\t\tpush(@res, [@cur]) if @cur;\n\t\t@cur = ();\n\t    }\n\t    elsif (s/^\\s*;// || s/^\\s+//) {\n\t\t# continue\n\t    }\n\t    else {\n\t\tdie \"This should not happen: '$_'\";\n\t    }\n\t}\n\tpush(@res, \\@cur) if @cur;\n    }\n    @res;\n}\n\n\nsub join_header_words\n{\n    @_ = ([@_]) if @_ && !ref($_[0]);\n    my @res;\n    for (@_) {\n\tmy @cur = @$_;\n\tmy @attr;\n\twhile (@cur) {\n\t    my $k = shift @cur;\n\t    my $v = shift @cur;\n\t    if (defined $v) {\n\t\tif ($v =~ /[\\x00-\\x20()<>@,;:\\\\\\\"\\/\\[\\]?={}\\x7F-\\xFF]/ || !length($v)) {\n\t\t    $v =~ s/([\\\"\\\\])/\\\\$1/g;  # escape \" and \\\n\t\t    $k .= qq(=\"$v\");\n\t\t}\n\t\telse {\n\t\t    # token\n\t\t    $k .= \"=$v\";\n\t\t}\n\t    }\n\t    push(@attr, $k);\n\t}\n\tpush(@res, join(\"; \", @attr)) if @attr;\n    }\n    join(\", \", @res);\n}\n\n\n1;\n\n__END__\n\n=head1 NAME\n\nHTTP::Headers::Util - Header value parsing utility functions\n\n=head1 SYNOPSIS\n\n  use HTTP::Headers::Util qw(split_header_words);\n  @values = split_header_words($h->header(\"Content-Type\"));\n\n=head1 DESCRIPTION\n\nThis module provides a few functions that helps parsing and\nconstruction of valid HTTP header values.  None of the functions are\nexported by default.\n\nThe following functions are available:\n\n=over 4\n\n\n=item split_header_words( @header_values )\n\nThis function will parse the header values given as argument into a\nlist of anonymous arrays containing key/value pairs.  The function\nknows how to deal with \",\", \";\" and \"=\" as well as quoted values after\n\"=\".  A list of space separated tokens are parsed as if they were\nseparated by \";\".\n\nIf the @header_values passed as argument contains multiple values,\nthen they are treated as if they were a single value separated by\ncomma \",\".\n\nThis means that this function is useful for parsing header fields that\nfollow this syntax (BNF as from the HTTP/1.1 specification, but we relax\nthe requirement for tokens).\n\n  headers           = #header\n  header            = (token | parameter) *( [\";\"] (token | parameter))\n\n  token             = 1*<any CHAR except CTLs or separators>\n  separators        = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                    | \"{\" | \"}\" | SP | HT\n\n  quoted-string     = ( <\"> *(qdtext | quoted-pair ) <\"> )\n  qdtext            = <any TEXT except <\">>\n  quoted-pair       = \"\\\" CHAR\n\n  parameter         = attribute \"=\" value\n  attribute         = token\n  value             = token | quoted-string\n\nEach I<header> is represented by an anonymous array of key/value\npairs.  The keys will be all be forced to lower case.\nThe value for a simple token (not part of a parameter) is C<undef>.\nSyntactically incorrect headers will not necessarily be parsed as you\nwould want.\n\nThis is easier to describe with some examples:\n\n   split_header_words('foo=\"bar\"; port=\"80,81\"; DISCARD, BAR=baz');\n   split_header_words('text/html; charset=\"iso-8859-1\"');\n   split_header_words('Basic realm=\"\\\\\"foo\\\\\\\\bar\\\\\"\"');\n\nwill return\n\n   [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]\n   ['text/html' => undef, charset => 'iso-8859-1']\n   [basic => undef, realm => \"\\\"foo\\\\bar\\\"\"]\n\nIf you don't want the function to convert tokens and attribute keys to\nlower case you can call it as C<_split_header_words> instead (with a\nleading underscore).\n\n=item join_header_words( @arrays )\n\nThis will do the opposite of the conversion done by split_header_words().\nIt takes a list of anonymous arrays as arguments (or a list of\nkey/value pairs) and produces a single header value.  Attribute values\nare quoted if needed.\n\nExample:\n\n   join_header_words([\"text/plain\" => undef, charset => \"iso-8859/1\"]);\n   join_header_words(\"text/plain\" => undef, charset => \"iso-8859/1\");\n\nwill both return the string:\n\n   text/plain; charset=\"iso-8859/1\"\n\n=back\n\n=head1 COPYRIGHT\n\nCopyright 1997-1998, Gisle Aas\n\nThis library is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\n", 8192) = 4888
09:02:57.342967 lseek(3, 1711, SEEK_SET) = 1711
09:02:57.343050 lseek(3, 0, SEEK_CUR)   = 1711
09:02:57.343107 close(3)                = 0
09:02:57.345512 brk(0x2192000)          = 0x2192000
09:02:57.346168 stat("modules/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346246 stat("modules/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.346308 stat("modules/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346364 stat("modules/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.346449 stat("/etc/perl/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346519 stat("/etc/perl/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.346594 stat("/usr/local/lib/perl/5.14.2/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346671 stat("/usr/local/lib/perl/5.14.2/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.346748 stat("/usr/local/share/perl/5.14.2/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346824 stat("/usr/local/share/perl/5.14.2/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.346901 stat("/usr/lib/perl5/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.346972 stat("/usr/lib/perl5/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.347046 stat("/usr/share/perl5/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.347117 stat("/usr/share/perl5/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.347192 stat("/usr/lib/perl/5.14/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.347274 stat("/usr/lib/perl/5.14/utf8.pm", 0x7ffe1233ba70) = -1 ENOENT (No such file or directory)
09:02:57.347352 stat("/usr/share/perl/5.14/utf8.pmc", 0x7ffe1233bb20) = -1 ENOENT (No such file or directory)
09:02:57.347430 stat("/usr/share/perl/5.14/utf8.pm", {st_mode=S_IFREG|0644, st_size=379, ...}) = 0
09:02:57.347533 open("/usr/share/perl/5.14/utf8.pm", O_RDONLY) = 3
09:02:57.347617 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b800) = -1 ENOTTY (Inappropriate ioctl for device)
09:02:57.347685 lseek(3, 0, SEEK_CUR)   = 0
09:02:57.347785 read(3, "package utf8;\n\n$utf8::hint_bits = 0x00800000;\n\nour $VERSION = '1.09';\n\nsub import {\n    $^H |= $utf8::hint_bits;\n    $enc{caller()} = $_[1] if $_[1];\n}\n\nsub unimport {\n    $^H &= ~$utf8::hint_bits;\n}\n\nsub AUTOLOAD {\n    require \"utf8_heavy.pl\";\n    goto &$AUTOLOAD if defined &$AUTOLOAD;\n    require Carp;\n    Carp::croak(\"Undefined subroutine $AUTOLOAD called\");\n}\n\n1;\n__END__\n\n", 8192) = 379
09:02:57.348121 lseek(3, 378, SEEK_SET) = 378
09:02:57.348206 lseek(3, 0, SEEK_CUR)   = 378
09:02:57.348265 close(3)                = 0
09:02:57.348404 stat("modules/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348492 stat("modules/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348563 stat("/etc/perl/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348665 stat("/usr/local/lib/perl/5.14.2/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348746 stat("/usr/local/share/perl/5.14.2/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348823 stat("/usr/lib/perl5/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348896 stat("/usr/share/perl5/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.348969 stat("/usr/lib/perl/5.14/utf8_heavy.pl", 0x7ffe1233be20) = -1 ENOENT (No such file or directory)
09:02:57.349048 stat("/usr/share/perl/5.14/utf8_heavy.pl", {st_mode=S_IFREG|0644, st_size=24093, ...}) = 0
09:02:57.349164 open("/usr/share/perl/5.14/utf8_heavy.pl", O_RDONLY) = 3
09:02:57.349254 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233bbb0) = -1 ENOTTY (Inappropriate ioctl for device)
09:02:57.349312 lseek(3, 0, SEEK_CUR)   = 0
09:02:57.349395 read(3, "package utf8;\nuse strict;\nuse warnings;\n\nsub DEBUG () { 0 }\n\nsub DESTROY {}\n\nmy %Cache;\n\nsub croak { require Carp; Carp::croak(@_) }\n\n##\n## \"SWASH\" == \"SWATCH HASH\". A \"swatch\" is a swatch of the Unicode landscape.\n## It's a data structure that encodes a set of Unicode characters.\n##\n\n{\n    # If a floating point number is within this distance from the value of a\n    # fraction, it is considered to be that fraction, even if many more digits\n    # are specified that don't exactly match.\n    my $min_floating_slop;\n\n    # To guard against this program calling something that in turn ends up\n    # calling this program with the same inputs, and hence infinitely\n    # recursing, we keep a stack of the properties that are currently in\n    # progress, pushed upon entry, popped upon return.\n    my @recursed;\n\n    sub SWASHNEW {\n        my ($class, $type, $list, $minbits, $none) = @_;\n        local $^D = 0 if $^D;\n\n        $class = \"\" unless defined $class;\n        print STDERR __LINE__, \": class=$class, type=$type, list=\",\n                                (defined $list) ? $list : ':undef:',\n                                \", minbits=$minbits, none=$none\\n\" if DEBUG;\n\n        ##\n        ## Get the list of codepoints for the type.\n        ## Called from swash_init (see utf8.c) or SWASHNEW itself.\n        ##\n        ## Callers of swash_init:\n        ##     op.c:pmtrans             -- for tr/// and y///\n        ##     regexec.c:regclass_swash -- for /[]/, \\p, and \\P\n        ##     utf8.c:is_utf8_common    -- for common Unicode properties\n        ##     utf8.c:to_utf8_case      -- for lc, uc, ucfirst, etc. and //i\n        ##\n        ## Given a $type, our goal is to fill $list with the set of codepoint\n        ## ranges. If $type is false, $list passed is used.\n        ##\n        ## $minbits:\n        ##     For binary properties, $minbits must be 1.\n        ##     For character mappings (case and transliteration), $minbits must\n        ##     be a number except 1.\n        ##\n        ## $list (or that filled according to $type):\n        ##     Refer to perlunicode.pod, \"User-Defined Character Properties.\"\n        ##     \n        ##     For binary properties, only characters with the property value\n        ##     of True should be listed. The 3rd column, if any, will be ignored\n        ##\n        ## $none is undocumented, so I'm (khw) trying to do some documentation\n        ## of it now.  It appears to be if there is a mapping in an input file\n        ## that maps to 'XXXX', then that is replaced by $none+1, expressed in\n        ## hexadecimal.  The only place I found it possibly used was in\n        ## S_pmtrans in op.c.\n        ##\n        ## To make the parsing of $type clear, this code takes the a rather\n        ## unorthodox approach of last'ing out of the block once we have the\n        ## info we need. Were this to be a subroutine, the 'last' would just\n        ## be a 'return'.\n        ##\n        my $file; ## file to load data from, and also part of the %Cache key.\n        my $ListSorted = 0;\n\n        # Change this to get a different set of Unicode tables\n        my $unicore_dir = 'unicore';\n\n        if ($type)\n        {\n\n            # Verify that this isn't a recursive call for this property.\n            # Can't use croak, as it may try to recurse here itself.\n            my $class_type = $class . \"::$type\";\n            if (grep { $_ eq $class_type } @recursed) {\n                CORE::die \"panic: Infinite recursion in SWASHNEW for '$type'\\n\";\n            }\n            push @recursed, $class_type;\n\n            $type =~ s/^\\s+//;\n            $type =~ s/\\s+$//;\n\n            # regcomp.c surrounds the property name with '__\" and '_i' if this\n            # is to be caseless matching.\n            my $caseless = $type =~ s/^__(.*)_i$/$1/;\n\n            print STDERR __LINE__, \": type=$type, caseless=$caseless\\n\" if DEBUG;\n\n        GETFILE:\n            {\n                ##\n                ## It could be a user-defined property.  Look in current\n                ## package if no package given\n                ##\n\n                my $caller1 = $type =~ s/(.+)::// ? $1 : caller(1);\n\n                if (defined $caller1 && $type =~ /^I[ns]\\w+$/) {\n                    my $prop = \"${caller1}::$type\";\n                    if (exists &{$prop}) {\n                        # stolen from Scalar::Util::PP::tainted()\n                        my $tainted;\n                        {\n                            local($@, $SIG{__DIE__}, $SIG{__WARN__});\n                            local $^W = 0;\n                            no warnings;\n                            eval { kill 0 * $prop };\n                            $tainted = 1 if $@ =~ /^Insecure/;\n                        }\n                        die \"Insecure user-defined property \\\\p{$prop}\\n\"\n                            if $tainted;\n                        no strict 'refs';\n                        $list = &{$prop}($caseless);\n                        last GETFILE;\n                    }\n                }\n\n                # During Perl's compilation, this routine may be called before\n                # the tables are constructed.  If so, we have a chicken/egg\n                # problem.  If we die, the tables never get constructed, so\n                # keep going, but return an empty table so only what the code\n                # has compiled in internally (currently ASCII/Latin1 range\n                # matching) will work.\n                BEGIN {\n                    # Poor man's constant, to avoid a run-time check.\n                    $utf8::{miniperl}\n                        = \\! defined &DynaLoader::boot_DynaLoader;\n                }\n                if (miniperl) {\n                    eval \"require '$unicore_dir/Heavy.pl'\";\n                    last GETFILE if $@;\n                }\n                else {\n                    require \"$unicore_dir/Heavy.pl\";\n                }\n                BEGIN { delete $utf8::{miniperl} }\n\n                # All property names are matched caselessly\n                my $property_and_table = CORE::lc $type;\n                print STDERR __LINE__, \": $property_and_table\\n\" if DEBUG;\n\n                # See if is of the compound form 'property=value', where the\n                # value indicates the table we should use.\n                my ($property, $table, @remainder) =\n                                    split /\\s*[:=]\\s*/, $property_and_table, -1;\n                if (@remainder) {\n                    pop @recursed if @recursed;\n                    return $type;\n                }\n\n                my $prefix;\n                if (! defined $table) {\n                        \n                    # Here, is the single form.  The property becomes empty, and\n                    # the whole value is the table.\n                    $table = $property;\n                    $prefix = $property = \"\";\n                } else {\n                    print STDERR __LINE__, \": $property\\n\" if DEBUG;\n\n                    # Here it is the compound property=table form.  The property\n                    # name is always loosely matched, which means remove any of\n                    # these:\n                    $property =~ s/[_\\s-]//g;\n\n                    # And convert to canonical form.  Quit if not valid.\n                    $property = $utf8::loose_property_name_of{$property};\n                    if (! defined $property) {\n                        pop @recursed if @recursed;\n                        return $type;\n                    }\n\n                    $prefix = \"$property=\";\n\n                    # If the rhs looks like it is a number...\n                    print STDERR __LINE__, \": table=$table\\n\" if DEBUG;\n                    if ($table =~ qr{ ^ [ \\s 0-9 _  + / . -]+ $ }x) {\n                        print STDERR __LINE__, \": table=$table\\n\" if DEBUG;\n\n                        # Don't allow leading nor trailing slashes \n                        if ($table =~ / ^ \\/ | \\/ $ /x) {\n                            pop @recursed if @recursed;\n                            return $type;\n                        }\n\n                        # Split on slash, in case it is a rational, like \\p{1/5}\n                        my @parts = split qr", 8192) = 8192
09:02:57.351849 read(3, "{ \\s* / \\s* }x, $table, -1;\n                        print __LINE__, \": $type\\n\" if @parts > 2 && DEBUG;\n\n                        # Can have maximum of one slash\n                        if (@parts > 2) {\n                            pop @recursed if @recursed;\n                            return $type;\n                        }\n\n                        foreach my $part (@parts) {\n                            print __LINE__, \": part=$part\\n\" if DEBUG;\n\n                            $part =~ s/^\\+\\s*//;    # Remove leading plus\n                            $part =~ s/^-\\s*/-/;    # Remove blanks after unary\n                                                    # minus\n\n                            # Remove underscores between digits.\n                            $part =~ s/( ?<= [0-9] ) _ (?= [0-9] ) //xg;\n\n                            # No leading zeros (but don't make a single '0'\n                            # into a null string)\n                            $part =~ s/ ^ ( -? ) 0+ /$1/x;\n                            $part .= '0' if $part eq '-' || $part eq \"\";\n\n                            # No trailing zeros after a decimal point\n                            $part =~ s/ ( \\. .*? ) 0+ $ /$1/x;\n\n                            # Begin with a 0 if a leading decimal point\n                            $part =~ s/ ^ ( -? ) \\. /${1}0./x;\n\n                            # Ensure not a trailing decimal point: turn into an\n                            # integer\n                            $part =~ s/ \\. $ //x;\n\n                            print STDERR __LINE__, \": part=$part\\n\" if DEBUG;\n                            #return $type if $part eq \"\";\n                            \n                            # Result better look like a number.  (This test is\n                            # needed because, for example could have a plus in\n                            # the middle.)\n                            if ($part !~ / ^ -? [0-9]+ ( \\. [0-9]+)? $ /x) {\n                                pop @recursed if @recursed;\n                                return $type;\n                            }\n                        }\n\n                        #  If a rational...\n                        if (@parts == 2) {\n\n                            # If denominator is negative, get rid of it, and ...\n                            if ($parts[1] =~ s/^-//) {\n\n                                # If numerator is also negative, convert the\n                                # whole thing to positive, or move the minus to\n                                # the numerator\n                                if ($parts[0] !~ s/^-//) {\n                                    $parts[0] = '-' . $parts[0];\n                                }\n                            }\n                            $table = join '/', @parts;\n                        }\n                        elsif ($property ne 'nv' || $parts[0] !~ /\\./) {\n\n                            # Here is not numeric value, or doesn't have a\n                            # decimal point.  No further manipulation is\n                            # necessary.  (Note the hard-coded property name.\n                            # This could fail if other properties eventually\n                            # had fractions as well; perhaps the cjk ones\n                            # could evolve to do that.  This hard-coding could\n                            # be fixed by mktables generating a list of\n                            # properties that could have fractions.)\n                            $table = $parts[0];\n                        } else {\n\n                            # Here is a floating point numeric_value.  Try to\n                            # convert to rational.  First see if is in the list\n                            # of known ones.\n                            if (exists $utf8::nv_floating_to_rational{$parts[0]}) {\n                                $table = $utf8::nv_floating_to_rational{$parts[0]};\n                            } else {\n\n                                # Here not in the list.  See if is close\n                                # enough to something in the list.  First\n                                # determine what 'close enough' means.  It has\n                                # to be as tight as what mktables says is the\n                                # maximum slop, and as tight as how many\n                                # digits we were passed.  That is, if the user\n                                # said .667, .6667, .66667, etc.  we match as\n                                # many digits as they passed until get to\n                                # where it doesn't matter any more due to the\n                                # machine's precision.  If they said .6666668,\n                                # we fail.\n                                (my $fraction = $parts[0]) =~ s/^.*\\.//;\n                                my $epsilon = 10 ** - (length($fraction));\n                                if ($epsilon > $utf8::max_floating_slop) {\n                                    $epsilon = $utf8::max_floating_slop;\n                                }\n\n                                # But it can't be tighter than the minimum\n                                # precision for this machine.  If haven't\n                                # already calculated that minimum, do so now.\n                                if (! defined $min_floating_slop) {\n\n                                    # Keep going down an order of magnitude\n                                    # until find that adding this quantity to\n                                    # 1 remains 1; but put an upper limit on\n                                    # this so in case this algorithm doesn't\n                                    # work properly on some platform, that we\n                                    # won't loop forever.\n                                    my $count = 0;\n                                    $min_floating_slop = 1;\n                                    while (1+ $min_floating_slop != 1\n                                           && $count++ < 50)\n                                    {\n                                        my $next = $min_floating_slop / 10;\n                                        last if $next == 0; # If underflows,\n                                                            # use previous one\n                                        $min_floating_slop = $next;\n                                        print STDERR __LINE__, \": min_float_slop=$min_floating_slop\\n\" if DEBUG;\n                                    }\n\n                                    # Back off a couple orders of magnitude,\n                                    # just to be safe.\n                                    $min_floating_slop *= 100;\n                                }\n                                    \n                                if ($epsilon < $min_floating_slop) {\n                                    $epsilon = $min_floating_slop;\n                                }\n                                print STDERR __LINE__, \": fraction=.$fraction; epsilon=$epsilon\\n\" if DEBUG;\n\n                                undef $table;\n\n                                # And for each possible rational in the table,\n                                # see if it is within epsilon of the input.\n                                foreach my $official\n                                        (keys %utf8::nv_floating_to_rational)\n                                {\n                                    print STDERR __LINE__, \": epsilon=$epsilon, official=$official, diff=\", abs($parts[0] - $official), \"\\n\" if DEBUG;\n                                    if (abs($parts[0] - $official) < $epsilon) {\n                                      $table =\n                                      $utf8::nv_floating_to_rational{$official};\n                                        last;\n                                    }\n                                }\n\n                                # Quit if didn't find one.\n                                if (! defined $table) {\n                                    pop @recursed if @recursed;\n                                    ret", 8192) = 8192
09:02:57.353643 read(3, "urn $type;\n                                }\n                            }\n                        }\n                        print STDERR __LINE__, \": $property=$table\\n\" if DEBUG;\n                    }\n                }\n\n                # Combine lhs (if any) and rhs to get something that matches\n                # the syntax of the lookups.\n                $property_and_table = \"$prefix$table\";\n                print STDERR __LINE__, \": $property_and_table\\n\" if DEBUG;\n\n                # First try stricter matching.\n                $file = $utf8::stricter_to_file_of{$property_and_table};\n\n                # If didn't find it, try again with looser matching by editing\n                # out the applicable characters on the rhs and looking up\n                # again.\n                if (! defined $file) {\n                    $table =~ s/ [_\\s-] //xg;\n                    $property_and_table = \"$prefix$table\";\n                    print STDERR __LINE__, \": $property_and_table\\n\" if DEBUG;\n                    $file = $utf8::loose_to_file_of{$property_and_table};\n                }\n\n                # Add the constant and go fetch it in.\n                if (defined $file) {\n                    if ($utf8::why_deprecated{$file}) {\n                        warnings::warnif('deprecated', \"Use of '$type' in \\\\p{} or \\\\P{} is deprecated because: $utf8::why_deprecated{$file};\");\n                    }\n\n                    if ($caseless\n                        && exists $utf8::caseless_equivalent{$property_and_table})\n                    {\n                        $file = $utf8::caseless_equivalent{$property_and_table};\n                    }\n                    $file= \"$unicore_dir/lib/$file.pl\";\n                    last GETFILE;\n                }\n                print STDERR __LINE__, \": didn't find $property_and_table\\n\" if DEBUG;\n\n                ##\n                ## See if it's a user-level \"To\".\n                ##\n\n                my $caller0 = caller(0);\n\n                if (defined $caller0 && $type =~ /^To(?:\\w+)$/) {\n                    my $map = $caller0 . \"::\" . $type;\n\n                    if (exists &{$map}) {\n                        no strict 'refs';\n                        \n                        $list = &{$map};\n                        warnings::warnif('deprecated', \"User-defined case-mapping '$type' is deprecated\");\n                        last GETFILE;\n                    }\n                }\n\n                ##\n                ## Last attempt -- see if it's a standard \"To\" name\n                ## (e.g. \"ToLower\")  ToTitle is used by ucfirst().\n                ## The user-level way to access ToDigit() and ToFold()\n                ## is to use Unicode::UCD.\n                ##\n                if ($type =~ /^To(Digit|Fold|Lower|Title|Upper)$/) {\n                    $file = \"$unicore_dir/To/$1.pl\";\n                    ## would like to test to see if $file actually exists....\n                    last GETFILE;\n                }\n\n                ##\n                ## If we reach this line, it's because we couldn't figure\n                ## out what to do with $type. Ouch.\n                ##\n\n                pop @recursed if @recursed;\n                return $type;\n            }\n\n            if (defined $file) {\n                print STDERR __LINE__, \": found it (file='$file')\\n\" if DEBUG;\n\n                ##\n                ## If we reach here, it was due to a 'last GETFILE' above\n                ## (exception: user-defined properties and mappings), so we\n                ## have a filename, so now we load it if we haven't already.\n                ## If we have, return the cached results. The cache key is the\n                ## class and file to load.\n                ##\n                my $found = $Cache{$class, $file};\n                if ($found and ref($found) eq $class) {\n                    print STDERR __LINE__, \": Returning cached '$file' for \\\\p{$type}\\n\" if DEBUG;\n                    pop @recursed if @recursed;\n                    return $found;\n                }\n\n                local $@;\n                local $!;\n                $list = do $file; die $@ if $@;\n            }\n\n            $ListSorted = 1; ## we know that these lists are sorted\n        }\n\n        my $extras;\n        my $bits = $minbits;\n\n        if ($list) {\n            my $taint = substr($list,0,0); # maintain taint\n            my @tmp = split(/^/m, $list);\n            my %seen;\n            no warnings;\n            $extras = join '', $taint, grep /^[^0-9a-fA-F]/, @tmp;\n            $list = join '', $taint,\n                map  { $_->[1] }\n                sort { $a->[0] <=> $b->[0] }\n                map  { /^([0-9a-fA-F]+)/; [ CORE::hex($1), $_ ] }\n                grep { /^([0-9a-fA-F]+)/ and not $seen{$1}++ } @tmp; # XXX doesn't do ranges right\n        }\n\n        if ($none) {\n            my $hextra = sprintf \"%04x\", $none + 1;\n            $list =~ s/\\tXXXX$/\\t$hextra/mg;\n        }\n\n        if ($minbits != 1 && $minbits < 32) { # not binary property\n            my $top = 0;\n            while ($list =~ /^([0-9a-fA-F]+)(?:[\\t]([0-9a-fA-F]+)?)(?:[ \\t]([0-9a-fA-F]+))?/mg) {\n                my $min = CORE::hex $1;\n                my $max = defined $2 ? CORE::hex $2 : $min;\n                my $val = defined $3 ? CORE::hex $3 : 0;\n                $val += $max - $min if defined $3;\n                $top = $val if $val > $top;\n            }\n            my $topbits =\n                $top > 0xffff ? 32 :\n                $top > 0xff ? 16 : 8;\n            $bits = $topbits if $bits < $topbits;\n        }\n\n        my @extras;\n        if ($extras) {\n            for my $x ($extras) {\n                my $taint = substr($x,0,0); # maintain taint\n                pos $x = 0;\n                while ($x =~ /^([^0-9a-fA-F\\n])(.*)/mg) {\n                    my $char = \"$1$taint\";\n                    my $name = \"$2$taint\";\n                    print STDERR __LINE__, \": char [$char] => name [$name]\\n\"\n                        if DEBUG;\n                    if ($char =~ /[-+!&]/) {\n                        my ($c,$t) = split(/::/, $name, 2);\t# bogus use of ::, really\n                        my $subobj;\n                        if ($c eq 'utf8') {\n                            $subobj = utf8->SWASHNEW($t, \"\", $minbits, 0);\n                        }\n                        elsif (exists &$name) {\n                            $subobj = utf8->SWASHNEW($name, \"\", $minbits, 0);\n                        }\n                        elsif ($c =~ /^([0-9a-fA-F]+)/) {\n                            $subobj = utf8->SWASHNEW(\"\", $c, $minbits, 0);\n                        }\n                        if (! ref $subobj) {\n                            pop @recursed if @recursed && $type;\n                            return $subobj;\n                        }\n                        push @extras, $name => $subobj;\n                        $bits = $subobj->{BITS} if $bits < $subobj->{BITS};\n                    }\n                }\n            }\n        }\n\n        if (DEBUG) {\n            print STDERR __LINE__, \": CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none\";\n            print STDERR \"\\nLIST =>\\n$list\" if defined $list;\n            print STDERR \"\\nEXTRAS =>\\n$extras\" if defined $extras;\n            print STDERR \"\\n\";\n        }\n\n        my $SWASH = bless {\n            TYPE => $type,\n            BITS => $bits,\n            EXTRAS => $extras,\n            LIST => $list,\n            NONE => $none,\n            @extras,\n        } => $class;\n\n        if ($file) {\n            $Cache{$class, $file} = $SWASH;\n        }\n\n        pop @recursed if @recursed && $type;\n\n        return $SWASH;\n    }\n}\n\n# Now SWASHGET is recasted into a C function S_swash_get (see utf8.c).\n\n1;\n", 8192) = 7709
09:02:57.356557 read(3, "", 8192)       = 0
09:02:57.356639 close(3)                = 0
09:02:57.356762 stat("modules/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.356843 stat("modules/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.356906 stat("/etc/perl/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.356971 stat("/usr/local/lib/perl/5.14.2/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.357040 stat("/usr/local/share/perl/5.14.2/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.357107 stat("/usr/lib/perl5/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.357173 stat("/usr/share/perl5/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.357238 stat("/usr/lib/perl/5.14/unicore/Heavy.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.357307 stat("/usr/share/perl/5.14/unicore/Heavy.pl", {st_mode=S_IFREG|0644, st_size=106089, ...}) = 0
09:02:57.357397 open("/usr/share/perl/5.14/unicore/Heavy.pl", O_RDONLY) = 3
09:02:57.357471 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b9c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:02:57.357529 lseek(3, 0, SEEK_CUR)   = 0
09:02:57.357612 read(3, "# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file is machine-generated by lib/unicore/mktables from the Unicode\n# database, Version 6.0.0.  Any changes made here will be lost!\n\n\n# !!!!!!!   INTERNAL PERL USE ONLY   !!!!!!!\n# This file is for internal use by the Perl program only.  The format and even\n# the name or existence of this file are subject to change without notice.\n# Don't use it directly.\n\n\n# This file is for the use of utf8_heavy.pl\n\n# Maps property names in loose standard form to its standard name\n%utf8::loose_property_name_of = (\n    'age' => 'age',\n    'ahex' => 'ahex',\n    'alpha' => 'alpha',\n    'alphabetic' => 'alpha',\n    'asciihexdigit' => 'ahex',\n    'bc' => 'bc',\n    'bidic' => 'bidic',\n    'bidiclass' => 'bc',\n    'bidicontrol' => 'bidic',\n    'bidim' => 'bidim',\n    'bidimirrored' => 'bidim',\n    'blk' => 'blk',\n    'block' => 'blk',\n    'canonicalcombiningclass' => 'ccc',\n    'cased' => 'cased',\n    'caseignorable' => 'ci',\n    'category' => 'gc',\n    'ccc' => 'ccc',\n    'ce' => 'ce',\n    'changeswhencasefolded' => 'cwcf',\n    'changeswhencasemapped' => 'cwcm',\n    'changeswhenlowercased' => 'cwl',\n    'changeswhennfkccasefolded' => 'cwkcf',\n    'changeswhentitlecased' => 'cwt',\n    'changeswhenuppercased' => 'cwu',\n    'ci' => 'ci',\n    'compex' => 'compex',\n    'compositionexclusion' => 'ce',\n    'cwcf' => 'cwcf',\n    'cwcm' => 'cwcm',\n    'cwkcf' => 'cwkcf',\n    'cwl' => 'cwl',\n    'cwt' => 'cwt',\n    'cwu' => 'cwu',\n    'dash' => 'dash',\n    'decompositiontype' => 'dt',\n    'defaultignorablecodepoint' => 'di',\n    'dep' => 'dep',\n    'deprecated' => 'dep',\n    'di' => 'di',\n    'dia' => 'dia',\n    'diacritic' => 'dia',\n    'dt' => 'dt',\n    'ea' => 'ea',\n    'eastasianwidth' => 'ea',\n    'ext' => 'ext',\n    'extender' => 'ext',\n    'fullcompositionexclusion' => 'compex',\n    'gc' => 'gc',\n    'gcb' => 'gcb',\n    'generalcategory' => 'gc',\n    'graphemebase' => 'grbase',\n    'graphemeclusterbreak' => 'gcb',\n    'graphemeextend' => 'grext',\n    'grbase' => 'grbase',\n    'grext' => 'grext',\n    'hangulsyllabletype' => 'hst',\n    'hex' => 'hex',\n    'hexdigit' => 'hex',\n    'hst' => 'hst',\n    'hyphen' => 'hyphen',\n    'idc' => 'idc',\n    'idcontinue' => 'idc',\n    'ideo' => 'ideo',\n    'ideographic' => 'ideo',\n    'ids' => 'ids',\n    'idsb' => 'idsb',\n    'idsbinaryoperator' => 'idsb',\n    'idst' => 'idst',\n    'idstart' => 'ids',\n    'idstrinaryoperator' => 'idst',\n    'in' => 'in',\n    'isage' => 'age',\n    'isahex' => 'ahex',\n    'isalpha' => 'alpha',\n    'isalphabetic' => 'alpha',\n    'isasciihexdigit' => 'ahex',\n    'isbc' => 'bc',\n    'isbidic' => 'bidic',\n    'isbidiclass' => 'bc',\n    'isbidicontrol' => 'bidic',\n    'isbidim' => 'bidim',\n    'isbidimirrored' => 'bidim',\n    'isblk' => 'blk',\n    'isblock' => 'blk',\n    'iscanonicalcombiningclass' => 'ccc',\n    'iscased' => 'cased',\n    'iscaseignorable' => 'ci',\n    'iscategory' => 'gc',\n    'isccc' => 'ccc',\n    'isce' => 'ce',\n    'ischangeswhencasefolded' => 'cwcf',\n    'ischangeswhencasemapped' => 'cwcm',\n    'ischangeswhenlowercased' => 'cwl',\n    'ischangeswhennfkccasefolded' => 'cwkcf',\n    'ischangeswhentitlecased' => 'cwt',\n    'ischangeswhenuppercased' => 'cwu',\n    'isci' => 'ci',\n    'iscompex' => 'compex',\n    'iscompositionexclusion' => 'ce',\n    'iscwcf' => 'cwcf',\n    'iscwcm' => 'cwcm',\n    'iscwkcf' => 'cwkcf',\n    'iscwl' => 'cwl',\n    'iscwt' => 'cwt',\n    'iscwu' => 'cwu',\n    'isdash' => 'dash',\n    'isdecompositiontype' => 'dt',\n    'isdefaultignorablecodepoint' => 'di',\n    'isdep' => 'dep',\n    'isdeprecated' => 'dep',\n    'isdi' => 'di',\n    'isdia' => 'dia',\n    'isdiacritic' => 'dia',\n    'isdt' => 'dt',\n    'isea' => 'ea',\n    'iseastasianwidth' => 'ea',\n    'isext' => 'ext',\n    'isextender' => 'ext',\n    'isfullcompositionexclusion' => 'compex',\n    'isgc' => 'gc',\n    'isgcb' => 'gcb',\n    'isgeneralcategory' => 'gc',\n    'isgraphemebase' => 'grbase',\n    'isgraphemeclusterbreak' => 'gcb',\n    'isgraphemeextend' => 'grext',\n    'isgrbase' => 'grbase',\n    'isgrext' => 'grext',\n    'ishangulsyllabletype' => 'hst',\n    'ishex' => 'hex',\n    'ishexdigit' => 'hex',\n    'ishst' => 'hst',\n    'ishyphen' => 'hyphen',\n    'isidc' => 'idc',\n    'isidcontinue' => 'idc',\n    'isideo' => 'ideo',\n    'isideographic' => 'ideo',\n    'isids' => 'ids',\n    'isidsb' => 'idsb',\n    'isidsbinaryoperator' => 'idsb',\n    'isidst' => 'idst',\n    'isidstart' => 'ids',\n    'isidstrinaryoperator' => 'idst',\n    'isjg' => 'jg',\n    'isjoinc' => 'joinc',\n    'isjoincontrol' => 'joinc',\n    'isjoininggroup' => 'jg',\n    'isjoiningtype' => 'jt',\n    'isjt' => 'jt',\n    'islb' => 'lb',\n    'islinebreak' => 'lb',\n    'isloe' => 'loe',\n    'islogicalorderexception' => 'loe',\n    'islower' => 'lower',\n    'islowercase' => 'lower',\n    'ismath' => 'math',\n    'isnchar' => 'nchar',\n    'isnfcqc' => 'nfcqc',\n    'isnfcquickcheck' => 'nfcqc',\n    'isnfdqc' => 'nfdqc',\n    'isnfdquickcheck' => 'nfdqc',\n    'isnfkcqc' => 'nfkcqc',\n    'isnfkcquickcheck' => 'nfkcqc',\n    'isnfkdqc' => 'nfkdqc',\n    'isnfkdquickcheck' => 'nfkdqc',\n    'isnoncharactercodepoint' => 'nchar',\n    'isnt' => 'nt',\n    'isnumerictype' => 'nt',\n    'isnumericvalue' => 'nv',\n    'isnv' => 'nv',\n    'isoalpha' => 'oalpha',\n    'isodi' => 'odi',\n    'isogrext' => 'ogrext',\n    'isoidc' => 'oidc',\n    'isoids' => 'oids',\n    'isolower' => 'olower',\n    'isomath' => 'omath',\n    'isotheralphabetic' => 'oalpha',\n    'isotherdefaultignorablecodepoint' => 'odi',\n    'isothergraphemeextend' => 'ogrext',\n    'isotheridcontinue' => 'oidc',\n    'isotheridstart' => 'oids',\n    'isotherlowercase' => 'olower',\n    'isothermath' => 'omath',\n    'isotheruppercase' => 'oupper',\n    'isoupper' => 'oupper',\n    'ispatsyn' => 'patsyn',\n    'ispatternsyntax' => 'patsyn',\n    'ispatternwhitespace' => 'patws',\n    'ispatws' => 'patws',\n    'isqmark' => 'qmark',\n    'isquotationmark' => 'qmark',\n    'isradical' => 'radical',\n    'issb' => 'sb',\n    'issc' => 'sc',\n    'isscript' => 'sc',\n    'issd' => 'sd',\n    'issentencebreak' => 'sb',\n    'issoftdotted' => 'sd',\n    'isspace' => 'wspace',\n    'issterm' => 'sterm',\n    'isterm' => 'term',\n    'isterminalpunctuation' => 'term',\n    'isuideo' => 'uideo',\n    'isunifiedideograph' => 'uideo',\n    'isupper' => 'upper',\n    'isuppercase' => 'upper',\n    'isvariationselector' => 'vs',\n    'isvs' => 'vs',\n    'iswb' => 'wb',\n    'iswhitespace' => 'wspace',\n    'iswordbreak' => 'wb',\n    'iswspace' => 'wspace',\n    'isxidc' => 'xidc',\n    'isxidcontinue' => 'xidc',\n    'isxids' => 'xids',\n    'isxidstart' => 'xids',\n    'jg' => 'jg',\n    'joinc' => 'joinc',\n    'joincontrol' => 'joinc',\n    'joininggroup' => 'jg',\n    'joiningtype' => 'jt',\n    'jt' => 'jt',\n    'lb' => 'lb',\n    'linebreak' => 'lb',\n    'loe' => 'loe',\n    'logicalorderexception' => 'loe',\n    'lower' => 'lower',\n    'lowercase' => 'lower',\n    'math' => 'math',\n    'nchar' => 'nchar',\n    'nfcqc' => 'nfcqc',\n    'nfcquickcheck' => 'nfcqc',\n    'nfdqc' => 'nfdqc',\n    'nfdquickcheck' => 'nfdqc',\n    'nfkcqc' => 'nfkcqc',\n    'nfkcquickcheck' => 'nfkcqc',\n    'nfkdqc' => 'nfkdqc',\n    'nfkdquickcheck' => 'nfkdqc',\n    'noncharactercodepoint' => 'nchar',\n    'nt' => 'nt',\n    'numerictype' => 'nt',\n    'numericvalue' => 'nv',\n    'nv' => 'nv',\n    'oalpha' => 'oalpha',\n    'odi' => 'odi',\n    'ogrext' => 'ogrext',\n    'oidc' => 'oidc',\n    'oids' => 'oids',\n    'olower' => 'olower',\n    'omath' => 'omath',\n    'otheralphabetic' => 'oalpha',\n    'otherdefaultignorablecodepoint' => 'odi',\n    'othergraphemeextend' => 'ogrext',\n    'otheridcontinue' => 'oidc',\n    'otheridstart' => 'oids',\n    'otherlowercase' => 'olower',\n    'othermath' => 'omath',\n    'otheruppercase' => 'oupper',\n    'oupper' => 'oupper',\n    'patsyn' => 'patsyn',\n    'patternsyntax' => 'patsyn',\n    'patternwhitespace' => 'patws',\n    'patws' => 'patws',\n    'perlcanonicalcombiningclass' => 'perlccc',\n    'perlccc' => 'perlccc',\n    'presentin' => 'in',\n    'qmark' => 'qmark',\n    'quotationmark' => 'qmark',\n    'radical' => 'radical',\n    'sb' => 'sb',\n    'sc' => 'sc',\n    'script' => 'sc',\n    'sd' => 'sd',\n    'sentencebreak'", 8192) = 8192
09:02:57.359298 read(3, " => 'sb',\n    'softdotted' => 'sd',\n    'space' => 'wspace',\n    'sterm' => 'sterm',\n    'term' => 'term',\n    'terminalpunctuation' => 'term',\n    'uideo' => 'uideo',\n    'unifiedideograph' => 'uideo',\n    'upper' => 'upper',\n    'uppercase' => 'upper',\n    'variationselector' => 'vs',\n    'vs' => 'vs',\n    'wb' => 'wb',\n    'whitespace' => 'wspace',\n    'wordbreak' => 'wb',\n    'wspace' => 'wspace',\n    'xidc' => 'xidc',\n    'xidcontinue' => 'xidc',\n    'xids' => 'xids',\n    'xidstart' => 'xids',\n);\n\n# Maps property, table to file for those using stricter matching\n%utf8::stricter_to_file_of = (\n    '_canondcij' => 'SD/Y',\n    '_case_ignorable' => 'CI/Y',\n    '_combabove' => 'Ccc/A',\n    '_x_begin' => 'Perl/_XBegin',\n    '_x_extend' => 'Perl/_XExtend',\n    '_x_lv_lvt_v' => 'Perl/_XLVLVTV',\n    'age=1.1' => 'Age/1_1',\n    'age=2' => 'Age/2_0',\n    'age=2.0' => 'Age/2_0',\n    'age=2.1' => 'Age/2_1',\n    'age=3' => 'Age/3_0',\n    'age=3.0' => 'Age/3_0',\n    'age=3.1' => 'Age/3_1',\n    'age=3.2' => 'Age/3_2',\n    'age=4' => 'Age/4_0',\n    'age=4.0' => 'Age/4_0',\n    'age=4.1' => 'Age/4_1',\n    'age=5' => 'Age/5_0',\n    'age=5.0' => 'Age/5_0',\n    'age=5.1' => 'Age/5_1',\n    'age=5.2' => 'Age/5_2',\n    'age=6' => 'Age/6_0',\n    'age=6.0' => 'Age/6_0',\n    'ccc=0' => 'Ccc/NR',\n    'ccc=1' => 'Ccc/OV',\n    'ccc=10' => 'Ccc/10',\n    'ccc=103' => 'Ccc/103',\n    'ccc=107' => 'Ccc/107',\n    'ccc=11' => 'Ccc/11',\n    'ccc=118' => 'Ccc/118',\n    'ccc=12' => 'Ccc/12',\n    'ccc=122' => 'Ccc/122',\n    'ccc=129' => 'Ccc/129',\n    'ccc=13' => 'Ccc/13',\n    'ccc=130' => 'Ccc/130',\n    'ccc=132' => 'Ccc/132',\n    'ccc=14' => 'Ccc/14',\n    'ccc=15' => 'Ccc/15',\n    'ccc=16' => 'Ccc/16',\n    'ccc=17' => 'Ccc/17',\n    'ccc=18' => 'Ccc/18',\n    'ccc=19' => 'Ccc/19',\n    'ccc=20' => 'Ccc/20',\n    'ccc=200' => 'Ccc/ATBL',\n    'ccc=202' => 'Ccc/ATB',\n    'ccc=21' => 'Ccc/21',\n    'ccc=214' => 'Ccc/ATA',\n    'ccc=216' => 'Ccc/ATAR',\n    'ccc=218' => 'Ccc/BL',\n    'ccc=22' => 'Ccc/22',\n    'ccc=220' => 'Ccc/B',\n    'ccc=222' => 'Ccc/BR',\n    'ccc=224' => 'Ccc/L',\n    'ccc=226' => 'Ccc/R',\n    'ccc=228' => 'Ccc/AL',\n    'ccc=23' => 'Ccc/23',\n    'ccc=230' => 'Ccc/A',\n    'ccc=232' => 'Ccc/AR',\n    'ccc=233' => 'Ccc/DB',\n    'ccc=234' => 'Ccc/DA',\n    'ccc=24' => 'Ccc/24',\n    'ccc=240' => 'Ccc/IS',\n    'ccc=25' => 'Ccc/25',\n    'ccc=26' => 'Ccc/26',\n    'ccc=27' => 'Ccc/27',\n    'ccc=28' => 'Ccc/28',\n    'ccc=29' => 'Ccc/29',\n    'ccc=30' => 'Ccc/30',\n    'ccc=31' => 'Ccc/31',\n    'ccc=32' => 'Ccc/32',\n    'ccc=33' => 'Ccc/33',\n    'ccc=34' => 'Ccc/34',\n    'ccc=35' => 'Ccc/35',\n    'ccc=36' => 'Ccc/36',\n    'ccc=7' => 'Ccc/NK',\n    'ccc=8' => 'Ccc/KV',\n    'ccc=84' => 'Ccc/84',\n    'ccc=9' => 'Ccc/VR',\n    'ccc=91' => 'Ccc/91',\n    'in=1.1' => 'Age/1_1',\n    'in=2' => 'In/2_0',\n    'in=2.0' => 'In/2_0',\n    'in=2.1' => 'In/2_1',\n    'in=3' => 'In/3_0',\n    'in=3.0' => 'In/3_0',\n    'in=3.1' => 'In/3_1',\n    'in=3.2' => 'In/3_2',\n    'in=4' => 'In/4_0',\n    'in=4.0' => 'In/4_0',\n    'in=4.1' => 'In/4_1',\n    'in=5' => 'In/5_0',\n    'in=5.0' => 'In/5_0',\n    'in=5.1' => 'In/5_1',\n    'in=5.2' => 'In/5_2',\n    'in=6' => 'In/6_0',\n    'in=6.0' => 'In/6_0',\n    'nv=-1/2' => 'Nv/_1_2',\n    'nv=0' => 'Nv/0',\n    'nv=1' => 'Nv/1',\n    'nv=1/10' => 'Nv/1_10',\n    'nv=1/16' => 'Nv/1_16',\n    'nv=1/2' => 'Nv/1_2',\n    'nv=1/3' => 'Nv/1_3',\n    'nv=1/4' => 'Nv/1_4',\n    'nv=1/5' => 'Nv/1_5',\n    'nv=1/6' => 'Nv/1_6',\n    'nv=1/7' => 'Nv/1_7',\n    'nv=1/8' => 'Nv/1_8',\n    'nv=1/9' => 'Nv/1_9',\n    'nv=10' => 'Nv/10',\n    'nv=100' => 'Nv/100',\n    'nv=1000' => 'Nv/1000',\n    'nv=10000' => 'Nv/10000',\n    'nv=100000' => 'Nv/100000',\n    'nv=100000000' => 'Nv/10000000',\n    'nv=1000000000000' => 'Nv/10000002',\n    'nv=11' => 'Nv/11',\n    'nv=11/2' => 'Nv/11_2',\n    'nv=12' => 'Nv/12',\n    'nv=13' => 'Nv/13',\n    'nv=13/2' => 'Nv/13_2',\n    'nv=14' => 'Nv/14',\n    'nv=15' => 'Nv/15',\n    'nv=15/2' => 'Nv/15_2',\n    'nv=16' => 'Nv/16',\n    'nv=17' => 'Nv/17',\n    'nv=17/2' => 'Nv/17_2',\n    'nv=18' => 'Nv/18',\n    'nv=19' => 'Nv/19',\n    'nv=2' => 'Nv/2',\n    'nv=2/3' => 'Nv/2_3',\n    'nv=2/5' => 'Nv/2_5',\n    'nv=20' => 'Nv/20',\n    'nv=200' => 'Nv/200',\n    'nv=2000' => 'Nv/2000',\n    'nv=20000' => 'Nv/20000',\n    'nv=21' => 'Nv/21',\n    'nv=22' => 'Nv/22',\n    'nv=23' => 'Nv/23',\n    'nv=24' => 'Nv/24',\n    'nv=25' => 'Nv/25',\n    'nv=26' => 'Nv/26',\n    'nv=27' => 'Nv/27',\n    'nv=28' => 'Nv/28',\n    'nv=29' => 'Nv/29',\n    'nv=3' => 'Nv/3',\n    'nv=3/16' => 'Nv/3_16',\n    'nv=3/2' => 'Nv/3_2',\n    'nv=3/4' => 'Nv/3_4',\n    'nv=3/5' => 'Nv/3_5',\n    'nv=3/8' => 'Nv/3_8',\n    'nv=30' => 'Nv/30',\n    'nv=300' => 'Nv/300',\n    'nv=3000' => 'Nv/3000',\n    'nv=30000' => 'Nv/30000',\n    'nv=31' => 'Nv/31',\n    'nv=32' => 'Nv/32',\n    'nv=33' => 'Nv/33',\n    'nv=34' => 'Nv/34',\n    'nv=35' => 'Nv/35',\n    'nv=36' => 'Nv/36',\n    'nv=37' => 'Nv/37',\n    'nv=38' => 'Nv/38',\n    'nv=39' => 'Nv/39',\n    'nv=4' => 'Nv/4',\n    'nv=4/5' => 'Nv/4_5',\n    'nv=40' => 'Nv/40',\n    'nv=400' => 'Nv/400',\n    'nv=4000' => 'Nv/4000',\n    'nv=40000' => 'Nv/40000',\n    'nv=41' => 'Nv/41',\n    'nv=42' => 'Nv/42',\n    'nv=43' => 'Nv/43',\n    'nv=44' => 'Nv/44',\n    'nv=45' => 'Nv/45',\n    'nv=46' => 'Nv/46',\n    'nv=47' => 'Nv/47',\n    'nv=48' => 'Nv/48',\n    'nv=49' => 'Nv/49',\n    'nv=5' => 'Nv/5',\n    'nv=5/2' => 'Nv/5_2',\n    'nv=5/6' => 'Nv/5_6',\n    'nv=5/8' => 'Nv/5_8',\n    'nv=50' => 'Nv/50',\n    'nv=500' => 'Nv/500',\n    'nv=5000' => 'Nv/5000',\n    'nv=50000' => 'Nv/50000',\n    'nv=6' => 'Nv/6',\n    'nv=60' => 'Nv/60',\n    'nv=600' => 'Nv/600',\n    'nv=6000' => 'Nv/6000',\n    'nv=60000' => 'Nv/60000',\n    'nv=7' => 'Nv/7',\n    'nv=7/2' => 'Nv/7_2',\n    'nv=7/8' => 'Nv/7_8',\n    'nv=70' => 'Nv/70',\n    'nv=700' => 'Nv/700',\n    'nv=7000' => 'Nv/7000',\n    'nv=70000' => 'Nv/70000',\n    'nv=8' => 'Nv/8',\n    'nv=80' => 'Nv/80',\n    'nv=800' => 'Nv/800',\n    'nv=8000' => 'Nv/8000',\n    'nv=80000' => 'Nv/80000',\n    'nv=9' => 'Nv/9',\n    'nv=9/2' => 'Nv/9_2',\n    'nv=90' => 'Nv/90',\n    'nv=900' => 'Nv/900',\n    'nv=9000' => 'Nv/9000',\n    'nv=90000' => 'Nv/90000',\n);\n\n# Maps property, table to file for those using loose matching\n%utf8::loose_to_file_of = (\n    'aegeannumbers' => 'Blk/AegeanNu',\n    'age=unassigned' => 'Age/Unassign',\n    'ahex' => 'AHex/Y',\n    'ahex=f' => 'AHex/N',\n    'ahex=false' => 'AHex/N',\n    'ahex=n' => 'AHex/N',\n    'ahex=no' => 'AHex/N',\n    'ahex=t' => 'AHex/Y',\n    'ahex=true' => 'AHex/Y',\n    'ahex=y' => 'AHex/Y',\n    'ahex=yes' => 'AHex/Y',\n    'alchemicalsymbols' => 'Blk/Alchemic',\n    'all' => 'Perl/Any',\n    'alnum' => 'Perl/Alnum',\n    'alpha' => 'Alpha/Y',\n    'alpha=f' => 'Alpha/N',\n    'alpha=false' => 'Alpha/N',\n    'alpha=n' => 'Alpha/N',\n    'alpha=no' => 'Alpha/N',\n    'alpha=t' => 'Alpha/Y',\n    'alpha=true' => 'Alpha/Y',\n    'alpha=y' => 'Alpha/Y',\n    'alpha=yes' => 'Alpha/Y',\n    'alphabetic' => 'Alpha/Y',\n    'alphabeticpresentationforms' => 'Blk/Alphabet',\n    'ancientgreekmusicalnotation' => 'Blk/Ancient2',\n    'ancientgreeknumbers' => 'Blk/AncientG',\n    'ancientsymbols' => 'Blk/AncientS',\n    'any' => 'Perl/Any',\n    'arab' => 'Sc/Arab',\n    'arabic' => 'Sc/Arab',\n    'arabicpresentationformsa' => 'Blk/ArabicPr',\n    'arabicpresentationformsb' => 'Blk/ArabicP2',\n    'arabicsupplement' => 'Blk/ArabicSu',\n    'armenian' => 'Sc/Armn',\n    'armi' => 'Sc/Armi',\n    'armn' => 'Sc/Armn',\n    'arrows' => 'Blk/Arrows',\n    'ascii' => 'Blk/ASCII',\n    'asciihexdigit' => 'AHex/Y',\n    'assigned' => 'Perl/Assigned',\n    'avestan' => 'Sc/Avst',\n    'avst' => 'Sc/Avst',\n    'bali' => 'Sc/Bali',\n    'balinese' => 'Sc/Bali',\n    'bamu' => 'Sc/Bamu',\n    'bamum' => 'Sc/Bamu',\n    'bamumsupplement' => 'Blk/BamumSup',\n    'basiclatin' => 'Blk/ASCII',\n    'batak' => 'Sc/Batk',\n    'batk' => 'Sc/Batk',\n    'bc=al' => 'Bc/AL',\n    'bc=an' => 'Bc/AN',\n    'bc=arabicletter' => 'Bc/AL',\n    'bc=arabicnumber' => 'Bc/AN',\n    'bc=b' => 'Bc/B',\n    'bc=bn' => 'Bc/BN',\n    'bc=boundaryneutral' => 'Bc/BN',\n    'bc=commonseparator' => 'Bc/CS',\n    'bc=cs' => 'Bc/CS',\n    'bc=en' => 'Bc/EN',\n    'bc=es' => 'Bc/ES',\n    'bc=et' => 'Bc/ET',\n    'bc=europeannumber' => 'Bc/EN',\n    ", 8192) = 8192
09:02:57.361051 read(3, "'bc=europeanseparator' => 'Bc/ES',\n    'bc=europeanterminator' => 'Bc/ET',\n    'bc=l' => 'Bc/L',\n    'bc=lefttoright' => 'Bc/L',\n    'bc=lefttorightembedding' => 'Bc/LRE',\n    'bc=lefttorightoverride' => 'Bc/LRO',\n    'bc=lre' => 'Bc/LRE',\n    'bc=lro' => 'Bc/LRO',\n    'bc=nonspacingmark' => 'Bc/NSM',\n    'bc=nsm' => 'Bc/NSM',\n    'bc=on' => 'Bc/ON',\n    'bc=otherneutral' => 'Bc/ON',\n    'bc=paragraphseparator' => 'Bc/B',\n    'bc=pdf' => 'Bc/PDF',\n    'bc=popdirectionalformat' => 'Bc/PDF',\n    'bc=r' => 'Bc/R',\n    'bc=righttoleft' => 'Bc/R',\n    'bc=righttoleftembedding' => 'Bc/RLE',\n    'bc=righttoleftoverride' => 'Bc/RLO',\n    'bc=rle' => 'Bc/RLE',\n    'bc=rlo' => 'Bc/RLO',\n    'bc=s' => 'Bc/S',\n    'bc=segmentseparator' => 'Bc/S',\n    'bc=whitespace' => 'Bc/WS',\n    'bc=ws' => 'Bc/WS',\n    'beng' => 'Sc/Beng',\n    'bengali' => 'Sc/Beng',\n    'bidic' => 'BidiC/Y',\n    'bidic=f' => 'BidiC/N',\n    'bidic=false' => 'BidiC/N',\n    'bidic=n' => 'BidiC/N',\n    'bidic=no' => 'BidiC/N',\n    'bidic=t' => 'BidiC/Y',\n    'bidic=true' => 'BidiC/Y',\n    'bidic=y' => 'BidiC/Y',\n    'bidic=yes' => 'BidiC/Y',\n    'bidicontrol' => 'BidiC/Y',\n    'bidim' => 'BidiM/Y',\n    'bidim=f' => 'BidiM/N',\n    'bidim=false' => 'BidiM/N',\n    'bidim=n' => 'BidiM/N',\n    'bidim=no' => 'BidiM/N',\n    'bidim=t' => 'BidiM/Y',\n    'bidim=true' => 'BidiM/Y',\n    'bidim=y' => 'BidiM/Y',\n    'bidim=yes' => 'BidiM/Y',\n    'bidimirrored' => 'BidiM/Y',\n    'blank' => 'Perl/Blank',\n    'blk=aegeannumbers' => 'Blk/AegeanNu',\n    'blk=alchemicalsymbols' => 'Blk/Alchemic',\n    'blk=alphabeticpresentationforms' => 'Blk/Alphabet',\n    'blk=ancientgreekmusicalnotation' => 'Blk/Ancient2',\n    'blk=ancientgreeknumbers' => 'Blk/AncientG',\n    'blk=ancientsymbols' => 'Blk/AncientS',\n    'blk=arabic' => 'Blk/Arabic',\n    'blk=arabicpresentationformsa' => 'Blk/ArabicPr',\n    'blk=arabicpresentationformsb' => 'Blk/ArabicP2',\n    'blk=arabicsupplement' => 'Blk/ArabicSu',\n    'blk=armenian' => 'Blk/Armenian',\n    'blk=arrows' => 'Blk/Arrows',\n    'blk=ascii' => 'Blk/ASCII',\n    'blk=avestan' => 'Blk/Avestan',\n    'blk=balinese' => 'Blk/Balinese',\n    'blk=bamum' => 'Blk/Bamum',\n    'blk=bamumsupplement' => 'Blk/BamumSup',\n    'blk=basiclatin' => 'Blk/ASCII',\n    'blk=batak' => 'Blk/Batak',\n    'blk=bengali' => 'Blk/Bengali',\n    'blk=blockelements' => 'Blk/BlockEle',\n    'blk=bopomofo' => 'Blk/Bopomofo',\n    'blk=bopomofoextended' => 'Blk/Bopomof2',\n    'blk=boxdrawing' => 'Blk/BoxDrawi',\n    'blk=brahmi' => 'Blk/Brahmi',\n    'blk=braillepatterns' => 'Blk/BrailleP',\n    'blk=buginese' => 'Blk/Buginese',\n    'blk=buhid' => 'Blk/Buhid',\n    'blk=byzantinemusicalsymbols' => 'Blk/Byzantin',\n    'blk=canadiansyllabics' => 'Blk/Canadian',\n    'blk=carian' => 'Blk/Carian',\n    'blk=cham' => 'Blk/Cham',\n    'blk=cherokee' => 'Blk/Cherokee',\n    'blk=cjkcompatibility' => 'Blk/CJKCompa',\n    'blk=cjkcompatibilityforms' => 'Blk/CJKComp2',\n    'blk=cjkcompatibilityideographs' => 'Blk/CJKComp3',\n    'blk=cjkcompatibilityideographssupplement' => 'Blk/CJKComp4',\n    'blk=cjkradicalssupplement' => 'Blk/CJKRadic',\n    'blk=cjkstrokes' => 'Blk/CJKStrok',\n    'blk=cjksymbolsandpunctuation' => 'Blk/CJKSymbo',\n    'blk=cjkunifiedideographs' => 'Blk/CJKUnifi',\n    'blk=cjkunifiedideographsextensiona' => 'Blk/CJKUnif2',\n    'blk=cjkunifiedideographsextensionb' => 'Blk/CJKUnif3',\n    'blk=cjkunifiedideographsextensionc' => 'Blk/CJKUnif4',\n    'blk=cjkunifiedideographsextensiond' => 'Blk/CJKUnif5',\n    'blk=combiningdiacriticalmarks' => 'Blk/Combini3',\n    'blk=combiningdiacriticalmarksforsymbols' => 'Blk/Combini2',\n    'blk=combiningdiacriticalmarkssupplement' => 'Blk/Combini4',\n    'blk=combininghalfmarks' => 'Blk/Combinin',\n    'blk=combiningmarksforsymbols' => 'Blk/Combini2',\n    'blk=commonindicnumberforms' => 'Blk/CommonIn',\n    'blk=controlpictures' => 'Blk/ControlP',\n    'blk=coptic' => 'Blk/Coptic',\n    'blk=countingrodnumerals' => 'Blk/Counting',\n    'blk=cuneiform' => 'Blk/Cuneifor',\n    'blk=cuneiformnumbersandpunctuation' => 'Blk/Cuneifo2',\n    'blk=currencysymbols' => 'Blk/Currency',\n    'blk=cypriotsyllabary' => 'Blk/CypriotS',\n    'blk=cyrillic' => 'Blk/Cyrillic',\n    'blk=cyrillicextendeda' => 'Blk/Cyrilli2',\n    'blk=cyrillicextendedb' => 'Blk/Cyrilli3',\n    'blk=cyrillicsupplement' => 'Blk/Cyrilli4',\n    'blk=cyrillicsupplementary' => 'Blk/Cyrilli4',\n    'blk=deseret' => 'Blk/Deseret',\n    'blk=devanagari' => 'Blk/Devanaga',\n    'blk=devanagariextended' => 'Blk/Devanag2',\n    'blk=dingbats' => 'Blk/Dingbats',\n    'blk=dominotiles' => 'Blk/DominoTi',\n    'blk=egyptianhieroglyphs' => 'Blk/Egyptian',\n    'blk=emoticons' => 'Blk/Emoticon',\n    'blk=enclosedalphanumerics' => 'Blk/Enclosed',\n    'blk=enclosedalphanumericsupplement' => 'Blk/Enclose4',\n    'blk=enclosedcjklettersandmonths' => 'Blk/Enclose2',\n    'blk=enclosedideographicsupplement' => 'Blk/Enclose3',\n    'blk=ethiopic' => 'Blk/Ethiopic',\n    'blk=ethiopicextended' => 'Blk/Ethiopi2',\n    'blk=ethiopicextendeda' => 'Blk/Ethiopi3',\n    'blk=ethiopicsupplement' => 'Blk/Ethiopi4',\n    'blk=generalpunctuation' => 'Blk/GeneralP',\n    'blk=geometricshapes' => 'Blk/Geometri',\n    'blk=georgian' => 'Blk/Georgian',\n    'blk=georgiansupplement' => 'Blk/Georgia2',\n    'blk=glagolitic' => 'Blk/Glagolit',\n    'blk=gothic' => 'Blk/Gothic',\n    'blk=greek' => 'Blk/Greek',\n    'blk=greekandcoptic' => 'Blk/Greek',\n    'blk=greekextended' => 'Blk/GreekExt',\n    'blk=gujarati' => 'Blk/Gujarati',\n    'blk=gurmukhi' => 'Blk/Gurmukhi',\n    'blk=halfwidthandfullwidthforms' => 'Blk/Halfwidt',\n    'blk=hangulcompatibilityjamo' => 'Blk/HangulCo',\n    'blk=hanguljamo' => 'Blk/HangulJa',\n    'blk=hanguljamoextendeda' => 'Blk/HangulJ2',\n    'blk=hanguljamoextendedb' => 'Blk/HangulJ3',\n    'blk=hangulsyllables' => 'Blk/HangulSy',\n    'blk=hanunoo' => 'Blk/Hanunoo',\n    'blk=hebrew' => 'Blk/Hebrew',\n    'blk=highprivateusesurrogates' => 'Blk/HighPriv',\n    'blk=highsurrogates' => 'Blk/HighSurr',\n    'blk=hiragana' => 'Blk/Hiragana',\n    'blk=ideographicdescriptioncharacters' => 'Blk/Ideograp',\n    'blk=imperialaramaic' => 'Blk/Imperial',\n    'blk=inscriptionalpahlavi' => 'Blk/Inscript',\n    'blk=inscriptionalparthian' => 'Blk/Inscrip2',\n    'blk=ipaextensions' => 'Blk/IPAExten',\n    'blk=javanese' => 'Blk/Javanese',\n    'blk=kaithi' => 'Blk/Kaithi',\n    'blk=kanasupplement' => 'Blk/KanaSupp',\n    'blk=kanbun' => 'Blk/Kanbun',\n    'blk=kangxiradicals' => 'Blk/KangxiRa',\n    'blk=kannada' => 'Blk/Kannada',\n    'blk=katakana' => 'Blk/Katakana',\n    'blk=katakanaphoneticextensions' => 'Blk/Katakan2',\n    'blk=kayahli' => 'Blk/KayahLi',\n    'blk=kharoshthi' => 'Blk/Kharosht',\n    'blk=khmer' => 'Blk/Khmer',\n    'blk=khmersymbols' => 'Blk/KhmerSym',\n    'blk=lao' => 'Blk/Lao',\n    'blk=latin1' => 'Blk/Latin1',\n    'blk=latin1supplement' => 'Blk/Latin1',\n    'blk=latinextendeda' => 'Blk/LatinExt',\n    'blk=latinextendedadditional' => 'Blk/LatinEx5',\n    'blk=latinextendedb' => 'Blk/LatinEx2',\n    'blk=latinextendedc' => 'Blk/LatinEx3',\n    'blk=latinextendedd' => 'Blk/LatinEx4',\n    'blk=lepcha' => 'Blk/Lepcha',\n    'blk=letterlikesymbols' => 'Blk/Letterli',\n    'blk=limbu' => 'Blk/Limbu',\n    'blk=linearbideograms' => 'Blk/LinearBI',\n    'blk=linearbsyllabary' => 'Blk/LinearBS',\n    'blk=lisu' => 'Blk/Lisu',\n    'blk=lowsurrogates' => 'Blk/LowSurro',\n    'blk=lycian' => 'Blk/Lycian',\n    'blk=lydian' => 'Blk/Lydian',\n    'blk=mahjongtiles' => 'Blk/MahjongT',\n    'blk=malayalam' => 'Blk/Malayala',\n    'blk=mandaic' => 'Blk/Mandaic',\n    'blk=mathematicalalphanumericsymbols' => 'Blk/Mathema2',\n    'blk=mathematicaloperators' => 'Blk/Mathemat',\n    'blk=meeteimayek' => 'Blk/MeeteiMa',\n    'blk=miscellaneousmathematicalsymbolsa' => 'Blk/Miscell4',\n    'blk=miscellaneousmathematicalsymbolsb' => 'Blk/Miscell5',\n    'blk=miscellaneoussymbols' => 'Blk/Miscella',\n    'blk=miscellaneoussymbolsandarrows' => 'Blk/Miscell3',\n    'blk=miscellaneoussymbolsandpictographs' => 'Blk/Miscell6',\n    'blk=miscellaneoustechnical' => 'Blk/Miscell2',\n    'blk=modifiertoneletters' => 'Blk/Modifier',\n    'blk=mongolian' => 'Blk/Mongolia',\n    'blk=musicalsymbols' => 'Blk/MusicalS',\n    'blk=myanmar' =>", 8192) = 8192
09:02:57.362390 brk(0x21b3000)          = 0x21b3000
09:02:57.362624 read(3, " 'Blk/Myanmar',\n    'blk=myanmarextendeda' => 'Blk/MyanmarE',\n    'blk=newtailue' => 'Blk/NewTaiLu',\n    'blk=nko' => 'Blk/NKo',\n    'blk=noblock' => 'Blk/NoBlock',\n    'blk=numberforms' => 'Blk/NumberFo',\n    'blk=ogham' => 'Blk/Ogham',\n    'blk=olchiki' => 'Blk/OlChiki',\n    'blk=olditalic' => 'Blk/OldItali',\n    'blk=oldpersian' => 'Blk/OldPersi',\n    'blk=oldsoutharabian' => 'Blk/OldSouth',\n    'blk=oldturkic' => 'Blk/OldTurki',\n    'blk=opticalcharacterrecognition' => 'Blk/OpticalC',\n    'blk=oriya' => 'Blk/Oriya',\n    'blk=osmanya' => 'Blk/Osmanya',\n    'blk=phagspa' => 'Blk/PhagsPa',\n    'blk=phaistosdisc' => 'Blk/Phaistos',\n    'blk=phoenician' => 'Blk/Phoenici',\n    'blk=phoneticextensions' => 'Blk/Phonetic',\n    'blk=phoneticextensionssupplement' => 'Blk/Phoneti2',\n    'blk=playingcards' => 'Blk/PlayingC',\n    'blk=privateuse' => 'Blk/PrivateU',\n    'blk=privateusearea' => 'Blk/PrivateU',\n    'blk=rejang' => 'Blk/Rejang',\n    'blk=ruminumeralsymbols' => 'Blk/RumiNume',\n    'blk=runic' => 'Blk/Runic',\n    'blk=samaritan' => 'Blk/Samarita',\n    'blk=saurashtra' => 'Blk/Saurasht',\n    'blk=shavian' => 'Blk/Shavian',\n    'blk=sinhala' => 'Blk/Sinhala',\n    'blk=smallformvariants' => 'Blk/SmallFor',\n    'blk=spacingmodifierletters' => 'Blk/SpacingM',\n    'blk=specials' => 'Blk/Specials',\n    'blk=sundanese' => 'Blk/Sundanes',\n    'blk=superscriptsandsubscripts' => 'Blk/Superscr',\n    'blk=supplementalarrowsa' => 'Blk/Suppleme',\n    'blk=supplementalarrowsb' => 'Blk/Supplem2',\n    'blk=supplementalmathematicaloperators' => 'Blk/Supplem6',\n    'blk=supplementalpunctuation' => 'Blk/Supplem3',\n    'blk=supplementaryprivateuseareaa' => 'Blk/Supplem4',\n    'blk=supplementaryprivateuseareab' => 'Blk/Supplem5',\n    'blk=sylotinagri' => 'Blk/SylotiNa',\n    'blk=syriac' => 'Blk/Syriac',\n    'blk=tagalog' => 'Blk/Tagalog',\n    'blk=tagbanwa' => 'Blk/Tagbanwa',\n    'blk=tags' => 'Blk/Tags',\n    'blk=taile' => 'Blk/TaiLe',\n    'blk=taitham' => 'Blk/TaiTham',\n    'blk=taiviet' => 'Blk/TaiViet',\n    'blk=taixuanjingsymbols' => 'Blk/TaiXuanJ',\n    'blk=tamil' => 'Blk/Tamil',\n    'blk=telugu' => 'Blk/Telugu',\n    'blk=thaana' => 'Blk/Thaana',\n    'blk=thai' => 'Blk/Thai',\n    'blk=tibetan' => 'Blk/Tibetan',\n    'blk=tifinagh' => 'Blk/Tifinagh',\n    'blk=transportandmapsymbols' => 'Blk/Transpor',\n    'blk=ugaritic' => 'Blk/Ugaritic',\n    'blk=unifiedcanadianaboriginalsyllabics' => 'Blk/Canadian',\n    'blk=unifiedcanadianaboriginalsyllabicsextended' => 'Blk/UnifiedC',\n    'blk=vai' => 'Blk/Vai',\n    'blk=variationselectors' => 'Blk/Variatio',\n    'blk=variationselectorssupplement' => 'Blk/Variati2',\n    'blk=vedicextensions' => 'Blk/VedicExt',\n    'blk=verticalforms' => 'Blk/Vertical',\n    'blk=yijinghexagramsymbols' => 'Blk/YijingHe',\n    'blk=yiradicals' => 'Blk/YiRadica',\n    'blk=yisyllables' => 'Blk/YiSyllab',\n    'blockelements' => 'Blk/BlockEle',\n    'bopo' => 'Sc/Bopo',\n    'bopomofo' => 'Sc/Bopo',\n    'bopomofoextended' => 'Blk/Bopomof2',\n    'boxdrawing' => 'Blk/BoxDrawi',\n    'brah' => 'Sc/Brah',\n    'brahmi' => 'Sc/Brah',\n    'brai' => 'Blk/BrailleP',\n    'braille' => 'Blk/BrailleP',\n    'braillepatterns' => 'Blk/BrailleP',\n    'bugi' => 'Sc/Bugi',\n    'buginese' => 'Sc/Bugi',\n    'buhd' => 'Sc/Buhd',\n    'buhid' => 'Sc/Buhd',\n    'byzantinemusicalsymbols' => 'Blk/Byzantin',\n    'c' => 'Gc/C',\n    'canadianaboriginal' => 'Sc/Cans',\n    'canadiansyllabics' => 'Blk/Canadian',\n    'cans' => 'Sc/Cans',\n    'cari' => 'Sc/Cari',\n    'carian' => 'Sc/Cari',\n    'cased' => 'Cased/Y',\n    'cased=f' => 'Cased/N',\n    'cased=false' => 'Cased/N',\n    'cased=n' => 'Cased/N',\n    'cased=no' => 'Cased/N',\n    'cased=t' => 'Cased/Y',\n    'cased=true' => 'Cased/Y',\n    'cased=y' => 'Cased/Y',\n    'cased=yes' => 'Cased/Y',\n    'casedletter' => 'Gc/LC',\n    'caseignorable' => 'CI/Y',\n    'cc' => 'Gc/Cc',\n    'ccc=a' => 'Ccc/A',\n    'ccc=above' => 'Ccc/A',\n    'ccc=aboveleft' => 'Ccc/AL',\n    'ccc=aboveright' => 'Ccc/AR',\n    'ccc=al' => 'Ccc/AL',\n    'ccc=ar' => 'Ccc/AR',\n    'ccc=ata' => 'Ccc/ATA',\n    'ccc=atar' => 'Ccc/ATAR',\n    'ccc=atb' => 'Ccc/ATB',\n    'ccc=atbl' => 'Ccc/ATBL',\n    'ccc=attachedabove' => 'Ccc/ATA',\n    'ccc=attachedaboveright' => 'Ccc/ATAR',\n    'ccc=attachedbelow' => 'Ccc/ATB',\n    'ccc=attachedbelowleft' => 'Ccc/ATBL',\n    'ccc=b' => 'Ccc/B',\n    'ccc=below' => 'Ccc/B',\n    'ccc=belowleft' => 'Ccc/BL',\n    'ccc=belowright' => 'Ccc/BR',\n    'ccc=bl' => 'Ccc/BL',\n    'ccc=br' => 'Ccc/BR',\n    'ccc=da' => 'Ccc/DA',\n    'ccc=db' => 'Ccc/DB',\n    'ccc=doubleabove' => 'Ccc/DA',\n    'ccc=doublebelow' => 'Ccc/DB',\n    'ccc=iotasubscript' => 'Ccc/IS',\n    'ccc=is' => 'Ccc/IS',\n    'ccc=kanavoicing' => 'Ccc/KV',\n    'ccc=kv' => 'Ccc/KV',\n    'ccc=l' => 'Ccc/L',\n    'ccc=left' => 'Ccc/L',\n    'ccc=nk' => 'Ccc/NK',\n    'ccc=notreordered' => 'Ccc/NR',\n    'ccc=nr' => 'Ccc/NR',\n    'ccc=nukta' => 'Ccc/NK',\n    'ccc=ov' => 'Ccc/OV',\n    'ccc=overlay' => 'Ccc/OV',\n    'ccc=r' => 'Ccc/R',\n    'ccc=right' => 'Ccc/R',\n    'ccc=virama' => 'Ccc/VR',\n    'ccc=vr' => 'Ccc/VR',\n    'ce' => 'CE/Y',\n    'ce=f' => 'CE/N',\n    'ce=false' => 'CE/N',\n    'ce=n' => 'CE/N',\n    'ce=no' => 'CE/N',\n    'ce=t' => 'CE/Y',\n    'ce=true' => 'CE/Y',\n    'ce=y' => 'CE/Y',\n    'ce=yes' => 'CE/Y',\n    'cf' => 'Gc/Cf',\n    'cham' => 'Sc/Cham',\n    'changeswhencasefolded' => 'CWCF/Y',\n    'changeswhencasemapped' => 'CWCM/Y',\n    'changeswhenlowercased' => 'CWL/Y',\n    'changeswhennfkccasefolded' => 'CWKCF/Y',\n    'changeswhentitlecased' => 'CWT/Y',\n    'changeswhenuppercased' => 'CWU/Y',\n    'cher' => 'Sc/Cher',\n    'cherokee' => 'Sc/Cher',\n    'ci' => 'CI/Y',\n    'ci=f' => 'CI/N',\n    'ci=false' => 'CI/N',\n    'ci=n' => 'CI/N',\n    'ci=no' => 'CI/N',\n    'ci=t' => 'CI/Y',\n    'ci=true' => 'CI/Y',\n    'ci=y' => 'CI/Y',\n    'ci=yes' => 'CI/Y',\n    'cjkcompatibility' => 'Blk/CJKCompa',\n    'cjkcompatibilityforms' => 'Blk/CJKComp2',\n    'cjkcompatibilityideographs' => 'Blk/CJKComp3',\n    'cjkcompatibilityideographssupplement' => 'Blk/CJKComp4',\n    'cjkradicalssupplement' => 'Blk/CJKRadic',\n    'cjkstrokes' => 'Blk/CJKStrok',\n    'cjksymbolsandpunctuation' => 'Blk/CJKSymbo',\n    'cjkunifiedideographs' => 'Blk/CJKUnifi',\n    'cjkunifiedideographsextensiona' => 'Blk/CJKUnif2',\n    'cjkunifiedideographsextensionb' => 'Blk/CJKUnif3',\n    'cjkunifiedideographsextensionc' => 'Blk/CJKUnif4',\n    'cjkunifiedideographsextensiond' => 'Blk/CJKUnif5',\n    'closepunctuation' => 'Gc/Pe',\n    'cn' => 'Gc/Cn',\n    'cntrl' => 'Gc/Cc',\n    'co' => 'Gc/Co',\n    'combiningdiacriticalmarks' => 'Blk/Combini3',\n    'combiningdiacriticalmarksforsymbols' => 'Blk/Combini2',\n    'combiningdiacriticalmarkssupplement' => 'Blk/Combini4',\n    'combininghalfmarks' => 'Blk/Combinin',\n    'combiningmarksforsymbols' => 'Blk/Combini2',\n    'common' => 'Sc/Zyyy',\n    'commonindicnumberforms' => 'Blk/CommonIn',\n    'compex' => 'CompEx/Y',\n    'compex=f' => 'CompEx/N',\n    'compex=false' => 'CompEx/N',\n    'compex=n' => 'CompEx/N',\n    'compex=no' => 'CompEx/N',\n    'compex=t' => 'CompEx/Y',\n    'compex=true' => 'CompEx/Y',\n    'compex=y' => 'CompEx/Y',\n    'compex=yes' => 'CompEx/Y',\n    'compositionexclusion' => 'CE/Y',\n    'connectorpunctuation' => 'WB/EX',\n    'control' => 'Gc/Cc',\n    'controlpictures' => 'Blk/ControlP',\n    'copt' => 'Sc/Copt',\n    'coptic' => 'Sc/Copt',\n    'countingrodnumerals' => 'Blk/Counting',\n    'cprt' => 'Sc/Cprt',\n    'cs' => 'Gc/Cs',\n    'cuneiform' => 'Sc/Xsux',\n    'cuneiformnumbersandpunctuation' => 'Blk/Cuneifo2',\n    'currencysymbol' => 'Gc/Sc',\n    'currencysymbols' => 'Blk/Currency',\n    'cwcf' => 'CWCF/Y',\n    'cwcf=f' => 'CWCF/N',\n    'cwcf=false' => 'CWCF/N',\n    'cwcf=n' => 'CWCF/N',\n    'cwcf=no' => 'CWCF/N',\n    'cwcf=t' => 'CWCF/Y',\n    'cwcf=true' => 'CWCF/Y',\n    'cwcf=y' => 'CWCF/Y',\n    'cwcf=yes' => 'CWCF/Y',\n    'cwcm' => 'CWCM/Y',\n    'cwcm=f' => 'CWCM/N',\n    'cwcm=false' => 'CWCM/N',\n    'cwcm=n' => 'CWCM/N',\n    'cwcm=no' => 'CWCM/N',\n    'cwcm=t' => 'CWCM/Y',\n    'cwcm=true' => 'CWCM/Y',\n    'cwcm=y' => 'CWCM/Y',\n    'cwcm=yes' => 'CWCM/Y',\n    'cwkcf' => 'CWKCF/Y',\n    'cwkcf=f' => 'CWKCF/N',\n    'cwkcf=false' => 'CWKCF/N',\n    'cwkcf=n' => 'CWKCF/N',\n    'c", 8192) = 8192
09:02:57.364089 read(3, "wkcf=no' => 'CWKCF/N',\n    'cwkcf=t' => 'CWKCF/Y',\n    'cwkcf=true' => 'CWKCF/Y',\n    'cwkcf=y' => 'CWKCF/Y',\n    'cwkcf=yes' => 'CWKCF/Y',\n    'cwl' => 'CWL/Y',\n    'cwl=f' => 'CWL/N',\n    'cwl=false' => 'CWL/N',\n    'cwl=n' => 'CWL/N',\n    'cwl=no' => 'CWL/N',\n    'cwl=t' => 'CWL/Y',\n    'cwl=true' => 'CWL/Y',\n    'cwl=y' => 'CWL/Y',\n    'cwl=yes' => 'CWL/Y',\n    'cwt' => 'CWT/Y',\n    'cwt=f' => 'CWT/N',\n    'cwt=false' => 'CWT/N',\n    'cwt=n' => 'CWT/N',\n    'cwt=no' => 'CWT/N',\n    'cwt=t' => 'CWT/Y',\n    'cwt=true' => 'CWT/Y',\n    'cwt=y' => 'CWT/Y',\n    'cwt=yes' => 'CWT/Y',\n    'cwu' => 'CWU/Y',\n    'cwu=f' => 'CWU/N',\n    'cwu=false' => 'CWU/N',\n    'cwu=n' => 'CWU/N',\n    'cwu=no' => 'CWU/N',\n    'cwu=t' => 'CWU/Y',\n    'cwu=true' => 'CWU/Y',\n    'cwu=y' => 'CWU/Y',\n    'cwu=yes' => 'CWU/Y',\n    'cypriot' => 'Sc/Cprt',\n    'cypriotsyllabary' => 'Blk/CypriotS',\n    'cyrillic' => 'Sc/Cyrl',\n    'cyrillicextendeda' => 'Blk/Cyrilli2',\n    'cyrillicextendedb' => 'Blk/Cyrilli3',\n    'cyrillicsupplement' => 'Blk/Cyrilli4',\n    'cyrillicsupplementary' => 'Blk/Cyrilli4',\n    'cyrl' => 'Sc/Cyrl',\n    'dash' => 'Dash/Y',\n    'dash=f' => 'Dash/N',\n    'dash=false' => 'Dash/N',\n    'dash=n' => 'Dash/N',\n    'dash=no' => 'Dash/N',\n    'dash=t' => 'Dash/Y',\n    'dash=true' => 'Dash/Y',\n    'dash=y' => 'Dash/Y',\n    'dash=yes' => 'Dash/Y',\n    'dashpunctuation' => 'Gc/Pd',\n    'decimalnumber' => 'Nt/De',\n    'defaultignorablecodepoint' => 'DI/Y',\n    'dep' => 'Dep/Y',\n    'dep=f' => 'Dep/N',\n    'dep=false' => 'Dep/N',\n    'dep=n' => 'Dep/N',\n    'dep=no' => 'Dep/N',\n    'dep=t' => 'Dep/Y',\n    'dep=true' => 'Dep/Y',\n    'dep=y' => 'Dep/Y',\n    'dep=yes' => 'Dep/Y',\n    'deprecated' => 'Dep/Y',\n    'deseret' => 'Blk/Deseret',\n    'deva' => 'Sc/Deva',\n    'devanagari' => 'Sc/Deva',\n    'devanagariextended' => 'Blk/Devanag2',\n    'di' => 'DI/Y',\n    'di=f' => 'DI/N',\n    'di=false' => 'DI/N',\n    'di=n' => 'DI/N',\n    'di=no' => 'DI/N',\n    'di=t' => 'DI/Y',\n    'di=true' => 'DI/Y',\n    'di=y' => 'DI/Y',\n    'di=yes' => 'DI/Y',\n    'dia' => 'Dia/Y',\n    'dia=f' => 'Dia/N',\n    'dia=false' => 'Dia/N',\n    'dia=n' => 'Dia/N',\n    'dia=no' => 'Dia/N',\n    'dia=t' => 'Dia/Y',\n    'dia=true' => 'Dia/Y',\n    'dia=y' => 'Dia/Y',\n    'dia=yes' => 'Dia/Y',\n    'diacritic' => 'Dia/Y',\n    'digit' => 'Nt/De',\n    'dingbats' => 'Blk/Dingbats',\n    'dominotiles' => 'Blk/DominoTi',\n    'dsrt' => 'Blk/Deseret',\n    'dt=can' => 'NFDQC/N',\n    'dt=canonical' => 'NFDQC/N',\n    'dt=circle' => 'Dt/Enc',\n    'dt=com' => 'Dt/Com',\n    'dt=compat' => 'Dt/Com',\n    'dt=enc' => 'Dt/Enc',\n    'dt=fin' => 'Dt/Fin',\n    'dt=final' => 'Dt/Fin',\n    'dt=font' => 'Dt/Font',\n    'dt=fra' => 'Dt/Fra',\n    'dt=fraction' => 'Dt/Fra',\n    'dt=init' => 'Dt/Init',\n    'dt=initial' => 'Dt/Init',\n    'dt=iso' => 'Dt/Iso',\n    'dt=isolated' => 'Dt/Iso',\n    'dt=med' => 'Dt/Med',\n    'dt=medial' => 'Dt/Med',\n    'dt=nar' => 'Dt/Nar',\n    'dt=narrow' => 'Dt/Nar',\n    'dt=nb' => 'Dt/Nb',\n    'dt=nobreak' => 'Dt/Nb',\n    'dt=noncanon' => 'Dt/NonCanon',\n    'dt=noncanonical' => 'Dt/NonCanon',\n    'dt=none' => 'Dt/None',\n    'dt=small' => 'Dt/Sml',\n    'dt=sml' => 'Dt/Sml',\n    'dt=sqr' => 'Dt/Sqr',\n    'dt=square' => 'Dt/Sqr',\n    'dt=sub' => 'Dt/Sub',\n    'dt=sup' => 'Dt/Sup',\n    'dt=super' => 'Dt/Sup',\n    'dt=vert' => 'Dt/Vert',\n    'dt=vertical' => 'Dt/Vert',\n    'dt=wide' => 'Ea/F',\n    'ea=a' => 'Ea/A',\n    'ea=ambiguous' => 'Ea/A',\n    'ea=f' => 'Ea/F',\n    'ea=fullwidth' => 'Ea/F',\n    'ea=h' => 'Ea/H',\n    'ea=halfwidth' => 'Ea/H',\n    'ea=n' => 'Ea/N',\n    'ea=na' => 'Ea/Na',\n    'ea=narrow' => 'Ea/Na',\n    'ea=neutral' => 'Ea/N',\n    'ea=w' => 'Ea/W',\n    'ea=wide' => 'Ea/W',\n    'egyp' => 'Sc/Egyp',\n    'egyptianhieroglyphs' => 'Sc/Egyp',\n    'emoticons' => 'Blk/Emoticon',\n    'enclosedalphanumerics' => 'Blk/Enclosed',\n    'enclosedalphanumericsupplement' => 'Blk/Enclose4',\n    'enclosedcjklettersandmonths' => 'Blk/Enclose2',\n    'enclosedideographicsupplement' => 'Blk/Enclose3',\n    'enclosingmark' => 'Gc/Me',\n    'ethi' => 'Sc/Ethi',\n    'ethiopic' => 'Sc/Ethi',\n    'ethiopicextended' => 'Blk/Ethiopi2',\n    'ethiopicextendeda' => 'Blk/Ethiopi3',\n    'ethiopicsupplement' => 'Blk/Ethiopi4',\n    'ext' => 'Ext/Y',\n    'ext=f' => 'Ext/N',\n    'ext=false' => 'Ext/N',\n    'ext=n' => 'Ext/N',\n    'ext=no' => 'Ext/N',\n    'ext=t' => 'Ext/Y',\n    'ext=true' => 'Ext/Y',\n    'ext=y' => 'Ext/Y',\n    'ext=yes' => 'Ext/Y',\n    'extender' => 'Ext/Y',\n    'finalpunctuation' => 'Gc/Pf',\n    'format' => 'Gc/Cf',\n    'fullcompositionexclusion' => 'CompEx/Y',\n    'gc=c' => 'Gc/C',\n    'gc=casedletter' => 'Gc/LC',\n    'gc=cc' => 'Gc/Cc',\n    'gc=cf' => 'Gc/Cf',\n    'gc=closepunctuation' => 'Gc/Pe',\n    'gc=cn' => 'Gc/Cn',\n    'gc=cntrl' => 'Gc/Cc',\n    'gc=co' => 'Gc/Co',\n    'gc=connectorpunctuation' => 'WB/EX',\n    'gc=control' => 'Gc/Cc',\n    'gc=cs' => 'Gc/Cs',\n    'gc=currencysymbol' => 'Gc/Sc',\n    'gc=dashpunctuation' => 'Gc/Pd',\n    'gc=decimalnumber' => 'Nt/De',\n    'gc=digit' => 'Nt/De',\n    'gc=enclosingmark' => 'Gc/Me',\n    'gc=finalpunctuation' => 'Gc/Pf',\n    'gc=format' => 'Gc/Cf',\n    'gc=initialpunctuation' => 'Gc/Pi',\n    'gc=l' => 'Gc/L',\n    'gc=l&' => 'Gc/LC',\n    'gc=l_' => 'Gc/LC',\n    'gc=lc' => 'Gc/LC',\n    'gc=letter' => 'Gc/L',\n    'gc=letternumber' => 'Gc/Nl',\n    'gc=lineseparator' => 'Gc/Zl',\n    'gc=ll' => 'Gc/Ll',\n    'gc=lm' => 'Gc/Lm',\n    'gc=lo' => 'Gc/Lo',\n    'gc=lowercaseletter' => 'Gc/Ll',\n    'gc=lt' => 'Perl/Title',\n    'gc=lu' => 'Gc/Lu',\n    'gc=m' => 'Gc/M',\n    'gc=mark' => 'Gc/M',\n    'gc=mathsymbol' => 'Gc/Sm',\n    'gc=mc' => 'Gc/Mc',\n    'gc=me' => 'Gc/Me',\n    'gc=mn' => 'Gc/Mn',\n    'gc=modifierletter' => 'Gc/Lm',\n    'gc=modifiersymbol' => 'Gc/Sk',\n    'gc=n' => 'Gc/N',\n    'gc=nd' => 'Nt/De',\n    'gc=nl' => 'Gc/Nl',\n    'gc=no' => 'Gc/No',\n    'gc=nonspacingmark' => 'Gc/Mn',\n    'gc=number' => 'Gc/N',\n    'gc=openpunctuation' => 'Gc/Ps',\n    'gc=other' => 'Gc/C',\n    'gc=otherletter' => 'Gc/Lo',\n    'gc=othernumber' => 'Gc/No',\n    'gc=otherpunctuation' => 'Gc/Po',\n    'gc=othersymbol' => 'Gc/So',\n    'gc=p' => 'Gc/P',\n    'gc=paragraphseparator' => 'Gc/Zp',\n    'gc=pc' => 'WB/EX',\n    'gc=pd' => 'Gc/Pd',\n    'gc=pe' => 'Gc/Pe',\n    'gc=pf' => 'Gc/Pf',\n    'gc=pi' => 'Gc/Pi',\n    'gc=po' => 'Gc/Po',\n    'gc=privateuse' => 'Gc/Co',\n    'gc=ps' => 'Gc/Ps',\n    'gc=punct' => 'Gc/P',\n    'gc=punctuation' => 'Gc/P',\n    'gc=s' => 'Gc/S',\n    'gc=sc' => 'Gc/Sc',\n    'gc=separator' => 'Gc/Z',\n    'gc=sk' => 'Gc/Sk',\n    'gc=sm' => 'Gc/Sm',\n    'gc=so' => 'Gc/So',\n    'gc=spaceseparator' => 'Gc/Zs',\n    'gc=spacingmark' => 'Gc/Mc',\n    'gc=surrogate' => 'Gc/Cs',\n    'gc=symbol' => 'Gc/S',\n    'gc=titlecaseletter' => 'Perl/Title',\n    'gc=unassigned' => 'Gc/Cn',\n    'gc=uppercaseletter' => 'Gc/Lu',\n    'gc=z' => 'Gc/Z',\n    'gc=zl' => 'Gc/Zl',\n    'gc=zp' => 'Gc/Zp',\n    'gc=zs' => 'Gc/Zs',\n    'gcb=cn' => 'GCB/CN',\n    'gcb=control' => 'GCB/CN',\n    'gcb=cr' => 'GCB/CR',\n    'gcb=ex' => 'GCB/EX',\n    'gcb=extend' => 'GCB/EX',\n    'gcb=l' => 'GCB/L',\n    'gcb=lf' => 'GCB/LF',\n    'gcb=lv' => 'GCB/LV',\n    'gcb=lvt' => 'GCB/LVT',\n    'gcb=other' => 'GCB/XX',\n    'gcb=pp' => 'GCB/PP',\n    'gcb=prepend' => 'GCB/PP',\n    'gcb=sm' => 'GCB/SM',\n    'gcb=spacingmark' => 'GCB/SM',\n    'gcb=t' => 'GCB/T',\n    'gcb=v' => 'GCB/V',\n    'gcb=xx' => 'GCB/XX',\n    'generalpunctuation' => 'Blk/GeneralP',\n    'geometricshapes' => 'Blk/Geometri',\n    'geor' => 'Sc/Geor',\n    'georgian' => 'Sc/Geor',\n    'georgiansupplement' => 'Blk/Georgia2',\n    'glag' => 'Sc/Glag',\n    'glagolitic' => 'Sc/Glag',\n    'goth' => 'Sc/Goth',\n    'gothic' => 'Sc/Goth',\n    'graph' => 'Perl/Graph',\n    'graphemebase' => 'GrBase/Y',\n    'graphemeextend' => 'GCB/EX',\n    'grbase' => 'GrBase/Y',\n    'grbase=f' => 'GrBase/N',\n    'grbase=false' => 'GrBase/N',\n    'grbase=n' => 'GrBase/N',\n    'grbase=no' => 'GrBase/N',\n    'grbase=t' => 'GrBase/Y',\n    'grbase=true' => 'GrBase/Y',\n    'grbase=y' => 'GrBase/Y',\n    'grbase=yes' => 'GrBase/Y',\n    'greek' => 'Sc/Grek',\n    'greekandcoptic' => 'Blk/Greek',\n    'greekextended' => 'Blk/GreekExt',\n    'grek' => 'Sc/Grek',\n    'grext' => 'GCB/EX',\n    'g", 8192) = 8192
09:02:57.365465 brk(0x21d4000)          = 0x21d4000
09:02:57.365706 read(3, "rext=f' => 'GrExt/N',\n    'grext=false' => 'GrExt/N',\n    'grext=n' => 'GrExt/N',\n    'grext=no' => 'GrExt/N',\n    'grext=t' => 'GCB/EX',\n    'grext=true' => 'GCB/EX',\n    'grext=y' => 'GCB/EX',\n    'grext=yes' => 'GCB/EX',\n    'gujarati' => 'Sc/Gujr',\n    'gujr' => 'Sc/Gujr',\n    'gurmukhi' => 'Sc/Guru',\n    'guru' => 'Sc/Guru',\n    'halfwidthandfullwidthforms' => 'Blk/Halfwidt',\n    'han' => 'Sc/Han',\n    'hang' => 'Sc/Hang',\n    'hangul' => 'Sc/Hang',\n    'hangulcompatibilityjamo' => 'Blk/HangulCo',\n    'hanguljamo' => 'Blk/HangulJa',\n    'hanguljamoextendeda' => 'Blk/HangulJ2',\n    'hanguljamoextendedb' => 'Blk/HangulJ3',\n    'hangulsyllables' => 'Blk/HangulSy',\n    'hani' => 'Sc/Han',\n    'hano' => 'Sc/Hano',\n    'hanunoo' => 'Sc/Hano',\n    'hebr' => 'Sc/Hebr',\n    'hebrew' => 'Sc/Hebr',\n    'hex' => 'Hex/Y',\n    'hex=f' => 'Hex/N',\n    'hex=false' => 'Hex/N',\n    'hex=n' => 'Hex/N',\n    'hex=no' => 'Hex/N',\n    'hex=t' => 'Hex/Y',\n    'hex=true' => 'Hex/Y',\n    'hex=y' => 'Hex/Y',\n    'hex=yes' => 'Hex/Y',\n    'hexdigit' => 'Hex/Y',\n    'highprivateusesurrogates' => 'Blk/HighPriv',\n    'highsurrogates' => 'Blk/HighSurr',\n    'hira' => 'Sc/Hira',\n    'hiragana' => 'Sc/Hira',\n    'horizspace' => 'Perl/Blank',\n    'hst=l' => 'GCB/L',\n    'hst=leadingjamo' => 'GCB/L',\n    'hst=lv' => 'GCB/LV',\n    'hst=lvsyllable' => 'GCB/LV',\n    'hst=lvt' => 'GCB/LVT',\n    'hst=lvtsyllable' => 'GCB/LVT',\n    'hst=na' => 'Hst/NA',\n    'hst=notapplicable' => 'Hst/NA',\n    'hst=t' => 'GCB/T',\n    'hst=trailingjamo' => 'GCB/T',\n    'hst=v' => 'GCB/V',\n    'hst=voweljamo' => 'GCB/V',\n    'hyphen' => 'Hyphen/Y',\n    'hyphen=f' => 'Hyphen/N',\n    'hyphen=false' => 'Hyphen/N',\n    'hyphen=n' => 'Hyphen/N',\n    'hyphen=no' => 'Hyphen/N',\n    'hyphen=t' => 'Hyphen/Y',\n    'hyphen=true' => 'Hyphen/Y',\n    'hyphen=y' => 'Hyphen/Y',\n    'hyphen=yes' => 'Hyphen/Y',\n    'idc' => 'IDC/Y',\n    'idc=f' => 'IDC/N',\n    'idc=false' => 'IDC/N',\n    'idc=n' => 'IDC/N',\n    'idc=no' => 'IDC/N',\n    'idc=t' => 'IDC/Y',\n    'idc=true' => 'IDC/Y',\n    'idc=y' => 'IDC/Y',\n    'idc=yes' => 'IDC/Y',\n    'idcontinue' => 'IDC/Y',\n    'ideo' => 'Ideo/Y',\n    'ideo=f' => 'Ideo/N',\n    'ideo=false' => 'Ideo/N',\n    'ideo=n' => 'Ideo/N',\n    'ideo=no' => 'Ideo/N',\n    'ideo=t' => 'Ideo/Y',\n    'ideo=true' => 'Ideo/Y',\n    'ideo=y' => 'Ideo/Y',\n    'ideo=yes' => 'Ideo/Y',\n    'ideographic' => 'Ideo/Y',\n    'ideographicdescriptioncharacters' => 'Blk/Ideograp',\n    'ids' => 'IDS/Y',\n    'ids=f' => 'IDS/N',\n    'ids=false' => 'IDS/N',\n    'ids=n' => 'IDS/N',\n    'ids=no' => 'IDS/N',\n    'ids=t' => 'IDS/Y',\n    'ids=true' => 'IDS/Y',\n    'ids=y' => 'IDS/Y',\n    'ids=yes' => 'IDS/Y',\n    'idsb' => 'IDSB/Y',\n    'idsb=f' => 'IDSB/N',\n    'idsb=false' => 'IDSB/N',\n    'idsb=n' => 'IDSB/N',\n    'idsb=no' => 'IDSB/N',\n    'idsb=t' => 'IDSB/Y',\n    'idsb=true' => 'IDSB/Y',\n    'idsb=y' => 'IDSB/Y',\n    'idsb=yes' => 'IDSB/Y',\n    'idsbinaryoperator' => 'IDSB/Y',\n    'idst' => 'IDST/Y',\n    'idst=f' => 'IDST/N',\n    'idst=false' => 'IDST/N',\n    'idst=n' => 'IDST/N',\n    'idst=no' => 'IDST/N',\n    'idst=t' => 'IDST/Y',\n    'idst=true' => 'IDST/Y',\n    'idst=y' => 'IDST/Y',\n    'idst=yes' => 'IDST/Y',\n    'idstart' => 'IDS/Y',\n    'idstrinaryoperator' => 'IDST/Y',\n    'imperialaramaic' => 'Sc/Armi',\n    'in=unassigned' => 'Age/Unassign',\n    'inaegeannumbers' => 'Blk/AegeanNu',\n    'inalchemicalsymbols' => 'Blk/Alchemic',\n    'inalphabeticpresentationforms' => 'Blk/Alphabet',\n    'inancientgreekmusicalnotation' => 'Blk/Ancient2',\n    'inancientgreeknumbers' => 'Blk/AncientG',\n    'inancientsymbols' => 'Blk/AncientS',\n    'inarabic' => 'Blk/Arabic',\n    'inarabicpresentationformsa' => 'Blk/ArabicPr',\n    'inarabicpresentationformsb' => 'Blk/ArabicP2',\n    'inarabicsupplement' => 'Blk/ArabicSu',\n    'inarmenian' => 'Blk/Armenian',\n    'inarrows' => 'Blk/Arrows',\n    'inascii' => 'Blk/ASCII',\n    'inavestan' => 'Blk/Avestan',\n    'inbalinese' => 'Blk/Balinese',\n    'inbamum' => 'Blk/Bamum',\n    'inbamumsupplement' => 'Blk/BamumSup',\n    'inbasiclatin' => 'Blk/ASCII',\n    'inbatak' => 'Blk/Batak',\n    'inbengali' => 'Blk/Bengali',\n    'inblockelements' => 'Blk/BlockEle',\n    'inbopomofo' => 'Blk/Bopomofo',\n    'inbopomofoextended' => 'Blk/Bopomof2',\n    'inboxdrawing' => 'Blk/BoxDrawi',\n    'inbrahmi' => 'Blk/Brahmi',\n    'inbraillepatterns' => 'Blk/BrailleP',\n    'inbuginese' => 'Blk/Buginese',\n    'inbuhid' => 'Blk/Buhid',\n    'inbyzantinemusicalsymbols' => 'Blk/Byzantin',\n    'incanadiansyllabics' => 'Blk/Canadian',\n    'incarian' => 'Blk/Carian',\n    'incham' => 'Blk/Cham',\n    'incherokee' => 'Blk/Cherokee',\n    'incjkcompatibility' => 'Blk/CJKCompa',\n    'incjkcompatibilityforms' => 'Blk/CJKComp2',\n    'incjkcompatibilityideographs' => 'Blk/CJKComp3',\n    'incjkcompatibilityideographssupplement' => 'Blk/CJKComp4',\n    'incjkradicalssupplement' => 'Blk/CJKRadic',\n    'incjkstrokes' => 'Blk/CJKStrok',\n    'incjksymbolsandpunctuation' => 'Blk/CJKSymbo',\n    'incjkunifiedideographs' => 'Blk/CJKUnifi',\n    'incjkunifiedideographsextensiona' => 'Blk/CJKUnif2',\n    'incjkunifiedideographsextensionb' => 'Blk/CJKUnif3',\n    'incjkunifiedideographsextensionc' => 'Blk/CJKUnif4',\n    'incjkunifiedideographsextensiond' => 'Blk/CJKUnif5',\n    'incombiningdiacriticalmarks' => 'Blk/Combini3',\n    'incombiningdiacriticalmarksforsymbols' => 'Blk/Combini2',\n    'incombiningdiacriticalmarkssupplement' => 'Blk/Combini4',\n    'incombininghalfmarks' => 'Blk/Combinin',\n    'incombiningmarksforsymbols' => 'Blk/Combini2',\n    'incommonindicnumberforms' => 'Blk/CommonIn',\n    'incontrolpictures' => 'Blk/ControlP',\n    'incoptic' => 'Blk/Coptic',\n    'incountingrodnumerals' => 'Blk/Counting',\n    'incuneiform' => 'Blk/Cuneifor',\n    'incuneiformnumbersandpunctuation' => 'Blk/Cuneifo2',\n    'incurrencysymbols' => 'Blk/Currency',\n    'incypriotsyllabary' => 'Blk/CypriotS',\n    'incyrillic' => 'Blk/Cyrillic',\n    'incyrillicextendeda' => 'Blk/Cyrilli2',\n    'incyrillicextendedb' => 'Blk/Cyrilli3',\n    'incyrillicsupplement' => 'Blk/Cyrilli4',\n    'incyrillicsupplementary' => 'Blk/Cyrilli4',\n    'indeseret' => 'Blk/Deseret',\n    'indevanagari' => 'Blk/Devanaga',\n    'indevanagariextended' => 'Blk/Devanag2',\n    'indingbats' => 'Blk/Dingbats',\n    'indominotiles' => 'Blk/DominoTi',\n    'inegyptianhieroglyphs' => 'Blk/Egyptian',\n    'inemoticons' => 'Blk/Emoticon',\n    'inenclosedalphanumerics' => 'Blk/Enclosed',\n    'inenclosedalphanumericsupplement' => 'Blk/Enclose4',\n    'inenclosedcjklettersandmonths' => 'Blk/Enclose2',\n    'inenclosedideographicsupplement' => 'Blk/Enclose3',\n    'inethiopic' => 'Blk/Ethiopic',\n    'inethiopicextended' => 'Blk/Ethiopi2',\n    'inethiopicextendeda' => 'Blk/Ethiopi3',\n    'inethiopicsupplement' => 'Blk/Ethiopi4',\n    'ingeneralpunctuation' => 'Blk/GeneralP',\n    'ingeometricshapes' => 'Blk/Geometri',\n    'ingeorgian' => 'Blk/Georgian',\n    'ingeorgiansupplement' => 'Blk/Georgia2',\n    'inglagolitic' => 'Blk/Glagolit',\n    'ingothic' => 'Blk/Gothic',\n    'ingreek' => 'Blk/Greek',\n    'ingreekandcoptic' => 'Blk/Greek',\n    'ingreekextended' => 'Blk/GreekExt',\n    'ingujarati' => 'Blk/Gujarati',\n    'ingurmukhi' => 'Blk/Gurmukhi',\n    'inhalfwidthandfullwidthforms' => 'Blk/Halfwidt',\n    'inhangulcompatibilityjamo' => 'Blk/HangulCo',\n    'inhanguljamo' => 'Blk/HangulJa',\n    'inhanguljamoextendeda' => 'Blk/HangulJ2',\n    'inhanguljamoextendedb' => 'Blk/HangulJ3',\n    'inhangulsyllables' => 'Blk/HangulSy',\n    'inhanunoo' => 'Blk/Hanunoo',\n    'inhebrew' => 'Blk/Hebrew',\n    'inherited' => 'Sc/Zinh',\n    'inhighprivateusesurrogates' => 'Blk/HighPriv',\n    'inhighsurrogates' => 'Blk/HighSurr',\n    'inhiragana' => 'Blk/Hiragana',\n    'inideographicdescriptioncharacters' => 'Blk/Ideograp',\n    'inimperialaramaic' => 'Blk/Imperial',\n    'ininscriptionalpahlavi' => 'Blk/Inscript',\n    'ininscriptionalparthian' => 'Blk/Inscrip2',\n    'inipaextensions' => 'Blk/IPAExten',\n    'initialpunctuation' => 'Gc/Pi',\n    'injavanese' => 'Blk/Javanese',\n    'inkaithi' => 'Blk/Kaithi',\n    'inkanasupplement' => 'Blk/KanaSupp',\n    'inkanbun' => 'Blk/Kanbun',\n    'inkangxiradicals' => 'Blk/KangxiRa',\n    'inkannada' ", 8192) = 8192
09:02:57.367198 read(3, "=> 'Blk/Kannada',\n    'inkatakana' => 'Blk/Katakana',\n    'inkatakanaphoneticextensions' => 'Blk/Katakan2',\n    'inkayahli' => 'Blk/KayahLi',\n    'inkharoshthi' => 'Blk/Kharosht',\n    'inkhmer' => 'Blk/Khmer',\n    'inkhmersymbols' => 'Blk/KhmerSym',\n    'inlao' => 'Blk/Lao',\n    'inlatin1' => 'Blk/Latin1',\n    'inlatin1supplement' => 'Blk/Latin1',\n    'inlatinextendeda' => 'Blk/LatinExt',\n    'inlatinextendedadditional' => 'Blk/LatinEx5',\n    'inlatinextendedb' => 'Blk/LatinEx2',\n    'inlatinextendedc' => 'Blk/LatinEx3',\n    'inlatinextendedd' => 'Blk/LatinEx4',\n    'inlepcha' => 'Blk/Lepcha',\n    'inletterlikesymbols' => 'Blk/Letterli',\n    'inlimbu' => 'Blk/Limbu',\n    'inlinearbideograms' => 'Blk/LinearBI',\n    'inlinearbsyllabary' => 'Blk/LinearBS',\n    'inlisu' => 'Blk/Lisu',\n    'inlowsurrogates' => 'Blk/LowSurro',\n    'inlycian' => 'Blk/Lycian',\n    'inlydian' => 'Blk/Lydian',\n    'inmahjongtiles' => 'Blk/MahjongT',\n    'inmalayalam' => 'Blk/Malayala',\n    'inmandaic' => 'Blk/Mandaic',\n    'inmathematicalalphanumericsymbols' => 'Blk/Mathema2',\n    'inmathematicaloperators' => 'Blk/Mathemat',\n    'inmeeteimayek' => 'Blk/MeeteiMa',\n    'inmiscellaneousmathematicalsymbolsa' => 'Blk/Miscell4',\n    'inmiscellaneousmathematicalsymbolsb' => 'Blk/Miscell5',\n    'inmiscellaneoussymbols' => 'Blk/Miscella',\n    'inmiscellaneoussymbolsandarrows' => 'Blk/Miscell3',\n    'inmiscellaneoussymbolsandpictographs' => 'Blk/Miscell6',\n    'inmiscellaneoustechnical' => 'Blk/Miscell2',\n    'inmodifiertoneletters' => 'Blk/Modifier',\n    'inmongolian' => 'Blk/Mongolia',\n    'inmusicalsymbols' => 'Blk/MusicalS',\n    'inmyanmar' => 'Blk/Myanmar',\n    'inmyanmarextendeda' => 'Blk/MyanmarE',\n    'innewtailue' => 'Blk/NewTaiLu',\n    'innko' => 'Blk/NKo',\n    'innoblock' => 'Blk/NoBlock',\n    'innumberforms' => 'Blk/NumberFo',\n    'inogham' => 'Blk/Ogham',\n    'inolchiki' => 'Blk/OlChiki',\n    'inolditalic' => 'Blk/OldItali',\n    'inoldpersian' => 'Blk/OldPersi',\n    'inoldsoutharabian' => 'Blk/OldSouth',\n    'inoldturkic' => 'Blk/OldTurki',\n    'inopticalcharacterrecognition' => 'Blk/OpticalC',\n    'inoriya' => 'Blk/Oriya',\n    'inosmanya' => 'Blk/Osmanya',\n    'inphagspa' => 'Blk/PhagsPa',\n    'inphaistosdisc' => 'Blk/Phaistos',\n    'inphoenician' => 'Blk/Phoenici',\n    'inphoneticextensions' => 'Blk/Phonetic',\n    'inphoneticextensionssupplement' => 'Blk/Phoneti2',\n    'inplayingcards' => 'Blk/PlayingC',\n    'inprivateuse' => 'Blk/PrivateU',\n    'inprivateusearea' => 'Blk/PrivateU',\n    'inrejang' => 'Blk/Rejang',\n    'inruminumeralsymbols' => 'Blk/RumiNume',\n    'inrunic' => 'Blk/Runic',\n    'insamaritan' => 'Blk/Samarita',\n    'insaurashtra' => 'Blk/Saurasht',\n    'inscriptionalpahlavi' => 'Sc/Phli',\n    'inscriptionalparthian' => 'Sc/Prti',\n    'inshavian' => 'Blk/Shavian',\n    'insinhala' => 'Blk/Sinhala',\n    'insmallformvariants' => 'Blk/SmallFor',\n    'inspacingmodifierletters' => 'Blk/SpacingM',\n    'inspecials' => 'Blk/Specials',\n    'insundanese' => 'Blk/Sundanes',\n    'insuperscriptsandsubscripts' => 'Blk/Superscr',\n    'insupplementalarrowsa' => 'Blk/Suppleme',\n    'insupplementalarrowsb' => 'Blk/Supplem2',\n    'insupplementalmathematicaloperators' => 'Blk/Supplem6',\n    'insupplementalpunctuation' => 'Blk/Supplem3',\n    'insupplementaryprivateuseareaa' => 'Blk/Supplem4',\n    'insupplementaryprivateuseareab' => 'Blk/Supplem5',\n    'insylotinagri' => 'Blk/SylotiNa',\n    'insyriac' => 'Blk/Syriac',\n    'intagalog' => 'Blk/Tagalog',\n    'intagbanwa' => 'Blk/Tagbanwa',\n    'intags' => 'Blk/Tags',\n    'intaile' => 'Blk/TaiLe',\n    'intaitham' => 'Blk/TaiTham',\n    'intaiviet' => 'Blk/TaiViet',\n    'intaixuanjingsymbols' => 'Blk/TaiXuanJ',\n    'intamil' => 'Blk/Tamil',\n    'intelugu' => 'Blk/Telugu',\n    'inthaana' => 'Blk/Thaana',\n    'inthai' => 'Blk/Thai',\n    'intibetan' => 'Blk/Tibetan',\n    'intifinagh' => 'Blk/Tifinagh',\n    'intransportandmapsymbols' => 'Blk/Transpor',\n    'inugaritic' => 'Blk/Ugaritic',\n    'inunifiedcanadianaboriginalsyllabics' => 'Blk/Canadian',\n    'inunifiedcanadianaboriginalsyllabicsextended' => 'Blk/UnifiedC',\n    'invai' => 'Blk/Vai',\n    'invariationselectors' => 'Blk/Variatio',\n    'invariationselectorssupplement' => 'Blk/Variati2',\n    'invedicextensions' => 'Blk/VedicExt',\n    'inverticalforms' => 'Blk/Vertical',\n    'inyijinghexagramsymbols' => 'Blk/YijingHe',\n    'inyiradicals' => 'Blk/YiRadica',\n    'inyisyllables' => 'Blk/YiSyllab',\n    'ipaextensions' => 'Blk/IPAExten',\n    'isaegeannumbers' => 'Blk/AegeanNu',\n    'isahex' => 'AHex/Y',\n    'isalchemicalsymbols' => 'Blk/Alchemic',\n    'isall' => 'Perl/Any',\n    'isalnum' => 'Perl/Alnum',\n    'isalpha' => 'Alpha/Y',\n    'isalphabetic' => 'Alpha/Y',\n    'isalphabeticpresentationforms' => 'Blk/Alphabet',\n    'isancientgreekmusicalnotation' => 'Blk/Ancient2',\n    'isancientgreeknumbers' => 'Blk/AncientG',\n    'isancientsymbols' => 'Blk/AncientS',\n    'isany' => 'Perl/Any',\n    'isarab' => 'Sc/Arab',\n    'isarabic' => 'Sc/Arab',\n    'isarabicpresentationformsa' => 'Blk/ArabicPr',\n    'isarabicpresentationformsb' => 'Blk/ArabicP2',\n    'isarabicsupplement' => 'Blk/ArabicSu',\n    'isarmenian' => 'Sc/Armn',\n    'isarmi' => 'Sc/Armi',\n    'isarmn' => 'Sc/Armn',\n    'isarrows' => 'Blk/Arrows',\n    'isascii' => 'Blk/ASCII',\n    'isasciihexdigit' => 'AHex/Y',\n    'isassigned' => 'Perl/Assigned',\n    'isavestan' => 'Sc/Avst',\n    'isavst' => 'Sc/Avst',\n    'isbali' => 'Sc/Bali',\n    'isbalinese' => 'Sc/Bali',\n    'isbamu' => 'Sc/Bamu',\n    'isbamum' => 'Sc/Bamu',\n    'isbamumsupplement' => 'Blk/BamumSup',\n    'isbasiclatin' => 'Blk/ASCII',\n    'isbatak' => 'Sc/Batk',\n    'isbatk' => 'Sc/Batk',\n    'isbeng' => 'Sc/Beng',\n    'isbengali' => 'Sc/Beng',\n    'isbidic' => 'BidiC/Y',\n    'isbidicontrol' => 'BidiC/Y',\n    'isbidim' => 'BidiM/Y',\n    'isbidimirrored' => 'BidiM/Y',\n    'isblank' => 'Perl/Blank',\n    'isblockelements' => 'Blk/BlockEle',\n    'isbopo' => 'Sc/Bopo',\n    'isbopomofo' => 'Sc/Bopo',\n    'isbopomofoextended' => 'Blk/Bopomof2',\n    'isboxdrawing' => 'Blk/BoxDrawi',\n    'isbrah' => 'Sc/Brah',\n    'isbrahmi' => 'Sc/Brah',\n    'isbrai' => 'Blk/BrailleP',\n    'isbraille' => 'Blk/BrailleP',\n    'isbraillepatterns' => 'Blk/BrailleP',\n    'isbugi' => 'Sc/Bugi',\n    'isbuginese' => 'Sc/Bugi',\n    'isbuhd' => 'Sc/Buhd',\n    'isbuhid' => 'Sc/Buhd',\n    'isbyzantinemusicalsymbols' => 'Blk/Byzantin',\n    'isc' => 'Gc/C',\n    'iscanadianaboriginal' => 'Sc/Cans',\n    'iscanadiansyllabics' => 'Blk/Canadian',\n    'iscans' => 'Sc/Cans',\n    'iscari' => 'Sc/Cari',\n    'iscarian' => 'Sc/Cari',\n    'iscased' => 'Cased/Y',\n    'iscasedletter' => 'Gc/LC',\n    'iscaseignorable' => 'CI/Y',\n    'iscc' => 'Gc/Cc',\n    'isce' => 'CE/Y',\n    'iscf' => 'Gc/Cf',\n    'ischam' => 'Sc/Cham',\n    'ischangeswhencasefolded' => 'CWCF/Y',\n    'ischangeswhencasemapped' => 'CWCM/Y',\n    'ischangeswhenlowercased' => 'CWL/Y',\n    'ischangeswhennfkccasefolded' => 'CWKCF/Y',\n    'ischangeswhentitlecased' => 'CWT/Y',\n    'ischangeswhenuppercased' => 'CWU/Y',\n    'ischer' => 'Sc/Cher',\n    'ischerokee' => 'Sc/Cher',\n    'isci' => 'CI/Y',\n    'iscjkcompatibility' => 'Blk/CJKCompa',\n    'iscjkcompatibilityforms' => 'Blk/CJKComp2',\n    'iscjkcompatibilityideographs' => 'Blk/CJKComp3',\n    'iscjkcompatibilityideographssupplement' => 'Blk/CJKComp4',\n    'iscjkradicalssupplement' => 'Blk/CJKRadic',\n    'iscjkstrokes' => 'Blk/CJKStrok',\n    'iscjksymbolsandpunctuation' => 'Blk/CJKSymbo',\n    'iscjkunifiedideographs' => 'Blk/CJKUnifi',\n    'iscjkunifiedideographsextensiona' => 'Blk/CJKUnif2',\n    'iscjkunifiedideographsextensionb' => 'Blk/CJKUnif3',\n    'iscjkunifiedideographsextensionc' => 'Blk/CJKUnif4',\n    'iscjkunifiedideographsextensiond' => 'Blk/CJKUnif5',\n    'isclosepunctuation' => 'Gc/Pe',\n    'iscn' => 'Gc/Cn',\n    'iscntrl' => 'Gc/Cc',\n    'isco' => 'Gc/Co',\n    'iscombiningdiacriticalmarks' => 'Blk/Combini3',\n    'iscombiningdiacriticalmarksforsymbols' => 'Blk/Combini2',\n    'iscombiningdiacriticalmarkssupplement' => 'Blk/Combini4',\n    'iscombininghalfmarks' => 'Blk/Combinin',\n    'iscombiningmarksforsymbols' => 'Blk/Combini2',\n    'iscommon' => 'Sc/Zyyy',\n    'iscommonindicnumberforms' => 'Blk/Comm", 8192) = 8192
09:02:57.368532 brk(0x21f5000)          = 0x21f5000
09:02:57.368685 read(3, "onIn',\n    'iscompex' => 'CompEx/Y',\n    'iscompositionexclusion' => 'CE/Y',\n    'isconnectorpunctuation' => 'WB/EX',\n    'iscontrol' => 'Gc/Cc',\n    'iscontrolpictures' => 'Blk/ControlP',\n    'iscopt' => 'Sc/Copt',\n    'iscoptic' => 'Sc/Copt',\n    'iscountingrodnumerals' => 'Blk/Counting',\n    'iscprt' => 'Sc/Cprt',\n    'iscs' => 'Gc/Cs',\n    'iscuneiform' => 'Sc/Xsux',\n    'iscuneiformnumbersandpunctuation' => 'Blk/Cuneifo2',\n    'iscurrencysymbol' => 'Gc/Sc',\n    'iscurrencysymbols' => 'Blk/Currency',\n    'iscwcf' => 'CWCF/Y',\n    'iscwcm' => 'CWCM/Y',\n    'iscwkcf' => 'CWKCF/Y',\n    'iscwl' => 'CWL/Y',\n    'iscwt' => 'CWT/Y',\n    'iscwu' => 'CWU/Y',\n    'iscypriot' => 'Sc/Cprt',\n    'iscypriotsyllabary' => 'Blk/CypriotS',\n    'iscyrillic' => 'Sc/Cyrl',\n    'iscyrillicextendeda' => 'Blk/Cyrilli2',\n    'iscyrillicextendedb' => 'Blk/Cyrilli3',\n    'iscyrillicsupplement' => 'Blk/Cyrilli4',\n    'iscyrillicsupplementary' => 'Blk/Cyrilli4',\n    'iscyrl' => 'Sc/Cyrl',\n    'isdash' => 'Dash/Y',\n    'isdashpunctuation' => 'Gc/Pd',\n    'isdecimalnumber' => 'Nt/De',\n    'isdefaultignorablecodepoint' => 'DI/Y',\n    'isdep' => 'Dep/Y',\n    'isdeprecated' => 'Dep/Y',\n    'isdeseret' => 'Blk/Deseret',\n    'isdeva' => 'Sc/Deva',\n    'isdevanagari' => 'Sc/Deva',\n    'isdevanagariextended' => 'Blk/Devanag2',\n    'isdi' => 'DI/Y',\n    'isdia' => 'Dia/Y',\n    'isdiacritic' => 'Dia/Y',\n    'isdigit' => 'Nt/De',\n    'isdingbats' => 'Blk/Dingbats',\n    'isdominotiles' => 'Blk/DominoTi',\n    'isdsrt' => 'Blk/Deseret',\n    'isegyp' => 'Sc/Egyp',\n    'isegyptianhieroglyphs' => 'Sc/Egyp',\n    'isemoticons' => 'Blk/Emoticon',\n    'isenclosedalphanumerics' => 'Blk/Enclosed',\n    'isenclosedalphanumericsupplement' => 'Blk/Enclose4',\n    'isenclosedcjklettersandmonths' => 'Blk/Enclose2',\n    'isenclosedideographicsupplement' => 'Blk/Enclose3',\n    'isenclosingmark' => 'Gc/Me',\n    'isethi' => 'Sc/Ethi',\n    'isethiopic' => 'Sc/Ethi',\n    'isethiopicextended' => 'Blk/Ethiopi2',\n    'isethiopicextendeda' => 'Blk/Ethiopi3',\n    'isethiopicsupplement' => 'Blk/Ethiopi4',\n    'isext' => 'Ext/Y',\n    'isextender' => 'Ext/Y',\n    'isfinalpunctuation' => 'Gc/Pf',\n    'isformat' => 'Gc/Cf',\n    'isfullcompositionexclusion' => 'CompEx/Y',\n    'isgeneralpunctuation' => 'Blk/GeneralP',\n    'isgeometricshapes' => 'Blk/Geometri',\n    'isgeor' => 'Sc/Geor',\n    'isgeorgian' => 'Sc/Geor',\n    'isgeorgiansupplement' => 'Blk/Georgia2',\n    'isglag' => 'Sc/Glag',\n    'isglagolitic' => 'Sc/Glag',\n    'isgoth' => 'Sc/Goth',\n    'isgothic' => 'Sc/Goth',\n    'isgraph' => 'Perl/Graph',\n    'isgraphemebase' => 'GrBase/Y',\n    'isgraphemeextend' => 'GCB/EX',\n    'isgrbase' => 'GrBase/Y',\n    'isgreek' => 'Sc/Grek',\n    'isgreekandcoptic' => 'Blk/Greek',\n    'isgreekextended' => 'Blk/GreekExt',\n    'isgrek' => 'Sc/Grek',\n    'isgrext' => 'GCB/EX',\n    'isgujarati' => 'Sc/Gujr',\n    'isgujr' => 'Sc/Gujr',\n    'isgurmukhi' => 'Sc/Guru',\n    'isguru' => 'Sc/Guru',\n    'ishalfwidthandfullwidthforms' => 'Blk/Halfwidt',\n    'ishan' => 'Sc/Han',\n    'ishang' => 'Sc/Hang',\n    'ishangul' => 'Sc/Hang',\n    'ishangulcompatibilityjamo' => 'Blk/HangulCo',\n    'ishanguljamo' => 'Blk/HangulJa',\n    'ishanguljamoextendeda' => 'Blk/HangulJ2',\n    'ishanguljamoextendedb' => 'Blk/HangulJ3',\n    'ishangulsyllables' => 'Blk/HangulSy',\n    'ishani' => 'Sc/Han',\n    'ishano' => 'Sc/Hano',\n    'ishanunoo' => 'Sc/Hano',\n    'ishebr' => 'Sc/Hebr',\n    'ishebrew' => 'Sc/Hebr',\n    'ishex' => 'Hex/Y',\n    'ishexdigit' => 'Hex/Y',\n    'ishighprivateusesurrogates' => 'Blk/HighPriv',\n    'ishighsurrogates' => 'Blk/HighSurr',\n    'ishira' => 'Sc/Hira',\n    'ishiragana' => 'Sc/Hira',\n    'ishorizspace' => 'Perl/Blank',\n    'ishyphen' => 'Hyphen/Y',\n    'isidc' => 'IDC/Y',\n    'isidcontinue' => 'IDC/Y',\n    'isideo' => 'Ideo/Y',\n    'isideographic' => 'Ideo/Y',\n    'isideographicdescriptioncharacters' => 'Blk/Ideograp',\n    'isids' => 'IDS/Y',\n    'isidsb' => 'IDSB/Y',\n    'isidsbinaryoperator' => 'IDSB/Y',\n    'isidst' => 'IDST/Y',\n    'isidstart' => 'IDS/Y',\n    'isidstrinaryoperator' => 'IDST/Y',\n    'isimperialaramaic' => 'Sc/Armi',\n    'isinherited' => 'Sc/Zinh',\n    'isinitialpunctuation' => 'Gc/Pi',\n    'isinscriptionalpahlavi' => 'Sc/Phli',\n    'isinscriptionalparthian' => 'Sc/Prti',\n    'isipaextensions' => 'Blk/IPAExten',\n    'isital' => 'Sc/Ital',\n    'isjava' => 'Sc/Java',\n    'isjavanese' => 'Sc/Java',\n    'isjoinc' => 'JoinC/Y',\n    'isjoincontrol' => 'JoinC/Y',\n    'iskaithi' => 'Sc/Kthi',\n    'iskali' => 'Blk/KayahLi',\n    'iskana' => 'Sc/Kana',\n    'iskanasupplement' => 'Blk/KanaSupp',\n    'iskanbun' => 'Blk/Kanbun',\n    'iskangxiradicals' => 'Blk/KangxiRa',\n    'iskannada' => 'Sc/Knda',\n    'iskatakana' => 'Sc/Kana',\n    'iskatakanaphoneticextensions' => 'Blk/Katakan2',\n    'iskayahli' => 'Blk/KayahLi',\n    'iskhar' => 'Sc/Khar',\n    'iskharoshthi' => 'Sc/Khar',\n    'iskhmer' => 'Sc/Khmr',\n    'iskhmersymbols' => 'Blk/KhmerSym',\n    'iskhmr' => 'Sc/Khmr',\n    'isknda' => 'Sc/Knda',\n    'iskthi' => 'Sc/Kthi',\n    'isl' => 'Gc/L',\n    'isl&' => 'Gc/LC',\n    'isl_' => 'Gc/LC',\n    'islana' => 'Sc/Lana',\n    'islao' => 'Sc/Lao',\n    'islaoo' => 'Sc/Lao',\n    'islatin' => 'Sc/Latn',\n    'islatin1' => 'Blk/Latin1',\n    'islatin1supplement' => 'Blk/Latin1',\n    'islatinextendeda' => 'Blk/LatinExt',\n    'islatinextendedadditional' => 'Blk/LatinEx5',\n    'islatinextendedb' => 'Blk/LatinEx2',\n    'islatinextendedc' => 'Blk/LatinEx3',\n    'islatinextendedd' => 'Blk/LatinEx4',\n    'islatn' => 'Sc/Latn',\n    'islc' => 'Gc/LC',\n    'islepc' => 'Sc/Lepc',\n    'islepcha' => 'Sc/Lepc',\n    'isletter' => 'Gc/L',\n    'isletterlikesymbols' => 'Blk/Letterli',\n    'isletternumber' => 'Gc/Nl',\n    'islimb' => 'Sc/Limb',\n    'islimbu' => 'Sc/Limb',\n    'islinb' => 'Sc/Linb',\n    'islinearb' => 'Sc/Linb',\n    'islinearbideograms' => 'Blk/LinearBI',\n    'islinearbsyllabary' => 'Blk/LinearBS',\n    'islineseparator' => 'Gc/Zl',\n    'islisu' => 'Blk/Lisu',\n    'isll' => 'Gc/Ll',\n    'islm' => 'Gc/Lm',\n    'islo' => 'Gc/Lo',\n    'isloe' => 'GCB/PP',\n    'islogicalorderexception' => 'GCB/PP',\n    'islower' => 'Lower/Y',\n    'islowercase' => 'Lower/Y',\n    'islowercaseletter' => 'Gc/Ll',\n    'islowsurrogates' => 'Blk/LowSurro',\n    'islt' => 'Perl/Title',\n    'islu' => 'Gc/Lu',\n    'islyci' => 'Sc/Lyci',\n    'islycian' => 'Sc/Lyci',\n    'islydi' => 'Sc/Lydi',\n    'islydian' => 'Sc/Lydi',\n    'ism' => 'Gc/M',\n    'ismahjongtiles' => 'Blk/MahjongT',\n    'ismalayalam' => 'Sc/Mlym',\n    'ismand' => 'Sc/Mand',\n    'ismandaic' => 'Sc/Mand',\n    'ismark' => 'Gc/M',\n    'ismath' => 'Math/Y',\n    'ismathematicalalphanumericsymbols' => 'Blk/Mathema2',\n    'ismathematicaloperators' => 'Blk/Mathemat',\n    'ismathsymbol' => 'Gc/Sm',\n    'ismc' => 'Gc/Mc',\n    'isme' => 'Gc/Me',\n    'ismeeteimayek' => 'Sc/Mtei',\n    'ismiscellaneousmathematicalsymbolsa' => 'Blk/Miscell4',\n    'ismiscellaneousmathematicalsymbolsb' => 'Blk/Miscell5',\n    'ismiscellaneoussymbols' => 'Blk/Miscella',\n    'ismiscellaneoussymbolsandarrows' => 'Blk/Miscell3',\n    'ismiscellaneoussymbolsandpictographs' => 'Blk/Miscell6',\n    'ismiscellaneoustechnical' => 'Blk/Miscell2',\n    'ismlym' => 'Sc/Mlym',\n    'ismn' => 'Gc/Mn',\n    'ismodifierletter' => 'Gc/Lm',\n    'ismodifiersymbol' => 'Gc/Sk',\n    'ismodifiertoneletters' => 'Blk/Modifier',\n    'ismong' => 'Sc/Mong',\n    'ismongolian' => 'Sc/Mong',\n    'ismtei' => 'Sc/Mtei',\n    'ismusicalsymbols' => 'Blk/MusicalS',\n    'ismyanmar' => 'Sc/Mymr',\n    'ismyanmarextendeda' => 'Blk/MyanmarE',\n    'ismymr' => 'Sc/Mymr',\n    'isn' => 'Gc/N',\n    'isnchar' => 'NChar/Y',\n    'isnd' => 'Nt/De',\n    'isnewtailue' => 'Sc/Talu',\n    'isnko' => 'Sc/Nko',\n    'isnkoo' => 'Sc/Nko',\n    'isnl' => 'Gc/Nl',\n    'isno' => 'Gc/No',\n    'isnoblock' => 'Blk/NoBlock',\n    'isnoncharactercodepoint' => 'NChar/Y',\n    'isnonspacingmark' => 'Gc/Mn',\n    'isnumber' => 'Gc/N',\n    'isnumberforms' => 'Blk/NumberFo',\n    'isoalpha' => 'OAlpha/Y',\n    'isodi' => 'ODI/Y',\n    'isogam' => 'Sc/Ogam',\n    'isogham' => 'Sc/Ogam',\n    'isogrext' => 'OGrExt/Y',\n    'isoidc' => 'OIDC/Y',\n    'isoids' => 'OIDS/Y',\n    'isolchiki' => 'Blk/OlChiki',\n    'isolck' => 'Blk/OlChi", 8192) = 8192
09:02:57.370204 read(3, "ki',\n    'isolditalic' => 'Sc/Ital',\n    'isoldpersian' => 'Sc/Xpeo',\n    'isoldsoutharabian' => 'Blk/OldSouth',\n    'isoldturkic' => 'Sc/Orkh',\n    'isolower' => 'OLower/Y',\n    'isomath' => 'OMath/Y',\n    'isopenpunctuation' => 'Gc/Ps',\n    'isopticalcharacterrecognition' => 'Blk/OpticalC',\n    'isoriya' => 'Sc/Orya',\n    'isorkh' => 'Sc/Orkh',\n    'isorya' => 'Sc/Orya',\n    'isosma' => 'Sc/Osma',\n    'isosmanya' => 'Sc/Osma',\n    'isother' => 'Gc/C',\n    'isotheralphabetic' => 'OAlpha/Y',\n    'isotherdefaultignorablecodepoint' => 'ODI/Y',\n    'isothergraphemeextend' => 'OGrExt/Y',\n    'isotheridcontinue' => 'OIDC/Y',\n    'isotheridstart' => 'OIDS/Y',\n    'isotherletter' => 'Gc/Lo',\n    'isotherlowercase' => 'OLower/Y',\n    'isothermath' => 'OMath/Y',\n    'isothernumber' => 'Gc/No',\n    'isotherpunctuation' => 'Gc/Po',\n    'isothersymbol' => 'Gc/So',\n    'isotheruppercase' => 'OUpper/Y',\n    'isoupper' => 'OUpper/Y',\n    'isp' => 'Gc/P',\n    'isparagraphseparator' => 'Gc/Zp',\n    'ispatsyn' => 'PatSyn/Y',\n    'ispatternsyntax' => 'PatSyn/Y',\n    'ispatternwhitespace' => 'PatWS/Y',\n    'ispatws' => 'PatWS/Y',\n    'ispc' => 'WB/EX',\n    'ispd' => 'Gc/Pd',\n    'ispe' => 'Gc/Pe',\n    'isperlspace' => 'Perl/PerlSpac',\n    'isperlword' => 'Perl/PerlWord',\n    'ispf' => 'Gc/Pf',\n    'isphag' => 'Sc/Phag',\n    'isphagspa' => 'Sc/Phag',\n    'isphaistosdisc' => 'Blk/Phaistos',\n    'isphli' => 'Sc/Phli',\n    'isphnx' => 'Sc/Phnx',\n    'isphoenician' => 'Sc/Phnx',\n    'isphoneticextensions' => 'Blk/Phonetic',\n    'isphoneticextensionssupplement' => 'Blk/Phoneti2',\n    'ispi' => 'Gc/Pi',\n    'isplayingcards' => 'Blk/PlayingC',\n    'ispo' => 'Gc/Po',\n    'isposixalnum' => 'Perl/PosixAln',\n    'isposixalpha' => 'Perl/PosixAlp',\n    'isposixblank' => 'Perl/PosixBla',\n    'isposixcntrl' => 'Perl/PosixCnt',\n    'isposixdigit' => 'Perl/PosixDig',\n    'isposixgraph' => 'Perl/PosixGra',\n    'isposixlower' => 'Perl/PosixLow',\n    'isposixprint' => 'Perl/PosixPri',\n    'isposixpunct' => 'Perl/PosixPun',\n    'isposixspace' => 'Perl/PosixSpa',\n    'isposixupper' => 'Perl/PosixUpp',\n    'isposixword' => 'Perl/PerlWord',\n    'isposixxdigit' => 'AHex/Y',\n    'isprint' => 'Perl/Print',\n    'isprivateuse' => 'Gc/Co',\n    'isprivateusearea' => 'Blk/PrivateU',\n    'isprti' => 'Sc/Prti',\n    'isps' => 'Gc/Ps',\n    'ispunct' => 'Gc/P',\n    'ispunctuation' => 'Gc/P',\n    'isqaac' => 'Sc/Copt',\n    'isqaai' => 'Sc/Zinh',\n    'isqmark' => 'QMark/Y',\n    'isquotationmark' => 'QMark/Y',\n    'isradical' => 'Radical/Y',\n    'isrejang' => 'Sc/Rjng',\n    'isrjng' => 'Sc/Rjng',\n    'isruminumeralsymbols' => 'Blk/RumiNume',\n    'isrunic' => 'Sc/Runr',\n    'isrunr' => 'Sc/Runr',\n    'iss' => 'Gc/S',\n    'issamaritan' => 'Sc/Samr',\n    'issamr' => 'Sc/Samr',\n    'issarb' => 'Blk/OldSouth',\n    'issaur' => 'Sc/Saur',\n    'issaurashtra' => 'Sc/Saur',\n    'issc' => 'Gc/Sc',\n    'issd' => 'SD/Y',\n    'isseparator' => 'Gc/Z',\n    'isshavian' => 'Blk/Shavian',\n    'isshaw' => 'Blk/Shavian',\n    'issinh' => 'Sc/Sinh',\n    'issinhala' => 'Sc/Sinh',\n    'issk' => 'Gc/Sk',\n    'issm' => 'Gc/Sm',\n    'issmallformvariants' => 'Blk/SmallFor',\n    'isso' => 'Gc/So',\n    'issoftdotted' => 'SD/Y',\n    'isspace' => 'Space/Y',\n    'isspaceperl' => 'Perl/SpacePer',\n    'isspaceseparator' => 'Gc/Zs',\n    'isspacingmark' => 'Gc/Mc',\n    'isspacingmodifierletters' => 'Blk/SpacingM',\n    'isspecials' => 'Blk/Specials',\n    'issterm' => 'STerm/Y',\n    'issund' => 'Sc/Sund',\n    'issundanese' => 'Sc/Sund',\n    'issuperscriptsandsubscripts' => 'Blk/Superscr',\n    'issupplementalarrowsa' => 'Blk/Suppleme',\n    'issupplementalarrowsb' => 'Blk/Supplem2',\n    'issupplementalmathematicaloperators' => 'Blk/Supplem6',\n    'issupplementalpunctuation' => 'Blk/Supplem3',\n    'issupplementaryprivateuseareaa' => 'Blk/Supplem4',\n    'issupplementaryprivateuseareab' => 'Blk/Supplem5',\n    'issurrogate' => 'Gc/Cs',\n    'issylo' => 'Sc/Sylo',\n    'issylotinagri' => 'Sc/Sylo',\n    'issymbol' => 'Gc/S',\n    'issyrc' => 'Sc/Syrc',\n    'issyriac' => 'Sc/Syrc',\n    'istagalog' => 'Sc/Tglg',\n    'istagb' => 'Sc/Tagb',\n    'istagbanwa' => 'Sc/Tagb',\n    'istags' => 'Blk/Tags',\n    'istaile' => 'Sc/Tale',\n    'istaitham' => 'Sc/Lana',\n    'istaiviet' => 'Sc/Tavt',\n    'istaixuanjingsymbols' => 'Blk/TaiXuanJ',\n    'istale' => 'Sc/Tale',\n    'istalu' => 'Sc/Talu',\n    'istamil' => 'Sc/Taml',\n    'istaml' => 'Sc/Taml',\n    'istavt' => 'Sc/Tavt',\n    'istelu' => 'Sc/Telu',\n    'istelugu' => 'Sc/Telu',\n    'isterm' => 'Term/Y',\n    'isterminalpunctuation' => 'Term/Y',\n    'istfng' => 'Sc/Tfng',\n    'istglg' => 'Sc/Tglg',\n    'isthaa' => 'Sc/Thaa',\n    'isthaana' => 'Sc/Thaa',\n    'isthai' => 'Sc/Thai',\n    'istibetan' => 'Sc/Tibt',\n    'istibt' => 'Sc/Tibt',\n    'istifinagh' => 'Sc/Tfng',\n    'istitle' => 'Perl/Title',\n    'istitlecase' => 'Perl/Title',\n    'istitlecaseletter' => 'Perl/Title',\n    'istransportandmapsymbols' => 'Blk/Transpor',\n    'isugar' => 'Sc/Ugar',\n    'isugaritic' => 'Sc/Ugar',\n    'isuideo' => 'UIdeo/Y',\n    'isunassigned' => 'Gc/Cn',\n    'isunifiedcanadianaboriginalsyllabics' => 'Blk/Canadian',\n    'isunifiedcanadianaboriginalsyllabicsextended' => 'Blk/UnifiedC',\n    'isunifiedideograph' => 'UIdeo/Y',\n    'isunknown' => 'Sc/Zzzz',\n    'isupper' => 'Upper/Y',\n    'isuppercase' => 'Upper/Y',\n    'isuppercaseletter' => 'Gc/Lu',\n    'isvai' => 'Sc/Vai',\n    'isvaii' => 'Sc/Vai',\n    'isvariationselector' => 'VS/Y',\n    'isvariationselectors' => 'Blk/Variatio',\n    'isvariationselectorssupplement' => 'Blk/Variati2',\n    'isvedicextensions' => 'Blk/VedicExt',\n    'isverticalforms' => 'Blk/Vertical',\n    'isvertspace' => 'Perl/VertSpac',\n    'isvs' => 'VS/Y',\n    'iswhitespace' => 'Space/Y',\n    'isword' => 'Perl/Word',\n    'iswspace' => 'Space/Y',\n    'isxdigit' => 'Hex/Y',\n    'isxidc' => 'XIDC/Y',\n    'isxidcontinue' => 'XIDC/Y',\n    'isxids' => 'XIDS/Y',\n    'isxidstart' => 'XIDS/Y',\n    'isxpeo' => 'Sc/Xpeo',\n    'isxperlspace' => 'Perl/SpacePer',\n    'isxposixalnum' => 'Perl/Alnum',\n    'isxposixalpha' => 'Alpha/Y',\n    'isxposixblank' => 'Perl/Blank',\n    'isxposixcntrl' => 'Gc/Cc',\n    'isxposixdigit' => 'Nt/De',\n    'isxposixgraph' => 'Perl/Graph',\n    'isxposixlower' => 'Lower/Y',\n    'isxposixprint' => 'Perl/Print',\n    'isxposixpunct' => 'Perl/XPosixPu',\n    'isxposixspace' => 'Space/Y',\n    'isxposixupper' => 'Upper/Y',\n    'isxposixword' => 'Perl/Word',\n    'isxposixxdigit' => 'Hex/Y',\n    'isxsux' => 'Sc/Xsux',\n    'isyi' => 'Sc/Yi',\n    'isyiii' => 'Sc/Yi',\n    'isyijinghexagramsymbols' => 'Blk/YijingHe',\n    'isyiradicals' => 'Blk/YiRadica',\n    'isyisyllables' => 'Blk/YiSyllab',\n    'isz' => 'Gc/Z',\n    'iszinh' => 'Sc/Zinh',\n    'iszl' => 'Gc/Zl',\n    'iszp' => 'Gc/Zp',\n    'iszs' => 'Gc/Zs',\n    'iszyyy' => 'Sc/Zyyy',\n    'iszzzz' => 'Sc/Zzzz',\n    'ital' => 'Sc/Ital',\n    'java' => 'Sc/Java',\n    'javanese' => 'Sc/Java',\n    'jg=ain' => 'Jg/Ain',\n    'jg=alaph' => 'Jg/Alaph',\n    'jg=alef' => 'Jg/Alef',\n    'jg=beh' => 'Jg/Beh',\n    'jg=beth' => 'Jg/Beth',\n    'jg=burushaskiyehbarree' => 'Jg/Burushas',\n    'jg=dal' => 'Jg/Dal',\n    'jg=dalathrish' => 'Jg/DalathRi',\n    'jg=e' => 'Jg/E',\n    'jg=farsiyeh' => 'Jg/FarsiYeh',\n    'jg=fe' => 'Jg/Fe',\n    'jg=feh' => 'Jg/Feh',\n    'jg=finalsemkath' => 'Jg/FinalSem',\n    'jg=gaf' => 'Jg/Gaf',\n    'jg=gamal' => 'Jg/Gamal',\n    'jg=hah' => 'Jg/Hah',\n    'jg=hamzaonhehgoal' => 'Jg/TehMarb2',\n    'jg=he' => 'Jg/He',\n    'jg=heh' => 'Jg/Heh',\n    'jg=hehgoal' => 'Jg/HehGoal',\n    'jg=heth' => 'Jg/Heth',\n    'jg=kaf' => 'Jg/Kaf',\n    'jg=kaph' => 'Jg/Kaph',\n    'jg=khaph' => 'Jg/Khaph',\n    'jg=knottedheh' => 'Jg/KnottedH',\n    'jg=lam' => 'Jg/Lam',\n    'jg=lamadh' => 'Jg/Lamadh',\n    'jg=meem' => 'Jg/Meem',\n    'jg=mim' => 'Jg/Mim',\n    'jg=nojoininggroup' => 'Jg/NoJoinin',\n    'jg=noon' => 'Jg/Noon',\n    'jg=nun' => 'Jg/Nun',\n    'jg=nya' => 'Jg/Nya',\n    'jg=pe' => 'Jg/Pe',\n    'jg=qaf' => 'Jg/Qaf',\n    'jg=qaph' => 'Jg/Qaph',\n    'jg=reh' => 'Jg/Reh',\n    'jg=reversedpe' => 'Jg/Reversed',\n    'jg=sad' => 'Jg/Sad',\n    'jg=sadhe' => 'Jg/Sadhe',\n    'jg=seen' => 'Jg/Seen',\n    'jg=semkath' => 'Jg/Semkath',\n    'jg=shin' => 'Jg/Shin',\n    'jg=swashkaf' => 'Jg", 8192) = 8192
09:02:57.371605 brk(0x2216000)          = 0x2216000
09:02:57.371772 read(3, "/SwashKaf',\n    'jg=syriacwaw' => 'Jg/SyriacWa',\n    'jg=tah' => 'Jg/Tah',\n    'jg=taw' => 'Jg/Taw',\n    'jg=tehmarbuta' => 'Jg/TehMarbu',\n    'jg=tehmarbutagoal' => 'Jg/TehMarb2',\n    'jg=teth' => 'Jg/Teth',\n    'jg=waw' => 'Jg/Waw',\n    'jg=yeh' => 'Jg/Yeh',\n    'jg=yehbarree' => 'Jg/YehBarre',\n    'jg=yehwithtail' => 'Jg/YehWithT',\n    'jg=yudh' => 'Jg/Yudh',\n    'jg=yudhhe' => 'Jg/YudhHe',\n    'jg=zain' => 'Jg/Zain',\n    'jg=zhain' => 'Jg/Zhain',\n    'joinc' => 'JoinC/Y',\n    'joinc=f' => 'JoinC/N',\n    'joinc=false' => 'JoinC/N',\n    'joinc=n' => 'JoinC/N',\n    'joinc=no' => 'JoinC/N',\n    'joinc=t' => 'JoinC/Y',\n    'joinc=true' => 'JoinC/Y',\n    'joinc=y' => 'JoinC/Y',\n    'joinc=yes' => 'JoinC/Y',\n    'joincontrol' => 'JoinC/Y',\n    'jt=c' => 'Jt/C',\n    'jt=d' => 'Jt/D',\n    'jt=dualjoining' => 'Jt/D',\n    'jt=joincausing' => 'Jt/C',\n    'jt=l' => 'Ccc/ATBL',\n    'jt=leftjoining' => 'Ccc/ATBL',\n    'jt=nonjoining' => 'Jt/U',\n    'jt=r' => 'Jt/R',\n    'jt=rightjoining' => 'Jt/R',\n    'jt=t' => 'Jt/T',\n    'jt=transparent' => 'Jt/T',\n    'jt=u' => 'Jt/U',\n    'kaithi' => 'Sc/Kthi',\n    'kali' => 'Blk/KayahLi',\n    'kana' => 'Sc/Kana',\n    'kanasupplement' => 'Blk/KanaSupp',\n    'kanbun' => 'Blk/Kanbun',\n    'kangxiradicals' => 'Blk/KangxiRa',\n    'kannada' => 'Sc/Knda',\n    'katakana' => 'Sc/Kana',\n    'katakanaphoneticextensions' => 'Blk/Katakan2',\n    'kayahli' => 'Blk/KayahLi',\n    'khar' => 'Sc/Khar',\n    'kharoshthi' => 'Sc/Khar',\n    'khmer' => 'Sc/Khmr',\n    'khmersymbols' => 'Blk/KhmerSym',\n    'khmr' => 'Sc/Khmr',\n    'knda' => 'Sc/Knda',\n    'kthi' => 'Sc/Kthi',\n    'l' => 'Gc/L',\n    'l&' => 'Gc/LC',\n    'l_' => 'Gc/LC',\n    'lana' => 'Sc/Lana',\n    'lao' => 'Sc/Lao',\n    'laoo' => 'Sc/Lao',\n    'latin' => 'Sc/Latn',\n    'latin1' => 'Blk/Latin1',\n    'latin1supplement' => 'Blk/Latin1',\n    'latinextendeda' => 'Blk/LatinExt',\n    'latinextendedadditional' => 'Blk/LatinEx5',\n    'latinextendedb' => 'Blk/LatinEx2',\n    'latinextendedc' => 'Blk/LatinEx3',\n    'latinextendedd' => 'Blk/LatinEx4',\n    'latn' => 'Sc/Latn',\n    'lb=ai' => 'Lb/AI',\n    'lb=al' => 'Lb/AL',\n    'lb=alphabetic' => 'Lb/AL',\n    'lb=ambiguous' => 'Lb/AI',\n    'lb=b2' => 'Lb/B2',\n    'lb=ba' => 'Lb/BA',\n    'lb=bb' => 'Lb/BB',\n    'lb=bk' => 'Lb/BK',\n    'lb=breakafter' => 'Lb/BA',\n    'lb=breakbefore' => 'Lb/BB',\n    'lb=breakboth' => 'Lb/B2',\n    'lb=breaksymbols' => 'Lb/SY',\n    'lb=carriagereturn' => 'GCB/CR',\n    'lb=cb' => 'Lb/CB',\n    'lb=cl' => 'Lb/CL',\n    'lb=closeparenthesis' => 'Lb/CP',\n    'lb=closepunctuation' => 'Lb/CL',\n    'lb=cm' => 'Lb/CM',\n    'lb=combiningmark' => 'Lb/CM',\n    'lb=complexcontext' => 'Lb/SA',\n    'lb=contingentbreak' => 'Lb/CB',\n    'lb=cp' => 'Lb/CP',\n    'lb=cr' => 'GCB/CR',\n    'lb=ex' => 'Lb/EX',\n    'lb=exclamation' => 'Lb/EX',\n    'lb=gl' => 'Lb/GL',\n    'lb=glue' => 'Lb/GL',\n    'lb=h2' => 'GCB/LV',\n    'lb=h3' => 'GCB/LVT',\n    'lb=hy' => 'Lb/HY',\n    'lb=hyphen' => 'Lb/HY',\n    'lb=id' => 'Lb/ID',\n    'lb=ideographic' => 'Lb/ID',\n    'lb=in' => 'Lb/IN',\n    'lb=infixnumeric' => 'Lb/IS',\n    'lb=inseparable' => 'Lb/IN',\n    'lb=inseperable' => 'Lb/IN',\n    'lb=is' => 'Lb/IS',\n    'lb=jl' => 'GCB/L',\n    'lb=jt' => 'GCB/T',\n    'lb=jv' => 'GCB/V',\n    'lb=lf' => 'GCB/LF',\n    'lb=linefeed' => 'GCB/LF',\n    'lb=mandatorybreak' => 'Lb/BK',\n    'lb=nextline' => 'Lb/NL',\n    'lb=nl' => 'Lb/NL',\n    'lb=nonstarter' => 'Lb/NS',\n    'lb=ns' => 'Lb/NS',\n    'lb=nu' => 'Lb/NU',\n    'lb=numeric' => 'Lb/NU',\n    'lb=op' => 'Lb/OP',\n    'lb=openpunctuation' => 'Lb/OP',\n    'lb=po' => 'Lb/PO',\n    'lb=postfixnumeric' => 'Lb/PO',\n    'lb=pr' => 'Lb/PR',\n    'lb=prefixnumeric' => 'Lb/PR',\n    'lb=qu' => 'Lb/QU',\n    'lb=quotation' => 'Lb/QU',\n    'lb=sa' => 'Lb/SA',\n    'lb=sg' => 'Lb/SG',\n    'lb=sp' => 'Lb/SP',\n    'lb=space' => 'Lb/SP',\n    'lb=surrogate' => 'Lb/SG',\n    'lb=sy' => 'Lb/SY',\n    'lb=unknown' => 'Lb/XX',\n    'lb=wj' => 'Lb/WJ',\n    'lb=wordjoiner' => 'Lb/WJ',\n    'lb=xx' => 'Lb/XX',\n    'lb=zw' => 'Lb/ZW',\n    'lb=zwspace' => 'Lb/ZW',\n    'lc' => 'Gc/LC',\n    'lepc' => 'Sc/Lepc',\n    'lepcha' => 'Sc/Lepc',\n    'letter' => 'Gc/L',\n    'letterlikesymbols' => 'Blk/Letterli',\n    'letternumber' => 'Gc/Nl',\n    'limb' => 'Sc/Limb',\n    'limbu' => 'Sc/Limb',\n    'linb' => 'Sc/Linb',\n    'linearb' => 'Sc/Linb',\n    'linearbideograms' => 'Blk/LinearBI',\n    'linearbsyllabary' => 'Blk/LinearBS',\n    'lineseparator' => 'Gc/Zl',\n    'lisu' => 'Blk/Lisu',\n    'll' => 'Gc/Ll',\n    'lm' => 'Gc/Lm',\n    'lo' => 'Gc/Lo',\n    'loe' => 'GCB/PP',\n    'loe=f' => 'LOE/N',\n    'loe=false' => 'LOE/N',\n    'loe=n' => 'LOE/N',\n    'loe=no' => 'LOE/N',\n    'loe=t' => 'GCB/PP',\n    'loe=true' => 'GCB/PP',\n    'loe=y' => 'GCB/PP',\n    'loe=yes' => 'GCB/PP',\n    'logicalorderexception' => 'GCB/PP',\n    'lower' => 'Lower/Y',\n    'lower=f' => 'Lower/N',\n    'lower=false' => 'Lower/N',\n    'lower=n' => 'Lower/N',\n    'lower=no' => 'Lower/N',\n    'lower=t' => 'Lower/Y',\n    'lower=true' => 'Lower/Y',\n    'lower=y' => 'Lower/Y',\n    'lower=yes' => 'Lower/Y',\n    'lowercase' => 'Lower/Y',\n    'lowercaseletter' => 'Gc/Ll',\n    'lowsurrogates' => 'Blk/LowSurro',\n    'lt' => 'Perl/Title',\n    'lu' => 'Gc/Lu',\n    'lyci' => 'Sc/Lyci',\n    'lycian' => 'Sc/Lyci',\n    'lydi' => 'Sc/Lydi',\n    'lydian' => 'Sc/Lydi',\n    'm' => 'Gc/M',\n    'mahjongtiles' => 'Blk/MahjongT',\n    'malayalam' => 'Sc/Mlym',\n    'mand' => 'Sc/Mand',\n    'mandaic' => 'Sc/Mand',\n    'mark' => 'Gc/M',\n    'math' => 'Math/Y',\n    'math=f' => 'Math/N',\n    'math=false' => 'Math/N',\n    'math=n' => 'Math/N',\n    'math=no' => 'Math/N',\n    'math=t' => 'Math/Y',\n    'math=true' => 'Math/Y',\n    'math=y' => 'Math/Y',\n    'math=yes' => 'Math/Y',\n    'mathematicalalphanumericsymbols' => 'Blk/Mathema2',\n    'mathematicaloperators' => 'Blk/Mathemat',\n    'mathsymbol' => 'Gc/Sm',\n    'mc' => 'Gc/Mc',\n    'me' => 'Gc/Me',\n    'meeteimayek' => 'Sc/Mtei',\n    'miscellaneousmathematicalsymbolsa' => 'Blk/Miscell4',\n    'miscellaneousmathematicalsymbolsb' => 'Blk/Miscell5',\n    'miscellaneoussymbols' => 'Blk/Miscella',\n    'miscellaneoussymbolsandarrows' => 'Blk/Miscell3',\n    'miscellaneoussymbolsandpictographs' => 'Blk/Miscell6',\n    'miscellaneoustechnical' => 'Blk/Miscell2',\n    'mlym' => 'Sc/Mlym',\n    'mn' => 'Gc/Mn',\n    'modifierletter' => 'Gc/Lm',\n    'modifiersymbol' => 'Gc/Sk',\n    'modifiertoneletters' => 'Blk/Modifier',\n    'mong' => 'Sc/Mong',\n    'mongolian' => 'Sc/Mong',\n    'mtei' => 'Sc/Mtei',\n    'musicalsymbols' => 'Blk/MusicalS',\n    'myanmar' => 'Sc/Mymr',\n    'myanmarextendeda' => 'Blk/MyanmarE',\n    'mymr' => 'Sc/Mymr',\n    'n' => 'Gc/N',\n    'nchar' => 'NChar/Y',\n    'nchar=f' => 'NChar/N',\n    'nchar=false' => 'NChar/N',\n    'nchar=n' => 'NChar/N',\n    'nchar=no' => 'NChar/N',\n    'nchar=t' => 'NChar/Y',\n    'nchar=true' => 'NChar/Y',\n    'nchar=y' => 'NChar/Y',\n    'nchar=yes' => 'NChar/Y',\n    'nd' => 'Nt/De',\n    'newtailue' => 'Sc/Talu',\n    'nfcqc=m' => 'NFKCQC/M',\n    'nfcqc=maybe' => 'NFKCQC/M',\n    'nfcqc=n' => 'CompEx/Y',\n    'nfcqc=no' => 'CompEx/Y',\n    'nfcqc=y' => 'NFCQC/Y',\n    'nfcqc=yes' => 'NFCQC/Y',\n    'nfdqc=n' => 'NFDQC/N',\n    'nfdqc=no' => 'NFDQC/N',\n    'nfdqc=y' => 'NFDQC/Y',\n    'nfdqc=yes' => 'NFDQC/Y',\n    'nfkcqc=m' => 'NFKCQC/M',\n    'nfkcqc=maybe' => 'NFKCQC/M',\n    'nfkcqc=n' => 'NFKCQC/N',\n    'nfkcqc=no' => 'NFKCQC/N',\n    'nfkcqc=y' => 'NFKCQC/Y',\n    'nfkcqc=yes' => 'NFKCQC/Y',\n    'nfkdqc=n' => 'NFKDQC/N',\n    'nfkdqc=no' => 'NFKDQC/N',\n    'nfkdqc=y' => 'Dt/None',\n    'nfkdqc=yes' => 'Dt/None',\n    'nko' => 'Sc/Nko',\n    'nkoo' => 'Sc/Nko',\n    'nl' => 'Gc/Nl',\n    'no' => 'Gc/No',\n    'noblock' => 'Blk/NoBlock',\n    'noncharactercodepoint' => 'NChar/Y',\n    'nonspacingmark' => 'Gc/Mn',\n    'nt=de' => 'Nt/De',\n    'nt=decimal' => 'Nt/De',\n    'nt=di' => 'Nt/Di',\n    'nt=digit' => 'Nt/Di',\n    'nt=none' => 'Nv/NaN',\n    'nt=nu' => 'Nt/Nu',\n    'nt=numeric' => 'Nt/Nu',\n    'number' => 'Gc/N',\n    'numberforms' => 'Blk/NumberFo',\n    'nv=nan' => 'Nv/NaN',\n    'oalpha' => 'OAlpha/Y',\n    'oalpha=f' => 'OAlpha/N',\n    'oalpha=false' => 'OAlpha/N',\n    'oalpha=n' => 'OAlpha/N',\n    'oalpha=no' => 'OAlpha/N',\n    'oalpha=t' => 'OAlpha", 8192) = 8192
09:02:57.373305 read(3, "/Y',\n    'oalpha=true' => 'OAlpha/Y',\n    'oalpha=y' => 'OAlpha/Y',\n    'oalpha=yes' => 'OAlpha/Y',\n    'odi' => 'ODI/Y',\n    'odi=f' => 'ODI/N',\n    'odi=false' => 'ODI/N',\n    'odi=n' => 'ODI/N',\n    'odi=no' => 'ODI/N',\n    'odi=t' => 'ODI/Y',\n    'odi=true' => 'ODI/Y',\n    'odi=y' => 'ODI/Y',\n    'odi=yes' => 'ODI/Y',\n    'ogam' => 'Sc/Ogam',\n    'ogham' => 'Sc/Ogam',\n    'ogrext' => 'OGrExt/Y',\n    'ogrext=f' => 'OGrExt/N',\n    'ogrext=false' => 'OGrExt/N',\n    'ogrext=n' => 'OGrExt/N',\n    'ogrext=no' => 'OGrExt/N',\n    'ogrext=t' => 'OGrExt/Y',\n    'ogrext=true' => 'OGrExt/Y',\n    'ogrext=y' => 'OGrExt/Y',\n    'ogrext=yes' => 'OGrExt/Y',\n    'oidc' => 'OIDC/Y',\n    'oidc=f' => 'OIDC/N',\n    'oidc=false' => 'OIDC/N',\n    'oidc=n' => 'OIDC/N',\n    'oidc=no' => 'OIDC/N',\n    'oidc=t' => 'OIDC/Y',\n    'oidc=true' => 'OIDC/Y',\n    'oidc=y' => 'OIDC/Y',\n    'oidc=yes' => 'OIDC/Y',\n    'oids' => 'OIDS/Y',\n    'oids=f' => 'OIDS/N',\n    'oids=false' => 'OIDS/N',\n    'oids=n' => 'OIDS/N',\n    'oids=no' => 'OIDS/N',\n    'oids=t' => 'OIDS/Y',\n    'oids=true' => 'OIDS/Y',\n    'oids=y' => 'OIDS/Y',\n    'oids=yes' => 'OIDS/Y',\n    'olchiki' => 'Blk/OlChiki',\n    'olck' => 'Blk/OlChiki',\n    'olditalic' => 'Sc/Ital',\n    'oldpersian' => 'Sc/Xpeo',\n    'oldsoutharabian' => 'Blk/OldSouth',\n    'oldturkic' => 'Sc/Orkh',\n    'olower' => 'OLower/Y',\n    'olower=f' => 'OLower/N',\n    'olower=false' => 'OLower/N',\n    'olower=n' => 'OLower/N',\n    'olower=no' => 'OLower/N',\n    'olower=t' => 'OLower/Y',\n    'olower=true' => 'OLower/Y',\n    'olower=y' => 'OLower/Y',\n    'olower=yes' => 'OLower/Y',\n    'omath' => 'OMath/Y',\n    'omath=f' => 'OMath/N',\n    'omath=false' => 'OMath/N',\n    'omath=n' => 'OMath/N',\n    'omath=no' => 'OMath/N',\n    'omath=t' => 'OMath/Y',\n    'omath=true' => 'OMath/Y',\n    'omath=y' => 'OMath/Y',\n    'omath=yes' => 'OMath/Y',\n    'openpunctuation' => 'Gc/Ps',\n    'opticalcharacterrecognition' => 'Blk/OpticalC',\n    'oriya' => 'Sc/Orya',\n    'orkh' => 'Sc/Orkh',\n    'orya' => 'Sc/Orya',\n    'osma' => 'Sc/Osma',\n    'osmanya' => 'Sc/Osma',\n    'other' => 'Gc/C',\n    'otheralphabetic' => 'OAlpha/Y',\n    'otherdefaultignorablecodepoint' => 'ODI/Y',\n    'othergraphemeextend' => 'OGrExt/Y',\n    'otheridcontinue' => 'OIDC/Y',\n    'otheridstart' => 'OIDS/Y',\n    'otherletter' => 'Gc/Lo',\n    'otherlowercase' => 'OLower/Y',\n    'othermath' => 'OMath/Y',\n    'othernumber' => 'Gc/No',\n    'otherpunctuation' => 'Gc/Po',\n    'othersymbol' => 'Gc/So',\n    'otheruppercase' => 'OUpper/Y',\n    'oupper' => 'OUpper/Y',\n    'oupper=f' => 'OUpper/N',\n    'oupper=false' => 'OUpper/N',\n    'oupper=n' => 'OUpper/N',\n    'oupper=no' => 'OUpper/N',\n    'oupper=t' => 'OUpper/Y',\n    'oupper=true' => 'OUpper/Y',\n    'oupper=y' => 'OUpper/Y',\n    'oupper=yes' => 'OUpper/Y',\n    'p' => 'Gc/P',\n    'paragraphseparator' => 'Gc/Zp',\n    'patsyn' => 'PatSyn/Y',\n    'patsyn=f' => 'PatSyn/N',\n    'patsyn=false' => 'PatSyn/N',\n    'patsyn=n' => 'PatSyn/N',\n    'patsyn=no' => 'PatSyn/N',\n    'patsyn=t' => 'PatSyn/Y',\n    'patsyn=true' => 'PatSyn/Y',\n    'patsyn=y' => 'PatSyn/Y',\n    'patsyn=yes' => 'PatSyn/Y',\n    'patternsyntax' => 'PatSyn/Y',\n    'patternwhitespace' => 'PatWS/Y',\n    'patws' => 'PatWS/Y',\n    'patws=f' => 'PatWS/N',\n    'patws=false' => 'PatWS/N',\n    'patws=n' => 'PatWS/N',\n    'patws=no' => 'PatWS/N',\n    'patws=t' => 'PatWS/Y',\n    'patws=true' => 'PatWS/Y',\n    'patws=y' => 'PatWS/Y',\n    'patws=yes' => 'PatWS/Y',\n    'pc' => 'WB/EX',\n    'pd' => 'Gc/Pd',\n    'pe' => 'Gc/Pe',\n    'perlspace' => 'Perl/PerlSpac',\n    'perlword' => 'Perl/PerlWord',\n    'pf' => 'Gc/Pf',\n    'phag' => 'Sc/Phag',\n    'phagspa' => 'Sc/Phag',\n    'phaistosdisc' => 'Blk/Phaistos',\n    'phli' => 'Sc/Phli',\n    'phnx' => 'Sc/Phnx',\n    'phoenician' => 'Sc/Phnx',\n    'phoneticextensions' => 'Blk/Phonetic',\n    'phoneticextensionssupplement' => 'Blk/Phoneti2',\n    'pi' => 'Gc/Pi',\n    'playingcards' => 'Blk/PlayingC',\n    'po' => 'Gc/Po',\n    'posixalnum' => 'Perl/PosixAln',\n    'posixalpha' => 'Perl/PosixAlp',\n    'posixblank' => 'Perl/PosixBla',\n    'posixcntrl' => 'Perl/PosixCnt',\n    'posixdigit' => 'Perl/PosixDig',\n    'posixgraph' => 'Perl/PosixGra',\n    'posixlower' => 'Perl/PosixLow',\n    'posixprint' => 'Perl/PosixPri',\n    'posixpunct' => 'Perl/PosixPun',\n    'posixspace' => 'Perl/PosixSpa',\n    'posixupper' => 'Perl/PosixUpp',\n    'posixword' => 'Perl/PerlWord',\n    'posixxdigit' => 'AHex/Y',\n    'print' => 'Perl/Print',\n    'privateuse' => 'Gc/Co',\n    'privateusearea' => 'Blk/PrivateU',\n    'prti' => 'Sc/Prti',\n    'ps' => 'Gc/Ps',\n    'punct' => 'Gc/P',\n    'punctuation' => 'Gc/P',\n    'qaac' => 'Sc/Copt',\n    'qaai' => 'Sc/Zinh',\n    'qmark' => 'QMark/Y',\n    'qmark=f' => 'QMark/N',\n    'qmark=false' => 'QMark/N',\n    'qmark=n' => 'QMark/N',\n    'qmark=no' => 'QMark/N',\n    'qmark=t' => 'QMark/Y',\n    'qmark=true' => 'QMark/Y',\n    'qmark=y' => 'QMark/Y',\n    'qmark=yes' => 'QMark/Y',\n    'quotationmark' => 'QMark/Y',\n    'radical' => 'Radical/Y',\n    'radical=f' => 'Radical/N',\n    'radical=false' => 'Radical/N',\n    'radical=n' => 'Radical/N',\n    'radical=no' => 'Radical/N',\n    'radical=t' => 'Radical/Y',\n    'radical=true' => 'Radical/Y',\n    'radical=y' => 'Radical/Y',\n    'radical=yes' => 'Radical/Y',\n    'rejang' => 'Sc/Rjng',\n    'rjng' => 'Sc/Rjng',\n    'ruminumeralsymbols' => 'Blk/RumiNume',\n    'runic' => 'Sc/Runr',\n    'runr' => 'Sc/Runr',\n    's' => 'Gc/S',\n    'samaritan' => 'Sc/Samr',\n    'samr' => 'Sc/Samr',\n    'sarb' => 'Blk/OldSouth',\n    'saur' => 'Sc/Saur',\n    'saurashtra' => 'Sc/Saur',\n    'sb=at' => 'SB/AT',\n    'sb=aterm' => 'SB/AT',\n    'sb=cl' => 'SB/CL',\n    'sb=close' => 'SB/CL',\n    'sb=cr' => 'GCB/CR',\n    'sb=ex' => 'SB/EX',\n    'sb=extend' => 'SB/EX',\n    'sb=fo' => 'SB/FO',\n    'sb=format' => 'SB/FO',\n    'sb=le' => 'SB/LE',\n    'sb=lf' => 'GCB/LF',\n    'sb=lo' => 'SB/LO',\n    'sb=lower' => 'SB/LO',\n    'sb=nu' => 'Lb/NU',\n    'sb=numeric' => 'Lb/NU',\n    'sb=oletter' => 'SB/LE',\n    'sb=other' => 'SB/XX',\n    'sb=sc' => 'SB/SC',\n    'sb=scontinue' => 'SB/SC',\n    'sb=se' => 'SB/SE',\n    'sb=sep' => 'SB/SE',\n    'sb=sp' => 'SB/Sp',\n    'sb=st' => 'SB/ST',\n    'sb=sterm' => 'SB/ST',\n    'sb=up' => 'SB/UP',\n    'sb=upper' => 'SB/UP',\n    'sb=xx' => 'SB/XX',\n    'sc' => 'Gc/Sc',\n    'sc=arab' => 'Sc/Arab',\n    'sc=arabic' => 'Sc/Arab',\n    'sc=armenian' => 'Sc/Armn',\n    'sc=armi' => 'Sc/Armi',\n    'sc=armn' => 'Sc/Armn',\n    'sc=avestan' => 'Sc/Avst',\n    'sc=avst' => 'Sc/Avst',\n    'sc=bali' => 'Sc/Bali',\n    'sc=balinese' => 'Sc/Bali',\n    'sc=bamu' => 'Sc/Bamu',\n    'sc=bamum' => 'Sc/Bamu',\n    'sc=batak' => 'Sc/Batk',\n    'sc=batk' => 'Sc/Batk',\n    'sc=beng' => 'Sc/Beng',\n    'sc=bengali' => 'Sc/Beng',\n    'sc=bopo' => 'Sc/Bopo',\n    'sc=bopomofo' => 'Sc/Bopo',\n    'sc=brah' => 'Sc/Brah',\n    'sc=brahmi' => 'Sc/Brah',\n    'sc=brai' => 'Blk/BrailleP',\n    'sc=braille' => 'Blk/BrailleP',\n    'sc=bugi' => 'Sc/Bugi',\n    'sc=buginese' => 'Sc/Bugi',\n    'sc=buhd' => 'Sc/Buhd',\n    'sc=buhid' => 'Sc/Buhd',\n    'sc=canadianaboriginal' => 'Sc/Cans',\n    'sc=cans' => 'Sc/Cans',\n    'sc=cari' => 'Sc/Cari',\n    'sc=carian' => 'Sc/Cari',\n    'sc=cham' => 'Sc/Cham',\n    'sc=cher' => 'Sc/Cher',\n    'sc=cherokee' => 'Sc/Cher',\n    'sc=common' => 'Sc/Zyyy',\n    'sc=copt' => 'Sc/Copt',\n    'sc=coptic' => 'Sc/Copt',\n    'sc=cprt' => 'Sc/Cprt',\n    'sc=cuneiform' => 'Sc/Xsux',\n    'sc=cypriot' => 'Sc/Cprt',\n    'sc=cyrillic' => 'Sc/Cyrl',\n    'sc=cyrl' => 'Sc/Cyrl',\n    'sc=deseret' => 'Blk/Deseret',\n    'sc=deva' => 'Sc/Deva',\n    'sc=devanagari' => 'Sc/Deva',\n    'sc=dsrt' => 'Blk/Deseret',\n    'sc=egyp' => 'Sc/Egyp',\n    'sc=egyptianhieroglyphs' => 'Sc/Egyp',\n    'sc=ethi' => 'Sc/Ethi',\n    'sc=ethiopic' => 'Sc/Ethi',\n    'sc=geor' => 'Sc/Geor',\n    'sc=georgian' => 'Sc/Geor',\n    'sc=glag' => 'Sc/Glag',\n    'sc=glagolitic' => 'Sc/Glag',\n    'sc=goth' => 'Sc/Goth',\n    'sc=gothic' => 'Sc/Goth',\n    'sc=greek' => 'Sc/Grek',\n    'sc=grek' => 'Sc/Grek',\n    'sc=gujarati' => 'Sc/Gujr',\n    'sc=gujr' => 'Sc/Gujr',\n    'sc=gurmukhi' => 'Sc/Guru',\n    'sc=guru' => 'Sc/Guru',\n    'sc=han' => 'Sc/Han',\n    'sc=hang' => 'Sc/Hang',\n    'sc=hangu", 8192) = 8192
09:02:57.374600 brk(0x2237000)          = 0x2237000
09:02:57.374888 read(3, "l' => 'Sc/Hang',\n    'sc=hani' => 'Sc/Han',\n    'sc=hano' => 'Sc/Hano',\n    'sc=hanunoo' => 'Sc/Hano',\n    'sc=hebr' => 'Sc/Hebr',\n    'sc=hebrew' => 'Sc/Hebr',\n    'sc=hira' => 'Sc/Hira',\n    'sc=hiragana' => 'Sc/Hira',\n    'sc=imperialaramaic' => 'Sc/Armi',\n    'sc=inherited' => 'Sc/Zinh',\n    'sc=inscriptionalpahlavi' => 'Sc/Phli',\n    'sc=inscriptionalparthian' => 'Sc/Prti',\n    'sc=ital' => 'Sc/Ital',\n    'sc=java' => 'Sc/Java',\n    'sc=javanese' => 'Sc/Java',\n    'sc=kaithi' => 'Sc/Kthi',\n    'sc=kali' => 'Blk/KayahLi',\n    'sc=kana' => 'Sc/Kana',\n    'sc=kannada' => 'Sc/Knda',\n    'sc=katakana' => 'Sc/Kana',\n    'sc=kayahli' => 'Blk/KayahLi',\n    'sc=khar' => 'Sc/Khar',\n    'sc=kharoshthi' => 'Sc/Khar',\n    'sc=khmer' => 'Sc/Khmr',\n    'sc=khmr' => 'Sc/Khmr',\n    'sc=knda' => 'Sc/Knda',\n    'sc=kthi' => 'Sc/Kthi',\n    'sc=lana' => 'Sc/Lana',\n    'sc=lao' => 'Sc/Lao',\n    'sc=laoo' => 'Sc/Lao',\n    'sc=latin' => 'Sc/Latn',\n    'sc=latn' => 'Sc/Latn',\n    'sc=lepc' => 'Sc/Lepc',\n    'sc=lepcha' => 'Sc/Lepc',\n    'sc=limb' => 'Sc/Limb',\n    'sc=limbu' => 'Sc/Limb',\n    'sc=linb' => 'Sc/Linb',\n    'sc=linearb' => 'Sc/Linb',\n    'sc=lisu' => 'Blk/Lisu',\n    'sc=lyci' => 'Sc/Lyci',\n    'sc=lycian' => 'Sc/Lyci',\n    'sc=lydi' => 'Sc/Lydi',\n    'sc=lydian' => 'Sc/Lydi',\n    'sc=malayalam' => 'Sc/Mlym',\n    'sc=mand' => 'Sc/Mand',\n    'sc=mandaic' => 'Sc/Mand',\n    'sc=meeteimayek' => 'Sc/Mtei',\n    'sc=mlym' => 'Sc/Mlym',\n    'sc=mong' => 'Sc/Mong',\n    'sc=mongolian' => 'Sc/Mong',\n    'sc=mtei' => 'Sc/Mtei',\n    'sc=myanmar' => 'Sc/Mymr',\n    'sc=mymr' => 'Sc/Mymr',\n    'sc=newtailue' => 'Sc/Talu',\n    'sc=nko' => 'Sc/Nko',\n    'sc=nkoo' => 'Sc/Nko',\n    'sc=ogam' => 'Sc/Ogam',\n    'sc=ogham' => 'Sc/Ogam',\n    'sc=olchiki' => 'Blk/OlChiki',\n    'sc=olck' => 'Blk/OlChiki',\n    'sc=olditalic' => 'Sc/Ital',\n    'sc=oldpersian' => 'Sc/Xpeo',\n    'sc=oldsoutharabian' => 'Blk/OldSouth',\n    'sc=oldturkic' => 'Sc/Orkh',\n    'sc=oriya' => 'Sc/Orya',\n    'sc=orkh' => 'Sc/Orkh',\n    'sc=orya' => 'Sc/Orya',\n    'sc=osma' => 'Sc/Osma',\n    'sc=osmanya' => 'Sc/Osma',\n    'sc=phag' => 'Sc/Phag',\n    'sc=phagspa' => 'Sc/Phag',\n    'sc=phli' => 'Sc/Phli',\n    'sc=phnx' => 'Sc/Phnx',\n    'sc=phoenician' => 'Sc/Phnx',\n    'sc=prti' => 'Sc/Prti',\n    'sc=qaac' => 'Sc/Copt',\n    'sc=qaai' => 'Sc/Zinh',\n    'sc=rejang' => 'Sc/Rjng',\n    'sc=rjng' => 'Sc/Rjng',\n    'sc=runic' => 'Sc/Runr',\n    'sc=runr' => 'Sc/Runr',\n    'sc=samaritan' => 'Sc/Samr',\n    'sc=samr' => 'Sc/Samr',\n    'sc=sarb' => 'Blk/OldSouth',\n    'sc=saur' => 'Sc/Saur',\n    'sc=saurashtra' => 'Sc/Saur',\n    'sc=shavian' => 'Blk/Shavian',\n    'sc=shaw' => 'Blk/Shavian',\n    'sc=sinh' => 'Sc/Sinh',\n    'sc=sinhala' => 'Sc/Sinh',\n    'sc=sund' => 'Sc/Sund',\n    'sc=sundanese' => 'Sc/Sund',\n    'sc=sylo' => 'Sc/Sylo',\n    'sc=sylotinagri' => 'Sc/Sylo',\n    'sc=syrc' => 'Sc/Syrc',\n    'sc=syriac' => 'Sc/Syrc',\n    'sc=tagalog' => 'Sc/Tglg',\n    'sc=tagb' => 'Sc/Tagb',\n    'sc=tagbanwa' => 'Sc/Tagb',\n    'sc=taile' => 'Sc/Tale',\n    'sc=taitham' => 'Sc/Lana',\n    'sc=taiviet' => 'Sc/Tavt',\n    'sc=tale' => 'Sc/Tale',\n    'sc=talu' => 'Sc/Talu',\n    'sc=tamil' => 'Sc/Taml',\n    'sc=taml' => 'Sc/Taml',\n    'sc=tavt' => 'Sc/Tavt',\n    'sc=telu' => 'Sc/Telu',\n    'sc=telugu' => 'Sc/Telu',\n    'sc=tfng' => 'Sc/Tfng',\n    'sc=tglg' => 'Sc/Tglg',\n    'sc=thaa' => 'Sc/Thaa',\n    'sc=thaana' => 'Sc/Thaa',\n    'sc=thai' => 'Sc/Thai',\n    'sc=tibetan' => 'Sc/Tibt',\n    'sc=tibt' => 'Sc/Tibt',\n    'sc=tifinagh' => 'Sc/Tfng',\n    'sc=ugar' => 'Sc/Ugar',\n    'sc=ugaritic' => 'Sc/Ugar',\n    'sc=unknown' => 'Sc/Zzzz',\n    'sc=vai' => 'Sc/Vai',\n    'sc=vaii' => 'Sc/Vai',\n    'sc=xpeo' => 'Sc/Xpeo',\n    'sc=xsux' => 'Sc/Xsux',\n    'sc=yi' => 'Sc/Yi',\n    'sc=yiii' => 'Sc/Yi',\n    'sc=zinh' => 'Sc/Zinh',\n    'sc=zyyy' => 'Sc/Zyyy',\n    'sc=zzzz' => 'Sc/Zzzz',\n    'sd' => 'SD/Y',\n    'sd=f' => 'SD/N',\n    'sd=false' => 'SD/N',\n    'sd=n' => 'SD/N',\n    'sd=no' => 'SD/N',\n    'sd=t' => 'SD/Y',\n    'sd=true' => 'SD/Y',\n    'sd=y' => 'SD/Y',\n    'sd=yes' => 'SD/Y',\n    'separator' => 'Gc/Z',\n    'shavian' => 'Blk/Shavian',\n    'shaw' => 'Blk/Shavian',\n    'sinh' => 'Sc/Sinh',\n    'sinhala' => 'Sc/Sinh',\n    'sk' => 'Gc/Sk',\n    'sm' => 'Gc/Sm',\n    'smallformvariants' => 'Blk/SmallFor',\n    'so' => 'Gc/So',\n    'softdotted' => 'SD/Y',\n    'space' => 'Space/Y',\n    'spaceperl' => 'Perl/SpacePer',\n    'spaceseparator' => 'Gc/Zs',\n    'spacingmark' => 'Gc/Mc',\n    'spacingmodifierletters' => 'Blk/SpacingM',\n    'specials' => 'Blk/Specials',\n    'sterm' => 'STerm/Y',\n    'sterm=f' => 'STerm/N',\n    'sterm=false' => 'STerm/N',\n    'sterm=n' => 'STerm/N',\n    'sterm=no' => 'STerm/N',\n    'sterm=t' => 'STerm/Y',\n    'sterm=true' => 'STerm/Y',\n    'sterm=y' => 'STerm/Y',\n    'sterm=yes' => 'STerm/Y',\n    'sund' => 'Sc/Sund',\n    'sundanese' => 'Sc/Sund',\n    'superscriptsandsubscripts' => 'Blk/Superscr',\n    'supplementalarrowsa' => 'Blk/Suppleme',\n    'supplementalarrowsb' => 'Blk/Supplem2',\n    'supplementalmathematicaloperators' => 'Blk/Supplem6',\n    'supplementalpunctuation' => 'Blk/Supplem3',\n    'supplementaryprivateuseareaa' => 'Blk/Supplem4',\n    'supplementaryprivateuseareab' => 'Blk/Supplem5',\n    'surrogate' => 'Gc/Cs',\n    'sylo' => 'Sc/Sylo',\n    'sylotinagri' => 'Sc/Sylo',\n    'symbol' => 'Gc/S',\n    'syrc' => 'Sc/Syrc',\n    'syriac' => 'Sc/Syrc',\n    'tagalog' => 'Sc/Tglg',\n    'tagb' => 'Sc/Tagb',\n    'tagbanwa' => 'Sc/Tagb',\n    'tags' => 'Blk/Tags',\n    'taile' => 'Sc/Tale',\n    'taitham' => 'Sc/Lana',\n    'taiviet' => 'Sc/Tavt',\n    'taixuanjingsymbols' => 'Blk/TaiXuanJ',\n    'tale' => 'Sc/Tale',\n    'talu' => 'Sc/Talu',\n    'tamil' => 'Sc/Taml',\n    'taml' => 'Sc/Taml',\n    'tavt' => 'Sc/Tavt',\n    'telu' => 'Sc/Telu',\n    'telugu' => 'Sc/Telu',\n    'term' => 'Term/Y',\n    'term=f' => 'Term/N',\n    'term=false' => 'Term/N',\n    'term=n' => 'Term/N',\n    'term=no' => 'Term/N',\n    'term=t' => 'Term/Y',\n    'term=true' => 'Term/Y',\n    'term=y' => 'Term/Y',\n    'term=yes' => 'Term/Y',\n    'terminalpunctuation' => 'Term/Y',\n    'tfng' => 'Sc/Tfng',\n    'tglg' => 'Sc/Tglg',\n    'thaa' => 'Sc/Thaa',\n    'thaana' => 'Sc/Thaa',\n    'thai' => 'Sc/Thai',\n    'tibetan' => 'Sc/Tibt',\n    'tibt' => 'Sc/Tibt',\n    'tifinagh' => 'Sc/Tfng',\n    'title' => 'Perl/Title',\n    'titlecase' => 'Perl/Title',\n    'titlecaseletter' => 'Perl/Title',\n    'transportandmapsymbols' => 'Blk/Transpor',\n    'ugar' => 'Sc/Ugar',\n    'ugaritic' => 'Sc/Ugar',\n    'uideo' => 'UIdeo/Y',\n    'uideo=f' => 'UIdeo/N',\n    'uideo=false' => 'UIdeo/N',\n    'uideo=n' => 'UIdeo/N',\n    'uideo=no' => 'UIdeo/N',\n    'uideo=t' => 'UIdeo/Y',\n    'uideo=true' => 'UIdeo/Y',\n    'uideo=y' => 'UIdeo/Y',\n    'uideo=yes' => 'UIdeo/Y',\n    'unassigned' => 'Gc/Cn',\n    'unifiedcanadianaboriginalsyllabics' => 'Blk/Canadian',\n    'unifiedcanadianaboriginalsyllabicsextended' => 'Blk/UnifiedC',\n    'unifiedideograph' => 'UIdeo/Y',\n    'unknown' => 'Sc/Zzzz',\n    'upper' => 'Upper/Y',\n    'upper=f' => 'Upper/N',\n    'upper=false' => 'Upper/N',\n    'upper=n' => 'Upper/N',\n    'upper=no' => 'Upper/N',\n    'upper=t' => 'Upper/Y',\n    'upper=true' => 'Upper/Y',\n    'upper=y' => 'Upper/Y',\n    'upper=yes' => 'Upper/Y',\n    'uppercase' => 'Upper/Y',\n    'uppercaseletter' => 'Gc/Lu',\n    'vai' => 'Sc/Vai',\n    'vaii' => 'Sc/Vai',\n    'variationselector' => 'VS/Y',\n    'variationselectors' => 'Blk/Variatio',\n    'variationselectorssupplement' => 'Blk/Variati2',\n    'vedicextensions' => 'Blk/VedicExt',\n    'verticalforms' => 'Blk/Vertical',\n    'vertspace' => 'Perl/VertSpac',\n    'vs' => 'VS/Y',\n    'vs=f' => 'VS/N',\n    'vs=false' => 'VS/N',\n    'vs=n' => 'VS/N',\n    'vs=no' => 'VS/N',\n    'vs=t' => 'VS/Y',\n    'vs=true' => 'VS/Y',\n    'vs=y' => 'VS/Y',\n    'vs=yes' => 'VS/Y',\n    'wb=aletter' => 'WB/LE',\n    'wb=cr' => 'GCB/CR',\n    'wb=ex' => 'WB/EX',\n    'wb=extend' => 'SB/EX',\n    'wb=extendnumlet' => 'WB/EX',\n    'wb=fo' => 'WB/FO',\n    'wb=format' => 'WB/FO',\n    'wb=ka' => 'WB/KA',\n    'wb=katakana' => 'WB/KA',\n    'wb=le' => 'WB/LE',\n    'wb=lf' => 'GCB/LF',\n    'wb=mb' => 'WB/MB',\n    'wb=midletter' => 'WB/ML',\n    'wb=midnum' => 'WB/MN',\n    'wb=midnumlet' => 'WB/MB'", 8192) = 8192
09:02:57.376326 read(3, ",\n    'wb=ml' => 'WB/ML',\n    'wb=mn' => 'WB/MN',\n    'wb=newline' => 'WB/NL',\n    'wb=nl' => 'WB/NL',\n    'wb=nu' => 'WB/NU',\n    'wb=numeric' => 'WB/NU',\n    'wb=other' => 'WB/XX',\n    'wb=xx' => 'WB/XX',\n    'whitespace' => 'Space/Y',\n    'word' => 'Perl/Word',\n    'wspace' => 'Space/Y',\n    'wspace=f' => 'Space/N',\n    'wspace=false' => 'Space/N',\n    'wspace=n' => 'Space/N',\n    'wspace=no' => 'Space/N',\n    'wspace=t' => 'Space/Y',\n    'wspace=true' => 'Space/Y',\n    'wspace=y' => 'Space/Y',\n    'wspace=yes' => 'Space/Y',\n    'xdigit' => 'Hex/Y',\n    'xidc' => 'XIDC/Y',\n    'xidc=f' => 'XIDC/N',\n    'xidc=false' => 'XIDC/N',\n    'xidc=n' => 'XIDC/N',\n    'xidc=no' => 'XIDC/N',\n    'xidc=t' => 'XIDC/Y',\n    'xidc=true' => 'XIDC/Y',\n    'xidc=y' => 'XIDC/Y',\n    'xidc=yes' => 'XIDC/Y',\n    'xidcontinue' => 'XIDC/Y',\n    'xids' => 'XIDS/Y',\n    'xids=f' => 'XIDS/N',\n    'xids=false' => 'XIDS/N',\n    'xids=n' => 'XIDS/N',\n    'xids=no' => 'XIDS/N',\n    'xids=t' => 'XIDS/Y',\n    'xids=true' => 'XIDS/Y',\n    'xids=y' => 'XIDS/Y',\n    'xids=yes' => 'XIDS/Y',\n    'xidstart' => 'XIDS/Y',\n    'xpeo' => 'Sc/Xpeo',\n    'xperlspace' => 'Perl/SpacePer',\n    'xposixalnum' => 'Perl/Alnum',\n    'xposixalpha' => 'Alpha/Y',\n    'xposixblank' => 'Perl/Blank',\n    'xposixcntrl' => 'Gc/Cc',\n    'xposixdigit' => 'Nt/De',\n    'xposixgraph' => 'Perl/Graph',\n    'xposixlower' => 'Lower/Y',\n    'xposixprint' => 'Perl/Print',\n    'xposixpunct' => 'Perl/XPosixPu',\n    'xposixspace' => 'Space/Y',\n    'xposixupper' => 'Upper/Y',\n    'xposixword' => 'Perl/Word',\n    'xposixxdigit' => 'Hex/Y',\n    'xsux' => 'Sc/Xsux',\n    'yi' => 'Sc/Yi',\n    'yiii' => 'Sc/Yi',\n    'yijinghexagramsymbols' => 'Blk/YijingHe',\n    'yiradicals' => 'Blk/YiRadica',\n    'yisyllables' => 'Blk/YiSyllab',\n    'z' => 'Gc/Z',\n    'zinh' => 'Sc/Zinh',\n    'zl' => 'Gc/Zl',\n    'zp' => 'Gc/Zp',\n    'zs' => 'Gc/Zs',\n    'zyyy' => 'Sc/Zyyy',\n    'zzzz' => 'Sc/Zzzz',\n);\n\n# Maps floating point to fractional form\n%utf8::nv_floating_to_rational = (\n    -0.5 => '-1/2',\n    0.0625 => '1/16',\n    0.1 => '1/10',\n    0.111111111111111 => '1/9',\n    0.125 => '1/8',\n    0.142857142857143 => '1/7',\n    0.166666666666667 => '1/6',\n    0.1875 => '3/16',\n    0.2 => '1/5',\n    0.25 => '1/4',\n    0.333333333333333 => '1/3',\n    0.375 => '3/8',\n    0.4 => '2/5',\n    0.5 => '1/2',\n    0.6 => '3/5',\n    0.625 => '5/8',\n    0.666666666666667 => '2/3',\n    0.75 => '3/4',\n    0.8 => '4/5',\n    0.833333333333333 => '5/6',\n    0.875 => '7/8',\n    1.5 => '3/2',\n    2.5 => '5/2',\n    3.5 => '7/2',\n    4.5 => '9/2',\n    5.5 => '11/2',\n    6.5 => '13/2',\n    7.5 => '15/2',\n    8.5 => '17/2',\n);\n\n# If a floating point number doesn't have enough digits in it to get this\n# close to a fraction, it isn't considered to be that fraction even if all the\n# digits it does have match.\n$utf8::max_floating_slop = 0.001;\n\n# Deprecated tables to generate a warning for.  The key is the file containing\n# the table, so as to avoid duplication, as many property names can map to the\n# file, but we only need one entry for all of them.\n%utf8::why_deprecated = (\n    'Hyphen/N' => 'Supplanted by Line_Break property values; see www.unicode.org/reports/tr14',\n    'Hyphen/Y' => 'Supplanted by Line_Break property values; see www.unicode.org/reports/tr14',\n    'Lb/SG' => 'Deprecated by Unicode because surrogates should never appear in well-formed text, and therefore shouldn\\'t be the basis for line breaking',\n    'OAlpha/N' => 'Used by Unicode internally for generating the Alphabetic property (which should be used instead) and not intended to be used stand-alone',\n    'OAlpha/Y' => 'Used by Unicode internally for generating the Alphabetic property (which should be used instead) and not intended to be used stand-alone',\n    'ODI/N' => 'Used by Unicode internally for generating the Default_Ignorable_Code_Point property (which should be used instead) and not intended to be used stand-alone',\n    'ODI/Y' => 'Used by Unicode internally for generating the Default_Ignorable_Code_Point property (which should be used instead) and not intended to be used stand-alone',\n    'OGrExt/N' => 'Used by Unicode internally for generating the Grapheme_Extend property (which should be used instead) and not intended to be used stand-alone',\n    'OGrExt/Y' => 'Used by Unicode internally for generating the Grapheme_Extend property (which should be used instead) and not intended to be used stand-alone',\n    'OIDC/N' => 'Used by Unicode internally for generating the ID_Continue property (which should be used instead) and not intended to be used stand-alone',\n    'OIDC/Y' => 'Used by Unicode internally for generating the ID_Continue property (which should be used instead) and not intended to be used stand-alone',\n    'OIDS/N' => 'Used by Unicode internally for generating the ID_Start property (which should be used instead) and not intended to be used stand-alone',\n    'OIDS/Y' => 'Used by Unicode internally for generating the ID_Start property (which should be used instead) and not intended to be used stand-alone',\n    'OLower/N' => 'Used by Unicode internally for generating the Lowercase property (which should be used instead) and not intended to be used stand-alone',\n    'OLower/Y' => 'Used by Unicode internally for generating the Lowercase property (which should be used instead) and not intended to be used stand-alone',\n    'OMath/N' => 'Used by Unicode internally for generating the Math property (which should be used instead) and not intended to be used stand-alone',\n    'OMath/Y' => 'Used by Unicode internally for generating the Math property (which should be used instead) and not intended to be used stand-alone',\n    'OUpper/N' => 'Used by Unicode internally for generating the Uppercase property (which should be used instead) and not intended to be used stand-alone',\n    'OUpper/Y' => 'Used by Unicode internally for generating the Uppercase property (which should be used instead) and not intended to be used stand-alone',\n);\n\n# A few properties have different behavior under /i matching.  This maps the\n# those to substitute files to use under /i.\n%utf8::caseless_equivalent = (\n    'gc=ll' => 'Gc/LC',\n    'gc=lowercaseletter' => 'Gc/LC',\n    'gc=lt' => 'Gc/LC',\n    'gc=lu' => 'Gc/LC',\n    'gc=titlecaseletter' => 'Gc/LC',\n    'gc=uppercaseletter' => 'Gc/LC',\n    'isll' => 'Gc/LC',\n    'islower' => 'Cased/Y',\n    'islowercase' => 'Cased/Y',\n    'islowercaseletter' => 'Gc/LC',\n    'islt' => 'Gc/LC',\n    'islu' => 'Gc/LC',\n    'isposixlower' => 'Perl/PosixAlp',\n    'isposixupper' => 'Perl/PosixAlp',\n    'istitle' => 'Cased/Y',\n    'istitlecase' => 'Cased/Y',\n    'istitlecaseletter' => 'Gc/LC',\n    'isupper' => 'Cased/Y',\n    'isuppercase' => 'Cased/Y',\n    'isuppercaseletter' => 'Gc/LC',\n    'isxposixlower' => 'Cased/Y',\n    'isxposixupper' => 'Cased/Y',\n    'll' => 'Gc/LC',\n    'lower' => 'Cased/Y',\n    'lower=f' => 'Cased/N',\n    'lower=false' => 'Cased/N',\n    'lower=n' => 'Cased/N',\n    'lower=no' => 'Cased/N',\n    'lower=t' => 'Cased/Y',\n    'lower=true' => 'Cased/Y',\n    'lower=y' => 'Cased/Y',\n    'lower=yes' => 'Cased/Y',\n    'lowercase' => 'Cased/Y',\n    'lowercaseletter' => 'Gc/LC',\n    'lt' => 'Gc/LC',\n    'lu' => 'Gc/LC',\n    'posixlower' => 'Perl/PosixAlp',\n    'posixupper' => 'Perl/PosixAlp',\n    'title' => 'Cased/Y',\n    'titlecase' => 'Cased/Y',\n    'titlecaseletter' => 'Gc/LC',\n    'upper' => 'Cased/Y',\n    'upper=f' => 'Cased/N',\n    'upper=false' => 'Cased/N',\n    'upper=n' => 'Cased/N',\n    'upper=no' => 'Cased/N',\n    'upper=t' => 'Cased/Y',\n    'upper=true' => 'Cased/Y',\n    'upper=y' => 'Cased/Y',\n    'upper=yes' => 'Cased/Y',\n    'uppercase' => 'Cased/Y',\n    'uppercaseletter' => 'Gc/LC',\n    'xposixlower' => 'Cased/Y',\n    'xposixupper' => 'Cased/Y',\n);\n\n1;\n", 8192) = 7785
09:02:57.377684 brk(0x2258000)          = 0x2258000
09:02:57.377903 read(3, "", 8192)       = 0
09:02:57.377958 close(3)                = 0
09:02:57.378388 brk(0x227a000)          = 0x227a000
09:02:57.379475 brk(0x229b000)          = 0x229b000
09:02:57.380169 brk(0x22bc000)          = 0x22bc000
09:02:57.380782 brk(0x22e2000)          = 0x22e2000
09:02:57.382746 stat("modules/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.382926 stat("modules/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383080 stat("/etc/perl/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383232 stat("/usr/local/lib/perl/5.14.2/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383382 stat("/usr/local/share/perl/5.14.2/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383527 stat("/usr/lib/perl5/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383668 stat("/usr/share/perl5/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383808 stat("/usr/lib/perl/5.14/unicore/To/Lower.pl", 0x7ffe1233bc30) = -1 ENOENT (No such file or directory)
09:02:57.383954 stat("/usr/share/perl/5.14/unicore/To/Lower.pl", {st_mode=S_IFREG|0644, st_size=12533, ...}) = 0
09:02:57.384124 open("/usr/share/perl/5.14/unicore/To/Lower.pl", O_RDONLY) = 3
09:02:57.384280 ioctl(3, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7ffe1233b9c0) = -1 ENOTTY (Inappropriate ioctl for device)
09:02:57.384415 lseek(3, 0, SEEK_CUR)   = 0
09:02:57.384594 read(3, "# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file is machine-generated by lib/unicore/mktables from the Unicode\n# database, Version 6.0.0.  Any changes made here will be lost!\n\n\n# The name this swash is to be known by, with the format of the mappings in\n# the main body of the table, and what all code points missing from this file\n# map to.\n$utf8::SwashInfo{'ToLower'}{'format'} = 'x'; # positive hex whole number; a code point\n$utf8::SwashInfo{'ToLower'}{'missing'} = '<code point>'; # code point maps to itself\n\n# Some code points require special handling because their mappings are each to\n# multiple code points.  These do not appear in the main body, but are defined\n# in the hash below.\n\n# Each key is the string of N bytes that together make up the UTF-8 encoding\n# for the code point.  (i.e. the same as looking at the code point's UTF-8\n# under \"use bytes\").  Each value is the UTF-8 of the translation, for speed.\n%utf8::ToSpecLower = (\n\"\\xC4\\xB0\" => \"\\x{0069}\\x{0307}\",             # U+0130 => 0069 0307\n);\n\nreturn <<'END';\n0041\t\t0061\n0042\t\t0062\n0043\t\t0063\n0044\t\t0064\n0045\t\t0065\n0046\t\t0066\n0047\t\t0067\n0048\t\t0068\n0049\t\t0069\n004A\t\t006A\n004B\t\t006B\n004C\t\t006C\n004D\t\t006D\n004E\t\t006E\n004F\t\t006F\n0050\t\t0070\n0051\t\t0071\n0052\t\t0072\n0053\t\t0073\n0054\t\t0074\n0055\t\t0075\n0056\t\t0076\n0057\t\t0077\n0058\t\t0078\n0059\t\t0079\n005A\t\t007A\n00C0\t\t00E0\n00C1\t\t00E1\n00C2\t\t00E2\n00C3\t\t00E3\n00C4\t\t00E4\n00C5\t\t00E5\n00C6\t\t00E6\n00C7\t\t00E7\n00C8\t\t00E8\n00C9\t\t00E9\n00CA\t\t00EA\n00CB\t\t00EB\n00CC\t\t00EC\n00CD\t\t00ED\n00CE\t\t00EE\n00CF\t\t00EF\n00D0\t\t00F0\n00D1\t\t00F1\n00D2\t\t00F2\n00D3\t\t00F3\n00D4\t\t00F4\n00D5\t\t00F5\n00D6\t\t00F6\n00D8\t\t00F8\n00D9\t\t00F9\n00DA\t\t00FA\n00DB\t\t00FB\n00DC\t\t00FC\n00DD\t\t00FD\n00DE\t\t00FE\n0100\t\t0101\n0102\t\t0103\n0104\t\t0105\n0106\t\t0107\n0108\t\t0109\n010A\t\t010B\n010C\t\t010D\n010E\t\t010F\n0110\t\t0111\n0112\t\t0113\n0114\t\t0115\n0116\t\t0117\n0118\t\t0119\n011A\t\t011B\n011C\t\t011D\n011E\t\t011F\n0120\t\t0121\n0122\t\t0123\n0124\t\t0125\n0126\t\t0127\n0128\t\t0129\n012A\t\t012B\n012C\t\t012D\n012E\t\t012F\n0132\t\t0133\n0134\t\t0135\n0136\t\t0137\n0139\t\t013A\n013B\t\t013C\n013D\t\t013E\n013F\t\t0140\n0141\t\t0142\n0143\t\t0144\n0145\t\t0146\n0147\t\t0148\n014A\t\t014B\n014C\t\t014D\n014E\t\t014F\n0150\t\t0151\n0152\t\t0153\n0154\t\t0155\n0156\t\t0157\n0158\t\t0159\n015A\t\t015B\n015C\t\t015D\n015E\t\t015F\n0160\t\t0161\n0162\t\t0163\n0164\t\t0165\n0166\t\t0167\n0168\t\t0169\n016A\t\t016B\n016C\t\t016D\n016E\t\t016F\n0170\t\t0171\n0172\t\t0173\n0174\t\t0175\n0176\t\t0177\n0178\t\t00FF\n0179\t\t017A\n017B\t\t017C\n017D\t\t017E\n0181\t\t0253\n0182\t\t0183\n0184\t\t0185\n0186\t\t0254\n0187\t\t0188\n0189\t\t0256\n018A\t\t0257\n018B\t\t018C\n018E\t\t01DD\n018F\t\t0259\n0190\t\t025B\n0191\t\t0192\n0193\t\t0260\n0194\t\t0263\n0196\t\t0269\n0197\t\t0268\n0198\t\t0199\n019C\t\t026F\n019D\t\t0272\n019F\t\t0275\n01A0\t\t01A1\n01A2\t\t01A3\n01A4\t\t01A5\n01A6\t\t0280\n01A7\t\t01A8\n01A9\t\t0283\n01AC\t\t01AD\n01AE\t\t0288\n01AF\t\t01B0\n01B1\t\t028A\n01B2\t\t028B\n01B3\t\t01B4\n01B5\t\t01B6\n01B7\t\t0292\n01B8\t\t01B9\n01BC\t\t01BD\n01C4\t\t01C6\n01C5\t\t01C6\n01C7\t\t01C9\n01C8\t\t01C9\n01CA\t\t01CC\n01CB\t\t01CC\n01CD\t\t01CE\n01CF\t\t01D0\n01D1\t\t01D2\n01D3\t\t01D4\n01D5\t\t01D6\n01D7\t\t01D8\n01D9\t\t01DA\n01DB\t\t01DC\n01DE\t\t01DF\n01E0\t\t01E1\n01E2\t\t01E3\n01E4\t\t01E5\n01E6\t\t01E7\n01E8\t\t01E9\n01EA\t\t01EB\n01EC\t\t01ED\n01EE\t\t01EF\n01F1\t\t01F3\n01F2\t\t01F3\n01F4\t\t01F5\n01F6\t\t0195\n01F7\t\t01BF\n01F8\t\t01F9\n01FA\t\t01FB\n01FC\t\t01FD\n01FE\t\t01FF\n0200\t\t0201\n0202\t\t0203\n0204\t\t0205\n0206\t\t0207\n0208\t\t0209\n020A\t\t020B\n020C\t\t020D\n020E\t\t020F\n0210\t\t0211\n0212\t\t0213\n0214\t\t0215\n0216\t\t0217\n0218\t\t0219\n021A\t\t021B\n021C\t\t021D\n021E\t\t021F\n0220\t\t019E\n0222\t\t0223\n0224\t\t0225\n0226\t\t0227\n0228\t\t0229\n022A\t\t022B\n022C\t\t022D\n022E\t\t022F\n0230\t\t0231\n0232\t\t0233\n023A\t\t2C65\n023B\t\t023C\n023D\t\t019A\n023E\t\t2C66\n0241\t\t0242\n0243\t\t0180\n0244\t\t0289\n0245\t\t028C\n0246\t\t0247\n0248\t\t0249\n024A\t\t024B\n024C\t\t024D\n024E\t\t024F\n0370\t\t0371\n0372\t\t0373\n0376\t\t0377\n0386\t\t03AC\n0388\t\t03AD\n0389\t\t03AE\n038A\t\t03AF\n038C\t\t03CC\n038E\t\t03CD\n038F\t\t03CE\n0391\t\t03B1\n0392\t\t03B2\n0393\t\t03B3\n0394\t\t03B4\n0395\t\t03B5\n0396\t\t03B6\n0397\t\t03B7\n0398\t\t03B8\n0399\t\t03B9\n039A\t\t03BA\n039B\t\t03BB\n039C\t\t03BC\n039D\t\t03BD\n039E\t\t03BE\n039F\t\t03BF\n03A0\t\t03C0\n03A1\t\t03C1\n03A3\t\t03C3\n03A4\t\t03C4\n03A5\t\t03C5\n03A6\t\t03C6\n03A7\t\t03C7\n03A8\t\t03C8\n03A9\t\t03C9\n03AA\t\t03CA\n03AB\t\t03CB\n03CF\t\t03D7\n03D8\t\t03D9\n03DA\t\t03DB\n03DC\t\t03DD\n03DE\t\t03DF\n03E0\t\t03E1\n03E2\t\t03E3\n03E4\t\t03E5\n03E6\t\t03E7\n03E8\t\t03E9\n03EA\t\t03EB\n03EC\t\t03ED\n03EE\t\t03EF\n03F4\t\t03B8\n03F7\t\t03F8\n03F9\t\t03F2\n03FA\t\t03FB\n03FD\t\t037B\n03FE\t\t037C\n03FF\t\t037D\n0400\t\t0450\n0401\t\t0451\n0402\t\t0452\n0403\t\t0453\n0404\t\t0454\n0405\t\t0455\n0406\t\t0456\n0407\t\t0457\n0408\t\t0458\n0409\t\t0459\n040A\t\t045A\n040B\t\t045B\n040C\t\t045C\n040D\t\t045D\n040E\t\t045E\n040F\t\t045F\n0410\t\t0430\n0411\t\t0431\n0412\t\t0432\n0413\t\t0433\n0414\t\t0434\n0415\t\t0435\n0416\t\t0436\n0417\t\t0437\n0418\t\t0438\n0419\t\t0439\n041A\t\t043A\n041B\t\t043B\n041C\t\t043C\n041D\t\t043D\n041E\t\t043E\n041F\t\t043F\n0420\t\t0440\n0421\t\t0441\n0422\t\t0442\n0423\t\t0443\n0424\t\t0444\n0425\t\t0445\n0426\t\t0446\n0427\t\t0447\n0428\t\t0448\n0429\t\t0449\n042A\t\t044A\n042B\t\t044B\n042C\t\t044C\n042D\t\t044D\n042E\t\t044E\n042F\t\t044F\n0460\t\t0461\n0462\t\t0463\n0464\t\t0465\n0466\t\t0467\n0468\t\t0469\n046A\t\t046B\n046C\t\t046D\n046E\t\t046F\n0470\t\t0471\n0472\t\t0473\n0474\t\t0475\n0476\t\t0477\n0478\t\t0479\n047A\t\t047B\n047C\t\t047D\n047E\t\t047F\n0480\t\t0481\n048A\t\t048B\n048C\t\t048D\n048E\t\t048F\n0490\t\t0491\n0492\t\t0493\n0494\t\t0495\n0496\t\t0497\n0498\t\t0499\n049A\t\t049B\n049C\t\t049D\n049E\t\t049F\n04A0\t\t04A1\n04A2\t\t04A3\n04A4\t\t04A5\n04A6\t\t04A7\n04A8\t\t04A9\n04AA\t\t04AB\n04AC\t\t04AD\n04AE\t\t04AF\n04B0\t\t04B1\n04B2\t\t04B3\n04B4\t\t04B5\n04B6\t\t04B7\n04B8\t\t04B9\n04BA\t\t04BB\n04BC\t\t04BD\n04BE\t\t04BF\n04C0\t\t04CF\n04C1\t\t04C2\n04C3\t\t04C4\n04C5\t\t04C6\n04C7\t\t04C8\n04C9\t\t04CA\n04CB\t\t04CC\n04CD\t\t04CE\n04D0\t\t04D1\n04D2\t\t04D3\n04D4\t\t04D5\n04D6\t\t04D7\n04D8\t\t04D9\n04DA\t\t04DB\n04DC\t\t04DD\n04DE\t\t04DF\n04E0\t\t04E1\n04E2\t\t04E3\n04E4\t\t04E5\n04E6\t\t04E7\n04E8\t\t04E9\n04EA\t\t04EB\n04EC\t\t04ED\n04EE\t\t04EF\n04F0\t\t04F1\n04F2\t\t04F3\n04F4\t\t04F5\n04F6\t\t04F7\n04F8\t\t04F9\n04FA\t\t04FB\n04FC\t\t04FD\n04FE\t\t04FF\n0500\t\t0501\n0502\t\t0503\n0504\t\t0505\n0506\t\t0507\n0508\t\t0509\n050A\t\t050B\n050C\t\t050D\n050E\t\t050F\n0510\t\t0511\n0512\t\t0513\n0514\t\t0515\n0516\t\t0517\n0518\t\t0519\n051A\t\t051B\n051C\t\t051D\n051E\t\t051F\n0520\t\t0521\n0522\t\t0523\n0524\t\t0525\n0526\t\t0527\n0531\t\t0561\n0532\t\t0562\n0533\t\t0563\n0534\t\t0564\n0535\t\t0565\n0536\t\t0566\n0537\t\t0567\n0538\t\t0568\n0539\t\t0569\n053A\t\t056A\n053B\t\t056B\n053C\t\t056C\n053D\t\t056D\n053E\t\t056E\n053F\t\t056F\n0540\t\t0570\n0541\t\t0571\n0542\t\t0572\n0543\t\t0573\n0544\t\t0574\n0545\t\t0575\n0546\t\t0576\n0547\t\t0577\n0548\t\t0578\n0549\t\t0579\n054A\t\t057A\n054B\t\t057B\n054C\t\t057C\n054D\t\t057D\n054E\t\t057E\n054F\t\t057F\n0550\t\t0580\n0551\t\t0581\n0552\t\t0582\n0553\t\t0583\n0554\t\t0584\n0555\t\t0585\n0556\t\t0586\n10A0\t\t2D00\n10A1\t\t2D01\n10A2\t\t2D02\n10A3\t\t2D03\n10A4\t\t2D04\n10A5\t\t2D05\n10A6\t\t2D06\n10A7\t\t2D07\n10A8\t\t2D08\n10A9\t\t2D09\n10AA\t\t2D0A\n10AB\t\t2D0B\n10AC\t\t2D0C\n10AD\t\t2D0D\n10AE\t\t2D0E\n10AF\t\t2D0F\n10B0\t\t2D10\n10B1\t\t2D11\n10B2\t\t2D12\n10B3\t\t2D13\n10B4\t\t2D14\n10B5\t\t2D15\n10B6\t\t2D16\n10B7\t\t2D17\n10B8\t\t2D18\n10B9\t\t2D19\n10BA\t\t2D1A\n10BB\t\t2D1B\n10BC\t\t2D1C\n10BD\t\t2D1D\n10BE\t\t2D1E\n10BF\t\t2D1F\n10C0\t\t2D20\n10C1\t\t2D21\n10C2\t\t2D22\n10C3\t\t2D23\n10C4\t\t2D24\n10C5\t\t2D25\n1E00\t\t1E01\n1E02\t\t1E03\n1E04\t\t1E05\n1E06\t\t1E07\n1E08\t\t1E09\n1E0A\t\t1E0B\n1E0C\t\t1E0D\n1E0E\t\t1E0F\n1E10\t\t1E11\n1E12\t\t1E13\n1E14\t\t1E15\n1E16\t\t1E17\n1E18\t\t1E19\n1E1A\t\t1E1B\n1E1C\t\t1E1D\n1E1E\t\t1E1F\n1E20\t\t1E21\n1E22\t\t1E23\n1E24\t\t1E25\n1E26\t\t1E27\n1E28\t\t1E29\n1E2A\t\t1E2B\n1E2C\t\t1E2D\n1E2E\t\t1E2F\n1E30\t\t1E31\n1E32\t\t1E33\n1E34\t\t1E35\n1E36\t\t1E37\n1E38\t\t1E39\n1E3A\t\t1E3B\n1E3C\t\t1E3D\n1E3E\t\t1E3F\n1E40\t\t1E41\n1E42\t\t1E43\n1E44\t\t1E45\n1E46\t\t1E47\n1E48\t\t1E49\n1E4A\t\t1E4B\n1E4C\t\t1E4D\n1E4E\t\t1E4F\n1E50\t\t1E51\n1E52\t\t1E53\n1E54\t\t1E55\n1E56\t\t1E57\n1E58\t\t1E59\n1E5A\t\t1E5B\n1E5C\t\t1E5D\n1E5E\t\t1E5F\n1E60\t\t1E61\n1E62\t\t1E63\n1E64\t\t1E65\n1E66\t\t1E67\n1E68\t\t1E69\n1E6A\t\t1E6B\n1E6C\t\t1E6D\n1E6E\t\t1E6F\n1E70\t\t1E71\n1E72\t\t1E73\n1E74\t\t1E75\n1E76\t\t1E77\n1E78\t\t1E79\n1E7A\t\t1E7B\n1E7C\t\t1E7D\n1E7E\t\t1E7F\n1E80\t\t1E81\n1E82\t\t1E83\n1E84\t\t1E85\n1E86\t\t1E87\n1E88\t\t1E89\n1E8A\t\t1E8B\n1E8C\t\t1E8D\n1E8E\t\t1E8F\n1E90\t\t1E91\n1E92\t\t1E93\n1E94\t\t1E95\n1E9E\t\t00DF\n1EA0\t\t1EA1\n1EA2\t\t1EA3\n1EA4\t\t1EA5\n1EA6\t\t1EA7\n1EA8\t\t1EA9\n1EAA\t\t1EAB\n1EAC\t\t1EAD\n1EAE\t\t1EAF\n1EB0\t\t1EB1\n1EB2\t\t1EB3\n1EB4\t\t1EB5\n1EB6\t\t1EB7\n1EB8\t\t1EB9\n1EBA\t\t1EBB\n1EBC\t\t1EBD\n1EBE\t\t1EBF\n1EC0\t\t1EC1\n1EC2\t\t1EC3\n1EC4\t\t1EC5\n1EC6\t\t1EC7\n1EC8\t\t1EC9\n1ECA\t\t1ECB\n1ECC\t\t1ECD\n1ECE\t\t1ECF\n1ED0\t\t1ED1\n1ED2\t\t1ED3\n1ED4\t\t1ED5\n1ED6\t\t1ED7\n1ED8\t\t1ED9\n1EDA\t\t1EDB\n1EDC\t\t1EDD\n1EDE\t\t1EDF\n1EE0\t\t1EE1\n1EE2\t\t1EE3\n1EE4\t\t1EE5\n1EE6\t\t1EE7\n1EE8\t\t1EE9\n1EEA\t\t1EEB\n1EEC\t\t1EED\n1EEE\t\t1EEF\n1EF0\t\t1EF1\n1EF2\t\t1EF3\n1EF4\t\t1EF5\n1EF6\t\t1EF7\n1EF8\t\t1EF9\n1EFA\t\t1EFB\n1EFC\t\t1EFD\n1EFE\t\t1EFF\n1F08\t\t1F00\n1F09\t\t1F01\n1F0A\t\t1F02\n1F0B\t\t1F03\n1F0C\t\t1F04\n1F0D\t\t1F05\n1F0E\t\t1F06\n1F0F\t\t1F07\n1F18\t\t1F10\n1F19\t\t1F11\n1F1A\t\t1F12\n1F1B\t\t1F13\n1F1C\t\t1F14\n1F1D\t\t1F15\n1F28\t\t1F20\n1F29\t\t1F21\n1F2A\t\t1F22\n1F2B\t\t1F23\n1F2C\t\t1F24\n1F2D\t\t1F25\n1F2E\t\t1F26\n1F2F\t\t1F27\n1F38\t\t1F30\n1F39\t\t1F31\n1F3A\t\t1F32\n", 8192) = 8192
09:02:57.385777 read(3, "1F3B\t\t1F33\n1F3C\t\t1F34\n1F3D\t\t1F35\n1F3E\t\t1F36\n1F3F\t\t1F37\n1F48\t\t1F40\n1F49\t\t1F41\n1F4A\t\t1F42\n1F4B\t\t1F43\n1F4C\t\t1F44\n1F4D\t\t1F45\n1F59\t\t1F51\n1F5B\t\t1F53\n1F5D\t\t1F55\n1F5F\t\t1F57\n1F68\t\t1F60\n1F69\t\t1F61\n1F6A\t\t1F62\n1F6B\t\t1F63\n1F6C\t\t1F64\n1F6D\t\t1F65\n1F6E\t\t1F66\n1F6F\t\t1F67\n1F88\t\t1F80\n1F89\t\t1F81\n1F8A\t\t1F82\n1F8B\t\t1F83\n1F8C\t\t1F84\n1F8D\t\t1F85\n1F8E\t\t1F86\n1F8F\t\t1F87\n1F98\t\t1F90\n1F99\t\t1F91\n1F9A\t\t1F92\n1F9B\t\t1F93\n1F9C\t\t1F94\n1F9D\t\t1F95\n1F9E\t\t1F96\n1F9F\t\t1F97\n1FA8\t\t1FA0\n1FA9\t\t1FA1\n1FAA\t\t1FA2\n1FAB\t\t1FA3\n1FAC\t\t1FA4\n1FAD\t\t1FA5\n1FAE\t\t1FA6\n1FAF\t\t1FA7\n1FB8\t\t1FB0\n1FB9\t\t1FB1\n1FBA\t\t1F70\n1FBB\t\t1F71\n1FBC\t\t1FB3\n1FC8\t\t1F72\n1FC9\t\t1F73\n1FCA\t\t1F74\n1FCB\t\t1F75\n1FCC\t\t1FC3\n1FD8\t\t1FD0\n1FD9\t\t1FD1\n1FDA\t\t1F76\n1FDB\t\t1F77\n1FE8\t\t1FE0\n1FE9\t\t1FE1\n1FEA\t\t1F7A\n1FEB\t\t1F7B\n1FEC\t\t1FE5\n1FF8\t\t1F78\n1FF9\t\t1F79\n1FFA\t\t1F7C\n1FFB\t\t1F7D\n1FFC\t\t1FF3\n2126\t\t03C9\n212A\t\t006B\n212B\t\t00E5\n2132\t\t214E\n2160\t\t2170\n2161\t\t2171\n2162\t\t2172\n2163\t\t2173\n2164\t\t2174\n2165\t\t2175\n2166\t\t2176\n2167\t\t2177\n2168\t\t2178\n2169\t\t2179\n216A\t\t217A\n216B\t\t217B\n216C\t\t217C\n216D\t\t217D\n216E\t\t217E\n216F\t\t217F\n2183\t\t2184\n24B6\t\t24D0\n24B7\t\t24D1\n24B8\t\t24D2\n24B9\t\t24D3\n24BA\t\t24D4\n24BB\t\t24D5\n24BC\t\t24D6\n24BD\t\t24D7\n24BE\t\t24D8\n24BF\t\t24D9\n24C0\t\t24DA\n24C1\t\t24DB\n24C2\t\t24DC\n24C3\t\t24DD\n24C4\t\t24DE\n24C5\t\t24DF\n24C6\t\t24E0\n24C7\t\t24E1\n24C8\t\t24E2\n24C9\t\t24E3\n24CA\t\t24E4\n24CB\t\t24E5\n24CC\t\t24E6\n24CD\t\t24E7\n24CE\t\t24E8\n24CF\t\t24E9\n2C00\t\t2C30\n2C01\t\t2C31\n2C02\t\t2C32\n2C03\t\t2C33\n2C04\t\t2C34\n2C05\t\t2C35\n2C06\t\t2C36\n2C07\t\t2C37\n2C08\t\t2C38\n2C09\t\t2C39\n2C0A\t\t2C3A\n2C0B\t\t2C3B\n2C0C\t\t2C3C\n2C0D\t\t2C3D\n2C0E\t\t2C3E\n2C0F\t\t2C3F\n2C10\t\t2C40\n2C11\t\t2C41\n2C12\t\t2C42\n2C13\t\t2C43\n2C14\t\t2C44\n2C15\t\t2C45\n2C16\t\t2C46\n2C17\t\t2C47\n2C18\t\t2C48\n2C19\t\t2C49\n2C1A\t\t2C4A\n2C1B\t\t2C4B\n2C1C\t\t2C4C\n2C1D\t\t2C4D\n2C1E\t\t2C4E\n2C1F\t\t2C4F\n2C20\t\t2C50\n2C21\t\t2C51\n2C22\t\t2C52\n2C23\t\t2C53\n2C24\t\t2C54\n2C25\t\t2C55\n2C26\t\t2C56\n2C27\t\t2C57\n2C28\t\t2C58\n2C29\t\t2C59\n2C2A\t\t2C5A\n2C2B\t\t2C5B\n2C2C\t\t2C5C\n2C2D\t\t2C5D\n2C2E\t\t2C5E\n2C60\t\t2C61\n2C62\t\t026B\n2C63\t\t1D7D\n2C64\t\t027D\n2C67\t\t2C68\n2C69\t\t2C6A\n2C6B\t\t2C6C\n2C6D\t\t0251\n2C6E\t\t0271\n2C6F\t\t0250\n2C70\t\t0252\n2C72\t\t2C73\n2C75\t\t2C76\n2C7E\t\t023F\n2C7F\t\t0240\n2C80\t\t2C81\n2C82\t\t2C83\n2C84\t\t2C85\n2C86\t\t2C87\n2C88\t\t2C89\n2C8A\t\t2C8B\n2C8C\t\t2C8D\n2C8E\t\t2C8F\n2C90\t\t2C91\n2C92\t\t2C93\n2C94\t\t2C95\n2C96\t\t2C97\n2C98\t\t2C99\n2C9A\t\t2C9B\n2C9C\t\t2C9D\n2C9E\t\t2C9F\n2CA0\t\t2CA1\n2CA2\t\t2CA3\n2CA4\t\t2CA5\n2CA6\t\t2CA7\n2CA8\t\t2CA9\n2CAA\t\t2CAB\n2CAC\t\t2CAD\n2CAE\t\t2CAF\n2CB0\t\t2CB1\n2CB2\t\t2CB3\n2CB4\t\t2CB5\n2CB6\t\t2CB7\n2CB8\t\t2CB9\n2CBA\t\t2CBB\n2CBC\t\t2CBD\n2CBE\t\t2CBF\n2CC0\t\t2CC1\n2CC2\t\t2CC3\n2CC4\t\t2CC5\n2CC6\t\t2CC7\n2CC8\t\t2CC9\n2CCA\t\t2CCB\n2CCC\t\t2CCD\n2CCE\t\t2CCF\n2CD0\t\t2CD1\n2CD2\t\t2CD3\n2CD4\t\t2CD5\n2CD6\t\t2CD7\n2CD8\t\t2CD9\n2CDA\t\t2CDB\n2CDC\t\t2CDD\n2CDE\t\t2CDF\n2CE0\t\t2CE1\n2CE2\t\t2CE3\n2CEB\t\t2CEC\n2CED\t\t2CEE\nA640\t\tA641\nA642\t\tA643\nA644\t\tA645\nA646\t\tA647\nA648\t\tA649\nA64A\t\tA64B\nA64C\t\tA64D\nA64E\t\tA64F\nA650\t\tA651\nA652\t\tA653\nA654\t\tA655\nA656\t\tA657\nA658\t\tA659\nA65A\t\tA65B\nA65C\t\tA65D\nA65E\t\tA65F\nA660\t\tA661\nA662\t\tA663\nA664\t\tA665\nA666\t\tA667\nA668\t\tA669\nA66A\t\tA66B\nA66C\t\tA66D\nA680\t\tA681\nA682\t\tA683\nA684\t\tA685\nA686\t\tA687\nA688\t\tA689\nA68A\t\tA68B\nA68C\t\tA68D\nA68E\t\tA68F\nA690\t\tA691\nA692\t\tA693\nA694\t\tA695\nA696\t\tA697\nA722\t\tA723\nA724\t\tA725\nA726\t\tA727\nA728\t\tA729\nA72A\t\tA72B\nA72C\t\tA72D\nA72E\t\tA72F\nA732\t\tA733\nA734\t\tA735\nA736\t\tA737\nA738\t\tA739\nA73A\t\tA73B\nA73C\t\tA73D\nA73E\t\tA73F\nA740\t\tA741\nA742\t\tA743\nA744\t\tA745\nA746\t\tA747\nA748\t\tA749\nA74A\t\tA74B\nA74C\t\tA74D\nA74E\t\tA74F\nA750\t\tA751\nA752\t\tA753\nA754\t\tA755\nA756\t\tA757\nA758\t\tA759\nA75A\t\tA75B\nA75C\t\tA75D\nA75E\t\tA75F\nA760\t\tA761\nA762\t\tA763\nA764\t\tA765\nA766\t\tA767\nA768\t\tA769\nA76A\t\tA76B\nA76C\t\tA76D\nA76E\t\tA76F\nA779\t\tA77A\nA77B\t\tA77C\nA77D\t\t1D79\nA77E\t\tA77F\nA780\t\tA781\nA782\t\tA783\nA784\t\tA785\nA786\t\tA787\nA78B\t\tA78C\nA78D\t\t0265\nA790\t\tA791\nA7A0\t\tA7A1\nA7A2\t\tA7A3\nA7A4\t\tA7A5\nA7A6\t\tA7A7\nA7A8\t\tA7A9\nFF21\t\tFF41\nFF22\t\tFF42\nFF23\t\tFF43\nFF24\t\tFF44\nFF25\t\tFF45\nFF26\t\tFF46\nFF27\t\tFF47\nFF28\t\tFF48\nFF29\t\tFF49\nFF2A\t\tFF4A\nFF2B\t\tFF4B\nFF2C\t\tFF4C\nFF2D\t\tFF4D\nFF2E\t\tFF4E\nFF2F\t\tFF4F\nFF30\t\tFF50\nFF31\t\tFF51\nFF32\t\tFF52\nFF33\t\tFF53\nFF34\t\tFF54\nFF35\t\tFF55\nFF36\t\tFF56\nFF37\t\tFF57\nFF38\t\tFF58\nFF39\t\tFF59\nFF3A\t\tFF5A\n10400\t\t10428\n10401\t\t10429\n10402\t\t1042A\n10403\t\t1042B\n10404\t\t1042C\n10405\t\t1042D\n10406\t\t1042E\n10407\t\t1042F\n10408\t\t10430\n10409\t\t10431\n1040A\t\t10432\n1040B\t\t10433\n1040C\t\t10434\n1040D\t\t10435\n1040E\t\t10436\n1040F\t\t10437\n10410\t\t10438\n10411\t\t10439\n10412\t\t1043A\n10413\t\t1043B\n10414\t\t1043C\n10415\t\t1043D\n10416\t\t1043E\n10417\t\t1043F\n10418\t\t10440\n10419\t\t10441\n1041A\t\t10442\n1041B\t\t10443\n1041C\t\t10444\n1041D\t\t10445\n1041E\t\t10446\n1041F\t\t10447\n10420\t\t10448\n10421\t\t10449\n10422\t\t1044A\n10423\t\t1044B\n10424\t\t1044C\n10425\t\t1044D\n10426\t\t1044E\n10427\t\t1044F\nEND\n", 8192) = 4341
09:02:57.386440 read(3, "", 8192)       = 0
09:02:57.386657 close(3)                = 0
09:02:57.498546 select(40, [4], [], [], {0, 0}) = 0 (Timeout)
09:02:57.498715 write(1, "[  Freelance Report: Dr Arcanonn Receives Death Threats ] - Elite Dangerous GalNet (community.elitedangerous.com/galnet)\n", 121) = 121
09:02:57.499149 rt_sigaction(SIG_0, NULL, {0x9f0ed807, [], SA_RESTORER|SA_RESTART|SA_INTERRUPT|SA_NOCLDWAIT|0x2d24c00, (nil)}, 8) = -1 EINVAL (Invalid argument)
09:02:57.499224 rt_sigaction(SIGHUP, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499285 rt_sigaction(SIGINT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499342 rt_sigaction(SIGQUIT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499399 rt_sigaction(SIGILL, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499456 rt_sigaction(SIGTRAP, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499512 rt_sigaction(SIGABRT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499570 rt_sigaction(SIGBUS, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499626 rt_sigaction(SIGFPE, NULL, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0x7f7435f9f1e0}, 8) = 0
09:02:57.499685 rt_sigaction(SIGKILL, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499742 rt_sigaction(SIGUSR1, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499798 rt_sigaction(SIGSEGV, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499858 rt_sigaction(SIGUSR2, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.499916 rt_sigaction(SIGPIPE, NULL, {SIG_IGN, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:57.499972 rt_sigaction(SIGALRM, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500029 rt_sigaction(SIGTERM, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500086 rt_sigaction(SIGSTKFLT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500155 rt_sigaction(SIGCHLD, NULL, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:57.500214 rt_sigaction(SIGCHLD, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, {0x7f7436a35aa0, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:57.500278 rt_sigaction(SIGCONT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500335 rt_sigaction(SIGSTOP, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500392 rt_sigaction(SIGTSTP, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500448 rt_sigaction(SIGTTIN, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500505 rt_sigaction(SIGTTOU, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500562 rt_sigaction(SIGURG, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500624 rt_sigaction(SIGXCPU, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500684 rt_sigaction(SIGXFSZ, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500741 rt_sigaction(SIGVTALRM, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500798 rt_sigaction(SIGPROF, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500855 rt_sigaction(SIGWINCH, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500912 rt_sigaction(SIGIO, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.500969 rt_sigaction(SIGPWR, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501025 rt_sigaction(SIGSYS, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501082 rt_sigaction(SIGRT_2, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501140 rt_sigaction(SIGRT_3, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501197 rt_sigaction(SIGRT_4, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501255 rt_sigaction(SIGRT_5, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501312 rt_sigaction(SIGRT_6, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501370 rt_sigaction(SIGRT_7, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501427 rt_sigaction(SIGRT_8, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501485 rt_sigaction(SIGRT_9, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501542 rt_sigaction(SIGRT_10, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501599 rt_sigaction(SIGRT_11, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501657 rt_sigaction(SIGRT_12, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501724 rt_sigaction(SIGRT_13, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501781 rt_sigaction(SIGRT_14, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501838 rt_sigaction(SIGRT_15, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501895 rt_sigaction(SIGRT_16, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.501952 rt_sigaction(SIGRT_17, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502008 rt_sigaction(SIGRT_18, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502081 rt_sigaction(SIGRT_19, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502140 rt_sigaction(SIGRT_20, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502199 rt_sigaction(SIGRT_21, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502257 rt_sigaction(SIGRT_22, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502314 rt_sigaction(SIGRT_23, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502372 rt_sigaction(SIGRT_24, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502430 rt_sigaction(SIGRT_25, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502487 rt_sigaction(SIGRT_26, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502545 rt_sigaction(SIGRT_27, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502605 rt_sigaction(SIGRT_28, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502665 rt_sigaction(SIGRT_29, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502724 rt_sigaction(SIGRT_30, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502781 rt_sigaction(SIGRT_31, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502840 rt_sigaction(SIGRT_32, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502897 rt_sigaction(SIGABRT, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.502954 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], SA_RESTORER, 0x7f74363070a0}, 8) = 0
09:02:57.503012 rt_sigaction(SIGIO, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.503069 rt_sigaction(SIGSYS, NULL, {SIG_DFL, [], 0}, 8) = 0
09:02:57.505613 close(5)                = 0
09:02:57.505694 close(4)                = 0
09:02:57.506011 exit_group(0)           = ?
